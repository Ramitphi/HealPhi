/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-client)/./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/Logger.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/Logger.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js\");\nconst LIB_NAME = 'awaitqueue';\nclass Logger {\n    constructor(prefix) {\n        if (prefix) {\n            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);\n            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);\n            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);\n        }\n        else {\n            this._debug = (0, debug_1.default)(LIB_NAME);\n            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);\n            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);\n        }\n        /* eslint-disable no-console */\n        this._debug.log = console.info.bind(console);\n        this._warn.log = console.warn.bind(console);\n        this._error.log = console.error.bind(console);\n        /* eslint-enable no-console */\n    }\n    get debug() {\n        return this._debug;\n    }\n    get warn() {\n        return this._warn;\n    }\n    get error() {\n        return this._error;\n    }\n}\nexports.Logger = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2F3YWl0cXVldWVAMy4wLjJfc3VwcG9ydHMtY29sb3JAOS40LjAvbm9kZV9tb2R1bGVzL2F3YWl0cXVldWUvbGliL0xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsbUhBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUyxHQUFHLE9BQU87QUFDckUsaURBQWlELFNBQVMsUUFBUSxPQUFPO0FBQ3pFLGtEQUFrRCxTQUFTLFNBQVMsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRCxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vYXdhaXRxdWV1ZUAzLjAuMl9zdXBwb3J0cy1jb2xvckA5LjQuMC9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvTG9nZ2VyLmpzPzY5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBMSUJfTkFNRSA9ICdhd2FpdHF1ZXVlJztcbmNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7TElCX05BTUV9OiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpXQVJOOiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06RVJST1I6JHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKExJQl9OQU1FKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06V0FSTmApO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06RVJST1JgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIHRoaXMuX2RlYnVnLmxvZyA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH1cbiAgICBnZXQgZGVidWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1ZztcbiAgICB9XG4gICAgZ2V0IHdhcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXJuO1xuICAgIH1cbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/Logger.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/index.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/Logger.js\");\nconst logger = new Logger_1.Logger();\n/**\n * Custom Error derived class used to reject pending tasks once stop() method\n * has been called.\n */\nclass AwaitQueueStoppedError extends Error {\n    constructor(message) {\n        super(message ?? 'AwaitQueue stopped');\n        this.name = 'AwaitQueueStoppedError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueStoppedError);\n        }\n    }\n}\nexports.AwaitQueueStoppedError = AwaitQueueStoppedError;\n/**\n * Custom Error derived class used to reject pending tasks once removeTask()\n * method has been called.\n */\nclass AwaitQueueRemovedTaskError extends Error {\n    constructor(message) {\n        super(message ?? 'AwaitQueue task removed');\n        this.name = 'AwaitQueueRemovedTaskError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);\n        }\n    }\n}\nexports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;\nclass AwaitQueue {\n    constructor() {\n        // Queue of pending tasks (map of PendingTasks indexed by id).\n        this.pendingTasks = new Map();\n        // Incrementing PendingTask id.\n        this.nextTaskId = 0;\n        // Whether stop() method is stopping all pending tasks.\n        this.stopping = false;\n    }\n    get size() {\n        return this.pendingTasks.size;\n    }\n    async push(task, name) {\n        name = name ?? task.name;\n        logger.debug(`push() [name:${name}]`);\n        if (typeof task !== 'function') {\n            throw new TypeError('given task is not a function');\n        }\n        if (name) {\n            try {\n                Object.defineProperty(task, 'name', { value: name });\n            }\n            catch (error) { }\n        }\n        return new Promise((resolve, reject) => {\n            const pendingTask = {\n                id: this.nextTaskId++,\n                task: task,\n                name: name,\n                enqueuedAt: Date.now(),\n                executedAt: undefined,\n                completed: false,\n                resolve: (result) => {\n                    // pendingTask.resolve() can only be called in execute() method. Since\n                    // resolve() was called it means that the task successfully completed.\n                    // However the task may have been stopped before it completed (via\n                    // stop() or remove()) so its completed flag was already set. If this\n                    // is the case, abort here since next task (if any) is already being\n                    // executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`resolving task [name:${pendingTask.name}]`);\n                    // Resolve the task with the obtained result.\n                    resolve(result);\n                    // Execute the next pending task (if any).\n                    const [nextPendingTask] = this.pendingTasks.values();\n                    // NOTE: During the resolve() callback the user app may have interacted\n                    // with the queue. For instance, the app may have pushed a task while\n                    // the queue was empty so such a task is already being executed. If so,\n                    // don't execute it twice.\n                    if (nextPendingTask && !nextPendingTask.executedAt) {\n                        void this.execute(nextPendingTask);\n                    }\n                },\n                reject: (error) => {\n                    // pendingTask.reject() can be called within execute() method if the\n                    // task completed with error. However it may have also been called in\n                    // stop() or remove() methods (before or while being executed) so its\n                    // completed flag was already set. If so, abort here since next task\n                    // (if any) is already being executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));\n                    // Reject the task with the obtained error.\n                    reject(error);\n                    // Execute the next pending task (if any) unless stop() is running.\n                    if (!this.stopping) {\n                        const [nextPendingTask] = this.pendingTasks.values();\n                        // NOTE: During the reject() callback the user app may have interacted\n                        // with the queue. For instance, the app may have pushed a task while\n                        // the queue was empty so such a task is already being executed. If so,\n                        // don't execute it twice.\n                        if (nextPendingTask && !nextPendingTask.executedAt) {\n                            void this.execute(nextPendingTask);\n                        }\n                    }\n                }\n            };\n            // Append task to the queue.\n            this.pendingTasks.set(pendingTask.id, pendingTask);\n            // And execute it if this is the only task in the queue.\n            if (this.pendingTasks.size === 1) {\n                void this.execute(pendingTask);\n            }\n        });\n    }\n    stop() {\n        logger.debug('stop()');\n        this.stopping = true;\n        for (const pendingTask of this.pendingTasks.values()) {\n            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);\n            pendingTask.reject(new AwaitQueueStoppedError());\n        }\n        this.stopping = false;\n    }\n    remove(taskIdx) {\n        logger.debug(`remove() [taskIdx:${taskIdx}]`);\n        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n        if (!pendingTask) {\n            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);\n            return;\n        }\n        pendingTask.reject(new AwaitQueueRemovedTaskError());\n    }\n    dump() {\n        const now = Date.now();\n        let idx = 0;\n        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({\n            idx: idx++,\n            task: pendingTask.task,\n            name: pendingTask.name,\n            enqueuedTime: pendingTask.executedAt\n                ? pendingTask.executedAt - pendingTask.enqueuedAt\n                : now - pendingTask.enqueuedAt,\n            executionTime: pendingTask.executedAt\n                ? now - pendingTask.executedAt\n                : 0\n        }));\n    }\n    async execute(pendingTask) {\n        logger.debug(`execute() [name:${pendingTask.name}]`);\n        if (pendingTask.executedAt) {\n            throw new Error('task already being executed');\n        }\n        pendingTask.executedAt = Date.now();\n        try {\n            const result = await pendingTask.task();\n            // Resolve the task with its resolved result (if any).\n            pendingTask.resolve(result);\n        }\n        catch (error) {\n            // Reject the task with its rejected error.\n            pendingTask.reject(error);\n        }\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2F3YWl0cXVldWVAMy4wLjJfc3VwcG9ydHMtY29sb3JAOS40LjAvbm9kZV9tb2R1bGVzL2F3YWl0cXVldWUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtDQUFrQyxHQUFHLDhCQUE4QjtBQUN4RixpQkFBaUIsbUJBQU8sQ0FBQywrSEFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vYXdhaXRxdWV1ZUAzLjAuMl9zdXBwb3J0cy1jb2xvckA5LjQuMC9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanM/OThjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdhaXRRdWV1ZSA9IGV4cG9ydHMuQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IgPSBleHBvcnRzLkF3YWl0UXVldWVTdG9wcGVkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGRlcml2ZWQgY2xhc3MgdXNlZCB0byByZWplY3QgcGVuZGluZyB0YXNrcyBvbmNlIHN0b3AoKSBtZXRob2RcbiAqIGhhcyBiZWVuIGNhbGxlZC5cbiAqL1xuY2xhc3MgQXdhaXRRdWV1ZVN0b3BwZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ0F3YWl0UXVldWUgc3RvcHBlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXdhaXRRdWV1ZVN0b3BwZWRFcnJvcic7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXdhaXRRdWV1ZVN0b3BwZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF3YWl0UXVldWVTdG9wcGVkRXJyb3IgPSBBd2FpdFF1ZXVlU3RvcHBlZEVycm9yO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgZGVyaXZlZCBjbGFzcyB1c2VkIHRvIHJlamVjdCBwZW5kaW5nIHRhc2tzIG9uY2UgcmVtb3ZlVGFzaygpXG4gKiBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuICovXG5jbGFzcyBBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ0F3YWl0UXVldWUgdGFzayByZW1vdmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvcic7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvciA9IEF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yO1xuY2xhc3MgQXdhaXRRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFF1ZXVlIG9mIHBlbmRpbmcgdGFza3MgKG1hcCBvZiBQZW5kaW5nVGFza3MgaW5kZXhlZCBieSBpZCkuXG4gICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBJbmNyZW1lbnRpbmcgUGVuZGluZ1Rhc2sgaWQuXG4gICAgICAgIHRoaXMubmV4dFRhc2tJZCA9IDA7XG4gICAgICAgIC8vIFdoZXRoZXIgc3RvcCgpIG1ldGhvZCBpcyBzdG9wcGluZyBhbGwgcGVuZGluZyB0YXNrcy5cbiAgICAgICAgdGhpcy5zdG9wcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1Rhc2tzLnNpemU7XG4gICAgfVxuICAgIGFzeW5jIHB1c2godGFzaywgbmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSA/PyB0YXNrLm5hbWU7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgcHVzaCgpIFtuYW1lOiR7bmFtZX1dYCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGFzayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2l2ZW4gdGFzayBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXNrLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5uZXh0VGFza0lkKyssXG4gICAgICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGVucXVldWVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgZXhlY3V0ZWRBdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nVGFzay5yZXNvbHZlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGV4ZWN1dGUoKSBtZXRob2QuIFNpbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUoKSB3YXMgY2FsbGVkIGl0IG1lYW5zIHRoYXQgdGhlIHRhc2sgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGUgdGFzayBtYXkgaGF2ZSBiZWVuIHN0b3BwZWQgYmVmb3JlIGl0IGNvbXBsZXRlZCAodmlhXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AoKSBvciByZW1vdmUoKSkgc28gaXRzIGNvbXBsZXRlZCBmbGFnIHdhcyBhbHJlYWR5IHNldC4gSWYgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGUgY2FzZSwgYWJvcnQgaGVyZSBzaW5jZSBuZXh0IHRhc2sgKGlmIGFueSkgaXMgYWxyZWFkeSBiZWluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUYXNrLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUYXNrLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGFzayBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHBlbmRpbmdUYXNrLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGByZXNvbHZpbmcgdGFzayBbbmFtZToke3BlbmRpbmdUYXNrLm5hbWV9XWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXNrIHdpdGggdGhlIG9idGFpbmVkIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBuZXh0IHBlbmRpbmcgdGFzayAoaWYgYW55KS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW25leHRQZW5kaW5nVGFza10gPSB0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogRHVyaW5nIHRoZSByZXNvbHZlKCkgY2FsbGJhY2sgdGhlIHVzZXIgYXBwIG1heSBoYXZlIGludGVyYWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgcXVldWUuIEZvciBpbnN0YW5jZSwgdGhlIGFwcCBtYXkgaGF2ZSBwdXNoZWQgYSB0YXNrIHdoaWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSB3YXMgZW1wdHkgc28gc3VjaCBhIHRhc2sgaXMgYWxyZWFkeSBiZWluZyBleGVjdXRlZC4gSWYgc28sXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgaXQgdHdpY2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UGVuZGluZ1Rhc2sgJiYgIW5leHRQZW5kaW5nVGFzay5leGVjdXRlZEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZXhlY3V0ZShuZXh0UGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWplY3Q6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nVGFzay5yZWplY3QoKSBjYW4gYmUgY2FsbGVkIHdpdGhpbiBleGVjdXRlKCkgbWV0aG9kIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXNrIGNvbXBsZXRlZCB3aXRoIGVycm9yLiBIb3dldmVyIGl0IG1heSBoYXZlIGFsc28gYmVlbiBjYWxsZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCgpIG9yIHJlbW92ZSgpIG1ldGhvZHMgKGJlZm9yZSBvciB3aGlsZSBiZWluZyBleGVjdXRlZCkgc28gaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBmbGFnIHdhcyBhbHJlYWR5IHNldC4gSWYgc28sIGFib3J0IGhlcmUgc2luY2UgbmV4dCB0YXNrXG4gICAgICAgICAgICAgICAgICAgIC8vIChpZiBhbnkpIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVGFzay5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVGFzay5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRhc2sgZnJvbSB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZShwZW5kaW5nVGFzay5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgcmVqZWN0aW5nIHRhc2sgW25hbWU6JHtwZW5kaW5nVGFzay5uYW1lfV06ICVzYCwgU3RyaW5nKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCB0aGUgdGFzayB3aXRoIHRoZSBvYnRhaW5lZCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgbmV4dCBwZW5kaW5nIHRhc2sgKGlmIGFueSkgdW5sZXNzIHN0b3AoKSBpcyBydW5uaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtuZXh0UGVuZGluZ1Rhc2tdID0gdGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBEdXJpbmcgdGhlIHJlamVjdCgpIGNhbGxiYWNrIHRoZSB1c2VyIGFwcCBtYXkgaGF2ZSBpbnRlcmFjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBxdWV1ZS4gRm9yIGluc3RhbmNlLCB0aGUgYXBwIG1heSBoYXZlIHB1c2hlZCBhIHRhc2sgd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSB3YXMgZW1wdHkgc28gc3VjaCBhIHRhc2sgaXMgYWxyZWFkeSBiZWluZyBleGVjdXRlZC4gSWYgc28sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBleGVjdXRlIGl0IHR3aWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQZW5kaW5nVGFzayAmJiAhbmV4dFBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZXhlY3V0ZShuZXh0UGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0YXNrIHRvIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldChwZW5kaW5nVGFzay5pZCwgcGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgLy8gQW5kIGV4ZWN1dGUgaXQgaWYgdGhpcyBpcyB0aGUgb25seSB0YXNrIGluIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdUYXNrcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmV4ZWN1dGUocGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wKCknKTtcbiAgICAgICAgdGhpcy5zdG9wcGluZyA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgcGVuZGluZ1Rhc2sgb2YgdGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zyhgc3RvcCgpIHwgc3RvcHBpbmcgdGFzayBbbmFtZToke3BlbmRpbmdUYXNrLm5hbWV9XWApO1xuICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVqZWN0KG5ldyBBd2FpdFF1ZXVlU3RvcHBlZEVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlKHRhc2tJZHgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGByZW1vdmUoKSBbdGFza0lkeDoke3Rhc2tJZHh9XWApO1xuICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpW3Rhc2tJZHhdO1xuICAgICAgICBpZiAoIXBlbmRpbmdUYXNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYHN0b3AoKSB8IG5vIHRhc2sgd2l0aCBnaXZlbiBpZHggW3Rhc2tJZHg6JHt0YXNrSWR4fV1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QobmV3IEF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yKCkpO1xuICAgIH1cbiAgICBkdW1wKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpLm1hcCgocGVuZGluZ1Rhc2spID0+ICh7XG4gICAgICAgICAgICBpZHg6IGlkeCsrLFxuICAgICAgICAgICAgdGFzazogcGVuZGluZ1Rhc2sudGFzayxcbiAgICAgICAgICAgIG5hbWU6IHBlbmRpbmdUYXNrLm5hbWUsXG4gICAgICAgICAgICBlbnF1ZXVlZFRpbWU6IHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXRcbiAgICAgICAgICAgICAgICA/IHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQgLSBwZW5kaW5nVGFzay5lbnF1ZXVlZEF0XG4gICAgICAgICAgICAgICAgOiBub3cgLSBwZW5kaW5nVGFzay5lbnF1ZXVlZEF0LFxuICAgICAgICAgICAgZXhlY3V0aW9uVGltZTogcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdFxuICAgICAgICAgICAgICAgID8gbm93IC0gcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdFxuICAgICAgICAgICAgICAgIDogMFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGUocGVuZGluZ1Rhc2spIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBleGVjdXRlKCkgW25hbWU6JHtwZW5kaW5nVGFzay5uYW1lfV1gKTtcbiAgICAgICAgaWYgKHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBhbHJlYWR5IGJlaW5nIGV4ZWN1dGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZW5kaW5nVGFzay50YXNrKCk7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXNrIHdpdGggaXRzIHJlc29sdmVkIHJlc3VsdCAoaWYgYW55KS5cbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlamVjdCB0aGUgdGFzayB3aXRoIGl0cyByZWplY3RlZCBlcnJvci5cbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF3YWl0UXVldWUgPSBBd2FpdFF1ZXVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js ***!
  \***********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/polyfills/process.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40X3N1cHBvcnRzLWNvbG9yQDkuNC4wL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPLDZCQUE2QixPQUFPO0FBQzdELE1BQU0sT0FBTztBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHFIQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWJ1Z0A0LjMuNF9zdXBwb3J0cy1jb2xvckA5LjQuMC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/ZmNjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/common.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/common.js ***!
  \**********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(app-client)/./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40X3N1cHBvcnRzLWNvbG9yQDkuNC4wL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLCtFQUFJO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWJ1Z0A0LjMuNF9zdXBwb3J0cy1jb2xvckA5LjQuMC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz8yZjhiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/common.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c0AzLjMuMC9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELFlBQVk7QUFDMUU7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9ldmVudHNAMy4zLjAvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanM/M2NkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/Logger.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/Logger.js ***!
  \******************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js\"));\nconst APP_NAME = 'h264-profile-level-id';\nclass Logger {\n    constructor(prefix) {\n        if (prefix) {\n            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);\n            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);\n            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);\n        }\n        else {\n            this._debug = (0, debug_1.default)(APP_NAME);\n            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);\n            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);\n        }\n        /* eslint-disable no-console */\n        this._debug.log = console.info.bind(console);\n        this._warn.log = console.warn.bind(console);\n        this._error.log = console.error.bind(console);\n        /* eslint-enable no-console */\n    }\n    get debug() {\n        return this._debug;\n    }\n    get warn() {\n        return this._warn;\n    }\n    get error() {\n        return this._error;\n    }\n}\nexports.Logger = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2gyNjQtcHJvZmlsZS1sZXZlbC1pZEAyLjAuMF9zdXBwb3J0cy1jb2xvckA5LjQuMC9ub2RlX21vZHVsZXMvaDI2NC1wcm9maWxlLWxldmVsLWlkL2xpYi9Mb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0NBQWdDLG1CQUFPLENBQUMsbUhBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUyxHQUFHLE9BQU87QUFDckUsaURBQWlELFNBQVMsUUFBUSxPQUFPO0FBQ3pFLGtEQUFrRCxTQUFTLFNBQVMsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRCxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vaDI2NC1wcm9maWxlLWxldmVsLWlkQDIuMC4wX3N1cHBvcnRzLWNvbG9yQDkuNC4wL25vZGVfbW9kdWxlcy9oMjY0LXByb2ZpbGUtbGV2ZWwtaWQvbGliL0xvZ2dlci5qcz9jMWM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBBUFBfTkFNRSA9ICdoMjY0LXByb2ZpbGUtbGV2ZWwtaWQnO1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtBUFBfTkFNRX06JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl93YXJuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OldBUk46JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0FQUF9OQU1FfTpFUlJPUjoke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoQVBQX05BTUUpO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0FQUF9OQU1FfTpXQVJOYCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0FQUF9OQU1FfTpFUlJPUmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgdGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX3dhcm4ubG9nID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnO1xuICAgIH1cbiAgICBnZXQgd2FybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm47XG4gICAgfVxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/Logger.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/index.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/index.js ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/Logger.js\");\nconst logger = new Logger_1.Logger();\n/**\n * Supported profiles.\n */\n// ESLint absurdly complains about \"'Profile' is already declared in\n// the upper scope\".\n// eslint-disable-next-line no-shadow\nvar Profile;\n(function (Profile) {\n    Profile[Profile[\"ConstrainedBaseline\"] = 1] = \"ConstrainedBaseline\";\n    Profile[Profile[\"Baseline\"] = 2] = \"Baseline\";\n    Profile[Profile[\"Main\"] = 3] = \"Main\";\n    Profile[Profile[\"ConstrainedHigh\"] = 4] = \"ConstrainedHigh\";\n    Profile[Profile[\"High\"] = 5] = \"High\";\n    Profile[Profile[\"PredictiveHigh444\"] = 6] = \"PredictiveHigh444\";\n})(Profile || (exports.Profile = Profile = {}));\n/**\n * Supported levels.\n */\n// ESLint absurdly complains about \"'Level' is already declared in\n// the upper scope\".\n// eslint-disable-next-line no-shadow\nvar Level;\n(function (Level) {\n    Level[Level[\"L1_b\"] = 0] = \"L1_b\";\n    Level[Level[\"L1\"] = 10] = \"L1\";\n    Level[Level[\"L1_1\"] = 11] = \"L1_1\";\n    Level[Level[\"L1_2\"] = 12] = \"L1_2\";\n    Level[Level[\"L1_3\"] = 13] = \"L1_3\";\n    Level[Level[\"L2\"] = 20] = \"L2\";\n    Level[Level[\"L2_1\"] = 21] = \"L2_1\";\n    Level[Level[\"L2_2\"] = 22] = \"L2_2\";\n    Level[Level[\"L3\"] = 30] = \"L3\";\n    Level[Level[\"L3_1\"] = 31] = \"L3_1\";\n    Level[Level[\"L3_2\"] = 32] = \"L3_2\";\n    Level[Level[\"L4\"] = 40] = \"L4\";\n    Level[Level[\"L4_1\"] = 41] = \"L4_1\";\n    Level[Level[\"L4_2\"] = 42] = \"L4_2\";\n    Level[Level[\"L5\"] = 50] = \"L5\";\n    Level[Level[\"L5_1\"] = 51] = \"L5_1\";\n    Level[Level[\"L5_2\"] = 52] = \"L5_2\";\n})(Level || (exports.Level = Level = {}));\n/**\n * Represents a parsed h264 profile-level-id value.\n */\nclass ProfileLevelId {\n    constructor(profile, level) {\n        this.profile = profile;\n        this.level = level;\n    }\n}\nexports.ProfileLevelId = ProfileLevelId;\n// Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\nconst DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);\n/**\n * Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to\n * be either 0 or 1.\n */\nclass BitPattern {\n    constructor(str) {\n        this.mask = ~byteMaskString('x', str);\n        this.masked_value = byteMaskString('1', str);\n    }\n    isMatch(value) {\n        return this.masked_value === (value & this.mask);\n    }\n}\n/**\n * Class for converting between profile_idc/profile_iop to Profile.\n */\nclass ProfilePattern {\n    constructor(profile_idc, profile_iop, profile) {\n        this.profile_idc = profile_idc;\n        this.profile_iop = profile_iop;\n        this.profile = profile;\n    }\n}\n// This is from https://tools.ietf.org/html/rfc6184#section-8.1.\nconst ProfilePatterns = [\n    new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline),\n    new ProfilePattern(0x4D, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline),\n    new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline),\n    new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline),\n    new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline),\n    new ProfilePattern(0x4D, new BitPattern('0x0x0000'), Profile.Main),\n    new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High),\n    new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh),\n    new ProfilePattern(0xF4, new BitPattern('00000000'), Profile.PredictiveHigh444)\n];\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n */\nfunction parseProfileLevelId(str) {\n    // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n    // flag specifies if level 1b or level 1.1 is used.\n    const ConstraintSet3Flag = 0x10;\n    // The string should consist of 3 bytes in hexadecimal format.\n    if (typeof str !== 'string' || str.length !== 6) {\n        return undefined;\n    }\n    const profile_level_id_numeric = parseInt(str, 16);\n    if (profile_level_id_numeric === 0) {\n        return undefined;\n    }\n    // Separate into three bytes.\n    const level_idc = (profile_level_id_numeric & 0xFF);\n    const profile_iop = (profile_level_id_numeric >> 8) & 0xFF;\n    const profile_idc = (profile_level_id_numeric >> 16) & 0xFF;\n    // Parse level based on level_idc and constraint set 3 flag.\n    let level;\n    switch (level_idc) {\n        case Level.L1_1:\n            {\n                level = (profile_iop & ConstraintSet3Flag) !== 0\n                    ? Level.L1_b\n                    : Level.L1_1;\n                break;\n            }\n        case Level.L1:\n        case Level.L1_2:\n        case Level.L1_3:\n        case Level.L2:\n        case Level.L2_1:\n        case Level.L2_2:\n        case Level.L3:\n        case Level.L3_1:\n        case Level.L3_2:\n        case Level.L4:\n        case Level.L4_1:\n        case Level.L4_2:\n        case Level.L5:\n        case Level.L5_1:\n        case Level.L5_2:\n            {\n                level = level_idc;\n                break;\n            }\n        // Unrecognized level_idc.\n        default:\n            {\n                logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);\n                return undefined;\n            }\n    }\n    // Parse profile_idc/profile_iop into a Profile enum.\n    for (const pattern of ProfilePatterns) {\n        if (profile_idc === pattern.profile_idc &&\n            pattern.profile_iop.isMatch(profile_iop)) {\n            return new ProfileLevelId(pattern.profile, level);\n        }\n    }\n    logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);\n    return undefined;\n}\nexports.parseProfileLevelId = parseProfileLevelId;\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n */\nfunction profileLevelIdToString(profile_level_id) {\n    // Handle special case level == 1b.\n    if (profile_level_id.level == Level.L1_b) {\n        switch (profile_level_id.profile) {\n            case Profile.ConstrainedBaseline:\n                {\n                    return '42f00b';\n                }\n            case Profile.Baseline:\n                {\n                    return '42100b';\n                }\n            case Profile.Main:\n                {\n                    return '4d100b';\n                }\n            // Level 1_b is not allowed for other profiles.\n            default:\n                {\n                    logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);\n                    return undefined;\n                }\n        }\n    }\n    let profile_idc_iop_string;\n    switch (profile_level_id.profile) {\n        case Profile.ConstrainedBaseline:\n            {\n                profile_idc_iop_string = '42e0';\n                break;\n            }\n        case Profile.Baseline:\n            {\n                profile_idc_iop_string = '4200';\n                break;\n            }\n        case Profile.Main:\n            {\n                profile_idc_iop_string = '4d00';\n                break;\n            }\n        case Profile.ConstrainedHigh:\n            {\n                profile_idc_iop_string = '640c';\n                break;\n            }\n        case Profile.High:\n            {\n                profile_idc_iop_string = '6400';\n                break;\n            }\n        case Profile.PredictiveHigh444:\n            {\n                profile_idc_iop_string = 'f400';\n                break;\n            }\n        default:\n            {\n                logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);\n                return undefined;\n            }\n    }\n    let levelStr = (profile_level_id.level).toString(16);\n    if (levelStr.length === 1) {\n        levelStr = `0${levelStr}`;\n    }\n    return `${profile_idc_iop_string}${levelStr}`;\n}\nexports.profileLevelIdToString = profileLevelIdToString;\n/**\n * Returns a human friendly name for the given profile.\n */\nfunction profileToString(profile) {\n    switch (profile) {\n        case Profile.ConstrainedBaseline:\n            {\n                return 'ConstrainedBaseline';\n            }\n        case Profile.Baseline:\n            {\n                return 'Baseline';\n            }\n        case Profile.Main:\n            {\n                return 'Main';\n            }\n        case Profile.ConstrainedHigh:\n            {\n                return 'ConstrainedHigh';\n            }\n        case Profile.High:\n            {\n                return 'High';\n            }\n        case Profile.PredictiveHigh444:\n            {\n                return 'PredictiveHigh444';\n            }\n        default:\n            {\n                logger.warn(`profileToString() | unrecognized profile ${profile}`);\n                return undefined;\n            }\n    }\n}\nexports.profileToString = profileToString;\n/**\n * Returns a human friendly name for the given level.\n */\nfunction levelToString(level) {\n    switch (level) {\n        case Level.L1_b:\n            {\n                return '1b';\n            }\n        case Level.L1:\n            {\n                return '1';\n            }\n        case Level.L1_1:\n            {\n                return '1.1';\n            }\n        case Level.L1_2:\n            {\n                return '1.2';\n            }\n        case Level.L1_3:\n            {\n                return '1.3';\n            }\n        case Level.L2:\n            {\n                return '2';\n            }\n        case Level.L2_1:\n            {\n                return '2.1';\n            }\n        case Level.L2_2:\n            {\n                return '2.2';\n            }\n        case Level.L3:\n            {\n                return '3';\n            }\n        case Level.L3_1:\n            {\n                return '3.1';\n            }\n        case Level.L3_2:\n            {\n                return '3.2';\n            }\n        case Level.L4:\n            {\n                return '4';\n            }\n        case Level.L4_1:\n            {\n                return '4.1';\n            }\n        case Level.L4_2:\n            {\n                return '4.2';\n            }\n        case Level.L5:\n            {\n                return '5';\n            }\n        case Level.L5_1:\n            {\n                return '5.1';\n            }\n        case Level.L5_2:\n            {\n                return '5.2';\n            }\n        default:\n            {\n                logger.warn(`levelToString() | unrecognized level ${level}`);\n                return undefined;\n            }\n    }\n}\nexports.levelToString = levelToString;\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned\n * if the key is present but the string is invalid.\n */\nfunction parseSdpProfileLevelId(params = {}) {\n    const profile_level_id = params['profile-level-id'];\n    return profile_level_id\n        ? parseProfileLevelId(profile_level_id)\n        : DefaultProfileLevelId;\n}\nexports.parseSdpProfileLevelId = parseSdpProfileLevelId;\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n */\nfunction isSameProfile(params1 = {}, params2 = {}) {\n    const profile_level_id_1 = parseSdpProfileLevelId(params1);\n    const profile_level_id_2 = parseSdpProfileLevelId(params2);\n    // Compare H264 profiles, but not levels.\n    return Boolean(profile_level_id_1 &&\n        profile_level_id_2 &&\n        profile_level_id_1.profile === profile_level_id_2.profile);\n}\nexports.isSameProfile = isSameProfile;\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict\n * superset of the profile in remote_offered_params, we could limit the profile\n * in the answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and\n * level-asymmetry-allowed.\n */\nfunction generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {\n    // If both local and remote params do not contain profile-level-id, they are\n    // both using the default profile. In this case, don't return anything.\n    if (!local_supported_params['profile-level-id'] &&\n        !remote_offered_params['profile-level-id']) {\n        logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');\n        return undefined;\n    }\n    // Parse profile-level-ids.\n    const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);\n    const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);\n    // The local and remote codec must have valid and equal H264 Profiles.\n    if (!local_profile_level_id) {\n        throw new TypeError('invalid local_profile_level_id');\n    }\n    if (!remote_profile_level_id) {\n        throw new TypeError('invalid remote_profile_level_id');\n    }\n    if (local_profile_level_id.profile !== remote_profile_level_id.profile) {\n        throw new TypeError('H264 Profile mismatch');\n    }\n    // Parse level information.\n    const level_asymmetry_allowed = (isLevelAsymmetryAllowed(local_supported_params) &&\n        isLevelAsymmetryAllowed(remote_offered_params));\n    const local_level = local_profile_level_id.level;\n    const remote_level = remote_profile_level_id.level;\n    const min_level = minLevel(local_level, remote_level);\n    // Determine answer level. When level asymmetry is not allowed, level upgrade\n    // is not allowed, i.e., the level in the answer must be equal to or lower\n    // than the level in the offer.\n    const answer_level = level_asymmetry_allowed\n        ? local_level\n        : min_level;\n    logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);\n    // Return the resulting profile-level-id for the answer parameters.\n    return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));\n}\nexports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;\n/**\n * Convert a string of 8 characters into a byte where the positions containing\n * character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n * will return 0b10110000.\n */\nfunction byteMaskString(c, str) {\n    return ((Number(str[0] === c) << 7) | (Number(str[1] === c) << 6) |\n        (Number(str[2] === c) << 5) | (Number(str[3] === c) << 4) |\n        (Number(str[4] === c) << 3) | (Number(str[5] === c) << 2) |\n        (Number(str[6] === c) << 1) | (Number(str[7] === c) << 0));\n}\n// Compare H264 levels and handle the level 1b case.\nfunction isLessLevel(a, b) {\n    if (a === Level.L1_b) {\n        return b !== Level.L1 && b !== Level.L1_b;\n    }\n    if (b === Level.L1_b) {\n        return a !== Level.L1;\n    }\n    return a < b;\n}\nfunction minLevel(a, b) {\n    return isLessLevel(a, b) ? a : b;\n}\nfunction isLevelAsymmetryAllowed(params = {}) {\n    const level_asymmetry_allowed = params['level-asymmetry-allowed'];\n    return (level_asymmetry_allowed === true ||\n        level_asymmetry_allowed === 1 ||\n        level_asymmetry_allowed === '1');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2gyNjQtcHJvZmlsZS1sZXZlbC1pZEAyLjAuMF9zdXBwb3J0cy1jb2xvckA5LjQuMC9ub2RlX21vZHVsZXMvaDI2NC1wcm9maWxlLWxldmVsLWlkL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2Q0FBNkMsR0FBRyxxQkFBcUIsR0FBRyw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUIsR0FBRyw4QkFBOEIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxhQUFhLEdBQUcsZUFBZTtBQUNsUixpQkFBaUIsbUJBQU8sQ0FBQyxxSkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWMsZUFBZSxlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxZQUFZLGFBQWEsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLElBQUksY0FBYyxVQUFVO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLElBQUksZ0JBQWdCLFlBQVksZ0JBQWdCLFlBQVk7QUFDN0o7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHlCQUF5QjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHlCQUF5QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQSxjQUFjLHVCQUF1QixFQUFFLFNBQVM7QUFDaEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsUUFBUTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDRCQUE0QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLCtCQUErQixVQUFVLGFBQWE7QUFDcEk7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oMjY0LXByb2ZpbGUtbGV2ZWwtaWRAMi4wLjBfc3VwcG9ydHMtY29sb3JAOS40LjAvbm9kZV9tb2R1bGVzL2gyNjQtcHJvZmlsZS1sZXZlbC1pZC9saWIvaW5kZXguanM/ZTcxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlciA9IGV4cG9ydHMuaXNTYW1lUHJvZmlsZSA9IGV4cG9ydHMucGFyc2VTZHBQcm9maWxlTGV2ZWxJZCA9IGV4cG9ydHMubGV2ZWxUb1N0cmluZyA9IGV4cG9ydHMucHJvZmlsZVRvU3RyaW5nID0gZXhwb3J0cy5wcm9maWxlTGV2ZWxJZFRvU3RyaW5nID0gZXhwb3J0cy5wYXJzZVByb2ZpbGVMZXZlbElkID0gZXhwb3J0cy5Qcm9maWxlTGV2ZWxJZCA9IGV4cG9ydHMuTGV2ZWwgPSBleHBvcnRzLlByb2ZpbGUgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoKTtcbi8qKlxuICogU3VwcG9ydGVkIHByb2ZpbGVzLlxuICovXG4vLyBFU0xpbnQgYWJzdXJkbHkgY29tcGxhaW5zIGFib3V0IFwiJ1Byb2ZpbGUnIGlzIGFscmVhZHkgZGVjbGFyZWQgaW5cbi8vIHRoZSB1cHBlciBzY29wZVwiLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xudmFyIFByb2ZpbGU7XG4oZnVuY3Rpb24gKFByb2ZpbGUpIHtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJDb25zdHJhaW5lZEJhc2VsaW5lXCJdID0gMV0gPSBcIkNvbnN0cmFpbmVkQmFzZWxpbmVcIjtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJCYXNlbGluZVwiXSA9IDJdID0gXCJCYXNlbGluZVwiO1xuICAgIFByb2ZpbGVbUHJvZmlsZVtcIk1haW5cIl0gPSAzXSA9IFwiTWFpblwiO1xuICAgIFByb2ZpbGVbUHJvZmlsZVtcIkNvbnN0cmFpbmVkSGlnaFwiXSA9IDRdID0gXCJDb25zdHJhaW5lZEhpZ2hcIjtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJIaWdoXCJdID0gNV0gPSBcIkhpZ2hcIjtcbiAgICBQcm9maWxlW1Byb2ZpbGVbXCJQcmVkaWN0aXZlSGlnaDQ0NFwiXSA9IDZdID0gXCJQcmVkaWN0aXZlSGlnaDQ0NFwiO1xufSkoUHJvZmlsZSB8fCAoZXhwb3J0cy5Qcm9maWxlID0gUHJvZmlsZSA9IHt9KSk7XG4vKipcbiAqIFN1cHBvcnRlZCBsZXZlbHMuXG4gKi9cbi8vIEVTTGludCBhYnN1cmRseSBjb21wbGFpbnMgYWJvdXQgXCInTGV2ZWwnIGlzIGFscmVhZHkgZGVjbGFyZWQgaW5cbi8vIHRoZSB1cHBlciBzY29wZVwiLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xudmFyIExldmVsO1xuKGZ1bmN0aW9uIChMZXZlbCkge1xuICAgIExldmVsW0xldmVsW1wiTDFfYlwiXSA9IDBdID0gXCJMMV9iXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMMVwiXSA9IDEwXSA9IFwiTDFcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwxXzFcIl0gPSAxMV0gPSBcIkwxXzFcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwxXzJcIl0gPSAxMl0gPSBcIkwxXzJcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwxXzNcIl0gPSAxM10gPSBcIkwxXzNcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkwyXCJdID0gMjBdID0gXCJMMlwiO1xuICAgIExldmVsW0xldmVsW1wiTDJfMVwiXSA9IDIxXSA9IFwiTDJfMVwiO1xuICAgIExldmVsW0xldmVsW1wiTDJfMlwiXSA9IDIyXSA9IFwiTDJfMlwiO1xuICAgIExldmVsW0xldmVsW1wiTDNcIl0gPSAzMF0gPSBcIkwzXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMM18xXCJdID0gMzFdID0gXCJMM18xXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMM18yXCJdID0gMzJdID0gXCJMM18yXCI7XG4gICAgTGV2ZWxbTGV2ZWxbXCJMNFwiXSA9IDQwXSA9IFwiTDRcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkw0XzFcIl0gPSA0MV0gPSBcIkw0XzFcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkw0XzJcIl0gPSA0Ml0gPSBcIkw0XzJcIjtcbiAgICBMZXZlbFtMZXZlbFtcIkw1XCJdID0gNTBdID0gXCJMNVwiO1xuICAgIExldmVsW0xldmVsW1wiTDVfMVwiXSA9IDUxXSA9IFwiTDVfMVwiO1xuICAgIExldmVsW0xldmVsW1wiTDVfMlwiXSA9IDUyXSA9IFwiTDVfMlwiO1xufSkoTGV2ZWwgfHwgKGV4cG9ydHMuTGV2ZWwgPSBMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwYXJzZWQgaDI2NCBwcm9maWxlLWxldmVsLWlkIHZhbHVlLlxuICovXG5jbGFzcyBQcm9maWxlTGV2ZWxJZCB7XG4gICAgY29uc3RydWN0b3IocHJvZmlsZSwgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZmlsZUxldmVsSWQgPSBQcm9maWxlTGV2ZWxJZDtcbi8vIERlZmF1bHQgUHJvZmlsZUxldmVsSWQuXG4vL1xuLy8gVE9ETzogVGhlIGRlZmF1bHQgc2hvdWxkIHJlYWxseSBiZSBwcm9maWxlIEJhc2VsaW5lIGFuZCBsZXZlbCAxIGFjY29yZGluZyB0b1xuLy8gdGhlIHNwZWM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MTg0I3NlY3Rpb24tOC4xLiBJbiBvcmRlciB0byBub3Rcbi8vIGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgV2ViUlRDIHdoZXJlIGV4dGVybmFsXG4vLyBjb2RlY3MgZG9uJ3QgaGF2ZSBhbnkgcGFyYW1ldGVycywgdXNlIHByb2ZpbGUgQ29uc3RyYWluZWRCYXNlbGluZSBsZXZlbCAzXzFcbi8vIGluc3RlYWQuIFRoaXMgd29ya2Fyb3VuZCB3aWxsIG9ubHkgYmUgZG9uZSBpbiBhbiBpbnRlcmltIHBlcmlvZCB0byBhbGxvd1xuLy8gZXh0ZXJuYWwgY2xpZW50cyB0byB1cGRhdGUgdGhlaXIgY29kZS5cbi8vXG4vLyBodHRwOi8vY3JidWcvd2VicnRjLzYzMzcuXG5jb25zdCBEZWZhdWx0UHJvZmlsZUxldmVsSWQgPSBuZXcgUHJvZmlsZUxldmVsSWQoUHJvZmlsZS5Db25zdHJhaW5lZEJhc2VsaW5lLCBMZXZlbC5MM18xKTtcbi8qKlxuICogQ2xhc3MgZm9yIG1hdGNoaW5nIGJpdCBwYXR0ZXJucyBzdWNoIGFzIFwieDF4eDAwMDBcIiB3aGVyZSAneCcgaXMgYWxsb3dlZCB0b1xuICogYmUgZWl0aGVyIDAgb3IgMS5cbiAqL1xuY2xhc3MgQml0UGF0dGVybiB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMubWFzayA9IH5ieXRlTWFza1N0cmluZygneCcsIHN0cik7XG4gICAgICAgIHRoaXMubWFza2VkX3ZhbHVlID0gYnl0ZU1hc2tTdHJpbmcoJzEnLCBzdHIpO1xuICAgIH1cbiAgICBpc01hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hc2tlZF92YWx1ZSA9PT0gKHZhbHVlICYgdGhpcy5tYXNrKTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gcHJvZmlsZV9pZGMvcHJvZmlsZV9pb3AgdG8gUHJvZmlsZS5cbiAqL1xuY2xhc3MgUHJvZmlsZVBhdHRlcm4ge1xuICAgIGNvbnN0cnVjdG9yKHByb2ZpbGVfaWRjLCBwcm9maWxlX2lvcCwgcHJvZmlsZSkge1xuICAgICAgICB0aGlzLnByb2ZpbGVfaWRjID0gcHJvZmlsZV9pZGM7XG4gICAgICAgIHRoaXMucHJvZmlsZV9pb3AgPSBwcm9maWxlX2lvcDtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcbiAgICB9XG59XG4vLyBUaGlzIGlzIGZyb20gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxODQjc2VjdGlvbi04LjEuXG5jb25zdCBQcm9maWxlUGF0dGVybnMgPSBbXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4NDIsIG5ldyBCaXRQYXR0ZXJuKCd4MXh4MDAwMCcpLCBQcm9maWxlLkNvbnN0cmFpbmVkQmFzZWxpbmUpLFxuICAgIG5ldyBQcm9maWxlUGF0dGVybigweDRELCBuZXcgQml0UGF0dGVybignMXh4eDAwMDAnKSwgUHJvZmlsZS5Db25zdHJhaW5lZEJhc2VsaW5lKSxcbiAgICBuZXcgUHJvZmlsZVBhdHRlcm4oMHg1OCwgbmV3IEJpdFBhdHRlcm4oJzExeHgwMDAwJyksIFByb2ZpbGUuQ29uc3RyYWluZWRCYXNlbGluZSksXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4NDIsIG5ldyBCaXRQYXR0ZXJuKCd4MHh4MDAwMCcpLCBQcm9maWxlLkJhc2VsaW5lKSxcbiAgICBuZXcgUHJvZmlsZVBhdHRlcm4oMHg1OCwgbmV3IEJpdFBhdHRlcm4oJzEweHgwMDAwJyksIFByb2ZpbGUuQmFzZWxpbmUpLFxuICAgIG5ldyBQcm9maWxlUGF0dGVybigweDRELCBuZXcgQml0UGF0dGVybignMHgweDAwMDAnKSwgUHJvZmlsZS5NYWluKSxcbiAgICBuZXcgUHJvZmlsZVBhdHRlcm4oMHg2NCwgbmV3IEJpdFBhdHRlcm4oJzAwMDAwMDAwJyksIFByb2ZpbGUuSGlnaCksXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4NjQsIG5ldyBCaXRQYXR0ZXJuKCcwMDAwMTEwMCcpLCBQcm9maWxlLkNvbnN0cmFpbmVkSGlnaCksXG4gICAgbmV3IFByb2ZpbGVQYXR0ZXJuKDB4RjQsIG5ldyBCaXRQYXR0ZXJuKCcwMDAwMDAwMCcpLCBQcm9maWxlLlByZWRpY3RpdmVIaWdoNDQ0KVxuXTtcbi8qKlxuICogUGFyc2UgcHJvZmlsZSBsZXZlbCBpZCB0aGF0IGlzIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9mIDMgaGV4IGJ5dGVzLlxuICogTm90aGluZyB3aWxsIGJlIHJldHVybmVkIGlmIHRoZSBzdHJpbmcgaXMgbm90IGEgcmVjb2duaXplZCBIMjY0IHByb2ZpbGVcbiAqIGxldmVsIGlkLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb2ZpbGVMZXZlbElkKHN0cikge1xuICAgIC8vIEZvciBsZXZlbF9pZGM9MTEgYW5kIHByb2ZpbGVfaWRjPTB4NDIsIDB4NEQsIG9yIDB4NTgsIHRoZSBjb25zdHJhaW50IHNldDNcbiAgICAvLyBmbGFnIHNwZWNpZmllcyBpZiBsZXZlbCAxYiBvciBsZXZlbCAxLjEgaXMgdXNlZC5cbiAgICBjb25zdCBDb25zdHJhaW50U2V0M0ZsYWcgPSAweDEwO1xuICAgIC8vIFRoZSBzdHJpbmcgc2hvdWxkIGNvbnNpc3Qgb2YgMyBieXRlcyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IHN0ci5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcHJvZmlsZV9sZXZlbF9pZF9udW1lcmljID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgaWYgKHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBTZXBhcmF0ZSBpbnRvIHRocmVlIGJ5dGVzLlxuICAgIGNvbnN0IGxldmVsX2lkYyA9IChwcm9maWxlX2xldmVsX2lkX251bWVyaWMgJiAweEZGKTtcbiAgICBjb25zdCBwcm9maWxlX2lvcCA9IChwcm9maWxlX2xldmVsX2lkX251bWVyaWMgPj4gOCkgJiAweEZGO1xuICAgIGNvbnN0IHByb2ZpbGVfaWRjID0gKHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA+PiAxNikgJiAweEZGO1xuICAgIC8vIFBhcnNlIGxldmVsIGJhc2VkIG9uIGxldmVsX2lkYyBhbmQgY29uc3RyYWludCBzZXQgMyBmbGFnLlxuICAgIGxldCBsZXZlbDtcbiAgICBzd2l0Y2ggKGxldmVsX2lkYykge1xuICAgICAgICBjYXNlIExldmVsLkwxXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSAocHJvZmlsZV9pb3AgJiBDb25zdHJhaW50U2V0M0ZsYWcpICE9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gTGV2ZWwuTDFfYlxuICAgICAgICAgICAgICAgICAgICA6IExldmVsLkwxXzE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDE6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDFfMjpcbiAgICAgICAgY2FzZSBMZXZlbC5MMV8zOlxuICAgICAgICBjYXNlIExldmVsLkwyOlxuICAgICAgICBjYXNlIExldmVsLkwyXzE6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDJfMjpcbiAgICAgICAgY2FzZSBMZXZlbC5MMzpcbiAgICAgICAgY2FzZSBMZXZlbC5MM18xOlxuICAgICAgICBjYXNlIExldmVsLkwzXzI6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDQ6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDRfMTpcbiAgICAgICAgY2FzZSBMZXZlbC5MNF8yOlxuICAgICAgICBjYXNlIExldmVsLkw1OlxuICAgICAgICBjYXNlIExldmVsLkw1XzE6XG4gICAgICAgIGNhc2UgTGV2ZWwuTDVfMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IGxldmVsX2lkYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVW5yZWNvZ25pemVkIGxldmVsX2lkYy5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcGFyc2VQcm9maWxlTGV2ZWxJZCgpIHwgdW5yZWNvZ25pemVkIGxldmVsX2lkYyBbc3RyOiR7c3RyfSwgbGV2ZWxfaWRjOiR7bGV2ZWxfaWRjfV1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBwcm9maWxlX2lkYy9wcm9maWxlX2lvcCBpbnRvIGEgUHJvZmlsZSBlbnVtLlxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBQcm9maWxlUGF0dGVybnMpIHtcbiAgICAgICAgaWYgKHByb2ZpbGVfaWRjID09PSBwYXR0ZXJuLnByb2ZpbGVfaWRjICYmXG4gICAgICAgICAgICBwYXR0ZXJuLnByb2ZpbGVfaW9wLmlzTWF0Y2gocHJvZmlsZV9pb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb2ZpbGVMZXZlbElkKHBhdHRlcm4ucHJvZmlsZSwgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci53YXJuKGBwYXJzZVByb2ZpbGVMZXZlbElkKCkgfCB1bnJlY29nbml6ZWQgcHJvZmlsZV9pZGMvcHJvZmlsZV9pb3AgY29tYmluYXRpb24gW3N0cjoke3N0cn0sIHByb2ZpbGVfaWRjOiR7cHJvZmlsZV9pZGN9LCBwcm9maWxlX2lvcDoke3Byb2ZpbGVfaW9wfV1gKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5wYXJzZVByb2ZpbGVMZXZlbElkID0gcGFyc2VQcm9maWxlTGV2ZWxJZDtcbi8qKlxuICogUmV0dXJucyBjYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIHRocmVlIGhleCBieXRlcyBvZiB0aGUgcHJvZmlsZVxuICogbGV2ZWwgaWQsIG9yIHJldHVybnMgbm90aGluZyBmb3IgaW52YWxpZCBwcm9maWxlIGxldmVsIGlkcy5cbiAqL1xuZnVuY3Rpb24gcHJvZmlsZUxldmVsSWRUb1N0cmluZyhwcm9maWxlX2xldmVsX2lkKSB7XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBsZXZlbCA9PSAxYi5cbiAgICBpZiAocHJvZmlsZV9sZXZlbF9pZC5sZXZlbCA9PSBMZXZlbC5MMV9iKSB7XG4gICAgICAgIHN3aXRjaCAocHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlKSB7XG4gICAgICAgICAgICBjYXNlIFByb2ZpbGUuQ29uc3RyYWluZWRCYXNlbGluZTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnNDJmMDBiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFByb2ZpbGUuQmFzZWxpbmU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzQyMTAwYic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQcm9maWxlLk1haW46XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzRkMTAwYic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV2ZWwgMV9iIGlzIG5vdCBhbGxvd2VkIGZvciBvdGhlciBwcm9maWxlcy5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcHJvZmlsZUxldmVsSWRUb1N0cmluZygpIHwgTGV2ZWwgMV9iIG5vdCBpcyBhbGxvd2VkIGZvciBwcm9maWxlICR7cHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvZmlsZV9pZGNfaW9wX3N0cmluZztcbiAgICBzd2l0Y2ggKHByb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSkge1xuICAgICAgICBjYXNlIFByb2ZpbGUuQ29uc3RyYWluZWRCYXNlbGluZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzQyZTAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuQmFzZWxpbmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICc0MjAwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLk1haW46XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICc0ZDAwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLkNvbnN0cmFpbmVkSGlnaDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzY0MGMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuSGlnaDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzY0MDAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuUHJlZGljdGl2ZUhpZ2g0NDQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICdmNDAwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcHJvZmlsZUxldmVsSWRUb1N0cmluZygpIHwgdW5yZWNvZ25pemVkIHByb2ZpbGUgJHtwcm9maWxlX2xldmVsX2lkLnByb2ZpbGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxldmVsU3RyID0gKHByb2ZpbGVfbGV2ZWxfaWQubGV2ZWwpLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAobGV2ZWxTdHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGxldmVsU3RyID0gYDAke2xldmVsU3RyfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcm9maWxlX2lkY19pb3Bfc3RyaW5nfSR7bGV2ZWxTdHJ9YDtcbn1cbmV4cG9ydHMucHJvZmlsZUxldmVsSWRUb1N0cmluZyA9IHByb2ZpbGVMZXZlbElkVG9TdHJpbmc7XG4vKipcbiAqIFJldHVybnMgYSBodW1hbiBmcmllbmRseSBuYW1lIGZvciB0aGUgZ2l2ZW4gcHJvZmlsZS5cbiAqL1xuZnVuY3Rpb24gcHJvZmlsZVRvU3RyaW5nKHByb2ZpbGUpIHtcbiAgICBzd2l0Y2ggKHByb2ZpbGUpIHtcbiAgICAgICAgY2FzZSBQcm9maWxlLkNvbnN0cmFpbmVkQmFzZWxpbmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDb25zdHJhaW5lZEJhc2VsaW5lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLkJhc2VsaW5lOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQmFzZWxpbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuTWFpbjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01haW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGUuQ29uc3RyYWluZWRIaWdoOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ29uc3RyYWluZWRIaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLkhpZ2g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdIaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9maWxlLlByZWRpY3RpdmVIaWdoNDQ0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnUHJlZGljdGl2ZUhpZ2g0NDQnO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBwcm9maWxlVG9TdHJpbmcoKSB8IHVucmVjb2duaXplZCBwcm9maWxlICR7cHJvZmlsZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucHJvZmlsZVRvU3RyaW5nID0gcHJvZmlsZVRvU3RyaW5nO1xuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4gZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGdpdmVuIGxldmVsLlxuICovXG5mdW5jdGlvbiBsZXZlbFRvU3RyaW5nKGxldmVsKSB7XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlIExldmVsLkwxX2I6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcxYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMV8xOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMS4xJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMV8yOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMS4yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMV8zOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMS4zJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzInO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkwyXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcyLjEnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkwyXzI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcyLjInO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkwzOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDNfMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzMuMSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDNfMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzMuMic7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTGV2ZWwuTDQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MNF8xOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnNC4xJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MNF8yOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAnNC4yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBMZXZlbC5MNTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzUnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkw1XzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc1LjEnO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIExldmVsLkw1XzI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc1LjInO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbFRvU3RyaW5nKCkgfCB1bnJlY29nbml6ZWQgbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubGV2ZWxUb1N0cmluZyA9IGxldmVsVG9TdHJpbmc7XG4vKipcbiAqIFBhcnNlIHByb2ZpbGUgbGV2ZWwgaWQgdGhhdCBpcyByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvZiAzIGhleCBieXRlc1xuICogY29udGFpbmVkIGluIGFuIFNEUCBrZXktdmFsdWUgbWFwLiBBIGRlZmF1bHQgcHJvZmlsZSBsZXZlbCBpZCB3aWxsIGJlXG4gKiByZXR1cm5lZCBpZiB0aGUgcHJvZmlsZS1sZXZlbC1pZCBrZXkgaXMgbWlzc2luZy4gTm90aGluZyB3aWxsIGJlIHJldHVybmVkXG4gKiBpZiB0aGUga2V5IGlzIHByZXNlbnQgYnV0IHRoZSBzdHJpbmcgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTZHBQcm9maWxlTGV2ZWxJZChwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWQgPSBwYXJhbXNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICByZXR1cm4gcHJvZmlsZV9sZXZlbF9pZFxuICAgICAgICA/IHBhcnNlUHJvZmlsZUxldmVsSWQocHJvZmlsZV9sZXZlbF9pZClcbiAgICAgICAgOiBEZWZhdWx0UHJvZmlsZUxldmVsSWQ7XG59XG5leHBvcnRzLnBhcnNlU2RwUHJvZmlsZUxldmVsSWQgPSBwYXJzZVNkcFByb2ZpbGVMZXZlbElkO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSB0aGUgc2FtZSBIMjY0IHByb2ZpbGUsIGkuZS4gdGhlIHNhbWVcbiAqIEgyNjQgcHJvZmlsZSAoQmFzZWxpbmUsIEhpZ2gsIGV0YykuXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZVByb2ZpbGUocGFyYW1zMSA9IHt9LCBwYXJhbXMyID0ge30pIHtcbiAgICBjb25zdCBwcm9maWxlX2xldmVsX2lkXzEgPSBwYXJzZVNkcFByb2ZpbGVMZXZlbElkKHBhcmFtczEpO1xuICAgIGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWRfMiA9IHBhcnNlU2RwUHJvZmlsZUxldmVsSWQocGFyYW1zMik7XG4gICAgLy8gQ29tcGFyZSBIMjY0IHByb2ZpbGVzLCBidXQgbm90IGxldmVscy5cbiAgICByZXR1cm4gQm9vbGVhbihwcm9maWxlX2xldmVsX2lkXzEgJiZcbiAgICAgICAgcHJvZmlsZV9sZXZlbF9pZF8yICYmXG4gICAgICAgIHByb2ZpbGVfbGV2ZWxfaWRfMS5wcm9maWxlID09PSBwcm9maWxlX2xldmVsX2lkXzIucHJvZmlsZSk7XG59XG5leHBvcnRzLmlzU2FtZVByb2ZpbGUgPSBpc1NhbWVQcm9maWxlO1xuLyoqXG4gKiBHZW5lcmF0ZSBjb2RlYyBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGFuc3dlciBpbiBhbiBTRFAgbmVnb3RpYXRpb25cbiAqIGJhc2VkIG9uIGxvY2FsIHN1cHBvcnRlZCBwYXJhbWV0ZXJzIGFuZCByZW1vdGUgb2ZmZXJlZCBwYXJhbWV0ZXJzLiBCb3RoXG4gKiBsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zIGFuZCByZW1vdGVfb2ZmZXJlZF9wYXJhbXMgcmVwcmVzZW50IHNlbmRyZWN2IG1lZGlhXG4gKiBkZXNjcmlwdGlvbnMsIGkuZSB0aGV5IGFyZSBhIG1peCBvZiBib3RoIGVuY29kZSBhbmQgZGVjb2RlIGNhcGFiaWxpdGllcy4gSW5cbiAqIHRoZW9yeSwgd2hlbiB0aGUgcHJvZmlsZSBpbiBsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zIHJlcHJlc2VudCBhIHN0cmljdFxuICogc3VwZXJzZXQgb2YgdGhlIHByb2ZpbGUgaW4gcmVtb3RlX29mZmVyZWRfcGFyYW1zLCB3ZSBjb3VsZCBsaW1pdCB0aGUgcHJvZmlsZVxuICogaW4gdGhlIGFuc3dlciB0byB0aGUgcHJvZmlsZSBpbiByZW1vdGVfb2ZmZXJlZF9wYXJhbXMuXG4gKlxuICogSG93ZXZlciwgdG8gc2ltcGxpZnkgdGhlIGNvZGUsIGVhY2ggc3VwcG9ydGVkIEgyNjQgcHJvZmlsZSBzaG91bGQgYmUgbGlzdGVkXG4gKiBleHBsaWNpdGx5IGluIHRoZSBsaXN0IG9mIGxvY2FsIHN1cHBvcnRlZCBjb2RlY3MsIGV2ZW4gaWYgdGhleSBhcmUgcmVkdW5kYW50LlxuICogVGhlbiBlYWNoIGxvY2FsIGNvZGVjIGluIHRoZSBsaXN0IHNob3VsZCBiZSB0ZXN0ZWQgb25lIGF0IGEgdGltZSBhZ2FpbnN0IHRoZVxuICogcmVtb3RlIGNvZGVjLCBhbmQgb25seSB3aGVuIHRoZSBwcm9maWxlcyBhcmUgZXF1YWwgc2hvdWxkIHRoaXMgZnVuY3Rpb24gYmVcbiAqIGNhbGxlZC4gVGhlcmVmb3JlLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gaGFuZGxlIHByb2ZpbGUgaW50ZXJzZWN0aW9uLFxuICogYW5kIHRoZSBwcm9maWxlIG9mIGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMgYW5kIHJlbW90ZV9vZmZlcmVkX3BhcmFtcyBtdXN0IGJlXG4gKiBlcXVhbCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSB1c2VkIHdoZW5cbiAqIG5lZ290aWF0aW5nIGFyZSB0aGUgbGV2ZWwgcGFydCBvZiBwcm9maWxlLWxldmVsLWlkIGFuZFxuICogbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvZmlsZUxldmVsSWRTdHJpbmdGb3JBbnN3ZXIobG9jYWxfc3VwcG9ydGVkX3BhcmFtcyA9IHt9LCByZW1vdGVfb2ZmZXJlZF9wYXJhbXMgPSB7fSkge1xuICAgIC8vIElmIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBwYXJhbXMgZG8gbm90IGNvbnRhaW4gcHJvZmlsZS1sZXZlbC1pZCwgdGhleSBhcmVcbiAgICAvLyBib3RoIHVzaW5nIHRoZSBkZWZhdWx0IHByb2ZpbGUuIEluIHRoaXMgY2FzZSwgZG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICAgIGlmICghbG9jYWxfc3VwcG9ydGVkX3BhcmFtc1sncHJvZmlsZS1sZXZlbC1pZCddICYmXG4gICAgICAgICFyZW1vdGVfb2ZmZXJlZF9wYXJhbXNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSkge1xuICAgICAgICBsb2dnZXIud2FybignZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlcigpIHwgcHJvZmlsZS1sZXZlbC1pZCBtaXNzaW5nIGluIGxvY2FsIGFuZCByZW1vdGUgcGFyYW1zJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIFBhcnNlIHByb2ZpbGUtbGV2ZWwtaWRzLlxuICAgIGNvbnN0IGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQgPSBwYXJzZVNkcFByb2ZpbGVMZXZlbElkKGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMpO1xuICAgIGNvbnN0IHJlbW90ZV9wcm9maWxlX2xldmVsX2lkID0gcGFyc2VTZHBQcm9maWxlTGV2ZWxJZChyZW1vdGVfb2ZmZXJlZF9wYXJhbXMpO1xuICAgIC8vIFRoZSBsb2NhbCBhbmQgcmVtb3RlIGNvZGVjIG11c3QgaGF2ZSB2YWxpZCBhbmQgZXF1YWwgSDI2NCBQcm9maWxlcy5cbiAgICBpZiAoIWxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBsb2NhbF9wcm9maWxlX2xldmVsX2lkJyk7XG4gICAgfVxuICAgIGlmICghcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZCcpO1xuICAgIH1cbiAgICBpZiAobG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlICE9PSByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0gyNjQgUHJvZmlsZSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICAvLyBQYXJzZSBsZXZlbCBpbmZvcm1hdGlvbi5cbiAgICBjb25zdCBsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZCA9IChpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zKSAmJlxuICAgICAgICBpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChyZW1vdGVfb2ZmZXJlZF9wYXJhbXMpKTtcbiAgICBjb25zdCBsb2NhbF9sZXZlbCA9IGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQubGV2ZWw7XG4gICAgY29uc3QgcmVtb3RlX2xldmVsID0gcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQubGV2ZWw7XG4gICAgY29uc3QgbWluX2xldmVsID0gbWluTGV2ZWwobG9jYWxfbGV2ZWwsIHJlbW90ZV9sZXZlbCk7XG4gICAgLy8gRGV0ZXJtaW5lIGFuc3dlciBsZXZlbC4gV2hlbiBsZXZlbCBhc3ltbWV0cnkgaXMgbm90IGFsbG93ZWQsIGxldmVsIHVwZ3JhZGVcbiAgICAvLyBpcyBub3QgYWxsb3dlZCwgaS5lLiwgdGhlIGxldmVsIGluIHRoZSBhbnN3ZXIgbXVzdCBiZSBlcXVhbCB0byBvciBsb3dlclxuICAgIC8vIHRoYW4gdGhlIGxldmVsIGluIHRoZSBvZmZlci5cbiAgICBjb25zdCBhbnN3ZXJfbGV2ZWwgPSBsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZFxuICAgICAgICA/IGxvY2FsX2xldmVsXG4gICAgICAgIDogbWluX2xldmVsO1xuICAgIGxvZ2dlci5kZWJ1ZyhgZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlcigpIHwgcmVzdWx0IFtwcm9maWxlOiR7bG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlfSwgbGV2ZWw6JHthbnN3ZXJfbGV2ZWx9XWApO1xuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHByb2ZpbGUtbGV2ZWwtaWQgZm9yIHRoZSBhbnN3ZXIgcGFyYW1ldGVycy5cbiAgICByZXR1cm4gcHJvZmlsZUxldmVsSWRUb1N0cmluZyhuZXcgUHJvZmlsZUxldmVsSWQobG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlLCBhbnN3ZXJfbGV2ZWwpKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlciA9IGdlbmVyYXRlUHJvZmlsZUxldmVsSWRTdHJpbmdGb3JBbnN3ZXI7XG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgb2YgOCBjaGFyYWN0ZXJzIGludG8gYSBieXRlIHdoZXJlIHRoZSBwb3NpdGlvbnMgY29udGFpbmluZ1xuICogY2hhcmFjdGVyIGMgd2lsbCBoYXZlIHRoZWlyIGJpdCBzZXQuIEZvciBleGFtcGxlLCBjID0gJ3gnLCBzdHIgPSBcIngxeHgwMDAwXCJcbiAqIHdpbGwgcmV0dXJuIDBiMTAxMTAwMDAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVNYXNrU3RyaW5nKGMsIHN0cikge1xuICAgIHJldHVybiAoKE51bWJlcihzdHJbMF0gPT09IGMpIDw8IDcpIHwgKE51bWJlcihzdHJbMV0gPT09IGMpIDw8IDYpIHxcbiAgICAgICAgKE51bWJlcihzdHJbMl0gPT09IGMpIDw8IDUpIHwgKE51bWJlcihzdHJbM10gPT09IGMpIDw8IDQpIHxcbiAgICAgICAgKE51bWJlcihzdHJbNF0gPT09IGMpIDw8IDMpIHwgKE51bWJlcihzdHJbNV0gPT09IGMpIDw8IDIpIHxcbiAgICAgICAgKE51bWJlcihzdHJbNl0gPT09IGMpIDw8IDEpIHwgKE51bWJlcihzdHJbN10gPT09IGMpIDw8IDApKTtcbn1cbi8vIENvbXBhcmUgSDI2NCBsZXZlbHMgYW5kIGhhbmRsZSB0aGUgbGV2ZWwgMWIgY2FzZS5cbmZ1bmN0aW9uIGlzTGVzc0xldmVsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gTGV2ZWwuTDFfYikge1xuICAgICAgICByZXR1cm4gYiAhPT0gTGV2ZWwuTDEgJiYgYiAhPT0gTGV2ZWwuTDFfYjtcbiAgICB9XG4gICAgaWYgKGIgPT09IExldmVsLkwxX2IpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IExldmVsLkwxO1xuICAgIH1cbiAgICByZXR1cm4gYSA8IGI7XG59XG5mdW5jdGlvbiBtaW5MZXZlbChhLCBiKSB7XG4gICAgcmV0dXJuIGlzTGVzc0xldmVsKGEsIGIpID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGxldmVsX2FzeW1tZXRyeV9hbGxvd2VkID0gcGFyYW1zWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddO1xuICAgIHJldHVybiAobGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09IHRydWUgfHxcbiAgICAgICAgbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09IDEgfHxcbiAgICAgICAgbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09ICcxJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Consumer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Consumer.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Consumer = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst logger = new Logger_1.Logger('Consumer');\nclass Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData, }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor()');\n        this._id = id;\n        this._localId = localId;\n        this._producerId = producerId;\n        this._rtpReceiver = rtpReceiver;\n        this._track = track;\n        this._rtpParameters = rtpParameters;\n        this._paused = !track.enabled;\n        this._appData = appData || {};\n        this.onTrackEnded = this.onTrackEnded.bind(this);\n        this.handleTrack();\n    }\n    /**\n     * Consumer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Local id.\n     */\n    get localId() {\n        return this._localId;\n    }\n    /**\n     * Associated Producer id.\n     */\n    get producerId() {\n        return this._producerId;\n    }\n    /**\n     * Whether the Consumer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n    get kind() {\n        return this._track.kind;\n    }\n    /**\n     * Associated RTCRtpReceiver.\n     */\n    get rtpReceiver() {\n        return this._rtpReceiver;\n    }\n    /**\n     * The associated track.\n     */\n    get track() {\n        return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n    get rtpParameters() {\n        return this._rtpParameters;\n    }\n    /**\n     * Whether the Consumer is paused.\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Closes the Consumer.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        this.destroyTrack();\n        this.emit('@close');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this.destroyTrack();\n        this.safeEmit('transportclose');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated RTCRtpReceiver stats.\n     */\n    async getStats() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        return new Promise((resolve, reject) => {\n            this.safeEmit('@getstats', resolve, reject);\n        });\n    }\n    /**\n     * Pauses receiving media.\n     */\n    pause() {\n        logger.debug('pause()');\n        if (this._closed) {\n            logger.error('pause() | Consumer closed');\n            return;\n        }\n        if (this._paused) {\n            logger.debug('pause() | Consumer is already paused');\n            return;\n        }\n        this._paused = true;\n        this._track.enabled = false;\n        this.emit('@pause');\n        // Emit observer event.\n        this._observer.safeEmit('pause');\n    }\n    /**\n     * Resumes receiving media.\n     */\n    resume() {\n        logger.debug('resume()');\n        if (this._closed) {\n            logger.error('resume() | Consumer closed');\n            return;\n        }\n        if (!this._paused) {\n            logger.debug('resume() | Consumer is already resumed');\n            return;\n        }\n        this._paused = false;\n        this._track.enabled = true;\n        this.emit('@resume');\n        // Emit observer event.\n        this._observer.safeEmit('resume');\n    }\n    onTrackEnded() {\n        logger.debug('track \"ended\" event');\n        this.safeEmit('trackended');\n        // Emit observer event.\n        this._observer.safeEmit('trackended');\n    }\n    handleTrack() {\n        this._track.addEventListener('ended', this.onTrackEnded);\n    }\n    destroyTrack() {\n        try {\n            this._track.removeEventListener('ended', this.onTrackEnded);\n            this._track.stop();\n        }\n        catch (error) { }\n    }\n}\nexports.Consumer = Consumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0NvbnN1bWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBVTtBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQyxrSkFBd0I7QUFDL0QsaUJBQWlCLG1CQUFPLENBQUMsc0hBQVU7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQixzRUFBc0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0NvbnN1bWVyLmpzPzllODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnN1bWVyID0gdm9pZCAwO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0NvbnN1bWVyJyk7XG5jbGFzcyBDb25zdW1lciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGxvY2FsSWQsIHByb2R1Y2VySWQsIHJ0cFJlY2VpdmVyLCB0cmFjaywgcnRwUGFyYW1ldGVycywgYXBwRGF0YSwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9sb2NhbElkID0gbG9jYWxJZDtcbiAgICAgICAgdGhpcy5fcHJvZHVjZXJJZCA9IHByb2R1Y2VySWQ7XG4gICAgICAgIHRoaXMuX3J0cFJlY2VpdmVyID0gcnRwUmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG4gICAgICAgIHRoaXMuX3J0cFBhcmFtZXRlcnMgPSBydHBQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSAhdHJhY2suZW5hYmxlZDtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGEgfHwge307XG4gICAgICAgIHRoaXMub25UcmFja0VuZGVkID0gdGhpcy5vblRyYWNrRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lciBpZC5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9jYWwgaWQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIFByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBwcm9kdWNlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZHVjZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgQ29uc3VtZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lZGlhIGtpbmQuXG4gICAgICovXG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjay5raW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIFJUQ1J0cFJlY2VpdmVyLlxuICAgICAqL1xuICAgIGdldCBydHBSZWNlaXZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cFJlY2VpdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYXNzb2NpYXRlZCB0cmFjay5cbiAgICAgKi9cbiAgICBnZXQgdHJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUlRQIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0IHJ0cFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydHBQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBDb25zdW1lciBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgIH1cbiAgICBnZXQgb2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBDb25zdW1lci5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lUcmFjaygpO1xuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG4gICAgICovXG4gICAgdHJhbnNwb3J0Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFuc3BvcnRDbG9zZWQoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lUcmFjaygpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFuc3BvcnRjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFzc29jaWF0ZWQgUlRDUnRwUmVjZWl2ZXIgc3RhdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RhdHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0BnZXRzdGF0cycsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcmVjZWl2aW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdwYXVzZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZSgpIHwgQ29uc3VtZXIgaXMgYWxyZWFkeSBwYXVzZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl90cmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnQHBhdXNlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdwYXVzZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdyZXN1bWUoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZSgpIHwgQ29uc3VtZXIgaXMgYWxyZWFkeSByZXN1bWVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ0ByZXN1bWUnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3Jlc3VtZScpO1xuICAgIH1cbiAgICBvblRyYWNrRW5kZWQoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhY2sgXCJlbmRlZFwiIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICB9XG4gICAgaGFuZGxlVHJhY2soKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vblRyYWNrRW5kZWQpO1xuICAgIH1cbiAgICBkZXN0cm95VHJhY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub25UcmFja0VuZGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Consumer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataConsumer.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataConsumer.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConsumer = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst logger = new Logger_1.Logger('DataConsumer');\nclass DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData, }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor()');\n        this._id = id;\n        this._dataProducerId = dataProducerId;\n        this._dataChannel = dataChannel;\n        this._sctpStreamParameters = sctpStreamParameters;\n        this._appData = appData || {};\n        this.handleDataChannel();\n    }\n    /**\n     * DataConsumer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Associated DataProducer id.\n     */\n    get dataProducerId() {\n        return this._dataProducerId;\n    }\n    /**\n     * Whether the DataConsumer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * SCTP stream parameters.\n     */\n    get sctpStreamParameters() {\n        return this._sctpStreamParameters;\n    }\n    /**\n     * DataChannel readyState.\n     */\n    get readyState() {\n        return this._dataChannel.readyState;\n    }\n    /**\n     * DataChannel label.\n     */\n    get label() {\n        return this._dataChannel.label;\n    }\n    /**\n     * DataChannel protocol.\n     */\n    get protocol() {\n        return this._dataChannel.protocol;\n    }\n    /**\n     * DataChannel binaryType.\n     */\n    get binaryType() {\n        return this._dataChannel.binaryType;\n    }\n    /**\n     * Set DataChannel binaryType.\n     */\n    set binaryType(binaryType) {\n        this._dataChannel.binaryType = binaryType;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Closes the DataConsumer.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.emit('@close');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.safeEmit('transportclose');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    handleDataChannel() {\n        this._dataChannel.addEventListener('open', () => {\n            if (this._closed) {\n                return;\n            }\n            logger.debug('DataChannel \"open\" event');\n            this.safeEmit('open');\n        });\n        this._dataChannel.addEventListener('error', (event) => {\n            if (this._closed) {\n                return;\n            }\n            let { error } = event;\n            if (!error) {\n                error = new Error('unknown DataChannel error');\n            }\n            if (error.errorDetail === 'sctp-failure') {\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\n            }\n            else {\n                logger.error('DataChannel \"error\" event: %o', error);\n            }\n            this.safeEmit('error', error);\n        });\n        this._dataChannel.addEventListener('close', () => {\n            if (this._closed) {\n                return;\n            }\n            logger.warn('DataChannel \"close\" event');\n            this._closed = true;\n            this.emit('@close');\n            this.safeEmit('close');\n            // Emit observer event.\n            this._observer.safeEmit('close');\n        });\n        this._dataChannel.addEventListener('message', (event) => {\n            if (this._closed) {\n                return;\n            }\n            this.safeEmit('message', event.data);\n        });\n    }\n}\nexports.DataConsumer = DataConsumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RhdGFDb25zdW1lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsaUJBQWlCLG1CQUFPLENBQUMsc0hBQVU7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsa0pBQXdCO0FBQy9EO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWlFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRGF0YUNvbnN1bWVyLmpzPzU0YWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFDb25zdW1lciA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGF0YUNvbnN1bWVyJyk7XG5jbGFzcyBEYXRhQ29uc3VtZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBkYXRhUHJvZHVjZXJJZCwgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBhcHBEYXRhLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gT2JzZXJ2ZXIgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpJyk7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2RhdGFQcm9kdWNlcklkID0gZGF0YVByb2R1Y2VySWQ7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsID0gZGF0YUNoYW5uZWw7XG4gICAgICAgIHRoaXMuX3NjdHBTdHJlYW1QYXJhbWV0ZXJzID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFubmVsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDb25zdW1lciBpZC5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCBEYXRhUHJvZHVjZXIgaWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGFQcm9kdWNlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVByb2R1Y2VySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIERhdGFDb25zdW1lciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU0NUUCBzdHJlYW0gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXQgc2N0cFN0cmVhbVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgcmVhZHlTdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLnJlYWR5U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGxhYmVsLlxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBwcm90b2NvbC5cbiAgICAgKi9cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5wcm90b2NvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgYmluYXJ5VHlwZS5cbiAgICAgKi9cbiAgICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmJpbmFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBEYXRhQ2hhbm5lbCBiaW5hcnlUeXBlLlxuICAgICAqL1xuICAgIHNldCBiaW5hcnlUeXBlKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYXBwRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YSBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICB9XG4gICAgZ2V0IG9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgRGF0YUNvbnN1bWVyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYW5zcG9ydENsb3NlZCgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0RhdGFDaGFubmVsIFwib3BlblwiIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdvcGVuJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGVycm9yIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigndW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yRGV0YWlsID09PSAnc2N0cC1mYWlsdXJlJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRGF0YUNoYW5uZWwgU0NUUCBlcnJvciBbc2N0cENhdXNlQ29kZTolc106ICVzJywgZXJyb3Iuc2N0cENhdXNlQ29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFwiZXJyb3JcIiBldmVudDogJW8nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdEYXRhQ2hhbm5lbCBcImNsb3NlXCIgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUNvbnN1bWVyID0gRGF0YUNvbnN1bWVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataConsumer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataProducer.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataProducer.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataProducer = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst logger = new Logger_1.Logger('DataProducer');\nclass DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor({ id, dataChannel, sctpStreamParameters, appData, }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor()');\n        this._id = id;\n        this._dataChannel = dataChannel;\n        this._sctpStreamParameters = sctpStreamParameters;\n        this._appData = appData || {};\n        this.handleDataChannel();\n    }\n    /**\n     * DataProducer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the DataProducer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * SCTP stream parameters.\n     */\n    get sctpStreamParameters() {\n        return this._sctpStreamParameters;\n    }\n    /**\n     * DataChannel readyState.\n     */\n    get readyState() {\n        return this._dataChannel.readyState;\n    }\n    /**\n     * DataChannel label.\n     */\n    get label() {\n        return this._dataChannel.label;\n    }\n    /**\n     * DataChannel protocol.\n     */\n    get protocol() {\n        return this._dataChannel.protocol;\n    }\n    /**\n     * DataChannel bufferedAmount.\n     */\n    get bufferedAmount() {\n        return this._dataChannel.bufferedAmount;\n    }\n    /**\n     * DataChannel bufferedAmountLowThreshold.\n     */\n    get bufferedAmountLowThreshold() {\n        return this._dataChannel.bufferedAmountLowThreshold;\n    }\n    /**\n     * Set DataChannel bufferedAmountLowThreshold.\n     */\n    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {\n        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Closes the DataProducer.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.emit('@close');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.safeEmit('transportclose');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Send a message.\n     *\n     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.\n     */\n    send(data) {\n        logger.debug('send()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        this._dataChannel.send(data);\n    }\n    handleDataChannel() {\n        this._dataChannel.addEventListener('open', () => {\n            if (this._closed) {\n                return;\n            }\n            logger.debug('DataChannel \"open\" event');\n            this.safeEmit('open');\n        });\n        this._dataChannel.addEventListener('error', (event) => {\n            if (this._closed) {\n                return;\n            }\n            let { error } = event;\n            if (!error) {\n                error = new Error('unknown DataChannel error');\n            }\n            if (error.errorDetail === 'sctp-failure') {\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\n            }\n            else {\n                logger.error('DataChannel \"error\" event: %o', error);\n            }\n            this.safeEmit('error', error);\n        });\n        this._dataChannel.addEventListener('close', () => {\n            if (this._closed) {\n                return;\n            }\n            logger.warn('DataChannel \"close\" event');\n            this._closed = true;\n            this.emit('@close');\n            this.safeEmit('close');\n            // Emit observer event.\n            this._observer.safeEmit('close');\n        });\n        this._dataChannel.addEventListener('message', () => {\n            if (this._closed) {\n                return;\n            }\n            logger.warn('DataChannel \"message\" event in a DataProducer, message discarded');\n        });\n        this._dataChannel.addEventListener('bufferedamountlow', () => {\n            if (this._closed) {\n                return;\n            }\n            this.safeEmit('bufferedamountlow');\n        });\n    }\n}\nexports.DataProducer = DataProducer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RhdGFQcm9kdWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsaUJBQWlCLG1CQUFPLENBQUMsc0hBQVU7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsa0pBQXdCO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLHNIQUFVO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBeUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RhdGFQcm9kdWNlci5qcz9kNmM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhUHJvZHVjZXIgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEgPSByZXF1aXJlKFwiLi9FbmhhbmNlZEV2ZW50RW1pdHRlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGF0YVByb2R1Y2VyJyk7XG5jbGFzcyBEYXRhUHJvZHVjZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwgPSBkYXRhQ2hhbm5lbDtcbiAgICAgICAgdGhpcy5fc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGEgfHwge307XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YVByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBEYXRhUHJvZHVjZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNDVFAgc3RyZWFtIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIHJlYWR5U3RhdGUuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5yZWFkeVN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBsYWJlbC5cbiAgICAgKi9cbiAgICBnZXQgbGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5sYWJlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgcHJvdG9jb2wuXG4gICAgICovXG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwucHJvdG9jb2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50LlxuICAgICAqL1xuICAgIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZC5cbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkLlxuICAgICAqL1xuICAgIHNldCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZChidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEgc2V0dGVyLlxuICAgICAqL1xuICAgIHNldCBhcHBEYXRhKGFwcERhdGEpIHtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGE7XG4gICAgfVxuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIERhdGFQcm9kdWNlci5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG4gICAgICovXG4gICAgdHJhbnNwb3J0Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFuc3BvcnRDbG9zZWQoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFuc3BvcnRjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gZGF0YS5cbiAgICAgKi9cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0RhdGFDaGFubmVsIFwib3BlblwiIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdvcGVuJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGVycm9yIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigndW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yRGV0YWlsID09PSAnc2N0cC1mYWlsdXJlJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRGF0YUNoYW5uZWwgU0NUUCBlcnJvciBbc2N0cENhdXNlQ29kZTolc106ICVzJywgZXJyb3Iuc2N0cENhdXNlQ29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFwiZXJyb3JcIiBldmVudDogJW8nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdEYXRhQ2hhbm5lbCBcImNsb3NlXCIgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0RhdGFDaGFubmVsIFwibWVzc2FnZVwiIGV2ZW50IGluIGEgRGF0YVByb2R1Y2VyLCBtZXNzYWdlIGRpc2NhcmRlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignYnVmZmVyZWRhbW91bnRsb3cnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnYnVmZmVyZWRhbW91bnRsb3cnKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhUHJvZHVjZXIgPSBEYXRhUHJvZHVjZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataProducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Device.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Device.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Device = exports.detectDevice = void 0;\nconst ua_parser_js_1 = __webpack_require__(/*! ua-parser-js */ \"(app-client)/./node_modules/.pnpm/ua-parser-js@1.0.37/node_modules/ua-parser-js/src/ua-parser.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ./ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst Transport_1 = __webpack_require__(/*! ./Transport */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Transport.js\");\nconst Chrome111_1 = __webpack_require__(/*! ./handlers/Chrome111 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome111.js\");\nconst Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome74.js\");\nconst Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome70.js\");\nconst Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome67.js\");\nconst Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome55.js\");\nconst Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Firefox60.js\");\nconst Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari12.js\");\nconst Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari11.js\");\nconst Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Edge11.js\");\nconst ReactNativeUnifiedPlan_1 = __webpack_require__(/*! ./handlers/ReactNativeUnifiedPlan */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js\");\nconst ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNative.js\");\nconst logger = new Logger_1.Logger('Device');\nfunction detectDevice() {\n    // React-Native.\n    // NOTE: react-native-webrtc >= 1.75.0 is required.\n    // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.\n    if (typeof navigator === 'object' && navigator.product === 'ReactNative') {\n        logger.debug('detectDevice() | React-Native detected');\n        if (typeof RTCPeerConnection === 'undefined') {\n            logger.warn('detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?');\n            return undefined;\n        }\n        if (typeof RTCRtpTransceiver !== 'undefined') {\n            logger.debug('detectDevice() | ReactNative UnifiedPlan handler chosen');\n            return 'ReactNativeUnifiedPlan';\n        }\n        else {\n            logger.debug('detectDevice() | ReactNative PlanB handler chosen');\n            return 'ReactNative';\n        }\n    }\n    // Browser.\n    else if (typeof navigator === 'object' &&\n        typeof navigator.userAgent === 'string') {\n        const ua = navigator.userAgent;\n        const uaParser = new ua_parser_js_1.UAParser(ua);\n        logger.debug('detectDevice() | browser detected [ua:%s, parsed:%o]', ua, uaParser.getResult());\n        const browser = uaParser.getBrowser();\n        const browserName = browser.name?.toLowerCase();\n        const browserVersion = parseInt(browser.major ?? '0');\n        const engine = uaParser.getEngine();\n        const engineName = engine.name?.toLowerCase();\n        const os = uaParser.getOS();\n        const osName = os.name?.toLowerCase();\n        const osVersion = parseFloat(os.version ?? '0');\n        const device = uaParser.getDevice();\n        const deviceModel = device.model?.toLowerCase();\n        const isIOS = osName === 'ios' || deviceModel === 'ipad';\n        const isChrome = browserName &&\n            [\n                'chrome',\n                'chromium',\n                'mobile chrome',\n                'chrome webview',\n                'chrome headless',\n            ].includes(browserName);\n        const isFirefox = browserName &&\n            ['firefox', 'mobile firefox', 'mobile focus'].includes(browserName);\n        const isSafari = browserName && ['safari', 'mobile safari'].includes(browserName);\n        const isEdge = browserName && ['edge'].includes(browserName);\n        // Chrome, Chromium, and Edge.\n        if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {\n            return 'Chrome111';\n        }\n        else if ((isChrome && !isIOS && browserVersion >= 74) ||\n            (isEdge && !isIOS && browserVersion >= 88)) {\n            return 'Chrome74';\n        }\n        else if (isChrome && !isIOS && browserVersion >= 70) {\n            return 'Chrome70';\n        }\n        else if (isChrome && !isIOS && browserVersion >= 67) {\n            return 'Chrome67';\n        }\n        else if (isChrome && !isIOS && browserVersion >= 55) {\n            return 'Chrome55';\n        }\n        // Firefox.\n        else if (isFirefox && !isIOS && browserVersion >= 60) {\n            return 'Firefox60';\n        }\n        // Firefox on iOS (so Safari).\n        else if (isFirefox && isIOS && osVersion >= 14.3) {\n            return 'Safari12';\n        }\n        // Safari with Unified-Plan support enabled.\n        else if (isSafari &&\n            browserVersion >= 12 &&\n            typeof RTCRtpTransceiver !== 'undefined' &&\n            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {\n            return 'Safari12';\n        }\n        // Safari with Plab-B support.\n        else if (isSafari && browserVersion >= 11) {\n            return 'Safari11';\n        }\n        // Old Edge with ORTC support.\n        else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {\n            return 'Edge11';\n        }\n        // Best effort for WebKit based browsers in iOS.\n        else if (engineName === 'webkit' &&\n            isIOS &&\n            typeof RTCRtpTransceiver !== 'undefined' &&\n            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {\n            return 'Safari12';\n        }\n        // Best effort for Chromium based browsers.\n        else if (engineName === 'blink') {\n            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\\w+)/i);\n            if (match) {\n                const version = Number(match[1]);\n                if (version >= 111) {\n                    return 'Chrome111';\n                }\n                else if (version >= 74) {\n                    return 'Chrome74';\n                }\n                else if (version >= 70) {\n                    return 'Chrome70';\n                }\n                else if (version >= 67) {\n                    return 'Chrome67';\n                }\n                else {\n                    return 'Chrome55';\n                }\n            }\n            else {\n                return 'Chrome111';\n            }\n        }\n        // Unsupported browser.\n        else {\n            logger.warn('detectDevice() | browser not supported [name:%s, version:%s]', browserName, browserVersion);\n            return undefined;\n        }\n    }\n    // Unknown device.\n    else {\n        logger.warn('detectDevice() | unknown device');\n        return undefined;\n    }\n}\nexports.detectDevice = detectDevice;\nclass Device {\n    /**\n     * Create a new Device to connect to mediasoup server.\n     *\n     * @throws {UnsupportedError} if device is not supported.\n     */\n    constructor({ handlerName, handlerFactory, Handler } = {}) {\n        // Loaded flag.\n        this._loaded = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor()');\n        // Handle deprecated option.\n        if (Handler) {\n            logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');\n            if (typeof Handler === 'string') {\n                handlerName = Handler;\n            }\n            else {\n                throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');\n            }\n        }\n        if (handlerName && handlerFactory) {\n            throw new TypeError('just one of handlerName or handlerInterface can be given');\n        }\n        if (handlerFactory) {\n            this._handlerFactory = handlerFactory;\n        }\n        else {\n            if (handlerName) {\n                logger.debug('constructor() | handler given: %s', handlerName);\n            }\n            else {\n                handlerName = detectDevice();\n                if (handlerName) {\n                    logger.debug('constructor() | detected handler: %s', handlerName);\n                }\n                else {\n                    throw new errors_1.UnsupportedError('device not supported');\n                }\n            }\n            switch (handlerName) {\n                case 'Chrome111': {\n                    this._handlerFactory = Chrome111_1.Chrome111.createFactory();\n                    break;\n                }\n                case 'Chrome74': {\n                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();\n                    break;\n                }\n                case 'Chrome70': {\n                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();\n                    break;\n                }\n                case 'Chrome67': {\n                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();\n                    break;\n                }\n                case 'Chrome55': {\n                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();\n                    break;\n                }\n                case 'Firefox60': {\n                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();\n                    break;\n                }\n                case 'Safari12': {\n                    this._handlerFactory = Safari12_1.Safari12.createFactory();\n                    break;\n                }\n                case 'Safari11': {\n                    this._handlerFactory = Safari11_1.Safari11.createFactory();\n                    break;\n                }\n                case 'Edge11': {\n                    this._handlerFactory = Edge11_1.Edge11.createFactory();\n                    break;\n                }\n                case 'ReactNativeUnifiedPlan': {\n                    this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();\n                    break;\n                }\n                case 'ReactNative': {\n                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();\n                    break;\n                }\n                default: {\n                    throw new TypeError(`unknown handlerName \"${handlerName}\"`);\n                }\n            }\n        }\n        // Create a temporal handler to get its name.\n        const handler = this._handlerFactory();\n        this._handlerName = handler.name;\n        handler.close();\n        this._extendedRtpCapabilities = undefined;\n        this._recvRtpCapabilities = undefined;\n        this._canProduceByKind = {\n            audio: false,\n            video: false,\n        };\n        this._sctpCapabilities = undefined;\n    }\n    /**\n     * The RTC handler name.\n     */\n    get handlerName() {\n        return this._handlerName;\n    }\n    /**\n     * Whether the Device is loaded.\n     */\n    get loaded() {\n        return this._loaded;\n    }\n    /**\n     * RTP capabilities of the Device for receiving media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     */\n    get rtpCapabilities() {\n        if (!this._loaded) {\n            throw new errors_1.InvalidStateError('not loaded');\n        }\n        return this._recvRtpCapabilities;\n    }\n    /**\n     * SCTP capabilities of the Device.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     */\n    get sctpCapabilities() {\n        if (!this._loaded) {\n            throw new errors_1.InvalidStateError('not loaded');\n        }\n        return this._sctpCapabilities;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Initialize the Device.\n     */\n    async load({ routerRtpCapabilities, }) {\n        logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);\n        routerRtpCapabilities = utils.clone(routerRtpCapabilities);\n        // Temporal handler to get its capabilities.\n        let handler;\n        try {\n            if (this._loaded) {\n                throw new errors_1.InvalidStateError('already loaded');\n            }\n            // This may throw.\n            ortc.validateRtpCapabilities(routerRtpCapabilities);\n            handler = this._handlerFactory();\n            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();\n            logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);\n            // This may throw.\n            ortc.validateRtpCapabilities(nativeRtpCapabilities);\n            // Get extended RTP capabilities.\n            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);\n            logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);\n            // Check whether we can produce audio/video.\n            this._canProduceByKind.audio = ortc.canSend('audio', this._extendedRtpCapabilities);\n            this._canProduceByKind.video = ortc.canSend('video', this._extendedRtpCapabilities);\n            // Generate our receiving RTP capabilities for receiving media.\n            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);\n            // This may throw.\n            ortc.validateRtpCapabilities(this._recvRtpCapabilities);\n            logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);\n            // Generate our SCTP capabilities.\n            this._sctpCapabilities = await handler.getNativeSctpCapabilities();\n            logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);\n            // This may throw.\n            ortc.validateSctpCapabilities(this._sctpCapabilities);\n            logger.debug('load() succeeded');\n            this._loaded = true;\n            handler.close();\n        }\n        catch (error) {\n            if (handler) {\n                handler.close();\n            }\n            throw error;\n        }\n    }\n    /**\n     * Whether we can produce audio/video.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n    canProduce(kind) {\n        if (!this._loaded) {\n            throw new errors_1.InvalidStateError('not loaded');\n        }\n        else if (kind !== 'audio' && kind !== 'video') {\n            throw new TypeError(`invalid kind \"${kind}\"`);\n        }\n        return this._canProduceByKind[kind];\n    }\n    /**\n     * Creates a Transport for sending media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {\n        logger.debug('createSendTransport()');\n        return this.createTransport({\n            direction: 'send',\n            id: id,\n            iceParameters: iceParameters,\n            iceCandidates: iceCandidates,\n            dtlsParameters: dtlsParameters,\n            sctpParameters: sctpParameters,\n            iceServers: iceServers,\n            iceTransportPolicy: iceTransportPolicy,\n            additionalSettings: additionalSettings,\n            proprietaryConstraints: proprietaryConstraints,\n            appData: appData,\n        });\n    }\n    /**\n     * Creates a Transport for receiving media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {\n        logger.debug('createRecvTransport()');\n        return this.createTransport({\n            direction: 'recv',\n            id: id,\n            iceParameters: iceParameters,\n            iceCandidates: iceCandidates,\n            dtlsParameters: dtlsParameters,\n            sctpParameters: sctpParameters,\n            iceServers: iceServers,\n            iceTransportPolicy: iceTransportPolicy,\n            additionalSettings: additionalSettings,\n            proprietaryConstraints: proprietaryConstraints,\n            appData: appData,\n        });\n    }\n    createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {\n        if (!this._loaded) {\n            throw new errors_1.InvalidStateError('not loaded');\n        }\n        else if (typeof id !== 'string') {\n            throw new TypeError('missing id');\n        }\n        else if (typeof iceParameters !== 'object') {\n            throw new TypeError('missing iceParameters');\n        }\n        else if (!Array.isArray(iceCandidates)) {\n            throw new TypeError('missing iceCandidates');\n        }\n        else if (typeof dtlsParameters !== 'object') {\n            throw new TypeError('missing dtlsParameters');\n        }\n        else if (sctpParameters && typeof sctpParameters !== 'object') {\n            throw new TypeError('wrong sctpParameters');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // Create a new Transport.\n        const transport = new Transport_1.Transport({\n            direction,\n            id,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings,\n            proprietaryConstraints,\n            appData,\n            handlerFactory: this._handlerFactory,\n            extendedRtpCapabilities: this._extendedRtpCapabilities,\n            canProduceByKind: this._canProduceByKind,\n        });\n        // Emit observer event.\n        this._observer.safeEmit('newtransport', transport);\n        return transport;\n    }\n}\nexports.Device = Device;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RldmljZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLG9CQUFvQjtBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQyxzSEFBYztBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBVTtBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQyxrSkFBd0I7QUFDL0QsaUJBQWlCLG1CQUFPLENBQUMsc0hBQVU7QUFDbkMsMkJBQTJCLG1CQUFPLENBQUMsb0hBQVM7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMsa0hBQVE7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsNEhBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsOElBQXNCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDRJQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw0SUFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsNElBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDRJQUFxQjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyw4SUFBc0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsNElBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDRJQUFxQjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyx3SUFBbUI7QUFDNUMsaUNBQWlDLG1CQUFPLENBQUMsd0tBQW1DO0FBQzVFLHNCQUFzQixtQkFBTyxDQUFDLGtKQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxrQkFBa0IsdUNBQXVDLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSwwQkFBMEIsd0pBQXdKO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBLDBCQUEwQix3SkFBd0o7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQkFBc0IsbUtBQW1LO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9EZXZpY2UuanM/NGM2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZXZpY2UgPSBleHBvcnRzLmRldGVjdERldmljZSA9IHZvaWQgMDtcbmNvbnN0IHVhX3BhcnNlcl9qc18xID0gcmVxdWlyZShcInVhLXBhcnNlci1qc1wiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29ydGNcIikpO1xuY29uc3QgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9UcmFuc3BvcnRcIik7XG5jb25zdCBDaHJvbWUxMTFfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0Nocm9tZTExMVwiKTtcbmNvbnN0IENocm9tZTc0XzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9DaHJvbWU3NFwiKTtcbmNvbnN0IENocm9tZTcwXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9DaHJvbWU3MFwiKTtcbmNvbnN0IENocm9tZTY3XzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9DaHJvbWU2N1wiKTtcbmNvbnN0IENocm9tZTU1XzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9DaHJvbWU1NVwiKTtcbmNvbnN0IEZpcmVmb3g2MF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvRmlyZWZveDYwXCIpO1xuY29uc3QgU2FmYXJpMTJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1NhZmFyaTEyXCIpO1xuY29uc3QgU2FmYXJpMTFfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1NhZmFyaTExXCIpO1xuY29uc3QgRWRnZTExXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9FZGdlMTFcIik7XG5jb25zdCBSZWFjdE5hdGl2ZVVuaWZpZWRQbGFuXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuXCIpO1xuY29uc3QgUmVhY3ROYXRpdmVfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1JlYWN0TmF0aXZlXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGV2aWNlJyk7XG5mdW5jdGlvbiBkZXRlY3REZXZpY2UoKSB7XG4gICAgLy8gUmVhY3QtTmF0aXZlLlxuICAgIC8vIE5PVEU6IHJlYWN0LW5hdGl2ZS13ZWJydGMgPj0gMS43NS4wIGlzIHJlcXVpcmVkLlxuICAgIC8vIE5PVEU6IHJlYWN0LW5hdGl2ZS13ZWJydGMgd2l0aCBVbmlmaWVkIFBsYW4gcmVxdWlyZXMgdmVyc2lvbiA+PSAxMDYuMC4wLlxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2RldGVjdERldmljZSgpIHwgUmVhY3QtTmF0aXZlIGRldGVjdGVkJyk7XG4gICAgICAgIGlmICh0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZGV0ZWN0RGV2aWNlKCkgfCB1bnN1cHBvcnRlZCByZWFjdC1uYXRpdmUtd2VicnRjIHdpdGhvdXQgUlRDUGVlckNvbm5lY3Rpb24sIGZvcmdvdCB0byBjYWxsIHJlZ2lzdGVyR2xvYmFscygpPycpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIFJUQ1J0cFRyYW5zY2VpdmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdkZXRlY3REZXZpY2UoKSB8IFJlYWN0TmF0aXZlIFVuaWZpZWRQbGFuIGhhbmRsZXIgY2hvc2VuJyk7XG4gICAgICAgICAgICByZXR1cm4gJ1JlYWN0TmF0aXZlVW5pZmllZFBsYW4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdkZXRlY3REZXZpY2UoKSB8IFJlYWN0TmF0aXZlIFBsYW5CIGhhbmRsZXIgY2hvc2VuJyk7XG4gICAgICAgICAgICByZXR1cm4gJ1JlYWN0TmF0aXZlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCcm93c2VyLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgIGNvbnN0IHVhUGFyc2VyID0gbmV3IHVhX3BhcnNlcl9qc18xLlVBUGFyc2VyKHVhKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdkZXRlY3REZXZpY2UoKSB8IGJyb3dzZXIgZGV0ZWN0ZWQgW3VhOiVzLCBwYXJzZWQ6JW9dJywgdWEsIHVhUGFyc2VyLmdldFJlc3VsdCgpKTtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IHVhUGFyc2VyLmdldEJyb3dzZXIoKTtcbiAgICAgICAgY29uc3QgYnJvd3Nlck5hbWUgPSBicm93c2VyLm5hbWU/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci5tYWpvciA/PyAnMCcpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB1YVBhcnNlci5nZXRFbmdpbmUoKTtcbiAgICAgICAgY29uc3QgZW5naW5lTmFtZSA9IGVuZ2luZS5uYW1lPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBvcyA9IHVhUGFyc2VyLmdldE9TKCk7XG4gICAgICAgIGNvbnN0IG9zTmFtZSA9IG9zLm5hbWU/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG9zVmVyc2lvbiA9IHBhcnNlRmxvYXQob3MudmVyc2lvbiA/PyAnMCcpO1xuICAgICAgICBjb25zdCBkZXZpY2UgPSB1YVBhcnNlci5nZXREZXZpY2UoKTtcbiAgICAgICAgY29uc3QgZGV2aWNlTW9kZWwgPSBkZXZpY2UubW9kZWw/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGlzSU9TID0gb3NOYW1lID09PSAnaW9zJyB8fCBkZXZpY2VNb2RlbCA9PT0gJ2lwYWQnO1xuICAgICAgICBjb25zdCBpc0Nocm9tZSA9IGJyb3dzZXJOYW1lICYmXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2Nocm9tZScsXG4gICAgICAgICAgICAgICAgJ2Nocm9taXVtJyxcbiAgICAgICAgICAgICAgICAnbW9iaWxlIGNocm9tZScsXG4gICAgICAgICAgICAgICAgJ2Nocm9tZSB3ZWJ2aWV3JyxcbiAgICAgICAgICAgICAgICAnY2hyb21lIGhlYWRsZXNzJyxcbiAgICAgICAgICAgIF0uaW5jbHVkZXMoYnJvd3Nlck5hbWUpO1xuICAgICAgICBjb25zdCBpc0ZpcmVmb3ggPSBicm93c2VyTmFtZSAmJlxuICAgICAgICAgICAgWydmaXJlZm94JywgJ21vYmlsZSBmaXJlZm94JywgJ21vYmlsZSBmb2N1cyddLmluY2x1ZGVzKGJyb3dzZXJOYW1lKTtcbiAgICAgICAgY29uc3QgaXNTYWZhcmkgPSBicm93c2VyTmFtZSAmJiBbJ3NhZmFyaScsICdtb2JpbGUgc2FmYXJpJ10uaW5jbHVkZXMoYnJvd3Nlck5hbWUpO1xuICAgICAgICBjb25zdCBpc0VkZ2UgPSBicm93c2VyTmFtZSAmJiBbJ2VkZ2UnXS5pbmNsdWRlcyhicm93c2VyTmFtZSk7XG4gICAgICAgIC8vIENocm9tZSwgQ2hyb21pdW0sIGFuZCBFZGdlLlxuICAgICAgICBpZiAoKGlzQ2hyb21lIHx8IGlzRWRnZSkgJiYgIWlzSU9TICYmIGJyb3dzZXJWZXJzaW9uID49IDExMSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUxMTEnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChpc0Nocm9tZSAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gNzQpIHx8XG4gICAgICAgICAgICAoaXNFZGdlICYmICFpc0lPUyAmJiBicm93c2VyVmVyc2lvbiA+PSA4OCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hyb21lICYmICFpc0lPUyAmJiBicm93c2VyVmVyc2lvbiA+PSA3MCkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaHJvbWUgJiYgIWlzSU9TICYmIGJyb3dzZXJWZXJzaW9uID49IDY3KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTY3JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Nocm9tZSAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gNTUpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNTUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3guXG4gICAgICAgIGVsc2UgaWYgKGlzRmlyZWZveCAmJiAhaXNJT1MgJiYgYnJvd3NlclZlcnNpb24gPj0gNjApIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveDYwJztcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IG9uIGlPUyAoc28gU2FmYXJpKS5cbiAgICAgICAgZWxzZSBpZiAoaXNGaXJlZm94ICYmIGlzSU9TICYmIG9zVmVyc2lvbiA+PSAxNC4zKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaTEyJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgd2l0aCBVbmlmaWVkLVBsYW4gc3VwcG9ydCBlbmFibGVkLlxuICAgICAgICBlbHNlIGlmIChpc1NhZmFyaSAmJlxuICAgICAgICAgICAgYnJvd3NlclZlcnNpb24gPj0gMTIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBSVENSdHBUcmFuc2NlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIFJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudERpcmVjdGlvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaTEyJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgd2l0aCBQbGFiLUIgc3VwcG9ydC5cbiAgICAgICAgZWxzZSBpZiAoaXNTYWZhcmkgJiYgYnJvd3NlclZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpMTEnO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9sZCBFZGdlIHdpdGggT1JUQyBzdXBwb3J0LlxuICAgICAgICBlbHNlIGlmIChpc0VkZ2UgJiYgIWlzSU9TICYmIGJyb3dzZXJWZXJzaW9uID49IDExICYmIGJyb3dzZXJWZXJzaW9uIDw9IDE4KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0VkZ2UxMSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVzdCBlZmZvcnQgZm9yIFdlYktpdCBiYXNlZCBicm93c2VycyBpbiBpT1MuXG4gICAgICAgIGVsc2UgaWYgKGVuZ2luZU5hbWUgPT09ICd3ZWJraXQnICYmXG4gICAgICAgICAgICBpc0lPUyAmJlxuICAgICAgICAgICAgdHlwZW9mIFJUQ1J0cFRyYW5zY2VpdmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjdXJyZW50RGlyZWN0aW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpMTInO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlc3QgZWZmb3J0IGZvciBDaHJvbWl1bSBiYXNlZCBicm93c2Vycy5cbiAgICAgICAgZWxzZSBpZiAoZW5naW5lTmFtZSA9PT0gJ2JsaW5rJykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaCgvKD86KD86Q2hyb21lfENocm9taXVtKSlbIC9dKFxcdyspL2kpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IE51bWJlcihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMTExKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lMTExJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmVyc2lvbiA+PSA3NCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTc0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmVyc2lvbiA+PSA3MCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTcwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmVyc2lvbiA+PSA2Nykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTY3JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNTUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lMTExJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVbnN1cHBvcnRlZCBicm93c2VyLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdkZXRlY3REZXZpY2UoKSB8IGJyb3dzZXIgbm90IHN1cHBvcnRlZCBbbmFtZTolcywgdmVyc2lvbjolc10nLCBicm93c2VyTmFtZSwgYnJvd3NlclZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVbmtub3duIGRldmljZS5cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2RldGVjdERldmljZSgpIHwgdW5rbm93biBkZXZpY2UnKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmRldGVjdERldmljZSA9IGRldGVjdERldmljZTtcbmNsYXNzIERldmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IERldmljZSB0byBjb25uZWN0IHRvIG1lZGlhc291cCBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtVbnN1cHBvcnRlZEVycm9yfSBpZiBkZXZpY2UgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGhhbmRsZXJOYW1lLCBoYW5kbGVyRmFjdG9yeSwgSGFuZGxlciB9ID0ge30pIHtcbiAgICAgICAgLy8gTG9hZGVkIGZsYWcuXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgLy8gSGFuZGxlIGRlcHJlY2F0ZWQgb3B0aW9uLlxuICAgICAgICBpZiAoSGFuZGxlcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2NvbnN0cnVjdG9yKCkgfCBIYW5kbGVyIG9wdGlvbiBpcyBERVBSRUNBVEVELCB1c2UgaGFuZGxlck5hbWUgb3IgaGFuZGxlckZhY3RvcnkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBIYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJOYW1lID0gSGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vbiBzdHJpbmcgSGFuZGxlciBvcHRpb24gbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlIGhhbmRsZXJGYWN0b3J5IGluc3RlYWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlck5hbWUgJiYgaGFuZGxlckZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2p1c3Qgb25lIG9mIGhhbmRsZXJOYW1lIG9yIGhhbmRsZXJJbnRlcmZhY2UgY2FuIGJlIGdpdmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IGhhbmRsZXJGYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpIHwgaGFuZGxlciBnaXZlbjogJXMnLCBoYW5kbGVyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyTmFtZSA9IGRldGVjdERldmljZSgpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgfCBkZXRlY3RlZCBoYW5kbGVyOiAlcycsIGhhbmRsZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdkZXZpY2Ugbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoaGFuZGxlck5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdDaHJvbWUxMTEnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gQ2hyb21lMTExXzEuQ2hyb21lMTExLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ0Nocm9tZTc0Jzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTc0XzEuQ2hyb21lNzQuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnQ2hyb21lNzAnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gQ2hyb21lNzBfMS5DaHJvbWU3MC5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdDaHJvbWU2Nyc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBDaHJvbWU2N18xLkNocm9tZTY3LmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ0Nocm9tZTU1Jzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTU1XzEuQ2hyb21lNTUuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRmlyZWZveDYwJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IEZpcmVmb3g2MF8xLkZpcmVmb3g2MC5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdTYWZhcmkxMic6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBTYWZhcmkxMl8xLlNhZmFyaTEyLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ1NhZmFyaTExJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFNhZmFyaTExXzEuU2FmYXJpMTEuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRWRnZTExJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IEVkZ2UxMV8xLkVkZ2UxMS5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdSZWFjdE5hdGl2ZVVuaWZpZWRQbGFuJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFJlYWN0TmF0aXZlVW5pZmllZFBsYW5fMS5SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWN0TmF0aXZlJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFJlYWN0TmF0aXZlXzEuUmVhY3ROYXRpdmUuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bmtub3duIGhhbmRsZXJOYW1lIFwiJHtoYW5kbGVyTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhbCBoYW5kbGVyIHRvIGdldCBpdHMgbmFtZS5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXJGYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJOYW1lID0gaGFuZGxlci5uYW1lO1xuICAgICAgICBoYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgdmlkZW86IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zY3RwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgUlRDIGhhbmRsZXIgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgRGV2aWNlIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVFAgY2FwYWJpbGl0aWVzIG9mIHRoZSBEZXZpY2UgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldCBydHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ25vdCBsb2FkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU0NUUCBjYXBhYmlsaXRpZXMgb2YgdGhlIERldmljZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldCBzY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjdHBDYXBhYmlsaXRpZXM7XG4gICAgfVxuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBEZXZpY2UuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZCh7IHJvdXRlclJ0cENhcGFiaWxpdGllcywgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSBbcm91dGVyUnRwQ2FwYWJpbGl0aWVzOiVvXScsIHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgIHJvdXRlclJ0cENhcGFiaWxpdGllcyA9IHV0aWxzLmNsb25lKHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgIC8vIFRlbXBvcmFsIGhhbmRsZXIgdG8gZ2V0IGl0cyBjYXBhYmlsaXRpZXMuXG4gICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignYWxyZWFkeSBsb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyhyb3V0ZXJSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXJGYWN0b3J5KCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBhd2FpdCBoYW5kbGVyLmdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgfCBnb3QgbmF0aXZlIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzKG5hdGl2ZVJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBHZXQgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICAgIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gb3J0Yy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMsIHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSB8IGdvdCBleHRlbmRlZCBSVFAgY2FwYWJpbGl0aWVzOiVvJywgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBjYW4gcHJvZHVjZSBhdWRpby92aWRlby5cbiAgICAgICAgICAgIHRoaXMuX2NhblByb2R1Y2VCeUtpbmQuYXVkaW8gPSBvcnRjLmNhblNlbmQoJ2F1ZGlvJywgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgdGhpcy5fY2FuUHJvZHVjZUJ5S2luZC52aWRlbyA9IG9ydGMuY2FuU2VuZCgndmlkZW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgcmVjZWl2aW5nIFJUUCBjYXBhYmlsaXRpZXMgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgICAgICAgIHRoaXMuX3JlY3ZSdHBDYXBhYmlsaXRpZXMgPSBvcnRjLmdldFJlY3ZSdHBDYXBhYmlsaXRpZXModGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzKHRoaXMuX3JlY3ZSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgfCBnb3QgcmVjZWl2aW5nIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIG91ciBTQ1RQIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICAgIHRoaXMuX3NjdHBDYXBhYmlsaXRpZXMgPSBhd2FpdCBoYW5kbGVyLmdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHwgZ290IG5hdGl2ZSBTQ1RQIGNhcGFiaWxpdGllczolbycsIHRoaXMuX3NjdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlU2N0cENhcGFiaWxpdGllcyh0aGlzLl9zY3RwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB3ZSBjYW4gcHJvZHVjZSBhdWRpby92aWRlby5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGNhblByb2R1Y2Uoa2luZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2luZCAhPT0gJ2F1ZGlvJyAmJiBraW5kICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FuUHJvZHVjZUJ5S2luZFtraW5kXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRyYW5zcG9ydCBmb3Igc2VuZGluZyBtZWRpYS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGNyZWF0ZVNlbmRUcmFuc3BvcnQoeyBpZCwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgYXBwRGF0YSwgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NyZWF0ZVNlbmRUcmFuc3BvcnQoKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZCcsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzOiBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzOiBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzOiBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5nczogYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50czogcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGFwcERhdGE6IGFwcERhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVHJhbnNwb3J0IGZvciByZWNlaXZpbmcgbWVkaWEuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkU3RhdGVFcnJvcn0gaWYgbm90IGxvYWRlZC5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHdyb25nIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBjcmVhdGVSZWN2VHJhbnNwb3J0KHsgaWQsIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGFwcERhdGEsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjcmVhdGVSZWN2VHJhbnNwb3J0KCknKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVHJhbnNwb3J0KHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3YnLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyczogc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3ksXG4gICAgICAgICAgICBhZGRpdGlvbmFsU2V0dGluZ3M6IGFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgICAgIHByb3ByaWV0YXJ5Q29uc3RyYWludHM6IHByb3ByaWV0YXJ5Q29uc3RyYWludHMsXG4gICAgICAgICAgICBhcHBEYXRhOiBhcHBEYXRhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlVHJhbnNwb3J0KHsgZGlyZWN0aW9uLCBpZCwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgYXBwRGF0YSwgfSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpY2VQYXJhbWV0ZXJzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpY2VQYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaWNlQ2FuZGlkYXRlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlQ2FuZGlkYXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkdGxzUGFyYW1ldGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZHRsc1BhcmFtZXRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3RwUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2N0cFBhcmFtZXRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3cm9uZyBzY3RwUGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwcERhdGEgJiYgdHlwZW9mIGFwcERhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBUcmFuc3BvcnQuXG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnRfMS5UcmFuc3BvcnQoe1xuICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VTZXJ2ZXJzLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5LFxuICAgICAgICAgICAgYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGFwcERhdGEsXG4gICAgICAgICAgICBoYW5kbGVyRmFjdG9yeTogdGhpcy5faGFuZGxlckZhY3RvcnksXG4gICAgICAgICAgICBleHRlbmRlZFJ0cENhcGFiaWxpdGllczogdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICBjYW5Qcm9kdWNlQnlLaW5kOiB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ25ld3RyYW5zcG9ydCcsIHRyYW5zcG9ydCk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxufVxuZXhwb3J0cy5EZXZpY2UgPSBEZXZpY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Device.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EnhancedEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"(app-client)/./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst logger = new Logger_1.Logger('EnhancedEventEmitter');\nclass EnhancedEventEmitter extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.setMaxListeners(Infinity);\n    }\n    emit(eventName, ...args) {\n        return super.emit(eventName, ...args);\n    }\n    /**\n     * Special addition to the EventEmitter API.\n     */\n    safeEmit(eventName, ...args) {\n        const numListeners = super.listenerCount(eventName);\n        try {\n            return super.emit(eventName, ...args);\n        }\n        catch (error) {\n            logger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);\n            return Boolean(numListeners);\n        }\n    }\n    on(eventName, listener) {\n        super.on(eventName, listener);\n        return this;\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    addListener(eventName, listener) {\n        super.on(eventName, listener);\n        return this;\n    }\n    prependListener(eventName, listener) {\n        super.prependListener(eventName, listener);\n        return this;\n    }\n    once(eventName, listener) {\n        super.once(eventName, listener);\n        return this;\n    }\n    prependOnceListener(eventName, listener) {\n        super.prependOnceListener(eventName, listener);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    removeAllListeners(eventName) {\n        super.removeAllListeners(eventName);\n        return this;\n    }\n    listenerCount(eventName) {\n        return super.listenerCount(eventName);\n    }\n    listeners(eventName) {\n        return super.listeners(eventName);\n    }\n    rawListeners(eventName) {\n        return super.rawListeners(eventName);\n    }\n}\nexports.EnhancedEventEmitter = EnhancedEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0VuaGFuY2VkRXZlbnRFbWl0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QixpQkFBaUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRW5oYW5jZWRFdmVudEVtaXR0ZXIuanM/MTdjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5oYW5jZWRFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5jbGFzcyBFbmhhbmNlZEV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBhZGRpdGlvbiB0byB0aGUgRXZlbnRFbWl0dGVyIEFQSS5cbiAgICAgKi9cbiAgICBzYWZlRW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbnVtTGlzdGVuZXJzID0gc3VwZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignc2FmZUVtaXQoKSB8IGV2ZW50IGxpc3RlbmVyIHRocmV3IGFuIGVycm9yIFtldmVudE5hbWU6JXNdOiVvJywgZXZlbnROYW1lLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihudW1MaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIH1cbiAgICByYXdMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yYXdMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLkVuaGFuY2VkRXZlbnRFbWl0dGVyID0gRW5oYW5jZWRFdmVudEVtaXR0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js\"));\nconst APP_NAME = 'mediasoup-client';\nclass Logger {\n    constructor(prefix) {\n        if (prefix) {\n            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);\n            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);\n            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);\n        }\n        else {\n            this._debug = (0, debug_1.default)(APP_NAME);\n            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);\n            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);\n        }\n        /* eslint-disable no-console */\n        this._debug.log = console.info.bind(console);\n        this._warn.log = console.warn.bind(console);\n        this._error.log = console.error.bind(console);\n        /* eslint-enable no-console */\n    }\n    get debug() {\n        return this._debug;\n    }\n    get warn() {\n        return this._warn;\n    }\n    get error() {\n        return this._error;\n    }\n}\nexports.Logger = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQ0FBZ0MsbUJBQU8sQ0FBQyxtSEFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLEdBQUcsT0FBTztBQUNyRSxpREFBaUQsU0FBUyxRQUFRLE9BQU87QUFDekUsa0RBQWtELFNBQVMsU0FBUyxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFELGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9Mb2dnZXIuanM/YTQ4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgQVBQX05BTUUgPSAnbWVkaWFzb3VwLWNsaWVudCc7XG5jbGFzcyBMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0FQUF9OQU1FfToke3ByZWZpeH1gKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtBUFBfTkFNRX06V0FSTjoke3ByZWZpeH1gKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OkVSUk9SOiR7cHJlZml4fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShBUFBfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLl93YXJuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OldBUk5gKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7QVBQX05BTUV9OkVSUk9SYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICB0aGlzLl9kZWJ1Zy5sb2cgPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKTtcbiAgICAgICAgdGhpcy5fd2Fybi5sb2cgPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgICAgdGhpcy5fZXJyb3IubG9nID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB9XG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWc7XG4gICAgfVxuICAgIGdldCB3YXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FybjtcbiAgICB9XG4gICAgZ2V0IGVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Producer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Producer.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Producer = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst logger = new Logger_1.Logger('Producer');\nclass Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor()');\n        this._id = id;\n        this._localId = localId;\n        this._rtpSender = rtpSender;\n        this._track = track;\n        this._kind = track.kind;\n        this._rtpParameters = rtpParameters;\n        this._paused = disableTrackOnPause ? !track.enabled : false;\n        this._maxSpatialLayer = undefined;\n        this._stopTracks = stopTracks;\n        this._disableTrackOnPause = disableTrackOnPause;\n        this._zeroRtpOnPause = zeroRtpOnPause;\n        this._appData = appData || {};\n        this.onTrackEnded = this.onTrackEnded.bind(this);\n        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n        // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n        this.handleTrack();\n    }\n    /**\n     * Producer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Local id.\n     */\n    get localId() {\n        return this._localId;\n    }\n    /**\n     * Whether the Producer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n    get kind() {\n        return this._kind;\n    }\n    /**\n     * Associated RTCRtpSender.\n     */\n    get rtpSender() {\n        return this._rtpSender;\n    }\n    /**\n     * The associated track.\n     */\n    get track() {\n        return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n    get rtpParameters() {\n        return this._rtpParameters;\n    }\n    /**\n     * Whether the Producer is paused.\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Max spatial layer.\n     *\n     * @type {Number | undefined}\n     */\n    get maxSpatialLayer() {\n        return this._maxSpatialLayer;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Closes the Producer.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        this.destroyTrack();\n        this.emit('@close');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this.destroyTrack();\n        this.safeEmit('transportclose');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated RTCRtpSender stats.\n     */\n    async getStats() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        return new Promise((resolve, reject) => {\n            this.safeEmit('@getstats', resolve, reject);\n        });\n    }\n    /**\n     * Pauses sending media.\n     */\n    pause() {\n        logger.debug('pause()');\n        if (this._closed) {\n            logger.error('pause() | Producer closed');\n            return;\n        }\n        this._paused = true;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = false;\n        }\n        if (this._zeroRtpOnPause) {\n            new Promise((resolve, reject) => {\n                this.safeEmit('@pause', resolve, reject);\n            }).catch(() => { });\n        }\n        // Emit observer event.\n        this._observer.safeEmit('pause');\n    }\n    /**\n     * Resumes sending media.\n     */\n    resume() {\n        logger.debug('resume()');\n        if (this._closed) {\n            logger.error('resume() | Producer closed');\n            return;\n        }\n        this._paused = false;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = true;\n        }\n        if (this._zeroRtpOnPause) {\n            new Promise((resolve, reject) => {\n                this.safeEmit('@resume', resolve, reject);\n            }).catch(() => { });\n        }\n        // Emit observer event.\n        this._observer.safeEmit('resume');\n    }\n    /**\n     * Replaces the current track with a new one or null.\n     */\n    async replaceTrack({ track, }) {\n        logger.debug('replaceTrack() [track:%o]', track);\n        if (this._closed) {\n            // This must be done here. Otherwise there is no chance to stop the given\n            // track.\n            if (track && this._stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error) { }\n            }\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (track && track.readyState === 'ended') {\n            throw new errors_1.InvalidStateError('track ended');\n        }\n        // Do nothing if this is the same track as the current handled one.\n        if (track === this._track) {\n            logger.debug('replaceTrack() | same track, ignored');\n            return;\n        }\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@replacetrack', track, resolve, reject);\n        });\n        // Destroy the previous track.\n        this.destroyTrack();\n        // Set the new track.\n        this._track = track;\n        // If this Producer was paused/resumed and the state of the new\n        // track does not match, fix it.\n        if (this._track && this._disableTrackOnPause) {\n            if (!this._paused) {\n                this._track.enabled = true;\n            }\n            else if (this._paused) {\n                this._track.enabled = false;\n            }\n        }\n        // Handle the effective track.\n        this.handleTrack();\n    }\n    /**\n     * Sets the video max spatial layer to be sent.\n     */\n    async setMaxSpatialLayer(spatialLayer) {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._kind !== 'video') {\n            throw new errors_1.UnsupportedError('not a video Producer');\n        }\n        else if (typeof spatialLayer !== 'number') {\n            throw new TypeError('invalid spatialLayer');\n        }\n        if (spatialLayer === this._maxSpatialLayer) {\n            return;\n        }\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);\n        }).catch(() => { });\n        this._maxSpatialLayer = spatialLayer;\n    }\n    async setRtpEncodingParameters(params) {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (typeof params !== 'object') {\n            throw new TypeError('invalid params');\n        }\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@setrtpencodingparameters', params, resolve, reject);\n        });\n    }\n    onTrackEnded() {\n        logger.debug('track \"ended\" event');\n        this.safeEmit('trackended');\n        // Emit observer event.\n        this._observer.safeEmit('trackended');\n    }\n    handleTrack() {\n        if (!this._track) {\n            return;\n        }\n        this._track.addEventListener('ended', this.onTrackEnded);\n    }\n    destroyTrack() {\n        if (!this._track) {\n            return;\n        }\n        try {\n            this._track.removeEventListener('ended', this.onTrackEnded);\n            // Just stop the track unless the app set stopTracks: false.\n            if (this._stopTracks) {\n                this._track.stop();\n            }\n        }\n        catch (error) { }\n    }\n}\nexports.Producer = Producer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1Byb2R1Y2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBVTtBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQyxrSkFBd0I7QUFDL0QsaUJBQWlCLG1CQUFPLENBQUMsc0hBQVU7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQix5R0FBeUc7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1Byb2R1Y2VyLmpzPzk1YWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2R1Y2VyID0gdm9pZCAwO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1Byb2R1Y2VyJyk7XG5jbGFzcyBQcm9kdWNlciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGxvY2FsSWQsIHJ0cFNlbmRlciwgdHJhY2ssIHJ0cFBhcmFtZXRlcnMsIHN0b3BUcmFja3MsIGRpc2FibGVUcmFja09uUGF1c2UsIHplcm9SdHBPblBhdXNlLCBhcHBEYXRhLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gT2JzZXJ2ZXIgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpJyk7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2xvY2FsSWQgPSBsb2NhbElkO1xuICAgICAgICB0aGlzLl9ydHBTZW5kZXIgPSBydHBTZW5kZXI7XG4gICAgICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG4gICAgICAgIHRoaXMuX2tpbmQgPSB0cmFjay5raW5kO1xuICAgICAgICB0aGlzLl9ydHBQYXJhbWV0ZXJzID0gcnRwUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZGlzYWJsZVRyYWNrT25QYXVzZSA/ICF0cmFjay5lbmFibGVkIDogZmFsc2U7XG4gICAgICAgIHRoaXMuX21heFNwYXRpYWxMYXllciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RvcFRyYWNrcyA9IHN0b3BUcmFja3M7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVUcmFja09uUGF1c2UgPSBkaXNhYmxlVHJhY2tPblBhdXNlO1xuICAgICAgICB0aGlzLl96ZXJvUnRwT25QYXVzZSA9IHplcm9SdHBPblBhdXNlO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YSB8fCB7fTtcbiAgICAgICAgdGhpcy5vblRyYWNrRW5kZWQgPSB0aGlzLm9uVHJhY2tFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBOT1RFOiBNaW5vciBpc3N1ZS4gSWYgemVyb1J0cE9uUGF1c2UgaXMgdHJ1ZSwgd2UgY2Fubm90IGVtaXQgdGhlXG4gICAgICAgIC8vICdAcmVwbGFjZXRyYWNrJyBldmVudCBoZXJlLCBzbyBSVENSdHBTZW5kZXIudHJhY2sgd29uJ3QgYmUgbnVsbC5cbiAgICAgICAgdGhpcy5oYW5kbGVUcmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlciBpZC5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9jYWwgaWQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBQcm9kdWNlciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVkaWEga2luZC5cbiAgICAgKi9cbiAgICBnZXQga2luZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tpbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuICAgICAqL1xuICAgIGdldCBydHBTZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydHBTZW5kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhc3NvY2lhdGVkIHRyYWNrLlxuICAgICAqL1xuICAgIGdldCB0cmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVFAgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXQgcnRwUGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cFBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFByb2R1Y2VyIGlzIHBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXggc3BhdGlhbCBsYXllci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXIgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IG1heFNwYXRpYWxMYXllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heFNwYXRpYWxMYXllcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgIH1cbiAgICBnZXQgb2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBQcm9kdWNlci5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lUcmFjaygpO1xuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG4gICAgICovXG4gICAgdHJhbnNwb3J0Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFuc3BvcnRDbG9zZWQoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lUcmFjaygpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFuc3BvcnRjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIHN0YXRzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAZ2V0c3RhdHMnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHNlbmRpbmcgbWVkaWEuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2UoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3BhdXNlKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fdHJhY2sgJiYgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl96ZXJvUnRwT25QYXVzZSkge1xuICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0BwYXVzZScsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdwYXVzZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHNlbmRpbmcgbWVkaWEuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcigncmVzdW1lKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrICYmIHRoaXMuX2Rpc2FibGVUcmFja09uUGF1c2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl96ZXJvUnRwT25QYXVzZSkge1xuICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0ByZXN1bWUnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgncmVzdW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IHRyYWNrIHdpdGggYSBuZXcgb25lIG9yIG51bGwuXG4gICAgICovXG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKHsgdHJhY2ssIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbdHJhY2s6JW9dJywgdHJhY2spO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG11c3QgYmUgZG9uZSBoZXJlLiBPdGhlcndpc2UgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHN0b3AgdGhlIGdpdmVuXG4gICAgICAgICAgICAvLyB0cmFjay5cbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0aGlzLl9zdG9wVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFjayAmJiB0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ3RyYWNrIGVuZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGlzIGlzIHRoZSBzYW1lIHRyYWNrIGFzIHRoZSBjdXJyZW50IGhhbmRsZWQgb25lLlxuICAgICAgICBpZiAodHJhY2sgPT09IHRoaXMuX3RyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIHwgc2FtZSB0cmFjaywgaWdub3JlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0ByZXBsYWNldHJhY2snLCB0cmFjaywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERlc3Ryb3kgdGhlIHByZXZpb3VzIHRyYWNrLlxuICAgICAgICB0aGlzLmRlc3Ryb3lUcmFjaygpO1xuICAgICAgICAvLyBTZXQgdGhlIG5ldyB0cmFjay5cbiAgICAgICAgdGhpcy5fdHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8gSWYgdGhpcyBQcm9kdWNlciB3YXMgcGF1c2VkL3Jlc3VtZWQgYW5kIHRoZSBzdGF0ZSBvZiB0aGUgbmV3XG4gICAgICAgIC8vIHRyYWNrIGRvZXMgbm90IG1hdGNoLCBmaXggaXQuXG4gICAgICAgIGlmICh0aGlzLl90cmFjayAmJiB0aGlzLl9kaXNhYmxlVHJhY2tPblBhdXNlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgZWZmZWN0aXZlIHRyYWNrLlxuICAgICAgICB0aGlzLmhhbmRsZVRyYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpZGVvIG1heCBzcGF0aWFsIGxheWVyIHRvIGJlIHNlbnQuXG4gICAgICovXG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKHNwYXRpYWxMYXllcikge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2tpbmQgIT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgYSB2aWRlbyBQcm9kdWNlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzcGF0aWFsTGF5ZXIgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHNwYXRpYWxMYXllcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGF0aWFsTGF5ZXIgPT09IHRoaXMuX21heFNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0BzZXRtYXhzcGF0aWFsbGF5ZXInLCBzcGF0aWFsTGF5ZXIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMuX21heFNwYXRpYWxMYXllciA9IHNwYXRpYWxMYXllcjtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcycpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0BzZXRydHBlbmNvZGluZ3BhcmFtZXRlcnMnLCBwYXJhbXMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblRyYWNrRW5kZWQoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhY2sgXCJlbmRlZFwiIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICB9XG4gICAgaGFuZGxlVHJhY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub25UcmFja0VuZGVkKTtcbiAgICB9XG4gICAgZGVzdHJveVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vblRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgLy8gSnVzdCBzdG9wIHRoZSB0cmFjayB1bmxlc3MgdGhlIGFwcCBzZXQgc3RvcFRyYWNrczogZmFsc2UuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcFRyYWNrcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJvZHVjZXIgPSBQcm9kdWNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Producer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/RtpParameters.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/RtpParameters.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * The RTP capabilities define what mediasoup or an endpoint can receive at\n * media level.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1J0cFBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvUnRwUGFyYW1ldGVycy5qcz8wODkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGUgUlRQIGNhcGFiaWxpdGllcyBkZWZpbmUgd2hhdCBtZWRpYXNvdXAgb3IgYW4gZW5kcG9pbnQgY2FuIHJlY2VpdmUgYXRcbiAqIG1lZGlhIGxldmVsLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/RtpParameters.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/SctpParameters.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/SctpParameters.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1NjdHBQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9TY3RwUGFyYW1ldGVycy5qcz83MDViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/SctpParameters.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Transport.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Transport.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transport = void 0;\nconst awaitqueue_1 = __webpack_require__(/*! awaitqueue */ \"(app-client)/./node_modules/.pnpm/awaitqueue@3.0.2_supports-color@9.4.0/node_modules/awaitqueue/lib/index.js\");\nconst queue_microtask_1 = __importDefault(__webpack_require__(/*! queue-microtask */ \"(app-client)/./node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ./ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst Producer_1 = __webpack_require__(/*! ./Producer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Producer.js\");\nconst Consumer_1 = __webpack_require__(/*! ./Consumer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Consumer.js\");\nconst DataProducer_1 = __webpack_require__(/*! ./DataProducer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataProducer.js\");\nconst DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataConsumer.js\");\nconst logger = new Logger_1.Logger('Transport');\nclass ConsumerCreationTask {\n    constructor(consumerOptions) {\n        this.consumerOptions = consumerOptions;\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind, }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Transport ICE gathering state.\n        this._iceGatheringState = 'new';\n        // Transport connection state.\n        this._connectionState = 'new';\n        // Map of Producers indexed by id.\n        this._producers = new Map();\n        // Map of Consumers indexed by id.\n        this._consumers = new Map();\n        // Map of DataProducers indexed by id.\n        this._dataProducers = new Map();\n        // Map of DataConsumers indexed by id.\n        this._dataConsumers = new Map();\n        // Whether the Consumer for RTP probation has been created.\n        this._probatorConsumerCreated = false;\n        // AwaitQueue instance to make async tasks happen sequentially.\n        this._awaitQueue = new awaitqueue_1.AwaitQueue();\n        // Consumer creation tasks awaiting to be processed.\n        this._pendingConsumerTasks = [];\n        // Consumer creation in progress flag.\n        this._consumerCreationInProgress = false;\n        // Consumers pending to be paused.\n        this._pendingPauseConsumers = new Map();\n        // Consumer pause in progress flag.\n        this._consumerPauseInProgress = false;\n        // Consumers pending to be resumed.\n        this._pendingResumeConsumers = new Map();\n        // Consumer resume in progress flag.\n        this._consumerResumeInProgress = false;\n        // Consumers pending to be closed.\n        this._pendingCloseConsumers = new Map();\n        // Consumer close in progress flag.\n        this._consumerCloseInProgress = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n        this._id = id;\n        this._direction = direction;\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\n        this._canProduceByKind = canProduceByKind;\n        this._maxSctpMessageSize = sctpParameters\n            ? sctpParameters.maxMessageSize\n            : null;\n        // Clone and sanitize additionalSettings.\n        additionalSettings = utils.clone(additionalSettings) || {};\n        delete additionalSettings.iceServers;\n        delete additionalSettings.iceTransportPolicy;\n        delete additionalSettings.bundlePolicy;\n        delete additionalSettings.rtcpMuxPolicy;\n        delete additionalSettings.sdpSemantics;\n        this._handler = handlerFactory();\n        this._handler.run({\n            direction,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings,\n            proprietaryConstraints,\n            extendedRtpCapabilities,\n        });\n        this._appData = appData || {};\n        this.handleHandler();\n    }\n    /**\n     * Transport id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the Transport is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Transport direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * RTC handler instance.\n     */\n    get handler() {\n        return this._handler;\n    }\n    /**\n     * ICE gathering state.\n     */\n    get iceGatheringState() {\n        return this._iceGatheringState;\n    }\n    /**\n     * Connection state.\n     */\n    get connectionState() {\n        return this._connectionState;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * App custom data setter.\n     */\n    set appData(appData) {\n        this._appData = appData;\n    }\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Close the Transport.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        logger.debug('close()');\n        this._closed = true;\n        // Stop the AwaitQueue.\n        this._awaitQueue.stop();\n        // Close the handler.\n        this._handler.close();\n        // Change connection state to 'closed' since the handler may not emit\n        // '@connectionstatechange' event.\n        this._connectionState = 'closed';\n        // Close all Producers.\n        for (const producer of this._producers.values()) {\n            producer.transportClosed();\n        }\n        this._producers.clear();\n        // Close all Consumers.\n        for (const consumer of this._consumers.values()) {\n            consumer.transportClosed();\n        }\n        this._consumers.clear();\n        // Close all DataProducers.\n        for (const dataProducer of this._dataProducers.values()) {\n            dataProducer.transportClosed();\n        }\n        this._dataProducers.clear();\n        // Close all DataConsumers.\n        for (const dataConsumer of this._dataConsumers.values()) {\n            dataConsumer.transportClosed();\n        }\n        this._dataConsumers.clear();\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated Transport (RTCPeerConnection) stats.\n     *\n     * @returns {RTCStatsReport}\n     */\n    async getStats() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        return this._handler.getTransportStats();\n    }\n    /**\n     * Restart ICE connection.\n     */\n    async restartIce({ iceParameters, }) {\n        logger.debug('restartIce()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (!iceParameters) {\n            throw new TypeError('missing iceParameters');\n        }\n        // Enqueue command.\n        return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), 'transport.restartIce()');\n    }\n    /**\n     * Update ICE servers.\n     */\n    async updateIceServers({ iceServers, } = {}) {\n        logger.debug('updateIceServers()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (!Array.isArray(iceServers)) {\n            throw new TypeError('missing iceServers');\n        }\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n    }\n    /**\n     * Create a Producer.\n     */\n    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {}, } = {}) {\n        logger.debug('produce() [track:%o]', track);\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (!track) {\n            throw new TypeError('missing track');\n        }\n        else if (this._direction !== 'send') {\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        }\n        else if (!this._canProduceByKind[track.kind]) {\n            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\n        }\n        else if (track.readyState === 'ended') {\n            throw new errors_1.InvalidStateError('track ended');\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (this.listenerCount('produce') === 0) {\n            throw new TypeError('no \"produce\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // Enqueue command.\n        return (this._awaitQueue\n            .push(async () => {\n            let normalizedEncodings;\n            if (encodings && !Array.isArray(encodings)) {\n                throw TypeError('encodings must be an array');\n            }\n            else if (encodings && encodings.length === 0) {\n                normalizedEncodings = undefined;\n            }\n            else if (encodings) {\n                normalizedEncodings = encodings.map((encoding) => {\n                    const normalizedEncoding = { active: true };\n                    if (encoding.active === false) {\n                        normalizedEncoding.active = false;\n                    }\n                    if (typeof encoding.dtx === 'boolean') {\n                        normalizedEncoding.dtx = encoding.dtx;\n                    }\n                    if (typeof encoding.scalabilityMode === 'string') {\n                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n                    }\n                    if (typeof encoding.scaleResolutionDownBy === 'number') {\n                        normalizedEncoding.scaleResolutionDownBy =\n                            encoding.scaleResolutionDownBy;\n                    }\n                    if (typeof encoding.maxBitrate === 'number') {\n                        normalizedEncoding.maxBitrate = encoding.maxBitrate;\n                    }\n                    if (typeof encoding.maxFramerate === 'number') {\n                        normalizedEncoding.maxFramerate = encoding.maxFramerate;\n                    }\n                    if (typeof encoding.adaptivePtime === 'boolean') {\n                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n                    }\n                    if (typeof encoding.priority === 'string') {\n                        normalizedEncoding.priority = encoding.priority;\n                    }\n                    if (typeof encoding.networkPriority === 'string') {\n                        normalizedEncoding.networkPriority = encoding.networkPriority;\n                    }\n                    return normalizedEncoding;\n                });\n            }\n            const { localId, rtpParameters, rtpSender } = await this._handler.send({\n                track,\n                encodings: normalizedEncodings,\n                codecOptions,\n                codec,\n            });\n            try {\n                // This will fill rtpParameters's missing fields with default values.\n                ortc.validateRtpParameters(rtpParameters);\n                const { id } = await new Promise((resolve, reject) => {\n                    this.safeEmit('produce', {\n                        kind: track.kind,\n                        rtpParameters,\n                        appData,\n                    }, resolve, reject);\n                });\n                const producer = new Producer_1.Producer({\n                    id,\n                    localId,\n                    rtpSender,\n                    track,\n                    rtpParameters,\n                    stopTracks,\n                    disableTrackOnPause,\n                    zeroRtpOnPause,\n                    appData,\n                });\n                this._producers.set(producer.id, producer);\n                this.handleProducer(producer);\n                // Emit observer event.\n                this._observer.safeEmit('newproducer', producer);\n                return producer;\n            }\n            catch (error) {\n                this._handler.stopSending(localId).catch(() => { });\n                throw error;\n            }\n        }, 'transport.produce()')\n            // This catch is needed to stop the given track if the command above\n            // failed due to closed Transport.\n            .catch((error) => {\n            if (stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error2) { }\n            }\n            throw error;\n        }));\n    }\n    /**\n     * Create a Consumer to consume a remote Producer.\n     */\n    async consume({ id, producerId, kind, rtpParameters, streamId, appData = {}, }) {\n        logger.debug('consume()');\n        rtpParameters = utils.clone(rtpParameters);\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._direction !== 'recv') {\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        }\n        else if (typeof id !== 'string') {\n            throw new TypeError('missing id');\n        }\n        else if (typeof producerId !== 'string') {\n            throw new TypeError('missing producerId');\n        }\n        else if (kind !== 'audio' && kind !== 'video') {\n            throw new TypeError(`invalid kind '${kind}'`);\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // Ensure the device can consume it.\n        const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);\n        if (!canConsume) {\n            throw new errors_1.UnsupportedError('cannot consume this Producer');\n        }\n        const consumerCreationTask = new ConsumerCreationTask({\n            id,\n            producerId,\n            kind,\n            rtpParameters,\n            streamId,\n            appData,\n        });\n        // Store the Consumer creation task.\n        this._pendingConsumerTasks.push(consumerCreationTask);\n        // There is no Consumer creation in progress, create it now.\n        (0, queue_microtask_1.default)(() => {\n            if (this._closed) {\n                return;\n            }\n            if (this._consumerCreationInProgress === false) {\n                this.createPendingConsumers();\n            }\n        });\n        return consumerCreationTask.promise;\n    }\n    /**\n     * Create a DataProducer\n     */\n    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {}, } = {}) {\n        logger.debug('produceData()');\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._direction !== 'send') {\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        }\n        else if (!this._maxSctpMessageSize) {\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (this.listenerCount('producedata') === 0) {\n            throw new TypeError('no \"producedata\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        if (maxPacketLifeTime || maxRetransmits) {\n            ordered = false;\n        }\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({\n                ordered,\n                maxPacketLifeTime,\n                maxRetransmits,\n                label,\n                protocol,\n            });\n            // This will fill sctpStreamParameters's missing fields with default values.\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\n            const { id } = await new Promise((resolve, reject) => {\n                this.safeEmit('producedata', {\n                    sctpStreamParameters,\n                    label,\n                    protocol,\n                    appData,\n                }, resolve, reject);\n            });\n            const dataProducer = new DataProducer_1.DataProducer({\n                id,\n                dataChannel,\n                sctpStreamParameters,\n                appData,\n            });\n            this._dataProducers.set(dataProducer.id, dataProducer);\n            this.handleDataProducer(dataProducer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataproducer', dataProducer);\n            return dataProducer;\n        }, 'transport.produceData()');\n    }\n    /**\n     * Create a DataConsumer\n     */\n    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {}, }) {\n        logger.debug('consumeData()');\n        sctpStreamParameters = utils.clone(sctpStreamParameters);\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (this._direction !== 'recv') {\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        }\n        else if (!this._maxSctpMessageSize) {\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        }\n        else if (typeof id !== 'string') {\n            throw new TypeError('missing id');\n        }\n        else if (typeof dataProducerId !== 'string') {\n            throw new TypeError('missing dataProducerId');\n        }\n        else if (this.listenerCount('connect') === 0 &&\n            this._connectionState === 'new') {\n            throw new TypeError('no \"connect\" listener set into this transport');\n        }\n        else if (appData && typeof appData !== 'object') {\n            throw new TypeError('if given, appData must be an object');\n        }\n        // This may throw.\n        ortc.validateSctpStreamParameters(sctpStreamParameters);\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel } = await this._handler.receiveDataChannel({\n                sctpStreamParameters,\n                label,\n                protocol,\n            });\n            const dataConsumer = new DataConsumer_1.DataConsumer({\n                id,\n                dataProducerId,\n                dataChannel,\n                sctpStreamParameters,\n                appData,\n            });\n            this._dataConsumers.set(dataConsumer.id, dataConsumer);\n            this.handleDataConsumer(dataConsumer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataconsumer', dataConsumer);\n            return dataConsumer;\n        }, 'transport.consumeData()');\n    }\n    // This method is guaranteed to never throw.\n    async createPendingConsumers() {\n        this._consumerCreationInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingConsumerTasks.length === 0) {\n                logger.debug('createPendingConsumers() | there is no Consumer to be created');\n                return;\n            }\n            const pendingConsumerTasks = [...this._pendingConsumerTasks];\n            // Clear pending Consumer tasks.\n            this._pendingConsumerTasks = [];\n            // Video Consumer in order to create the probator.\n            let videoConsumerForProbator = undefined;\n            // Fill options list.\n            const optionsList = [];\n            for (const task of pendingConsumerTasks) {\n                const { id, kind, rtpParameters, streamId } = task.consumerOptions;\n                optionsList.push({\n                    trackId: id,\n                    kind: kind,\n                    rtpParameters,\n                    streamId,\n                });\n            }\n            try {\n                const results = await this._handler.receive(optionsList);\n                for (let idx = 0; idx < results.length; ++idx) {\n                    const task = pendingConsumerTasks[idx];\n                    const result = results[idx];\n                    const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;\n                    const { localId, rtpReceiver, track } = result;\n                    const consumer = new Consumer_1.Consumer({\n                        id: id,\n                        localId,\n                        producerId: producerId,\n                        rtpReceiver,\n                        track,\n                        rtpParameters,\n                        appData: appData,\n                    });\n                    this._consumers.set(consumer.id, consumer);\n                    this.handleConsumer(consumer);\n                    // If this is the first video Consumer and the Consumer for RTP probation\n                    // has not yet been created, it's time to create it.\n                    if (!this._probatorConsumerCreated &&\n                        !videoConsumerForProbator &&\n                        kind === 'video') {\n                        videoConsumerForProbator = consumer;\n                    }\n                    // Emit observer event.\n                    this._observer.safeEmit('newconsumer', consumer);\n                    task.resolve(consumer);\n                }\n            }\n            catch (error) {\n                for (const task of pendingConsumerTasks) {\n                    task.reject(error);\n                }\n            }\n            // If RTP probation must be handled, do it now.\n            if (videoConsumerForProbator) {\n                try {\n                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);\n                    await this._handler.receive([\n                        {\n                            trackId: 'probator',\n                            kind: 'video',\n                            rtpParameters: probatorRtpParameters,\n                        },\n                    ]);\n                    logger.debug('createPendingConsumers() | Consumer for RTP probation created');\n                    this._probatorConsumerCreated = true;\n                }\n                catch (error) {\n                    logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);\n                }\n            }\n        }, 'transport.createPendingConsumers()')\n            .then(() => {\n            this._consumerCreationInProgress = false;\n            // There are pending Consumer tasks, enqueue their creation.\n            if (this._pendingConsumerTasks.length > 0) {\n                this.createPendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    pausePendingConsumers() {\n        this._consumerPauseInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingPauseConsumers.size === 0) {\n                logger.debug('pausePendingConsumers() | there is no Consumer to be paused');\n                return;\n            }\n            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());\n            // Clear pending pause Consumer map.\n            this._pendingPauseConsumers.clear();\n            try {\n                const localIds = pendingPauseConsumers.map(consumer => consumer.localId);\n                await this._handler.pauseReceiving(localIds);\n            }\n            catch (error) {\n                logger.error('pausePendingConsumers() | failed to pause Consumers:', error);\n            }\n        }, 'transport.pausePendingConsumers')\n            .then(() => {\n            this._consumerPauseInProgress = false;\n            // There are pending Consumers to be paused, do it.\n            if (this._pendingPauseConsumers.size > 0) {\n                this.pausePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    resumePendingConsumers() {\n        this._consumerResumeInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingResumeConsumers.size === 0) {\n                logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');\n                return;\n            }\n            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());\n            // Clear pending resume Consumer map.\n            this._pendingResumeConsumers.clear();\n            try {\n                const localIds = pendingResumeConsumers.map(consumer => consumer.localId);\n                await this._handler.resumeReceiving(localIds);\n            }\n            catch (error) {\n                logger.error('resumePendingConsumers() | failed to resume Consumers:', error);\n            }\n        }, 'transport.resumePendingConsumers')\n            .then(() => {\n            this._consumerResumeInProgress = false;\n            // There are pending Consumer to be resumed, do it.\n            if (this._pendingResumeConsumers.size > 0) {\n                this.resumePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    closePendingConsumers() {\n        this._consumerCloseInProgress = true;\n        this._awaitQueue\n            .push(async () => {\n            if (this._pendingCloseConsumers.size === 0) {\n                logger.debug('closePendingConsumers() | there is no Consumer to be closed');\n                return;\n            }\n            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());\n            // Clear pending close Consumer map.\n            this._pendingCloseConsumers.clear();\n            try {\n                await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));\n            }\n            catch (error) {\n                logger.error('closePendingConsumers() | failed to close Consumers:', error);\n            }\n        }, 'transport.closePendingConsumers')\n            .then(() => {\n            this._consumerCloseInProgress = false;\n            // There are pending Consumer to be resumed, do it.\n            if (this._pendingCloseConsumers.size > 0) {\n                this.closePendingConsumers();\n            }\n        })\n            // NOTE: We only get here when the await queue is closed.\n            .catch(() => { });\n    }\n    handleHandler() {\n        const handler = this._handler;\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\n            if (this._closed) {\n                errback(new errors_1.InvalidStateError('closed'));\n                return;\n            }\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\n        });\n        handler.on('@icegatheringstatechange', (iceGatheringState) => {\n            if (iceGatheringState === this._iceGatheringState) {\n                return;\n            }\n            logger.debug('ICE gathering state changed to %s', iceGatheringState);\n            this._iceGatheringState = iceGatheringState;\n            if (!this._closed) {\n                this.safeEmit('icegatheringstatechange', iceGatheringState);\n            }\n        });\n        handler.on('@connectionstatechange', (connectionState) => {\n            if (connectionState === this._connectionState) {\n                return;\n            }\n            logger.debug('connection state changed to %s', connectionState);\n            this._connectionState = connectionState;\n            if (!this._closed) {\n                this.safeEmit('connectionstatechange', connectionState);\n            }\n        });\n    }\n    handleProducer(producer) {\n        producer.on('@close', () => {\n            this._producers.delete(producer.id);\n            if (this._closed) {\n                return;\n            }\n            this._awaitQueue\n                .push(async () => await this._handler.stopSending(producer.localId), 'producer @close event')\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\n        });\n        producer.on('@pause', (callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.pauseSending(producer.localId), 'producer @pause event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@resume', (callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.resumeSending(producer.localId), 'producer @resume event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@replacetrack', (track, callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n            this._awaitQueue\n                .push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@getstats', (callback, errback) => {\n            if (this._closed) {\n                return errback(new errors_1.InvalidStateError('closed'));\n            }\n            this._handler\n                .getSenderStats(producer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    handleConsumer(consumer) {\n        consumer.on('@close', () => {\n            this._consumers.delete(consumer.id);\n            this._pendingPauseConsumers.delete(consumer.id);\n            this._pendingResumeConsumers.delete(consumer.id);\n            if (this._closed) {\n                return;\n            }\n            // Store the Consumer into the close list.\n            this._pendingCloseConsumers.set(consumer.id, consumer);\n            // There is no Consumer close in progress, do it now.\n            if (this._consumerCloseInProgress === false) {\n                this.closePendingConsumers();\n            }\n        });\n        consumer.on('@pause', () => {\n            // If Consumer is pending to be resumed, remove from pending resume list.\n            if (this._pendingResumeConsumers.has(consumer.id)) {\n                this._pendingResumeConsumers.delete(consumer.id);\n            }\n            // Store the Consumer into the pending list.\n            this._pendingPauseConsumers.set(consumer.id, consumer);\n            // There is no Consumer pause in progress, do it now.\n            (0, queue_microtask_1.default)(() => {\n                if (this._closed) {\n                    return;\n                }\n                if (this._consumerPauseInProgress === false) {\n                    this.pausePendingConsumers();\n                }\n            });\n        });\n        consumer.on('@resume', () => {\n            // If Consumer is pending to be paused, remove from pending pause list.\n            if (this._pendingPauseConsumers.has(consumer.id)) {\n                this._pendingPauseConsumers.delete(consumer.id);\n            }\n            // Store the Consumer into the pending list.\n            this._pendingResumeConsumers.set(consumer.id, consumer);\n            // There is no Consumer resume in progress, do it now.\n            (0, queue_microtask_1.default)(() => {\n                if (this._closed) {\n                    return;\n                }\n                if (this._consumerResumeInProgress === false) {\n                    this.resumePendingConsumers();\n                }\n            });\n        });\n        consumer.on('@getstats', (callback, errback) => {\n            if (this._closed) {\n                return errback(new errors_1.InvalidStateError('closed'));\n            }\n            this._handler\n                .getReceiverStats(consumer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    handleDataProducer(dataProducer) {\n        dataProducer.on('@close', () => {\n            this._dataProducers.delete(dataProducer.id);\n        });\n    }\n    handleDataConsumer(dataConsumer) {\n        dataConsumer.on('@close', () => {\n            this._dataConsumers.delete(dataConsumer.id);\n        });\n    }\n}\nexports.Transport = Transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1RyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIscUJBQXFCLG1CQUFPLENBQUMsZ0lBQVk7QUFDekMsMENBQTBDLG1CQUFPLENBQUMsc0hBQWlCO0FBQ25FLGlCQUFpQixtQkFBTyxDQUFDLHNIQUFVO0FBQ25DLCtCQUErQixtQkFBTyxDQUFDLGtKQUF3QjtBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBVTtBQUNuQywyQkFBMkIsbUJBQU8sQ0FBQyxvSEFBUztBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxrSEFBUTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQywwSEFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQywwSEFBWTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQyxrSUFBZ0I7QUFDL0MsdUJBQXVCLG1CQUFPLENBQUMsa0lBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4TkFBOE47QUFDaFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEhBQTBILElBQUksSUFBSTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFdBQVc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBMkQsR0FBRztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEZBQTBGLElBQUksSUFBSTtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlGQUFpRixHQUFHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1RyYW5zcG9ydC5qcz85ZGM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zcG9ydCA9IHZvaWQgMDtcbmNvbnN0IGF3YWl0cXVldWVfMSA9IHJlcXVpcmUoXCJhd2FpdHF1ZXVlXCIpO1xuY29uc3QgcXVldWVfbWljcm90YXNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInF1ZXVlLW1pY3JvdGFza1wiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEgPSByZXF1aXJlKFwiLi9FbmhhbmNlZEV2ZW50RW1pdHRlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9vcnRjXCIpKTtcbmNvbnN0IFByb2R1Y2VyXzEgPSByZXF1aXJlKFwiLi9Qcm9kdWNlclwiKTtcbmNvbnN0IENvbnN1bWVyXzEgPSByZXF1aXJlKFwiLi9Db25zdW1lclwiKTtcbmNvbnN0IERhdGFQcm9kdWNlcl8xID0gcmVxdWlyZShcIi4vRGF0YVByb2R1Y2VyXCIpO1xuY29uc3QgRGF0YUNvbnN1bWVyXzEgPSByZXF1aXJlKFwiLi9EYXRhQ29uc3VtZXJcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdUcmFuc3BvcnQnKTtcbmNsYXNzIENvbnN1bWVyQ3JlYXRpb25UYXNrIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdW1lck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lck9wdGlvbnMgPSBjb25zdW1lck9wdGlvbnM7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoeyBkaXJlY3Rpb24sIGlkLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBhcHBEYXRhLCBoYW5kbGVyRmFjdG9yeSwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIGNhblByb2R1Y2VCeUtpbmQsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBUcmFuc3BvcnQgSUNFIGdhdGhlcmluZyBzdGF0ZS5cbiAgICAgICAgdGhpcy5faWNlR2F0aGVyaW5nU3RhdGUgPSAnbmV3JztcbiAgICAgICAgLy8gVHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9ICduZXcnO1xuICAgICAgICAvLyBNYXAgb2YgUHJvZHVjZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX3Byb2R1Y2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTWFwIG9mIENvbnN1bWVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9jb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcCBvZiBEYXRhUHJvZHVjZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX2RhdGFQcm9kdWNlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcCBvZiBEYXRhQ29uc3VtZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX2RhdGFDb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX3Byb2JhdG9yQ29uc3VtZXJDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEF3YWl0UXVldWUgaW5zdGFuY2UgdG8gbWFrZSBhc3luYyB0YXNrcyBoYXBwZW4gc2VxdWVudGlhbGx5LlxuICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlID0gbmV3IGF3YWl0cXVldWVfMS5Bd2FpdFF1ZXVlKCk7XG4gICAgICAgIC8vIENvbnN1bWVyIGNyZWF0aW9uIHRhc2tzIGF3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvbnN1bWVyVGFza3MgPSBbXTtcbiAgICAgICAgLy8gQ29uc3VtZXIgY3JlYXRpb24gaW4gcHJvZ3Jlc3MgZmxhZy5cbiAgICAgICAgdGhpcy5fY29uc3VtZXJDcmVhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgLy8gQ29uc3VtZXJzIHBlbmRpbmcgdG8gYmUgcGF1c2VkLlxuICAgICAgICB0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIENvbnN1bWVyIHBhdXNlIGluIHByb2dyZXNzIGZsYWcuXG4gICAgICAgIHRoaXMuX2NvbnN1bWVyUGF1c2VJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIC8vIENvbnN1bWVycyBwZW5kaW5nIHRvIGJlIHJlc3VtZWQuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIENvbnN1bWVyIHJlc3VtZSBpbiBwcm9ncmVzcyBmbGFnLlxuICAgICAgICB0aGlzLl9jb25zdW1lclJlc3VtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgLy8gQ29uc3VtZXJzIHBlbmRpbmcgdG8gYmUgY2xvc2VkLlxuICAgICAgICB0aGlzLl9wZW5kaW5nQ2xvc2VDb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIENvbnN1bWVyIGNsb3NlIGluIHByb2dyZXNzIGZsYWcuXG4gICAgICAgIHRoaXMuX2NvbnN1bWVyQ2xvc2VJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbaWQ6JXMsIGRpcmVjdGlvbjolc10nLCBpZCwgZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kID0gY2FuUHJvZHVjZUJ5S2luZDtcbiAgICAgICAgdGhpcy5fbWF4U2N0cE1lc3NhZ2VTaXplID0gc2N0cFBhcmFtZXRlcnNcbiAgICAgICAgICAgID8gc2N0cFBhcmFtZXRlcnMubWF4TWVzc2FnZVNpemVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgLy8gQ2xvbmUgYW5kIHNhbml0aXplIGFkZGl0aW9uYWxTZXR0aW5ncy5cbiAgICAgICAgYWRkaXRpb25hbFNldHRpbmdzID0gdXRpbHMuY2xvbmUoYWRkaXRpb25hbFNldHRpbmdzKSB8fCB7fTtcbiAgICAgICAgZGVsZXRlIGFkZGl0aW9uYWxTZXR0aW5ncy5pY2VTZXJ2ZXJzO1xuICAgICAgICBkZWxldGUgYWRkaXRpb25hbFNldHRpbmdzLmljZVRyYW5zcG9ydFBvbGljeTtcbiAgICAgICAgZGVsZXRlIGFkZGl0aW9uYWxTZXR0aW5ncy5idW5kbGVQb2xpY3k7XG4gICAgICAgIGRlbGV0ZSBhZGRpdGlvbmFsU2V0dGluZ3MucnRjcE11eFBvbGljeTtcbiAgICAgICAgZGVsZXRlIGFkZGl0aW9uYWxTZXR0aW5ncy5zZHBTZW1hbnRpY3M7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGVyRmFjdG9yeSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVyLnJ1bih7XG4gICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VTZXJ2ZXJzLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5LFxuICAgICAgICAgICAgYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGEgfHwge307XG4gICAgICAgIHRoaXMuaGFuZGxlSGFuZGxlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgaWQuXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFRyYW5zcG9ydCBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVEMgaGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElDRSBnYXRoZXJpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGljZUdhdGhlcmluZ1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWNlR2F0aGVyaW5nU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3Rpb24gc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgIH1cbiAgICBnZXQgb2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIFRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBTdG9wIHRoZSBBd2FpdFF1ZXVlLlxuICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlLnN0b3AoKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGhhbmRsZXIuXG4gICAgICAgIHRoaXMuX2hhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgLy8gQ2hhbmdlIGNvbm5lY3Rpb24gc3RhdGUgdG8gJ2Nsb3NlZCcgc2luY2UgdGhlIGhhbmRsZXIgbWF5IG5vdCBlbWl0XG4gICAgICAgIC8vICdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJyBldmVudC5cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgIC8vIENsb3NlIGFsbCBQcm9kdWNlcnMuXG4gICAgICAgIGZvciAoY29uc3QgcHJvZHVjZXIgb2YgdGhpcy5fcHJvZHVjZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBwcm9kdWNlci50cmFuc3BvcnRDbG9zZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9kdWNlcnMuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIENvbnN1bWVycy5cbiAgICAgICAgZm9yIChjb25zdCBjb25zdW1lciBvZiB0aGlzLl9jb25zdW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN1bWVyLnRyYW5zcG9ydENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnN1bWVycy5jbGVhcigpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgRGF0YVByb2R1Y2Vycy5cbiAgICAgICAgZm9yIChjb25zdCBkYXRhUHJvZHVjZXIgb2YgdGhpcy5fZGF0YVByb2R1Y2Vycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZGF0YVByb2R1Y2VyLnRyYW5zcG9ydENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGFQcm9kdWNlcnMuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIERhdGFDb25zdW1lcnMuXG4gICAgICAgIGZvciAoY29uc3QgZGF0YUNvbnN1bWVyIG9mIHRoaXMuX2RhdGFDb25zdW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGRhdGFDb25zdW1lci50cmFuc3BvcnRDbG9zZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhQ29uc3VtZXJzLmNsZWFyKCk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXNzb2NpYXRlZCBUcmFuc3BvcnQgKFJUQ1BlZXJDb25uZWN0aW9uKSBzdGF0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSVENTdGF0c1JlcG9ydH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRUcmFuc3BvcnRTdGF0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0IElDRSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3RhcnRJY2UoeyBpY2VQYXJhbWV0ZXJzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlUGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9oYW5kbGVyLnJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycyksICd0cmFuc3BvcnQucmVzdGFydEljZSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBJQ0Ugc2VydmVycy5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKHsgaWNlU2VydmVycywgfSA9IHt9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaWNlU2VydmVycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlU2VydmVycycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB0aGlzLl9oYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycyksICd0cmFuc3BvcnQudXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFByb2R1Y2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2R1Y2UoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCBzdG9wVHJhY2tzID0gdHJ1ZSwgZGlzYWJsZVRyYWNrT25QYXVzZSA9IHRydWUsIHplcm9SdHBPblBhdXNlID0gZmFsc2UsIGFwcERhdGEgPSB7fSwgfSA9IHt9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncHJvZHVjZSgpIFt0cmFjazolb10nLCB0cmFjayk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHRyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgYSBzZW5kaW5nIFRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kW3RyYWNrLmtpbmRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcihgY2Fubm90IHByb2R1Y2UgJHt0cmFjay5raW5kfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcigndHJhY2sgZW5kZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Nvbm5lY3QnKSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJjb25uZWN0XCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ3Byb2R1Y2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJwcm9kdWNlXCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcHBEYXRhICYmIHR5cGVvZiBhcHBEYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWYgZ2l2ZW4sIGFwcERhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnF1ZXVlIGNvbW1hbmQuXG4gICAgICAgIHJldHVybiAodGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWRFbmNvZGluZ3M7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdzICYmICFBcnJheS5pc0FycmF5KGVuY29kaW5ncykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuY29kaW5ncyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmdzID0gZW5jb2RpbmdzLm1hcCgoZW5jb2RpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEVuY29kaW5nID0geyBhY3RpdmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLmR0eCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcuZHR4ID0gZW5jb2RpbmcuZHR4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLm1heEJpdHJhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcubWF4RnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcuYWRhcHRpdmVQdGltZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcuYWRhcHRpdmVQdGltZSA9IGVuY29kaW5nLmFkYXB0aXZlUHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5wcmlvcml0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5wcmlvcml0eSA9IGVuY29kaW5nLnByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcubmV0d29ya1ByaW9yaXR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLm5ldHdvcmtQcmlvcml0eSA9IGVuY29kaW5nLm5ldHdvcmtQcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEVuY29kaW5nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBsb2NhbElkLCBydHBQYXJhbWV0ZXJzLCBydHBTZW5kZXIgfSA9IGF3YWl0IHRoaXMuX2hhbmRsZXIuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgZW5jb2RpbmdzOiBub3JtYWxpemVkRW5jb2RpbmdzLFxuICAgICAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgZmlsbCBydHBQYXJhbWV0ZXJzJ3MgbWlzc2luZyBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICBvcnRjLnZhbGlkYXRlUnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ3Byb2R1Y2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjZXIgPSBuZXcgUHJvZHVjZXJfMS5Qcm9kdWNlcih7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgICAgICBydHBTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBzdG9wVHJhY2tzLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlVHJhY2tPblBhdXNlLFxuICAgICAgICAgICAgICAgICAgICB6ZXJvUnRwT25QYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9kdWNlcnMuc2V0KHByb2R1Y2VyLmlkLCBwcm9kdWNlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9kdWNlcihwcm9kdWNlcik7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnbmV3cHJvZHVjZXInLCBwcm9kdWNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2R1Y2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5zdG9wU2VuZGluZyhsb2NhbElkKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAndHJhbnNwb3J0LnByb2R1Y2UoKScpXG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoIGlzIG5lZWRlZCB0byBzdG9wIHRoZSBnaXZlbiB0cmFjayBpZiB0aGUgY29tbWFuZCBhYm92ZVxuICAgICAgICAgICAgLy8gZmFpbGVkIGR1ZSB0byBjbG9zZWQgVHJhbnNwb3J0LlxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BUcmFja3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQ29uc3VtZXIgdG8gY29uc3VtZSBhIHJlbW90ZSBQcm9kdWNlci5cbiAgICAgKi9cbiAgICBhc3luYyBjb25zdW1lKHsgaWQsIHByb2R1Y2VySWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkLCBhcHBEYXRhID0ge30sIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdW1lKCknKTtcbiAgICAgICAgcnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGEgcmVjZWl2aW5nIFRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvZHVjZXJJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgcHJvZHVjZXJJZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtpbmQgIT09ICdhdWRpbycgJiYga2luZCAhPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBraW5kICcke2tpbmR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnY29ubmVjdCcpID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcImNvbm5lY3RcIiBsaXN0ZW5lciBzZXQgaW50byB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwcERhdGEgJiYgdHlwZW9mIGFwcERhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGV2aWNlIGNhbiBjb25zdW1lIGl0LlxuICAgICAgICBjb25zdCBjYW5Db25zdW1lID0gb3J0Yy5jYW5SZWNlaXZlKHJ0cFBhcmFtZXRlcnMsIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgaWYgKCFjYW5Db25zdW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignY2Fubm90IGNvbnN1bWUgdGhpcyBQcm9kdWNlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnN1bWVyQ3JlYXRpb25UYXNrID0gbmV3IENvbnN1bWVyQ3JlYXRpb25UYXNrKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcHJvZHVjZXJJZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBhcHBEYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIENvbnN1bWVyIGNyZWF0aW9uIHRhc2suXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzLnB1c2goY29uc3VtZXJDcmVhdGlvblRhc2spO1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBDb25zdW1lciBjcmVhdGlvbiBpbiBwcm9ncmVzcywgY3JlYXRlIGl0IG5vdy5cbiAgICAgICAgKDAsIHF1ZXVlX21pY3JvdGFza18xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZXJDcmVhdGlvbkluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29uc3VtZXJDcmVhdGlvblRhc2sucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRGF0YVByb2R1Y2VyXG4gICAgICovXG4gICAgYXN5bmMgcHJvZHVjZURhdGEoeyBvcmRlcmVkID0gdHJ1ZSwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCA9ICcnLCBwcm90b2NvbCA9ICcnLCBhcHBEYXRhID0ge30sIH0gPSB7fSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Byb2R1Y2VEYXRhKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHNlbmRpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX21heFNjdHBNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ1NDVFAgbm90IGVuYWJsZWQgYnkgcmVtb3RlIFRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnY29ubmVjdCcpID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcImNvbm5lY3RcIiBsaXN0ZW5lciBzZXQgaW50byB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgncHJvZHVjZWRhdGEnKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJwcm9kdWNlZGF0YVwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lmIGdpdmVuLCBhcHBEYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFBhY2tldExpZmVUaW1lIHx8IG1heFJldHJhbnNtaXRzKSB7XG4gICAgICAgICAgICBvcmRlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH0gPSBhd2FpdCB0aGlzLl9oYW5kbGVyLnNlbmREYXRhQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgc2N0cFN0cmVhbVBhcmFtZXRlcnMncyBtaXNzaW5nIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdwcm9kdWNlZGF0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2N0cFN0cmVhbVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgICAgICB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhUHJvZHVjZXIgPSBuZXcgRGF0YVByb2R1Y2VyXzEuRGF0YVByb2R1Y2VyKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhcHBEYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLnNldChkYXRhUHJvZHVjZXIuaWQsIGRhdGFQcm9kdWNlcik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFQcm9kdWNlcihkYXRhUHJvZHVjZXIpO1xuICAgICAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCduZXdkYXRhcHJvZHVjZXInLCBkYXRhUHJvZHVjZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQcm9kdWNlcjtcbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5wcm9kdWNlRGF0YSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERhdGFDb25zdW1lclxuICAgICAqL1xuICAgIGFzeW5jIGNvbnN1bWVEYXRhKHsgaWQsIGRhdGFQcm9kdWNlcklkLCBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwgPSAnJywgcHJvdG9jb2wgPSAnJywgYXBwRGF0YSA9IHt9LCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3VtZURhdGEoKScpO1xuICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHJlY2VpdmluZyBUcmFuc3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fbWF4U2N0cE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignU0NUUCBub3QgZW5hYmxlZCBieSByZW1vdGUgVHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhUHJvZHVjZXJJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZGF0YVByb2R1Y2VySWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Nvbm5lY3QnKSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJjb25uZWN0XCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcHBEYXRhICYmIHR5cGVvZiBhcHBEYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWYgZ2l2ZW4sIGFwcERhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YUNoYW5uZWwgfSA9IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZURhdGFDaGFubmVsKHtcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YUNvbnN1bWVyID0gbmV3IERhdGFDb25zdW1lcl8xLkRhdGFDb25zdW1lcih7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZGF0YVByb2R1Y2VySWQsXG4gICAgICAgICAgICAgICAgZGF0YUNoYW5uZWwsXG4gICAgICAgICAgICAgICAgc2N0cFN0cmVhbVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNvbnN1bWVycy5zZXQoZGF0YUNvbnN1bWVyLmlkLCBkYXRhQ29uc3VtZXIpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ29uc3VtZXIoZGF0YUNvbnN1bWVyKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnbmV3ZGF0YWNvbnN1bWVyJywgZGF0YUNvbnN1bWVyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhQ29uc3VtZXI7XG4gICAgICAgIH0sICd0cmFuc3BvcnQuY29uc3VtZURhdGEoKScpO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBndWFyYW50ZWVkIHRvIG5ldmVyIHRocm93LlxuICAgIGFzeW5jIGNyZWF0ZVBlbmRpbmdDb25zdW1lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVyQ3JlYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlUGVuZGluZ0NvbnN1bWVycygpIHwgdGhlcmUgaXMgbm8gQ29uc3VtZXIgdG8gYmUgY3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdDb25zdW1lclRhc2tzID0gWy4uLnRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzXTtcbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgQ29uc3VtZXIgdGFza3MuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ29uc3VtZXJUYXNrcyA9IFtdO1xuICAgICAgICAgICAgLy8gVmlkZW8gQ29uc3VtZXIgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBwcm9iYXRvci5cbiAgICAgICAgICAgIGxldCB2aWRlb0NvbnN1bWVyRm9yUHJvYmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBGaWxsIG9wdGlvbnMgbGlzdC5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgcGVuZGluZ0NvbnN1bWVyVGFza3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gdGFzay5jb25zdW1lck9wdGlvbnM7XG4gICAgICAgICAgICAgICAgb3B0aW9uc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZShvcHRpb25zTGlzdCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmVzdWx0cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBwZW5kaW5nQ29uc3VtZXJUYXNrc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHByb2R1Y2VySWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIGFwcERhdGEgfSA9IHRhc2suY29uc3VtZXJPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxvY2FsSWQsIHJ0cFJlY2VpdmVyLCB0cmFjayB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdW1lciA9IG5ldyBDb25zdW1lcl8xLkNvbnN1bWVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWNlcklkOiBwcm9kdWNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBEYXRhOiBhcHBEYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJzLnNldChjb25zdW1lci5pZCwgY29uc3VtZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNvbnN1bWVyKGNvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdmlkZW8gQ29uc3VtZXIgYW5kIHRoZSBDb25zdW1lciBmb3IgUlRQIHByb2JhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbm90IHlldCBiZWVuIGNyZWF0ZWQsIGl0J3MgdGltZSB0byBjcmVhdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvYmF0b3JDb25zdW1lckNyZWF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF2aWRlb0NvbnN1bWVyRm9yUHJvYmF0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvQ29uc3VtZXJGb3JQcm9iYXRvciA9IGNvbnN1bWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCduZXdjb25zdW1lcicsIGNvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKGNvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgcGVuZGluZ0NvbnN1bWVyVGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIFJUUCBwcm9iYXRpb24gbXVzdCBiZSBoYW5kbGVkLCBkbyBpdCBub3cuXG4gICAgICAgICAgICBpZiAodmlkZW9Db25zdW1lckZvclByb2JhdG9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvYmF0b3JSdHBQYXJhbWV0ZXJzID0gb3J0Yy5nZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyh2aWRlb0NvbnN1bWVyRm9yUHJvYmF0b3IucnRwUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZShbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tJZDogJ3Byb2JhdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHByb2JhdG9yUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NyZWF0ZVBlbmRpbmdDb25zdW1lcnMoKSB8IENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uIGNyZWF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvYmF0b3JDb25zdW1lckNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdjcmVhdGVQZW5kaW5nQ29uc3VtZXJzKCkgfCBmYWlsZWQgdG8gY3JlYXRlIENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uOiVvJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5jcmVhdGVQZW5kaW5nQ29uc3VtZXJzKCknKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJDcmVhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwZW5kaW5nIENvbnN1bWVyIHRhc2tzLCBlbnF1ZXVlIHRoZWlyIGNyZWF0aW9uLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb25zdW1lclRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVBlbmRpbmdDb25zdW1lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIE5PVEU6IFdlIG9ubHkgZ2V0IGhlcmUgd2hlbiB0aGUgYXdhaXQgcXVldWUgaXMgY2xvc2VkLlxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgfVxuICAgIHBhdXNlUGVuZGluZ0NvbnN1bWVycygpIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZXJQYXVzZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlXG4gICAgICAgICAgICAucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1BhdXNlQ29uc3VtZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUGVuZGluZ0NvbnN1bWVycygpIHwgdGhlcmUgaXMgbm8gQ29uc3VtZXIgdG8gYmUgcGF1c2VkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGVuZGluZ1BhdXNlQ29uc3VtZXJzID0gQXJyYXkuZnJvbSh0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMudmFsdWVzKCkpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgcGVuZGluZyBwYXVzZSBDb25zdW1lciBtYXAuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxJZHMgPSBwZW5kaW5nUGF1c2VDb25zdW1lcnMubWFwKGNvbnN1bWVyID0+IGNvbnN1bWVyLmxvY2FsSWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZXIucGF1c2VSZWNlaXZpbmcobG9jYWxJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdwYXVzZVBlbmRpbmdDb25zdW1lcnMoKSB8IGZhaWxlZCB0byBwYXVzZSBDb25zdW1lcnM6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAndHJhbnNwb3J0LnBhdXNlUGVuZGluZ0NvbnN1bWVycycpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lclBhdXNlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHBlbmRpbmcgQ29uc3VtZXJzIHRvIGJlIHBhdXNlZCwgZG8gaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1BhdXNlQ29uc3VtZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZVBlbmRpbmdDb25zdW1lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIE5PVEU6IFdlIG9ubHkgZ2V0IGhlcmUgd2hlbiB0aGUgYXdhaXQgcXVldWUgaXMgY2xvc2VkLlxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgfVxuICAgIHJlc3VtZVBlbmRpbmdDb25zdW1lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVyUmVzdW1lSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2F3YWl0UXVldWVcbiAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzdW1lQ29uc3VtZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVBlbmRpbmdDb25zdW1lcnMoKSB8IHRoZXJlIGlzIG5vIENvbnN1bWVyIHRvIGJlIHJlc3VtZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nUmVzdW1lQ29uc3VtZXJzID0gQXJyYXkuZnJvbSh0aGlzLl9wZW5kaW5nUmVzdW1lQ29uc3VtZXJzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgcmVzdW1lIENvbnN1bWVyIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxJZHMgPSBwZW5kaW5nUmVzdW1lQ29uc3VtZXJzLm1hcChjb25zdW1lciA9PiBjb25zdW1lci5sb2NhbElkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVyLnJlc3VtZVJlY2VpdmluZyhsb2NhbElkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3Jlc3VtZVBlbmRpbmdDb25zdW1lcnMoKSB8IGZhaWxlZCB0byByZXN1bWUgQ29uc3VtZXJzOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5yZXN1bWVQZW5kaW5nQ29uc3VtZXJzJylcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVyUmVzdW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHBlbmRpbmcgQ29uc3VtZXIgdG8gYmUgcmVzdW1lZCwgZG8gaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1Jlc3VtZUNvbnN1bWVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lUGVuZGluZ0NvbnN1bWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gTk9URTogV2Ugb25seSBnZXQgaGVyZSB3aGVuIHRoZSBhd2FpdCBxdWV1ZSBpcyBjbG9zZWQuXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICB9XG4gICAgY2xvc2VQZW5kaW5nQ29uc3VtZXJzKCkge1xuICAgICAgICB0aGlzLl9jb25zdW1lckNsb3NlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2F3YWl0UXVldWVcbiAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQ2xvc2VDb25zdW1lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2VQZW5kaW5nQ29uc3VtZXJzKCkgfCB0aGVyZSBpcyBubyBDb25zdW1lciB0byBiZSBjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nQ2xvc2VDb25zdW1lcnMgPSBBcnJheS5mcm9tKHRoaXMuX3BlbmRpbmdDbG9zZUNvbnN1bWVycy52YWx1ZXMoKSk7XG4gICAgICAgICAgICAvLyBDbGVhciBwZW5kaW5nIGNsb3NlIENvbnN1bWVyIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDbG9zZUNvbnN1bWVycy5jbGVhcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVyLnN0b3BSZWNlaXZpbmcocGVuZGluZ0Nsb3NlQ29uc3VtZXJzLm1hcChjb25zdW1lciA9PiBjb25zdW1lci5sb2NhbElkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2Nsb3NlUGVuZGluZ0NvbnN1bWVycygpIHwgZmFpbGVkIHRvIGNsb3NlIENvbnN1bWVyczonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICd0cmFuc3BvcnQuY2xvc2VQZW5kaW5nQ29uc3VtZXJzJylcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVyQ2xvc2VJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcGVuZGluZyBDb25zdW1lciB0byBiZSByZXN1bWVkLCBkbyBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQ2xvc2VDb25zdW1lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUGVuZGluZ0NvbnN1bWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gTk9URTogV2Ugb25seSBnZXQgaGVyZSB3aGVuIHRoZSBhd2FpdCBxdWV1ZSBpcyBjbG9zZWQuXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICB9XG4gICAgaGFuZGxlSGFuZGxlcigpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIub24oJ0Bjb25uZWN0JywgKHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJiYWNrKG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ2Nvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIub24oJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIChpY2VHYXRoZXJpbmdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGljZUdhdGhlcmluZ1N0YXRlID09PSB0aGlzLl9pY2VHYXRoZXJpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnSUNFIGdhdGhlcmluZyBzdGF0ZSBjaGFuZ2VkIHRvICVzJywgaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5faWNlR2F0aGVyaW5nU3RhdGUgPSBpY2VHYXRoZXJpbmdTdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCBpY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVyLm9uKCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gdGhpcy5fY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQgdG8gJXMnLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gY29ubmVjdGlvblN0YXRlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUHJvZHVjZXIocHJvZHVjZXIpIHtcbiAgICAgICAgcHJvZHVjZXIub24oJ0BjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2R1Y2Vycy5kZWxldGUocHJvZHVjZXIuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2F3YWl0UXVldWVcbiAgICAgICAgICAgICAgICAucHVzaChhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9oYW5kbGVyLnN0b3BTZW5kaW5nKHByb2R1Y2VyLmxvY2FsSWQpLCAncHJvZHVjZXIgQGNsb3NlIGV2ZW50JylcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBsb2dnZXIud2FybigncHJvZHVjZXIuY2xvc2UoKSBmYWlsZWQ6JW8nLCBlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvZHVjZXIub24oJ0BwYXVzZScsIChjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX2hhbmRsZXIucGF1c2VTZW5kaW5nKHByb2R1Y2VyLmxvY2FsSWQpLCAncHJvZHVjZXIgQHBhdXNlIGV2ZW50JylcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQHJlc3VtZScsIChjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVzdW1lU2VuZGluZyhwcm9kdWNlci5sb2NhbElkKSwgJ3Byb2R1Y2VyIEByZXN1bWUgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAcmVwbGFjZXRyYWNrJywgKHRyYWNrLCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVwbGFjZVRyYWNrKHByb2R1Y2VyLmxvY2FsSWQsIHRyYWNrKSwgJ3Byb2R1Y2VyIEByZXBsYWNldHJhY2sgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAc2V0bWF4c3BhdGlhbGxheWVyJywgKHNwYXRpYWxMYXllciwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2F3YWl0UXVldWVcbiAgICAgICAgICAgICAgICAucHVzaChhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9oYW5kbGVyLnNldE1heFNwYXRpYWxMYXllcihwcm9kdWNlci5sb2NhbElkLCBzcGF0aWFsTGF5ZXIpLCAncHJvZHVjZXIgQHNldG1heHNwYXRpYWxsYXllciBldmVudCcpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvZHVjZXIub24oJ0BzZXRydHBlbmNvZGluZ3BhcmFtZXRlcnMnLCAocGFyYW1zLCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZVxuICAgICAgICAgICAgICAgIC5wdXNoKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX2hhbmRsZXIuc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKHByb2R1Y2VyLmxvY2FsSWQsIHBhcmFtcyksICdwcm9kdWNlciBAc2V0cnRwZW5jb2RpbmdwYXJhbWV0ZXJzIGV2ZW50JylcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQGdldHN0YXRzJywgKGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycmJhY2sobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyXG4gICAgICAgICAgICAgICAgLmdldFNlbmRlclN0YXRzKHByb2R1Y2VyLmxvY2FsSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ29uc3VtZXIoY29uc3VtZXIpIHtcbiAgICAgICAgY29uc3VtZXIub24oJ0BjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVycy5kZWxldGUoY29uc3VtZXIuaWQpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1BhdXNlQ29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzdW1lQ29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIENvbnN1bWVyIGludG8gdGhlIGNsb3NlIGxpc3QuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2xvc2VDb25zdW1lcnMuc2V0KGNvbnN1bWVyLmlkLCBjb25zdW1lcik7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBDb25zdW1lciBjbG9zZSBpbiBwcm9ncmVzcywgZG8gaXQgbm93LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN1bWVyQ2xvc2VJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lci5vbignQHBhdXNlJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgQ29uc3VtZXIgaXMgcGVuZGluZyB0byBiZSByZXN1bWVkLCByZW1vdmUgZnJvbSBwZW5kaW5nIHJlc3VtZSBsaXN0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMuaGFzKGNvbnN1bWVyLmlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXN1bWVDb25zdW1lcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBDb25zdW1lciBpbnRvIHRoZSBwZW5kaW5nIGxpc3QuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUGF1c2VDb25zdW1lcnMuc2V0KGNvbnN1bWVyLmlkLCBjb25zdW1lcik7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBDb25zdW1lciBwYXVzZSBpbiBwcm9ncmVzcywgZG8gaXQgbm93LlxuICAgICAgICAgICAgKDAsIHF1ZXVlX21pY3JvdGFza18xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN1bWVyUGF1c2VJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlUGVuZGluZ0NvbnN1bWVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZXIub24oJ0ByZXN1bWUnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBDb25zdW1lciBpcyBwZW5kaW5nIHRvIGJlIHBhdXNlZCwgcmVtb3ZlIGZyb20gcGVuZGluZyBwYXVzZSBsaXN0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdQYXVzZUNvbnN1bWVycy5oYXMoY29uc3VtZXIuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1BhdXNlQ29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgQ29uc3VtZXIgaW50byB0aGUgcGVuZGluZyBsaXN0LlxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc3VtZUNvbnN1bWVycy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVyKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIENvbnN1bWVyIHJlc3VtZSBpbiBwcm9ncmVzcywgZG8gaXQgbm93LlxuICAgICAgICAgICAgKDAsIHF1ZXVlX21pY3JvdGFza18xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN1bWVyUmVzdW1lSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWVQZW5kaW5nQ29uc3VtZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lci5vbignQGdldHN0YXRzJywgKGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycmJhY2sobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyXG4gICAgICAgICAgICAgICAgLmdldFJlY2VpdmVyU3RhdHMoY29uc3VtZXIubG9jYWxJZClcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhUHJvZHVjZXIoZGF0YVByb2R1Y2VyKSB7XG4gICAgICAgIGRhdGFQcm9kdWNlci5vbignQGNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YVByb2R1Y2Vycy5kZWxldGUoZGF0YVByb2R1Y2VyLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZURhdGFDb25zdW1lcihkYXRhQ29uc3VtZXIpIHtcbiAgICAgICAgZGF0YUNvbnN1bWVyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhQ29uc3VtZXJzLmRlbGV0ZShkYXRhQ29uc3VtZXIuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Transport.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidStateError = exports.UnsupportedError = void 0;\n/**\n * Error indicating not support for something.\n */\nclass UnsupportedError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'UnsupportedError';\n        if (Error.hasOwnProperty('captureStackTrace')) {\n            // Just in V8.\n            // @ts-ignore\n            Error.captureStackTrace(this, UnsupportedError);\n        }\n        else {\n            this.stack = new Error(message).stack;\n        }\n    }\n}\nexports.UnsupportedError = UnsupportedError;\n/**\n * Error produced when calling a method in an invalid state.\n */\nclass InvalidStateError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InvalidStateError';\n        if (Error.hasOwnProperty('captureStackTrace')) {\n            // Just in V8.\n            // @ts-ignore\n            Error.captureStackTrace(this, InvalidStateError);\n        }\n        else {\n            this.stack = new Error(message).stack;\n        }\n    }\n}\nexports.InvalidStateError = InvalidStateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyx3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9lcnJvcnMuanM/OGFlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFN0YXRlRXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkRXJyb3IgPSB2b2lkIDA7XG4vKipcbiAqIEVycm9yIGluZGljYXRpbmcgbm90IHN1cHBvcnQgZm9yIHNvbWV0aGluZy5cbiAqL1xuY2xhc3MgVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdXBwb3J0ZWRFcnJvcic7XG4gICAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgICAgICAgLy8gSnVzdCBpbiBWOC5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFVuc3VwcG9ydGVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRFcnJvciA9IFVuc3VwcG9ydGVkRXJyb3I7XG4vKipcbiAqIEVycm9yIHByb2R1Y2VkIHdoZW4gY2FsbGluZyBhIG1ldGhvZCBpbiBhbiBpbnZhbGlkIHN0YXRlLlxuICovXG5jbGFzcyBJbnZhbGlkU3RhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuICAgICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgaW4gVjguXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkU3RhdGVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU3RhdGVFcnJvciA9IEludmFsaWRTdGF0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome111.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome111.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chrome111 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\"));\nconst ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js\"));\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Chrome111');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome111 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome111();\n    }\n    constructor() {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Chrome111';\n    }\n    close() {\n        logger.debug('close()');\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            // libwebrtc supports NACK for OPUS but doesn't announce it.\n            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        this.assertNotClosed();\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        this.assertNotClosed();\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        this.assertNotClosed();\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        this.assertNotClosed();\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings && encodings.length > 1) {\n            encodings.forEach((encoding, idx) => {\n                encoding.rid = `r${idx}`;\n            });\n            // Set rid and verify scalabilityMode in each encoding.\n            // NOTE: Even if WebRTC allows different scalabilityMode (different number\n            // of temporal layers) per simulcast stream, we need that those are the\n            // same in all them, so let's pick up the highest value.\n            // NOTE: If scalabilityMode is not given, Chrome will use L1T3.\n            let nextRid = 1;\n            let maxTemporalLayers = 1;\n            for (const encoding of encodings) {\n                const temporalLayers = encoding.scalabilityMode\n                    ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers\n                    : 3;\n                if (temporalLayers > maxTemporalLayers) {\n                    maxTemporalLayers = temporalLayers;\n                }\n            }\n            for (const encoding of encodings) {\n                encoding.rid = `r${nextRid++}`;\n                encoding.scalabilityMode = `L1T${maxTemporalLayers}`;\n            }\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n            sendEncodings: encodings,\n        });\n        const offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n            Object.assign(newEncodings[0], encodings[0]);\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim.\n        else {\n            sendingRtpParameters.encodings = encodings;\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        if (this._closed) {\n            return;\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);\n        if (mediaSectionClosed) {\n            try {\n                transceiver.stop();\n            }\n            catch (error) { }\n        }\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    async pauseSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('pauseSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'inactive';\n        this._remoteSdp.pauseMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async resumeSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('resumeSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        this._remoteSdp.resumeSendingMediaSection(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'sendonly';\n        const offer = await this._pc.createOffer();\n        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            else {\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n                results.push({\n                    localId,\n                    track: transceiver.receiver.track,\n                    rtpReceiver: transceiver.receiver,\n                });\n            }\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        if (this._closed) {\n            return;\n        }\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('pauseReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'inactive';\n            this._remoteSdp.pauseMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async resumeReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('resumeReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'recvonly';\n            this._remoteSdp.resumeReceivingMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertNotClosed() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('method called in a closed handler');\n        }\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome111 = Chrome111;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTExMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtDQUFrQyxtQkFBTyxDQUFDLHFIQUFlO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLHVIQUFXO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLHFIQUFVO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFTO0FBQzNDLG9DQUFvQyxtQkFBTyxDQUFDLGlKQUFtQjtBQUMvRCx5Q0FBeUMsbUJBQU8sQ0FBQywySkFBd0I7QUFDekUsK0JBQStCLG1CQUFPLENBQUMsdUlBQWM7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMsbUpBQW9CO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLDZJQUFpQjtBQUM3QywyQkFBMkIsbUJBQU8sQ0FBQywySUFBcUI7QUFDeEQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrS0FBK0s7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QyxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBOEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTExMS5qcz83NmEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNocm9tZTExMSA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKSk7XG5jb25zdCBvcnRjVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Yy91dGlsc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3Qgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4uL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdDaHJvbWUxMTEnKTtcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIENocm9tZTExMSBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWUxMTEoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWUxMTEnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbGlid2VicnRjIHN1cHBvcnRzIE5BQ0sgZm9yIE9QVVMgYnV0IGRvZXNuJ3QgYW5ub3VuY2UgaXQuXG4gICAgICAgICAgICBvcnRjVXRpbHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdydW4oKSB8IHBjLmNvbm5lY3Rpb25TdGF0ZSBub3Qgc3VwcG9ydGVkLCB1c2luZyBwYy5pY2VDb25uZWN0aW9uU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5yaWQgPSBgciR7aWR4fWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNldCByaWQgYW5kIHZlcmlmeSBzY2FsYWJpbGl0eU1vZGUgaW4gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgICAgIC8vIE5PVEU6IEV2ZW4gaWYgV2ViUlRDIGFsbG93cyBkaWZmZXJlbnQgc2NhbGFiaWxpdHlNb2RlIChkaWZmZXJlbnQgbnVtYmVyXG4gICAgICAgICAgICAvLyBvZiB0ZW1wb3JhbCBsYXllcnMpIHBlciBzaW11bGNhc3Qgc3RyZWFtLCB3ZSBuZWVkIHRoYXQgdGhvc2UgYXJlIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBpbiBhbGwgdGhlbSwgc28gbGV0J3MgcGljayB1cCB0aGUgaGlnaGVzdCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHNjYWxhYmlsaXR5TW9kZSBpcyBub3QgZ2l2ZW4sIENocm9tZSB3aWxsIHVzZSBMMVQzLlxuICAgICAgICAgICAgbGV0IG5leHRSaWQgPSAxO1xuICAgICAgICAgICAgbGV0IG1heFRlbXBvcmFsTGF5ZXJzID0gMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcG9yYWxMYXllcnMgPSBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlKShlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpLnRlbXBvcmFsTGF5ZXJzXG4gICAgICAgICAgICAgICAgICAgIDogMztcbiAgICAgICAgICAgICAgICBpZiAodGVtcG9yYWxMYXllcnMgPiBtYXhUZW1wb3JhbExheWVycykge1xuICAgICAgICAgICAgICAgICAgICBtYXhUZW1wb3JhbExheWVycyA9IHRlbXBvcmFsTGF5ZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucmlkID0gYHIke25leHRSaWQrK31gO1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGBMMVQke21heFRlbXBvcmFsTGF5ZXJzfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwLmdldE5leHRNZWRpYVNlY3Rpb25JZHgoKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknLFxuICAgICAgICAgICAgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dLFxuICAgICAgICAgICAgc2VuZEVuY29kaW5nczogZW5jb2RpbmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VuY29kaW5nc1swXSwgZW5jb2RpbmdzWzBdKTtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25DbG9zZWQgPSB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgaWYgKG1lZGlhU2VjdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVzdW1lU2VuZGluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IG1hcExvY2FsSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkIHx8IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgICAgIG1hcExvY2FsSWQuc2V0KHRyYWNrSWQsIGxvY2FsSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQgfHwgcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBydHBSZWNlaXZlcjogdHJhbnNjZWl2ZXIucmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydE5vdENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdtZXRob2QgY2FsbGVkIGluIGEgY2xvc2VkIGhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lMTExID0gQ2hyb21lMTExO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome111.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome55.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome55.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chrome55 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Chrome55');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome55 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome55();\n    }\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of sending MediaStreamTracks indexed by localId.\n        this._mapSendLocalIdTrack = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Chrome55';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addStream(this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n            offerMediaObject,\n            track,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'L1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Insert into the map.\n        this._mapSendLocalIdTrack.set(localId, track);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const track = this._mapSendLocalIdTrack.get(localId);\n        if (!track) {\n            throw new Error('track not found');\n        }\n        this._mapSendLocalIdTrack.delete(localId);\n        this._sendStream.removeTrack(track);\n        this._pc.addStream(this._sendStream);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable') {\n            return;\n        }\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    track) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async setMaxSpatialLayer(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    spatialLayer) {\n        throw new errors_1.UnsupportedError(' not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setRtpEncodingParameters(localId, params) {\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getSenderStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertRecvDirection();\n        const results = [];\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const mid = kind;\n            this._remoteSdp.receive({\n                mid,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { kind, rtpParameters } = options;\n            const mid = kind;\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { kind, trackId, rtpParameters } = options;\n            const mid = kind;\n            const localId = trackId;\n            const streamId = options.streamId || rtpParameters.rtcp.cname;\n            const stream = this._pc\n                .getRemoteStreams()\n                .find((s) => s.id === streamId);\n            const track = stream.getTrackById(localId);\n            if (!track) {\n                throw new Error('remote track not found');\n            }\n            // Insert into the map.\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\n            results.push({ localId, track });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n            // Remove from the map.\n            this._mapRecvLocalIdInfo.delete(localId);\n            this._remoteSdp.planBStopReceiving({\n                mid: mid,\n                offerRtpParameters: rtpParameters,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getReceiverStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome55 = Chrome55;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTU1LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELG1DQUFtQyxtQkFBTyxDQUFDLCtJQUFrQjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtLQUErSztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUE4RDtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFO0FBQ0EsZ0JBQWdCLHVEQUF1RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTU1LmpzPzMzZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hyb21lNTUgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3BsYW5CVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTU1Jyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU1NSBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU1NSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIE1hcCBvZiBzZW5kaW5nIE1lZGlhU3RyZWFtVHJhY2tzIGluZGV4ZWQgYnkgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjayA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBzZW5kaW5nIGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIE1hcCBvZiBNSUQsIFJUUCBwYXJhbWV0ZXJzIGFuZCBSVENSdHBSZWNlaXZlciBpbmRleGVkIGJ5IGxvY2FsIGlkLlxuICAgICAgICAvLyBWYWx1ZSBpcyBhbiBPYmplY3Qgd2l0aCBtaWQsIHJ0cFBhcmFtZXRlcnMgYW5kIHJ0cFJlY2VpdmVyLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0Nocm9tZTU1JztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IGNvZGVjIHNlbGVjdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluICVzIGhhbmRsZXInLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycgJiYgZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICd2aWRlbycpO1xuICAgICAgICAgICAgc2RwUGxhbkJVdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID0gc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvIGVhY2hcbiAgICAgICAgLy8gZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gU3RyaW5nKHRoaXMuX25leHRTZW5kTG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCsrO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrLnNldChsb2NhbElkLCB0cmFjayk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkOiBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjayBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuICAgICAgICAgICAgLy8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2VuZFN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFNlbmRpbmcoKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdHJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWQsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsIC8vIE5PVEU6IE9sZCBzcGVjLlxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQgfHwgcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBraW5kLCB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBvcHRpb25zLnN0cmVhbUlkIHx8IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3BjXG4gICAgICAgICAgICAgICAgLmdldFJlbW90ZVN0cmVhbXMoKVxuICAgICAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLmlkID09PSBzdHJlYW1JZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFjayA9IHN0cmVhbS5nZXRUcmFja0J5SWQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdGUgdHJhY2sgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLnNldChsb2NhbElkLCB7IG1pZCwgcnRwUGFyYW1ldGVycyB9KTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IGxvY2FsSWQsIHRyYWNrIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoe1xuICAgICAgICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsIC8vIE5PVEU6IE9sZCBzcGVjLlxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKHsgb2xkRGF0YUNoYW5uZWxTcGVjOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0LCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNTUgPSBDaHJvbWU1NTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome55.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome67.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome67.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chrome67 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Chrome67');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome67 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome67();\n    }\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of RTCRtpSender indexed by localId.\n        this._mapSendLocalIdRtpSender = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Chrome67';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addTrack(track, this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n            offerMediaObject,\n            track,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'L1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        const rtpSender = this._pc\n            .getSenders()\n            .find((s) => s.track === track);\n        // Insert into the map.\n        this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        this._pc.removeTrack(rtpSender);\n        if (rtpSender.track) {\n            this._sendStream.removeTrack(rtpSender.track);\n        }\n        this._mapSendLocalIdRtpSender.delete(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable') {\n            return;\n        }\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(localId, track) {\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        const oldTrack = rtpSender.track;\n        await rtpSender.replaceTrack(track);\n        // Remove the old track from the local stream.\n        if (oldTrack) {\n            this._sendStream.removeTrack(oldTrack);\n        }\n        // Add the new track to the local stream.\n        if (track) {\n            this._sendStream.addTrack(track);\n        }\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this.assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        return rtpSender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertRecvDirection();\n        const results = [];\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const mid = kind;\n            this._remoteSdp.receive({\n                mid,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { kind, rtpParameters } = options;\n            const mid = kind;\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { kind, trackId, rtpParameters } = options;\n            const localId = trackId;\n            const mid = kind;\n            const rtpReceiver = this._pc\n                .getReceivers()\n                .find((r) => r.track && r.track.id === localId);\n            if (!rtpReceiver) {\n                throw new Error('new RTCRtpReceiver not');\n            }\n            // Insert into the map.\n            this._mapRecvLocalIdInfo.set(localId, {\n                mid,\n                rtpParameters,\n                rtpReceiver,\n            });\n            results.push({\n                localId,\n                track: rtpReceiver.track,\n                rtpReceiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n            // Remove from the map.\n            this._mapRecvLocalIdInfo.delete(localId);\n            this._remoteSdp.planBStopReceiving({\n                mid: mid,\n                offerRtpParameters: rtpParameters,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async getReceiverStats(localId) {\n        this.assertRecvDirection();\n        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\n        if (!rtpReceiver) {\n            throw new Error('associated RTCRtpReceiver not found');\n        }\n        return rtpReceiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome67 = Chrome67;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTY3LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELG1DQUFtQyxtQkFBTyxDQUFDLCtJQUFrQjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtLQUErSztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQThEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEUsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFO0FBQ0EsZ0JBQWdCLHVEQUF1RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTY3LmpzP2U3NzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hyb21lNjcgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3BsYW5CVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTY3Jyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU2NyBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU2NygpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIE1hcCBvZiBSVENSdHBTZW5kZXIgaW5kZXhlZCBieSBsb2NhbElkLlxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBzZW5kaW5nIGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIE1hcCBvZiBNSUQsIFJUUCBwYXJhbWV0ZXJzIGFuZCBSVENSdHBSZWNlaXZlciBpbmRleGVkIGJ5IGxvY2FsIGlkLlxuICAgICAgICAvLyBWYWx1ZSBpcyBhbiBPYmplY3Qgd2l0aCBtaWQsIHJ0cFBhcmFtZXRlcnMgYW5kIHJ0cFJlY2VpdmVyLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0Nocm9tZTY3JztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IGNvZGVjIHNlbGVjdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluICVzIGhhbmRsZXInLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRUcmFjayh0cmFjaywgdGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycgJiYgZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICd2aWRlbycpO1xuICAgICAgICAgICAgc2RwUGxhbkJVdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID0gc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvIGVhY2hcbiAgICAgICAgLy8gZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gU3RyaW5nKHRoaXMuX25leHRTZW5kTG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCsrO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgLmdldFNlbmRlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHMpID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuc2V0KGxvY2FsSWQsIHJ0cFNlbmRlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkOiBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpO1xuICAgICAgICBpZiAocnRwU2VuZGVyLnRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbW92ZVRyYWNrKHJ0cFNlbmRlci50cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHRoZXJlIGFyZSBubyBzZW5kaW5nIHRyYWNrcywgc2V0TG9jYWxEZXNjcmlwdGlvbigpIHdpbGwgZmFpbCB3aXRoXG4gICAgICAgICAgICAvLyBcIkZhaWxlZCB0byBjcmVhdGUgY2hhbm5lbHNcIi4gSWYgc28sIGlnbm9yZSBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZW5kU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzdG9wU2VuZGluZygpIHwgaWdub3JpbmcgZXhwZWN0ZWQgZXJyb3IgZHVlIG5vIHNlbmRpbmcgdHJhY2tzOiAlcycsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRUcmFjayA9IHJ0cFNlbmRlci50cmFjaztcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cbiAgICAgICAgaWYgKG9sZFRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbW92ZVRyYWNrKG9sZFRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBydHBTZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ0cFNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsIC8vIE5PVEU6IE9sZCBzcGVjLlxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQgfHwgcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBraW5kLCB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRSZWNlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKChyKSA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCFydHBSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFJlY2VpdmVyIG5vdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5zZXQobG9jYWxJZCwge1xuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgdHJhY2s6IHJ0cFJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB7IG1pZCwgcnRwUGFyYW1ldGVycyB9ID0gdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmdldChsb2NhbElkKSB8fCB7fTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBsYW5CU3RvcFJlY2VpdmluZyh7XG4gICAgICAgICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXN1bWVSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBydHBSZWNlaXZlciB9ID0gdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmdldChsb2NhbElkKSB8fCB7fTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFJlY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydHBSZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSwgLy8gTk9URTogT2xkIHNwZWMuXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DaHJvbWU2NyA9IENocm9tZTY3O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome67.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome70.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome70.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chrome70 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Chrome70');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome70 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome70();\n    }\n    constructor() {\n        super();\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Chrome70';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n        });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        if (encodings && encodings.length > 1) {\n            logger.debug('send() | enabling legacy simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        // Special case for VP9 with SVC.\n        let hackVp9Svc = false;\n        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);\n        if (encodings &&\n            encodings.length === 1 &&\n            layers.spatialLayers > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n            logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n            hackVp9Svc = true;\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: layers.spatialLayers,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // If encodings are given, apply them now.\n        if (encodings) {\n            logger.debug('send() | applying given encodings');\n            const parameters = transceiver.sender.getParameters();\n            for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {\n                const encoding = parameters.encodings[idx];\n                const desiredEncoding = encodings[idx];\n                // Should not happen but just in case.\n                if (!desiredEncoding) {\n                    break;\n                }\n                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);\n            }\n            await transceiver.sender.setParameters(parameters);\n        }\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n            offerMediaObject,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // Hack for VP9 SVC.\n        if (hackVp9Svc) {\n            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'L1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);\n        if (mediaSectionClosed) {\n            try {\n                transceiver.stop();\n            }\n            catch (error) { }\n        }\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(localId, track) {\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            // Store in the map.\n            this._mapMidTransceiver.set(localId, transceiver);\n            results.push({\n                localId,\n                track: transceiver.receiver.track,\n                rtpReceiver: transceiver.receiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async getReceiverStats(localId) {\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome70 = Chrome70;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTcwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELHlDQUF5QyxtQkFBTyxDQUFDLDJKQUF3QjtBQUN6RSwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDLDJCQUEyQixtQkFBTyxDQUFDLDJJQUFxQjtBQUN4RDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0tBQStLO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQThEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEUsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9DaHJvbWU3MC5qcz9hNWEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNocm9tZTcwID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBVbmlmaWVkUGxhblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTcwJyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU3MCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU3MCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3J1bigpIHwgcGMuY29ubmVjdGlvblN0YXRlIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIHBjLmljZUNvbm5lY3Rpb25TdGF0ZScpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIGxlZ2FjeSBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBWUDkgd2l0aCBTVkMuXG4gICAgICAgIGxldCBoYWNrVnA5U3ZjID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxheWVycyA9ICgwLCBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2UpKChlbmNvZGluZ3MgfHwgW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJlxuICAgICAgICAgICAgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgbGF5ZXJzLnNwYXRpYWxMYXllcnMgPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOScpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCBmb3IgVlA5IFNWQycpO1xuICAgICAgICAgICAgaGFja1ZwOVN2YyA9IHRydWU7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogbGF5ZXJzLnNwYXRpYWxMYXllcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBJZiBlbmNvZGluZ3MgYXJlIGdpdmVuLCBhcHBseSB0aGVtIG5vdy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBhcHBseWluZyBnaXZlbiBlbmNvZGluZ3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgKHBhcmFtZXRlcnMuZW5jb2RpbmdzIHx8IFtdKS5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRFbmNvZGluZyA9IGVuY29kaW5nc1tpZHhdO1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgICAgICAgaWYgKCFkZXNpcmVkRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSBPYmplY3QuYXNzaWduKGVuY29kaW5nLCBkZXNpcmVkRW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgY2FuIG5vdyBnZXQgdGhlIHRyYW5zY2VpdmVyLm1pZC5cbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMubWlkID0gbG9jYWxJZDtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID0gc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhY2sgZm9yIFZQOSBTVkMuXG4gICAgICAgIGlmIChoYWNrVnA5U3ZjKSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBbc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzWzBdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHJldXNlTWlkOiBtZWRpYVNlY3Rpb25JZHgucmV1c2VNaWQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbkNsb3NlZCA9IHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBpZiAobWVkaWFTZWN0aW9uQ2xvc2VkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSwgLy8gTk9URTogT2xkIHNwZWMuXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZShvcHRpb25zTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBtYXBMb2NhbElkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycywgc3RyZWFtSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCB8fCBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgICAgICBtYXBMb2NhbElkLnNldCh0cmFja0lkLCBsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkIHx8IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXN1bWVSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLCAvLyBOT1RFOiBPbGQgc3BlYy5cbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0LCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNzAgPSBDaHJvbWU3MDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome70.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome74.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome74.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chrome74 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\"));\nconst ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js\"));\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Chrome74');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome74 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome74();\n    }\n    constructor() {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Chrome74';\n    }\n    close() {\n        logger.debug('close()');\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            // libwebrtc supports NACK for OPUS but doesn't announce it.\n            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        this.assertNotClosed();\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        this.assertNotClosed();\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        this.assertNotClosed();\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings && encodings.length > 1) {\n            encodings.forEach((encoding, idx) => {\n                encoding.rid = `r${idx}`;\n            });\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n            sendEncodings: encodings,\n        });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        // Special case for VP9 with SVC.\n        let hackVp9Svc = false;\n        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);\n        if (encodings &&\n            encodings.length === 1 &&\n            layers.spatialLayers > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n            logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n            hackVp9Svc = true;\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: layers.spatialLayers,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n            Object.assign(newEncodings[0], encodings[0]);\n            // Hack for VP9 SVC.\n            if (hackVp9Svc) {\n                newEncodings = [newEncodings[0]];\n            }\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim.\n        else {\n            sendingRtpParameters.encodings = encodings;\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                if (encoding.scalabilityMode) {\n                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;\n                }\n                else {\n                    encoding.scalabilityMode = 'L1T3';\n                }\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        if (this._closed) {\n            return;\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);\n        if (mediaSectionClosed) {\n            try {\n                transceiver.stop();\n            }\n            catch (error) { }\n        }\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    async pauseSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('pauseSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'inactive';\n        this._remoteSdp.pauseMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async resumeSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('resumeSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        this._remoteSdp.resumeSendingMediaSection(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'sendonly';\n        const offer = await this._pc.createOffer();\n        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            else {\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n                results.push({\n                    localId,\n                    track: transceiver.receiver.track,\n                    rtpReceiver: transceiver.receiver,\n                });\n            }\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        if (this._closed) {\n            return;\n        }\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('pauseReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'inactive';\n            this._remoteSdp.pauseMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async resumeReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('resumeReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'recvonly';\n            this._remoteSdp.resumeReceivingMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertNotClosed() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('method called in a closed handler');\n        }\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome74 = Chrome74;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTc0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELHlDQUF5QyxtQkFBTyxDQUFDLDJKQUF3QjtBQUN6RSwrQkFBK0IsbUJBQU8sQ0FBQyx1SUFBYztBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx1SEFBVztBQUNwQywyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDLDJCQUEyQixtQkFBTyxDQUFDLDJJQUFxQjtBQUN4RDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtLQUErSztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBOEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTc0LmpzPzBkOWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hyb21lNzQgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3VuaWZpZWRQbGFuVXRpbHNcIikpO1xuY29uc3Qgb3J0Y1V0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29ydGMvdXRpbHNcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IHNjYWxhYmlsaXR5TW9kZXNfMSA9IHJlcXVpcmUoXCIuLi9zY2FsYWJpbGl0eU1vZGVzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignQ2hyb21lNzQnKTtcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIENocm9tZTc0IGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IENocm9tZTc0KCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE1hcCBvZiBSVENUcmFuc2NlaXZlcnMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbGlid2VicnRjIHN1cHBvcnRzIE5BQ0sgZm9yIE9QVVMgYnV0IGRvZXNuJ3QgYW5ub3VuY2UgaXQuXG4gICAgICAgICAgICBvcnRjVXRpbHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdydW4oKSB8IHBjLmNvbm5lY3Rpb25TdGF0ZSBub3Qgc3VwcG9ydGVkLCB1c2luZyBwYy5pY2VDb25uZWN0aW9uU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5yaWQgPSBgciR7aWR4fWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiBlbmNvZGluZ3MsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFZQOSB3aXRoIFNWQy5cbiAgICAgICAgbGV0IGhhY2tWcDlTdmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gKDAsIHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZSkoKGVuY29kaW5ncyB8fCBbe31dKVswXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBpZiAoZW5jb2RpbmdzICYmXG4gICAgICAgICAgICBlbmNvZGluZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBsYXllcnMuc3BhdGlhbExheWVycyA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA5Jykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0IGZvciBWUDkgU1ZDJyk7XG4gICAgICAgICAgICBoYWNrVnA5U3ZjID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBsYXllcnMuc3BhdGlhbExheWVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbmNvZGluZ3NbMF0sIGVuY29kaW5nc1swXSk7XG4gICAgICAgICAgICAvLyBIYWNrIGZvciBWUDkgU1ZDLlxuICAgICAgICAgICAgaWYgKGhhY2tWcDlTdmMpIHtcbiAgICAgICAgICAgICAgICBuZXdFbmNvZGluZ3MgPSBbbmV3RW5jb2RpbmdzWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGBMMVQke2xheWVycy50ZW1wb3JhbExheWVyc31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ0wxVDMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25DbG9zZWQgPSB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgaWYgKG1lZGlhU2VjdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVzdW1lU2VuZGluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IG1hcExvY2FsSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkIHx8IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgICAgIG1hcExvY2FsSWQuc2V0KHRyYWNrSWQsIGxvY2FsSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQgfHwgcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBydHBSZWNlaXZlcjogdHJhbnNjZWl2ZXIucmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydE5vdENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdtZXRob2QgY2FsbGVkIGluIGEgY2xvc2VkIGhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNzQgPSBDaHJvbWU3NDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Chrome74.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Edge11.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Edge11.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Edge11 = void 0;\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst edgeUtils = __importStar(__webpack_require__(/*! ./ortc/edgeUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst logger = new Logger_1.Logger('Edge11');\nclass Edge11 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Edge11();\n    }\n    constructor() {\n        super();\n        // Map of RTCRtpSenders indexed by id.\n        this._rtpSenders = new Map();\n        // Map of RTCRtpReceivers indexed by id.\n        this._rtpReceivers = new Map();\n        // Next localId for sending tracks.\n        this._nextSendLocalId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Edge11';\n    }\n    close() {\n        logger.debug('close()');\n        // Close the ICE gatherer.\n        // NOTE: Not yet implemented by Edge.\n        try {\n            this._iceGatherer.close();\n        }\n        catch (error) { }\n        // Close the ICE transport.\n        try {\n            this._iceTransport.stop();\n        }\n        catch (error) { }\n        // Close the DTLS transport.\n        try {\n            this._dtlsTransport.stop();\n        }\n        catch (error) { }\n        // Close RTCRtpSenders.\n        for (const rtpSender of this._rtpSenders.values()) {\n            try {\n                rtpSender.stop();\n            }\n            catch (error) { }\n        }\n        // Close RTCRtpReceivers.\n        for (const rtpReceiver of this._rtpReceivers.values()) {\n            try {\n                rtpReceiver.stop();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        return edgeUtils.getCapabilities();\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: { OS: 0, MIS: 0 },\n        };\n    }\n    run({ direction, // eslint-disable-line @typescript-eslint/no-unused-vars\n    iceParameters, iceCandidates, dtlsParameters, sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars\n    iceServers, iceTransportPolicy, additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars\n    proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars\n    extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._remoteIceParameters = iceParameters;\n        this._remoteIceCandidates = iceCandidates;\n        this._remoteDtlsParameters = dtlsParameters;\n        this._cname = `CNAME-${utils.generateRandomNumber()}`;\n        this.setIceGatherer({ iceServers, iceTransportPolicy });\n        this.setIceTransport();\n        this.setDtlsTransport();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateIceServers(iceServers) {\n        // NOTE: Edge 11 does not implement iceGatherer.gater().\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        this._remoteIceParameters = iceParameters;\n        if (!this._transportReady) {\n            return;\n        }\n        logger.debug('restartIce() | calling iceTransport.start()');\n        this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');\n        for (const candidate of this._remoteIceCandidates) {\n            this._iceTransport.addRemoteCandidate(candidate);\n        }\n        this._iceTransport.addRemoteCandidate({});\n    }\n    async getTransportStats() {\n        return this._iceTransport.getStats();\n    }\n    async send(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    { track, encodings, codecOptions, codec }) {\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (!this._transportReady) {\n            await this.setupTransport({ localDtlsRole: 'server' });\n        }\n        logger.debug('send() | calling new RTCRtpSender()');\n        const rtpSender = new RTCRtpSender(track, this._dtlsTransport);\n        const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);\n        const useRtx = rtpParameters.codecs.some((_codec) => /.+\\/rtx$/i.test(_codec.mimeType));\n        if (!encodings) {\n            encodings = [{}];\n        }\n        for (const encoding of encodings) {\n            encoding.ssrc = utils.generateRandomNumber();\n            if (useRtx) {\n                encoding.rtx = { ssrc: utils.generateRandomNumber() };\n            }\n        }\n        rtpParameters.encodings = encodings;\n        // Fill RTCRtpParameters.rtcp.\n        rtpParameters.rtcp = {\n            cname: this._cname,\n            reducedSize: true,\n            mux: true,\n        };\n        // NOTE: Convert our standard RTCRtpParameters into those that Edge\n        // expects.\n        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\n        logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);\n        await rtpSender.send(edgeRtpParameters);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Store it.\n        this._rtpSenders.set(localId, rtpSender);\n        return { localId, rtpParameters, rtpSender };\n    }\n    async stopSending(localId) {\n        logger.debug('stopSending() [localId:%s]', localId);\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender) {\n            throw new Error('RTCRtpSender not found');\n        }\n        this._rtpSenders.delete(localId);\n        try {\n            logger.debug('stopSending() | calling rtpSender.stop()');\n            rtpSender.stop();\n        }\n        catch (error) {\n            logger.warn('stopSending() | rtpSender.stop() failed:%o', error);\n            throw error;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(localId, track) {\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender) {\n            throw new Error('RTCRtpSender not found');\n        }\n        rtpSender.setTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender) {\n            throw new Error('RTCRtpSender not found');\n        }\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender) {\n            throw new Error('RTCRtpSender not found');\n        }\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender) {\n            throw new Error('RTCRtpSender not found');\n        }\n        return rtpSender.getStats();\n    }\n    async sendDataChannel(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receive(optionsList) {\n        const results = [];\n        for (const options of optionsList) {\n            const { trackId, kind } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        }\n        if (!this._transportReady) {\n            await this.setupTransport({ localDtlsRole: 'server' });\n        }\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters } = options;\n            logger.debug('receive() | calling new RTCRtpReceiver()');\n            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);\n            rtpReceiver.addEventListener('error', (event) => {\n                logger.error('rtpReceiver \"error\" event [event:%o]', event);\n            });\n            // NOTE: Convert our standard RTCRtpParameters into those that Edge\n            // expects.\n            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\n            logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);\n            await rtpReceiver.receive(edgeRtpParameters);\n            const localId = trackId;\n            // Store it.\n            this._rtpReceivers.set(localId, rtpReceiver);\n            results.push({\n                localId,\n                track: rtpReceiver.track,\n                rtpReceiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const rtpReceiver = this._rtpReceivers.get(localId);\n            if (!rtpReceiver) {\n                throw new Error('RTCRtpReceiver not found');\n            }\n            this._rtpReceivers.delete(localId);\n            try {\n                logger.debug('stopReceiving() | calling rtpReceiver.stop()');\n                rtpReceiver.stop();\n            }\n            catch (error) {\n                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);\n            }\n        }\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async getReceiverStats(localId) {\n        const rtpReceiver = this._rtpReceivers.get(localId);\n        if (!rtpReceiver) {\n            throw new Error('RTCRtpReceiver not found');\n        }\n        return rtpReceiver.getStats();\n    }\n    async receiveDataChannel(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    setIceGatherer({ iceServers, iceTransportPolicy, }) {\n        // @ts-ignore\n        const iceGatherer = new RTCIceGatherer({\n            iceServers: iceServers || [],\n            gatherPolicy: iceTransportPolicy || 'all',\n        });\n        iceGatherer.addEventListener('error', (event) => {\n            logger.error('iceGatherer \"error\" event [event:%o]', event);\n        });\n        // NOTE: Not yet implemented by Edge, which starts gathering automatically.\n        try {\n            iceGatherer.gather();\n        }\n        catch (error) {\n            logger.debug('setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());\n        }\n        this._iceGatherer = iceGatherer;\n    }\n    setIceTransport() {\n        const iceTransport = new RTCIceTransport(this._iceGatherer);\n        // NOTE: Not yet implemented by Edge.\n        iceTransport.addEventListener('statechange', () => {\n            switch (iceTransport.state) {\n                case 'checking': {\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                }\n                case 'connected':\n                case 'completed': {\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                }\n                case 'failed': {\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                }\n                case 'disconnected': {\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                }\n                case 'closed': {\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n                }\n            }\n        });\n        // NOTE: Not standard, but implemented by Edge.\n        iceTransport.addEventListener('icestatechange', () => {\n            switch (iceTransport.state) {\n                case 'checking': {\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                }\n                case 'connected':\n                case 'completed': {\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                }\n                case 'failed': {\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                }\n                case 'disconnected': {\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                }\n                case 'closed': {\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n                }\n            }\n        });\n        iceTransport.addEventListener('candidatepairchange', (event) => {\n            logger.debug('iceTransport \"candidatepairchange\" event [pair:%o]', event.pair);\n        });\n        this._iceTransport = iceTransport;\n    }\n    setDtlsTransport() {\n        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);\n        // NOTE: Not yet implemented by Edge.\n        dtlsTransport.addEventListener('statechange', () => {\n            logger.debug('dtlsTransport \"statechange\" event [state:%s]', dtlsTransport.state);\n        });\n        // NOTE: Not standard, but implemented by Edge.\n        dtlsTransport.addEventListener('dtlsstatechange', () => {\n            logger.debug('dtlsTransport \"dtlsstatechange\" event [state:%s]', dtlsTransport.state);\n            if (dtlsTransport.state === 'closed') {\n                this.emit('@connectionstatechange', 'closed');\n            }\n        });\n        dtlsTransport.addEventListener('error', (event) => {\n            logger.error('dtlsTransport \"error\" event [event:%o]', event);\n        });\n        this._dtlsTransport = dtlsTransport;\n    }\n    async setupTransport({ localDtlsRole, }) {\n        logger.debug('setupTransport()');\n        // Get our local DTLS parameters.\n        const dtlsParameters = this._dtlsTransport.getLocalParameters();\n        dtlsParameters.role = localDtlsRole;\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        // Start the RTCIceTransport.\n        this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');\n        // Add remote ICE candidates.\n        for (const candidate of this._remoteIceCandidates) {\n            this._iceTransport.addRemoteCandidate(candidate);\n        }\n        // Also signal a 'complete' candidate as per spec.\n        // NOTE: It should be {complete: true} but Edge prefers {}.\n        // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport\n        // won't enter the 'completed' state.\n        this._iceTransport.addRemoteCandidate({});\n        // NOTE: Edge does not like SHA less than 256.\n        this._remoteDtlsParameters.fingerprints =\n            this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {\n                return (fingerprint.algorithm === 'sha-256' ||\n                    fingerprint.algorithm === 'sha-384' ||\n                    fingerprint.algorithm === 'sha-512');\n            });\n        // Start the RTCDtlsTransport.\n        this._dtlsTransport.start(this._remoteDtlsParameters);\n        this._transportReady = true;\n    }\n}\nexports.Edge11 = Edge11;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0VkZ2UxMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGlCQUFpQixtQkFBTyxDQUFDLHVIQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHVIQUFXO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLHFIQUFVO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFTO0FBQzNDLCtCQUErQixtQkFBTyxDQUFDLCtJQUFrQjtBQUN6RCwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQsOEJBQThCLGdDQUFnQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVDQUF1QztBQUM3QztBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsbUJBQW1CO0FBQ2xFO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9FZGdlMTEuanM/OGM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FZGdlMTEgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBlZGdlVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Yy9lZGdlVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0VkZ2UxMScpO1xuY2xhc3MgRWRnZTExIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IEVkZ2UxMSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFNlbmRlcnMgaW5kZXhlZCBieSBpZC5cbiAgICAgICAgdGhpcy5fcnRwU2VuZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFJlY2VpdmVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9ydHBSZWNlaXZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgbG9jYWxJZCBmb3Igc2VuZGluZyB0cmFja3MuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdFZGdlMTEnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIHRoZSBJQ0UgZ2F0aGVyZXIuXG4gICAgICAgIC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2ljZUdhdGhlcmVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgLy8gQ2xvc2UgdGhlIElDRSB0cmFuc3BvcnQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9pY2VUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIC8vIENsb3NlIHRoZSBEVExTIHRyYW5zcG9ydC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2R0bHNUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIC8vIENsb3NlIFJUQ1J0cFNlbmRlcnMuXG4gICAgICAgIGZvciAoY29uc3QgcnRwU2VuZGVyIG9mIHRoaXMuX3J0cFNlbmRlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnRwU2VuZGVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgUlRDUnRwUmVjZWl2ZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IHJ0cFJlY2VpdmVyIG9mIHRoaXMuX3J0cFJlY2VpdmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4gZWRnZVV0aWxzLmdldENhcGFiaWxpdGllcygpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogeyBPUzogMCwgTUlTOiAwIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3J1bigpJyk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZW1vdGVJY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fcmVtb3RlSWNlQ2FuZGlkYXRlcyA9IGljZUNhbmRpZGF0ZXM7XG4gICAgICAgIHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX2NuYW1lID0gYENOQU1FLSR7dXRpbHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIoKX1gO1xuICAgICAgICB0aGlzLnNldEljZUdhdGhlcmVyKHsgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5IH0pO1xuICAgICAgICB0aGlzLnNldEljZVRyYW5zcG9ydCgpO1xuICAgICAgICB0aGlzLnNldER0bHNUcmFuc3BvcnQoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICAvLyBOT1RFOiBFZGdlIDExIGRvZXMgbm90IGltcGxlbWVudCBpY2VHYXRoZXJlci5nYXRlcigpLlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlSWNlUGFyYW1ldGVycyA9IGljZVBhcmFtZXRlcnM7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgaWNlVHJhbnNwb3J0LnN0YXJ0KCknKTtcbiAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LnN0YXJ0KHRoaXMuX2ljZUdhdGhlcmVyLCBpY2VQYXJhbWV0ZXJzLCAnY29udHJvbGxpbmcnKTtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdGhpcy5fcmVtb3RlSWNlQ2FuZGlkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljZVRyYW5zcG9ydC5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIG5ldyBSVENSdHBTZW5kZXIoKScpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSBuZXcgUlRDUnRwU2VuZGVyKHRyYWNrLCB0aGlzLl9kdGxzVHJhbnNwb3J0KTtcbiAgICAgICAgY29uc3QgcnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhydHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCB1c2VSdHggPSBydHBQYXJhbWV0ZXJzLmNvZGVjcy5zb21lKChfY29kZWMpID0+IC8uK1xcL3J0eCQvaS50ZXN0KF9jb2RlYy5taW1lVHlwZSkpO1xuICAgICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICAgICAgZW5jb2RpbmdzID0gW3t9XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIGVuY29kaW5ncykge1xuICAgICAgICAgICAgZW5jb2Rpbmcuc3NyYyA9IHV0aWxzLmdlbmVyYXRlUmFuZG9tTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAodXNlUnR4KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiB1dGlscy5nZW5lcmF0ZVJhbmRvbU51bWJlcigpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIC8vIEZpbGwgUlRDUnRwUGFyYW1ldGVycy5ydGNwLlxuICAgICAgICBydHBQYXJhbWV0ZXJzLnJ0Y3AgPSB7XG4gICAgICAgICAgICBjbmFtZTogdGhpcy5fY25hbWUsXG4gICAgICAgICAgICByZWR1Y2VkU2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgIG11eDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTk9URTogQ29udmVydCBvdXIgc3RhbmRhcmQgUlRDUnRwUGFyYW1ldGVycyBpbnRvIHRob3NlIHRoYXQgRWRnZVxuICAgICAgICAvLyBleHBlY3RzLlxuICAgICAgICBjb25zdCBlZGdlUnRwUGFyYW1ldGVycyA9IGVkZ2VVdGlscy5tYW5nbGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcnRwU2VuZGVyLnNlbmQoKSBbcGFyYW1zOiVvXScsIGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNlbmQoZWRnZVJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gU3RyaW5nKHRoaXMuX25leHRTZW5kTG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCsrO1xuICAgICAgICAvLyBTdG9yZSBpdC5cbiAgICAgICAgdGhpcy5fcnRwU2VuZGVycy5zZXQobG9jYWxJZCwgcnRwU2VuZGVyKTtcbiAgICAgICAgcmV0dXJuIHsgbG9jYWxJZCwgcnRwUGFyYW1ldGVycywgcnRwU2VuZGVyIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3J0cFNlbmRlcnMuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBydHBTZW5kZXIuc3RvcCgpJyk7XG4gICAgICAgICAgICBydHBTZW5kZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBydHBTZW5kZXIuc3RvcCgpIGZhaWxlZDolbycsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnRwU2VuZGVyLnNldFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwU2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwga2luZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBuZXcgUlRDUnRwUmVjZWl2ZXIoKScpO1xuICAgICAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSBuZXcgUlRDUnRwUmVjZWl2ZXIodGhpcy5fZHRsc1RyYW5zcG9ydCwga2luZCk7XG4gICAgICAgICAgICBydHBSZWNlaXZlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcigncnRwUmVjZWl2ZXIgXCJlcnJvclwiIGV2ZW50IFtldmVudDolb10nLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5PVEU6IENvbnZlcnQgb3VyIHN0YW5kYXJkIFJUQ1J0cFBhcmFtZXRlcnMgaW50byB0aG9zZSB0aGF0IEVkZ2VcbiAgICAgICAgICAgIC8vIGV4cGVjdHMuXG4gICAgICAgICAgICBjb25zdCBlZGdlUnRwUGFyYW1ldGVycyA9IGVkZ2VVdGlscy5tYW5nbGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHJ0cFJlY2VpdmVyLnJlY2VpdmUoKSBbcGFyYW1zOiVvXScsIGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGF3YWl0IHJ0cFJlY2VpdmVyLnJlY2VpdmUoZWRnZVJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgICAgICAvLyBTdG9yZSBpdC5cbiAgICAgICAgICAgIHRoaXMuX3J0cFJlY2VpdmVycy5zZXQobG9jYWxJZCwgcnRwUmVjZWl2ZXIpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgIHRyYWNrOiBydHBSZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCBydHBSZWNlaXZlciA9IHRoaXMuX3J0cFJlY2VpdmVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXJ0cFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3J0cFJlY2VpdmVycy5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBydHBSZWNlaXZlci5zdG9wKCknKTtcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFJlY2VpdmluZygpIHwgcnRwUmVjZWl2ZXIuc3RvcCgpIGZhaWxlZDolbycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9ydHBSZWNlaXZlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFJlY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFJlY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydHBSZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBzZXRJY2VHYXRoZXJlcih7IGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgfSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IGljZUdhdGhlcmVyID0gbmV3IFJUQ0ljZUdhdGhlcmVyKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBnYXRoZXJQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGljZUdhdGhlcmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ljZUdhdGhlcmVyIFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLCB3aGljaCBzdGFydHMgZ2F0aGVyaW5nIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpY2VHYXRoZXJlci5nYXRoZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0SWNlR2F0aGVyZXIoKSB8IGljZUdhdGhlcmVyLmdhdGhlcigpIGZhaWxlZDogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pY2VHYXRoZXJlciA9IGljZUdhdGhlcmVyO1xuICAgIH1cbiAgICBzZXRJY2VUcmFuc3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IGljZVRyYW5zcG9ydCA9IG5ldyBSVENJY2VUcmFuc3BvcnQodGhpcy5faWNlR2F0aGVyZXIpO1xuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoaWNlVHJhbnNwb3J0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFOiBOb3Qgc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuICAgICAgICBpY2VUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignaWNlc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGljZVRyYW5zcG9ydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbmRpZGF0ZXBhaXJjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnaWNlVHJhbnNwb3J0IFwiY2FuZGlkYXRlcGFpcmNoYW5nZVwiIGV2ZW50IFtwYWlyOiVvXScsIGV2ZW50LnBhaXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0ID0gaWNlVHJhbnNwb3J0O1xuICAgIH1cbiAgICBzZXREdGxzVHJhbnNwb3J0KCkge1xuICAgICAgICBjb25zdCBkdGxzVHJhbnNwb3J0ID0gbmV3IFJUQ0R0bHNUcmFuc3BvcnQodGhpcy5faWNlVHJhbnNwb3J0KTtcbiAgICAgICAgLy8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuICAgICAgICBkdGxzVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdkdGxzVHJhbnNwb3J0IFwic3RhdGVjaGFuZ2VcIiBldmVudCBbc3RhdGU6JXNdJywgZHRsc1RyYW5zcG9ydC5zdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFOiBOb3Qgc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuICAgICAgICBkdGxzVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2R0bHNzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnZHRsc1RyYW5zcG9ydCBcImR0bHNzdGF0ZWNoYW5nZVwiIGV2ZW50IFtzdGF0ZTolc10nLCBkdGxzVHJhbnNwb3J0LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChkdGxzVHJhbnNwb3J0LnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignZHRsc1RyYW5zcG9ydCBcImVycm9yXCIgZXZlbnQgW2V2ZW50OiVvXScsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2R0bHNUcmFuc3BvcnQgPSBkdGxzVHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXR1cFRyYW5zcG9ydCgpJyk7XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHRoaXMuX2R0bHNUcmFuc3BvcnQuZ2V0TG9jYWxQYXJhbWV0ZXJzKCk7XG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIFJUQ0ljZVRyYW5zcG9ydC5cbiAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LnN0YXJ0KHRoaXMuX2ljZUdhdGhlcmVyLCB0aGlzLl9yZW1vdGVJY2VQYXJhbWV0ZXJzLCAnY29udHJvbGxpbmcnKTtcbiAgICAgICAgLy8gQWRkIHJlbW90ZSBJQ0UgY2FuZGlkYXRlcy5cbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdGhpcy5fcmVtb3RlSWNlQ2FuZGlkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsc28gc2lnbmFsIGEgJ2NvbXBsZXRlJyBjYW5kaWRhdGUgYXMgcGVyIHNwZWMuXG4gICAgICAgIC8vIE5PVEU6IEl0IHNob3VsZCBiZSB7Y29tcGxldGU6IHRydWV9IGJ1dCBFZGdlIHByZWZlcnMge30uXG4gICAgICAgIC8vIE5PVEU6IElmIHdlIGRvbid0IHNpZ25hbCBlbmQgb2YgY2FuZGlkYXRlcywgdGhlIEVkZ2UgUlRDSWNlVHJhbnNwb3J0XG4gICAgICAgIC8vIHdvbid0IGVudGVyIHRoZSAnY29tcGxldGVkJyBzdGF0ZS5cbiAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZSh7fSk7XG4gICAgICAgIC8vIE5PVEU6IEVkZ2UgZG9lcyBub3QgbGlrZSBTSEEgbGVzcyB0aGFuIDI1Ni5cbiAgICAgICAgdGhpcy5fcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzID1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cy5maWx0ZXIoKGZpbmdlcnByaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaW5nZXJwcmludC5hbGdvcml0aG0gPT09ICdzaGEtMjU2JyB8fFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludC5hbGdvcml0aG0gPT09ICdzaGEtMzg0JyB8fFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludC5hbGdvcml0aG0gPT09ICdzaGEtNTEyJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIFJUQ0R0bHNUcmFuc3BvcnQuXG4gICAgICAgIHRoaXMuX2R0bHNUcmFuc3BvcnQuc3RhcnQodGhpcy5fcmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5FZGdlMTEgPSBFZGdlMTE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Edge11.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Firefox60.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Firefox60.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Firefox60 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Firefox60');\nconst SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };\nclass Firefox60 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Firefox60();\n    }\n    constructor() {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Firefox60';\n    }\n    close() {\n        logger.debug('close()');\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n        });\n        // NOTE: We need to add a real video track to get the RID extension mapping.\n        const canvas = document.createElement('canvas');\n        // NOTE: Otherwise Firefox fails in next line.\n        canvas.getContext('2d');\n        const fakeStream = canvas.captureStream();\n        const fakeVideoTrack = fakeStream.getVideoTracks()[0];\n        try {\n            pc.addTransceiver('audio', { direction: 'sendrecv' });\n            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {\n                direction: 'sendrecv',\n            });\n            const parameters = videoTransceiver.sender.getParameters();\n            const encodings = [\n                { rid: 'r0', maxBitrate: 100000 },\n                { rid: 'r1', maxBitrate: 500000 },\n            ];\n            parameters.encodings = encodings;\n            await videoTransceiver.sender.setParameters(parameters);\n            const offer = await pc.createOffer();\n            try {\n                canvas.remove();\n            }\n            catch (error) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error) { }\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                canvas.remove();\n            }\n            catch (error2) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error2) { }\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        this.assertNotClosed();\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateIceServers(iceServers) {\n        this.assertNotClosed();\n        // NOTE: Firefox does not implement pc.setConfiguration().\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    async restartIce(iceParameters) {\n        this.assertNotClosed();\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        this.assertNotClosed();\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings) {\n            encodings = utils.clone(encodings);\n            if (encodings.length > 1) {\n                encodings.forEach((encoding, idx) => {\n                    encoding.rid = `r${idx}`;\n                });\n                // Clone the encodings and reverse them because Firefox likes them\n                // from high to low.\n                encodings.reverse();\n            }\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        // NOTE: Firefox fails sometimes to properly anticipate the closed media\n        // section that it should use, so don't reuse closed media sections.\n        //   https://github.com/versatica/mediasoup-client/issues/104\n        //\n        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n        });\n        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver\n        // second argument, but Firefox does not support it.\n        if (encodings) {\n            const parameters = transceiver.sender.getParameters();\n            parameters.encodings = encodings;\n            await transceiver.sender.setParameters(parameters);\n        }\n        const offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        // In Firefox use DTLS role client even if we are the \"offerer\" since\n        // Firefox does not respect ICE-Lite.\n        if (!this._transportReady) {\n            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n        }\n        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n            Object.assign(newEncodings[0], encodings[0]);\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim (but\n        // reverse them back since we reversed them above to satisfy Firefox).\n        else {\n            sendingRtpParameters.encodings = encodings.reverse();\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                if (encoding.scalabilityMode) {\n                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;\n                }\n                else {\n                    encoding.scalabilityMode = 'L1T3';\n                }\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        if (this._closed) {\n            return;\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated transceiver not found');\n        }\n        transceiver.sender.replaceTrack(null);\n        // NOTE: Cannot use stop() the transceiver due to the the note above in\n        // send() method.\n        // try\n        // {\n        // \ttransceiver.stop();\n        // }\n        // catch (error)\n        // {}\n        this._pc.removeTrack(transceiver.sender);\n        // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n        // method.\n        // this._remoteSdp!.closeMediaSection(transceiver.mid);\n        this._remoteSdp.disableMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('pauseSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'inactive';\n        this._remoteSdp.pauseMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('resumeSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'sendonly';\n        this._remoteSdp.resumeSendingMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated transceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        // NOTE: We require encodings given from low to high, however Firefox\n        // requires them in reverse order, so do magic here.\n        spatialLayer = parameters.encodings.length - 1 - spatialLayer;\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx >= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    optionsList) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        if (!this._transportReady) {\n            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            // Store in the map.\n            this._mapMidTransceiver.set(localId, transceiver);\n            results.push({\n                localId,\n                track: transceiver.receiver.track,\n                rtpReceiver: transceiver.receiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        if (this._closed) {\n            return;\n        }\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('pauseReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'inactive';\n            this._remoteSdp.pauseMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async resumeReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('resumeReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'recvonly';\n            this._remoteSdp.resumeReceivingMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertNotClosed() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('method called in a closed handler');\n        }\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Firefox60 = Firefox60;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0ZpcmVmb3g2MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtDQUFrQyxtQkFBTyxDQUFDLHFIQUFlO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLHVIQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHVIQUFXO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLHFIQUFVO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFTO0FBQzNDLG9DQUFvQyxtQkFBTyxDQUFDLGlKQUFtQjtBQUMvRCx5Q0FBeUMsbUJBQU8sQ0FBQywySkFBd0I7QUFDekUsMkJBQTJCLG1CQUFPLENBQUMsbUpBQW9CO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLDZJQUFpQjtBQUM3QywyQkFBMkIsbUJBQU8sQ0FBQywySUFBcUI7QUFDeEQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRCxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0tBQStLO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUNBQXlDO0FBQ2pGO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBOEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUNBQXlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEUsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esd0NBQXdDLHlDQUF5QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlDQUF5QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9GaXJlZm94NjAuanM/NzViZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaXJlZm94NjAgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3VuaWZpZWRQbGFuVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IHNjYWxhYmlsaXR5TW9kZXNfMSA9IHJlcXVpcmUoXCIuLi9zY2FsYWJpbGl0eU1vZGVzXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRmlyZWZveDYwJyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTYsIE1JUzogMjA0OCB9O1xuY2xhc3MgRmlyZWZveDYwIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IEZpcmVmb3g2MCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBNYXAgb2YgUlRDVHJhbnNjZWl2ZXJzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0ZpcmVmb3g2MCc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogV2UgbmVlZCB0byBhZGQgYSByZWFsIHZpZGVvIHRyYWNrIHRvIGdldCB0aGUgUklEIGV4dGVuc2lvbiBtYXBwaW5nLlxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgLy8gTk9URTogT3RoZXJ3aXNlIEZpcmVmb3ggZmFpbHMgaW4gbmV4dCBsaW5lLlxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgZmFrZVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gICAgICAgIGNvbnN0IGZha2VWaWRlb1RyYWNrID0gZmFrZVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywgeyBkaXJlY3Rpb246ICdzZW5kcmVjdicgfSk7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gcGMuYWRkVHJhbnNjZWl2ZXIoZmFrZVZpZGVvVHJhY2ssIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kcmVjdicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB2aWRlb1RyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGluZ3MgPSBbXG4gICAgICAgICAgICAgICAgeyByaWQ6ICdyMCcsIG1heEJpdHJhdGU6IDEwMDAwMCB9LFxuICAgICAgICAgICAgICAgIHsgcmlkOiAncjEnLCBtYXhCaXRyYXRlOiA1MDAwMDAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgICAgIGF3YWl0IHZpZGVvVHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZha2VWaWRlb1RyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgfSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdAaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdydW4oKSB8IHBjLmNvbm5lY3Rpb25TdGF0ZSBub3Qgc3VwcG9ydGVkLCB1c2luZyBwYy5pY2VDb25uZWN0aW9uU3RhdGUnKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgLy8gTk9URTogRmlyZWZveCBkb2VzIG5vdCBpbXBsZW1lbnQgcGMuc2V0Q29uZmlndXJhdGlvbigpLlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZW5jb2RpbmdzID0gdXRpbHMuY2xvbmUoZW5jb2RpbmdzKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnJpZCA9IGByJHtpZHh9YDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgZW5jb2RpbmdzIGFuZCByZXZlcnNlIHRoZW0gYmVjYXVzZSBGaXJlZm94IGxpa2VzIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBmcm9tIGhpZ2ggdG8gbG93LlxuICAgICAgICAgICAgICAgIGVuY29kaW5ncy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgLy8gTk9URTogRmlyZWZveCBmYWlscyBzb21ldGltZXMgdG8gcHJvcGVybHkgYW50aWNpcGF0ZSB0aGUgY2xvc2VkIG1lZGlhXG4gICAgICAgIC8vIHNlY3Rpb24gdGhhdCBpdCBzaG91bGQgdXNlLCBzbyBkb24ndCByZXVzZSBjbG9zZWQgbWVkaWEgc2VjdGlvbnMuXG4gICAgICAgIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3ZlcnNhdGljYS9tZWRpYXNvdXAtY2xpZW50L2lzc3Vlcy8xMDRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwIS5nZXROZXh0TWVkaWFTZWN0aW9uSWR4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgICAgIHN0cmVhbXM6IFt0aGlzLl9zZW5kU3RyZWFtXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgbm90IHNwZWMgY29tcGxpYW50cy4gRW5jb2RpbmdzIHNob3VsZCBiZSBnaXZlbiBpbiBhZGRUcmFuc2NlaXZlclxuICAgICAgICAvLyBzZWNvbmQgYXJndW1lbnQsIGJ1dCBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAvLyBJbiBGaXJlZm94IHVzZSBEVExTIHJvbGUgY2xpZW50IGV2ZW4gaWYgd2UgYXJlIHRoZSBcIm9mZmVyZXJcIiBzaW5jZVxuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlc3BlY3QgSUNFLUxpdGUuXG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5ZXJzID0gKDAsIHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZSkoKGVuY29kaW5ncyB8fCBbe31dKVswXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhbnNjZWl2ZXIubWlkO1xuICAgICAgICAvLyBTZXQgTUlELlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5taWQgPSBsb2NhbElkO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVtsb2NhbFNkcE9iamVjdC5tZWRpYS5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPSBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGlmIG5vIGVuY29kaW5ncyBhcmUgZ2l2ZW4uXG4gICAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBhbmQgY29tcGxldGUgdGhlbSB3aXRoIGdpdmVuXG4gICAgICAgIC8vIG9uZSBpZiBqdXN0IGEgc2luZ2xlIGVuY29kaW5nIGhhcyBiZWVuIGdpdmVuLlxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbmNvZGluZ3NbMF0sIGVuY29kaW5nc1swXSk7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBuZXdFbmNvZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIG1vcmUgdGhhbiAxIGVuY29kaW5nIGFyZSBnaXZlbiB1c2UgdGhlbSB2ZXJiYXRpbSAoYnV0XG4gICAgICAgIC8vIHJldmVyc2UgdGhlbSBiYWNrIHNpbmNlIHdlIHJldmVyc2VkIHRoZW0gYWJvdmUgdG8gc2F0aXNmeSBGaXJlZm94KS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBvciBIMjY0IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvXG4gICAgICAgIC8vIGVhY2ggZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4JyB8fFxuICAgICAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vaDI2NCcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gYEwxVCR7bGF5ZXJzLnRlbXBvcmFsTGF5ZXJzfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgICAgICBleHRtYXBBbGxvd01peGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyOiB0cmFuc2NlaXZlci5zZW5kZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgdHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgLy8gTk9URTogQ2Fubm90IHVzZSBzdG9wKCkgdGhlIHRyYW5zY2VpdmVyIGR1ZSB0byB0aGUgdGhlIG5vdGUgYWJvdmUgaW5cbiAgICAgICAgLy8gc2VuZCgpIG1ldGhvZC5cbiAgICAgICAgLy8gdHJ5XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gXHR0cmFuc2NlaXZlci5zdG9wKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gY2F0Y2ggKGVycm9yKVxuICAgICAgICAvLyB7fVxuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICAvLyBOT1RFOiBDYW5ub3QgdXNlIGNsb3NlTWVkaWFTZWN0aW9uKCkgZHVlIHRvIHRoZSB0aGUgbm90ZSBhYm92ZSBpbiBzZW5kKClcbiAgICAgICAgLy8gbWV0aG9kLlxuICAgICAgICAvLyB0aGlzLl9yZW1vdGVTZHAhLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5kaXNhYmxlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHBhdXNlU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wYXVzZU1lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVzdW1lU2VuZGluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgLy8gTk9URTogV2UgcmVxdWlyZSBlbmNvZGluZ3MgZ2l2ZW4gZnJvbSBsb3cgdG8gaGlnaCwgaG93ZXZlciBGaXJlZm94XG4gICAgICAgIC8vIHJlcXVpcmVzIHRoZW0gaW4gcmV2ZXJzZSBvcmRlciwgc28gZG8gbWFnaWMgaGVyZS5cbiAgICAgICAgc3BhdGlhbExheWVyID0gcGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoIC0gMSAtIHNwYXRpYWxMYXllcjtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA+PSBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvcHRpb25zTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBtYXBMb2NhbElkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycywgc3RyZWFtSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCB8fCBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgICAgICBtYXBMb2NhbElkLnNldCh0cmFja0lkLCBsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkIHx8IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICB0cmFjazogdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0LCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnROb3RDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbWV0aG9kIGNhbGxlZCBpbiBhIGNsb3NlZCBoYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZpcmVmb3g2MCA9IEZpcmVmb3g2MDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Firefox60.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HandlerInterface = void 0;\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ../EnhancedEventEmitter */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nclass HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    constructor() {\n        super();\n    }\n}\nexports.HandlerInterface = HandlerInterface;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0hhbmRsZXJJbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLCtCQUErQixtQkFBTyxDQUFDLG1KQUF5QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9IYW5kbGVySW50ZXJmYWNlLmpzPzUzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhbmRsZXJJbnRlcmZhY2UgPSB2b2lkIDA7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4uL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY2xhc3MgSGFuZGxlckludGVyZmFjZSBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFuZGxlckludGVyZmFjZSA9IEhhbmRsZXJJbnRlcmZhY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNative.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNative.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReactNative = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('ReactNative');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass ReactNative extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new ReactNative();\n    }\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of sending MediaStreamTracks indexed by localId.\n        this._mapSendLocalIdTrack = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'ReactNative';\n    }\n    close() {\n        logger.debug('close()');\n        // Free/dispose native MediaStream but DO NOT free/dispose native\n        // MediaStreamTracks (that is parent's business).\n        // @ts-ignore (proprietary API in react-native-webrtc).\n        this._sendStream.release(/* releaseTracks */ false);\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addStream(this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n            offerMediaObject,\n            track,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'L1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Insert into the map.\n        this._mapSendLocalIdTrack.set(localId, track);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const track = this._mapSendLocalIdTrack.get(localId);\n        if (!track) {\n            throw new Error('track not found');\n        }\n        this._mapSendLocalIdTrack.delete(localId);\n        this._sendStream.removeTrack(track);\n        this._pc.addStream(this._sendStream);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable') {\n            return;\n        }\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    track) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async setMaxSpatialLayer(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    spatialLayer) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setRtpEncodingParameters(localId, params) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getSenderStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertRecvDirection();\n        const results = [];\n        const mapStreamId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const mid = kind;\n            let streamId = options.streamId || rtpParameters.rtcp.cname;\n            // NOTE: In React-Native we cannot reuse the same remote MediaStream for new\n            // remote tracks. This is because react-native-webrtc does not react on new\n            // tracks generated within already existing streams, so force the streamId\n            // to be different. See:\n            // https://github.com/react-native-webrtc/react-native-webrtc/issues/401\n            logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\n            streamId += `-hack-${utils.generateRandomNumber()}`;\n            mapStreamId.set(trackId, streamId);\n            this._remoteSdp.receive({\n                mid,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { kind, rtpParameters } = options;\n            const mid = kind;\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { kind, trackId, rtpParameters } = options;\n            const localId = trackId;\n            const mid = kind;\n            const streamId = mapStreamId.get(trackId);\n            const stream = this._pc\n                .getRemoteStreams()\n                .find((s) => s.id === streamId);\n            const track = stream.getTrackById(localId);\n            if (!track) {\n                throw new Error('remote track not found');\n            }\n            // Insert into the map.\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\n            results.push({ localId, track });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n            // Remove from the map.\n            this._mapRecvLocalIdInfo.delete(localId);\n            this._remoteSdp.planBStopReceiving({\n                mid: mid,\n                offerRtpParameters: rtpParameters,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getReceiverStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.ReactNative = ReactNative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1JlYWN0TmF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELG1DQUFtQyxtQkFBTyxDQUFDLCtJQUFrQjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0tBQStLO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBOEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFO0FBQ0EsZ0JBQWdCLHVEQUF1RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1JlYWN0TmF0aXZlLmpzP2FjMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVhY3ROYXRpdmUgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3BsYW5CVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1JlYWN0TmF0aXZlJyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBSZWFjdE5hdGl2ZSBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBSZWFjdE5hdGl2ZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIE1hcCBvZiBzZW5kaW5nIE1lZGlhU3RyZWFtVHJhY2tzIGluZGV4ZWQgYnkgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjayA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBzZW5kaW5nIGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIE1hcCBvZiBNSUQsIFJUUCBwYXJhbWV0ZXJzIGFuZCBSVENSdHBSZWNlaXZlciBpbmRleGVkIGJ5IGxvY2FsIGlkLlxuICAgICAgICAvLyBWYWx1ZSBpcyBhbiBPYmplY3Qgd2l0aCBtaWQsIHJ0cFBhcmFtZXRlcnMgYW5kIHJ0cFJlY2VpdmVyLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1JlYWN0TmF0aXZlJztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBGcmVlL2Rpc3Bvc2UgbmF0aXZlIE1lZGlhU3RyZWFtIGJ1dCBETyBOT1QgZnJlZS9kaXNwb3NlIG5hdGl2ZVxuICAgICAgICAvLyBNZWRpYVN0cmVhbVRyYWNrcyAodGhhdCBpcyBwYXJlbnQncyBidXNpbmVzcykuXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgKHByb3ByaWV0YXJ5IEFQSSBpbiByZWFjdC1uYXRpdmUtd2VicnRjKS5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZWxlYXNlKC8qIHJlbGVhc2VUcmFja3MgKi8gZmFsc2UpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IGNvZGVjIHNlbGVjdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluICVzIGhhbmRsZXInLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9IG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycgJiYgZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICd2aWRlbycpO1xuICAgICAgICAgICAgc2RwUGxhbkJVdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID0gc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IG9yIEgyNjQgYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG9cbiAgICAgICAgLy8gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnIHx8XG4gICAgICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9oMjY0JykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ0wxVDMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBTdHJpbmcodGhpcy5fbmV4dFNlbmRMb2NhbElkKTtcbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkKys7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suc2V0KGxvY2FsSWQsIHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkU3RyZWFtKHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHRoZXJlIGFyZSBubyBzZW5kaW5nIHRyYWNrcywgc2V0TG9jYWxEZXNjcmlwdGlvbigpIHdpbGwgZmFpbCB3aXRoXG4gICAgICAgICAgICAvLyBcIkZhaWxlZCB0byBjcmVhdGUgY2hhbm5lbHNcIi4gSWYgc28sIGlnbm9yZSBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZW5kU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzdG9wU2VuZGluZygpIHwgaWdub3JpbmcgZXhwZWN0ZWQgZXJyb3IgZHVlIG5vIHNlbmRpbmcgdHJhY2tzOiAlcycsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHJlc3VtZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2soXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWQsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB0cmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsIC8vIE5PVEU6IE9sZCBzcGVjLlxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwU3RyZWFtSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgbGV0IHN0cmVhbUlkID0gb3B0aW9ucy5zdHJlYW1JZCB8fCBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWU7XG4gICAgICAgICAgICAvLyBOT1RFOiBJbiBSZWFjdC1OYXRpdmUgd2UgY2Fubm90IHJldXNlIHRoZSBzYW1lIHJlbW90ZSBNZWRpYVN0cmVhbSBmb3IgbmV3XG4gICAgICAgICAgICAvLyByZW1vdGUgdHJhY2tzLiBUaGlzIGlzIGJlY2F1c2UgcmVhY3QtbmF0aXZlLXdlYnJ0YyBkb2VzIG5vdCByZWFjdCBvbiBuZXdcbiAgICAgICAgICAgIC8vIHRyYWNrcyBnZW5lcmF0ZWQgd2l0aGluIGFscmVhZHkgZXhpc3Rpbmcgc3RyZWFtcywgc28gZm9yY2UgdGhlIHN0cmVhbUlkXG4gICAgICAgICAgICAvLyB0byBiZSBkaWZmZXJlbnQuIFNlZTpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1uYXRpdmUtd2VicnRjL3JlYWN0LW5hdGl2ZS13ZWJydGMvaXNzdWVzLzQwMVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBmb3JjaW5nIGEgcmFuZG9tIHJlbW90ZSBzdHJlYW1JZCB0byBhdm9pZCB3ZWxsIGtub3duIGJ1ZyBpbiByZWFjdC1uYXRpdmUtd2VicnRjJyk7XG4gICAgICAgICAgICBzdHJlYW1JZCArPSBgLWhhY2stJHt1dGlscy5nZW5lcmF0ZVJhbmRvbU51bWJlcigpfWA7XG4gICAgICAgICAgICBtYXBTdHJlYW1JZC5zZXQodHJhY2tJZCwgc3RyZWFtSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUlkID0gbWFwU3RyZWFtSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0UmVtb3RlU3RyZWFtcygpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHMpID0+IHMuaWQgPT09IHN0cmVhbUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gc3RyZWFtLmdldFRyYWNrQnlJZChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW90ZSB0cmFjayBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgbG9jYWxJZCwgdHJhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB7IG1pZCwgcnRwUGFyYW1ldGVycyB9ID0gdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmdldChsb2NhbElkKSB8fCB7fTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBsYW5CU3RvcFJlY2VpdmluZyh7XG4gICAgICAgICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlUmVjZWl2aW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkcykge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICBhc3luYyByZXN1bWVSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSwgLy8gTk9URTogT2xkIHNwZWMuXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZWFjdE5hdGl2ZSA9IFJlYWN0TmF0aXZlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNative.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReactNativeUnifiedPlan = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\"));\nconst ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js\"));\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('ReactNativeUnifiedPlan');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new ReactNativeUnifiedPlan();\n    }\n    constructor() {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'ReactNativeUnifiedPlan';\n    }\n    close() {\n        logger.debug('close()');\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        // Free/dispose native MediaStream but DO NOT free/dispose native\n        // MediaStreamTracks (that is parent's business).\n        // @ts-ignore (proprietary API in react-native-webrtc).\n        this._sendStream.release(/* releaseTracks */ false);\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            // libwebrtc supports NACK for OPUS but doesn't announce it.\n            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        this.assertNotClosed();\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        this.assertNotClosed();\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        this.assertNotClosed();\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        this.assertNotClosed();\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings && encodings.length > 1) {\n            encodings.forEach((encoding, idx) => {\n                encoding.rid = `r${idx}`;\n            });\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n            sendEncodings: encodings,\n        });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        // Special case for VP9 with SVC.\n        let hackVp9Svc = false;\n        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);\n        if (encodings &&\n            encodings.length === 1 &&\n            layers.spatialLayers > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n            logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n            hackVp9Svc = true;\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: layers.spatialLayers,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0\n        // because transceiver.mid is not available until setRemoteDescription()\n        // is called, so this is best effort.\n        // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404\n        // NOTE: So let's fill MID in sendingRtpParameters later.\n        // NOTE: This is fixed in react-native-webrtc 111.0.3.\n        let localId = transceiver.mid ?? undefined;\n        if (!localId) {\n            logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');\n        }\n        // Set MID.\n        // NOTE: As per above, it could be unset yet.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                offerMediaObject,\n            });\n            Object.assign(newEncodings[0], encodings[0]);\n            // Hack for VP9 SVC.\n            if (hackVp9Svc) {\n                newEncodings = [newEncodings[0]];\n            }\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim.\n        else {\n            sendingRtpParameters.encodings = encodings;\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                if (encoding.scalabilityMode) {\n                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;\n                }\n                else {\n                    encoding.scalabilityMode = 'L1T3';\n                }\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,\n        // we can read generated MID (if not done above) and fill sendingRtpParameters.\n        // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't\n        // needed starting from that version.\n        if (!localId) {\n            localId = transceiver.mid;\n            sendingRtpParameters.mid = localId;\n        }\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        if (this._closed) {\n            return;\n        }\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);\n        if (mediaSectionClosed) {\n            try {\n                transceiver.stop();\n            }\n            catch (error) { }\n        }\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    async pauseSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('pauseSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'inactive';\n        this._remoteSdp.pauseMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async resumeSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('resumeSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        this._remoteSdp.resumeSendingMediaSection(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'sendonly';\n        const offer = await this._pc.createOffer();\n        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            else {\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n                results.push({\n                    localId,\n                    track: transceiver.receiver.track,\n                    rtpReceiver: transceiver.receiver,\n                });\n            }\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        if (this._closed) {\n            return;\n        }\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('pauseReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'inactive';\n            this._remoteSdp.pauseMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async resumeReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('resumeReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'recvonly';\n            this._remoteSdp.resumeReceivingMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertNotClosed() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('method called in a closed handler');\n        }\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1JlYWN0TmF0aXZlVW5pZmllZFBsYW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixrQ0FBa0MsbUJBQU8sQ0FBQyxxSEFBZTtBQUN6RCxpQkFBaUIsbUJBQU8sQ0FBQyx1SEFBVztBQUNwQywyQkFBMkIsbUJBQU8sQ0FBQyxxSEFBVTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxtSEFBUztBQUMzQyxvQ0FBb0MsbUJBQU8sQ0FBQyxpSkFBbUI7QUFDL0QseUNBQXlDLG1CQUFPLENBQUMsMkpBQXdCO0FBQ3pFLCtCQUErQixtQkFBTyxDQUFDLHVJQUFjO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHVIQUFXO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLG1KQUFvQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyw2SUFBaUI7QUFDN0MsMkJBQTJCLG1CQUFPLENBQUMsMklBQXFCO0FBQ3hEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrS0FBK0s7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBOEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1JlYWN0TmF0aXZlVW5pZmllZFBsYW4uanM/NjZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBVbmlmaWVkUGxhblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpKTtcbmNvbnN0IG9ydGNVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9vcnRjL3V0aWxzXCIpKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1JlYWN0TmF0aXZlVW5pZmllZFBsYW4nKTtcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIFJlYWN0TmF0aXZlVW5pZmllZFBsYW4gZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgUmVhY3ROYXRpdmVVbmlmaWVkUGxhbigpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBNYXAgb2YgUlRDVHJhbnNjZWl2ZXJzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1JlYWN0TmF0aXZlVW5pZmllZFBsYW4nO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBGcmVlL2Rpc3Bvc2UgbmF0aXZlIE1lZGlhU3RyZWFtIGJ1dCBETyBOT1QgZnJlZS9kaXNwb3NlIG5hdGl2ZVxuICAgICAgICAvLyBNZWRpYVN0cmVhbVRyYWNrcyAodGhhdCBpcyBwYXJlbnQncyBidXNpbmVzcykuXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgKHByb3ByaWV0YXJ5IEFQSSBpbiByZWFjdC1uYXRpdmUtd2VicnRjKS5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZWxlYXNlKC8qIHJlbGVhc2VUcmFja3MgKi8gZmFsc2UpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbGlid2VicnRjIHN1cHBvcnRzIE5BQ0sgZm9yIE9QVVMgYnV0IGRvZXNuJ3QgYW5ub3VuY2UgaXQuXG4gICAgICAgICAgICBvcnRjVXRpbHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMucm9sZSAmJiBkdGxzUGFyYW1ldGVycy5yb2xlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPVxuICAgICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPT09ICdzZXJ2ZXInID8gJ2NsaWVudCcgOiAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucmlkID0gYHIke2lkeH1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwLmdldE5leHRNZWRpYVNlY3Rpb25JZHgoKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknLFxuICAgICAgICAgICAgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dLFxuICAgICAgICAgICAgc2VuZEVuY29kaW5nczogZW5jb2RpbmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBWUDkgd2l0aCBTVkMuXG4gICAgICAgIGxldCBoYWNrVnA5U3ZjID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxheWVycyA9ICgwLCBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2UpKChlbmNvZGluZ3MgfHwgW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJlxuICAgICAgICAgICAgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgbGF5ZXJzLnNwYXRpYWxMYXllcnMgPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOScpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCBmb3IgVlA5IFNWQycpO1xuICAgICAgICAgICAgaGFja1ZwOVN2YyA9IHRydWU7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogbGF5ZXJzLnNwYXRpYWxMYXllcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICAvLyBOT1RFOiBXZSBjYW5ub3QgcmVhZCBnZW5lcmF0ZWQgTUlEIG9uIGlPUyByZWFjdC1uYXRpdmUtd2VicnRjIDExMS4wLjBcbiAgICAgICAgLy8gYmVjYXVzZSB0cmFuc2NlaXZlci5taWQgaXMgbm90IGF2YWlsYWJsZSB1bnRpbCBzZXRSZW1vdGVEZXNjcmlwdGlvbigpXG4gICAgICAgIC8vIGlzIGNhbGxlZCwgc28gdGhpcyBpcyBiZXN0IGVmZm9ydC5cbiAgICAgICAgLy8gSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1uYXRpdmUtd2VicnRjL3JlYWN0LW5hdGl2ZS13ZWJydGMvaXNzdWVzLzE0MDRcbiAgICAgICAgLy8gTk9URTogU28gbGV0J3MgZmlsbCBNSUQgaW4gc2VuZGluZ1J0cFBhcmFtZXRlcnMgbGF0ZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZml4ZWQgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0YyAxMTEuMC4zLlxuICAgICAgICBsZXQgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZCA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbG9jYWxJZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IG1pc3NpbmcgdHJhbnNjZWl2ZXIubWlkIChidWcgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0YywgdXNpbmcgYSB3b3JrYXJvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgLy8gTk9URTogQXMgcGVyIGFib3ZlLCBpdCBjb3VsZCBiZSB1bnNldCB5ZXQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbmNvZGluZ3NbMF0sIGVuY29kaW5nc1swXSk7XG4gICAgICAgICAgICAvLyBIYWNrIGZvciBWUDkgU1ZDLlxuICAgICAgICAgICAgaWYgKGhhY2tWcDlTdmMpIHtcbiAgICAgICAgICAgICAgICBuZXdFbmNvZGluZ3MgPSBbbmV3RW5jb2RpbmdzWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGBMMVQke2xheWVycy50ZW1wb3JhbExheWVyc31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ0wxVDMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIEZvbGxvdyB1cCBvZiBpT1MgcmVhY3QtbmF0aXZlLXdlYnJ0YyAxMTEuMC4wIGlzc3VlIHRvbGQgYWJvdmUuIE5vdyB5ZXMsXG4gICAgICAgIC8vIHdlIGNhbiByZWFkIGdlbmVyYXRlZCBNSUQgKGlmIG5vdCBkb25lIGFib3ZlKSBhbmQgZmlsbCBzZW5kaW5nUnRwUGFyYW1ldGVycy5cbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBmaXhlZCBpbiByZWFjdC1uYXRpdmUtd2VicnRjIDExMS4wLjMgc28gdGhpcyBibG9jayBpc24ndFxuICAgICAgICAvLyBuZWVkZWQgc3RhcnRpbmcgZnJvbSB0aGF0IHZlcnNpb24uXG4gICAgICAgIGlmICghbG9jYWxJZCkge1xuICAgICAgICAgICAgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbkNsb3NlZCA9IHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBpZiAobWVkaWFTZWN0aW9uQ2xvc2VkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgIH1cbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGF1c2VNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVTZW5kaW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLm11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChsb2NhbElkLCBwYXJhbWV0ZXJzLmVuY29kaW5ncyk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUob3B0aW9uc0xpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwTG9jYWxJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgfHwgU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICAgICAgbWFwTG9jYWxJZC5zZXQodHJhY2tJZCwgbG9jYWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCB8fCBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBydHBQYXJhbWV0ZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxJZCA9IG1hcExvY2FsSWQuZ2V0KHRyYWNrSWQpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgICAgICB0cmFjazogdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wYXVzZU1lZGlhU2VjdGlvbihsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXN1bWVSZWNlaXZpbmcobG9jYWxJZHMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9jYWxJZCBvZiBsb2NhbElkcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdyZWN2b25seSc7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVzdW1lUmVjZWl2aW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCwgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KSB7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ21ldGhvZCBjYWxsZWQgaW4gYSBjbG9zZWQgaGFuZGxlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZWFjdE5hdGl2ZVVuaWZpZWRQbGFuID0gUmVhY3ROYXRpdmVVbmlmaWVkUGxhbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari11.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari11.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Safari11 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\"));\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Safari11');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Safari11 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Safari11();\n    }\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of RTCRtpSender indexed by localId.\n        this._mapSendLocalIdRtpSender = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Safari11';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addTrack(track, this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n            offerMediaObject,\n            track,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'L1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        const rtpSender = this._pc\n            .getSenders()\n            .find((s) => s.track === track);\n        // Insert into the map.\n        this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        if (rtpSender.track) {\n            this._sendStream.removeTrack(rtpSender.track);\n        }\n        this._mapSendLocalIdRtpSender.delete(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable') {\n            return;\n        }\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        // Unimplemented.\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        // Unimplemented.\n    }\n    async replaceTrack(localId, track) {\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        const oldTrack = rtpSender.track;\n        await rtpSender.replaceTrack(track);\n        // Remove the old track from the local stream.\n        if (oldTrack) {\n            this._sendStream.removeTrack(oldTrack);\n        }\n        // Add the new track to the local stream.\n        if (track) {\n            this._sendStream.addTrack(track);\n        }\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this.assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender) {\n            throw new Error('associated RTCRtpSender not found');\n        }\n        return rtpSender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertRecvDirection();\n        const results = [];\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const mid = kind;\n            this._remoteSdp.receive({\n                mid,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { kind, rtpParameters } = options;\n            const mid = kind;\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { kind, trackId, rtpParameters } = options;\n            const mid = kind;\n            const localId = trackId;\n            const rtpReceiver = this._pc\n                .getReceivers()\n                .find((r) => r.track && r.track.id === localId);\n            if (!rtpReceiver) {\n                throw new Error('new RTCRtpReceiver not');\n            }\n            // Insert into the map.\n            this._mapRecvLocalIdInfo.set(localId, {\n                mid,\n                rtpParameters,\n                rtpReceiver,\n            });\n            results.push({\n                localId,\n                track: rtpReceiver.track,\n                rtpReceiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n            // Remove from the map.\n            this._mapRecvLocalIdInfo.delete(localId);\n            this._remoteSdp.planBStopReceiving({\n                mid: mid,\n                offerRtpParameters: rtpParameters,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertRecvDirection();\n        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\n        if (!rtpReceiver) {\n            throw new Error('associated RTCRtpReceiver not found');\n        }\n        return rtpReceiver.getStats();\n    }\n    async pauseReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async resumeReceiving(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localIds) {\n        // Unimplemented.\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Safari11 = Safari11;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1NhZmFyaTExLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELG1DQUFtQyxtQkFBTyxDQUFDLCtJQUFrQjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtLQUErSztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQThEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBLGdCQUFnQix1REFBdUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTEuanM/ODkzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZhcmkxMSA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwUGxhbkJVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignU2FmYXJpMTEnKTtcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIFNhZmFyaTExIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IFNhZmFyaTExKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFNlbmRlciBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOZXh0IHNlbmRpbmcgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkID0gMDtcbiAgICAgICAgLy8gTWFwIG9mIE1JRCwgUlRQIHBhcmFtZXRlcnMgYW5kIFJUQ1J0cFJlY2VpdmVyIGluZGV4ZWQgYnkgbG9jYWwgaWQuXG4gICAgICAgIC8vIFZhbHVlIGlzIGFuIE9iamVjdCB3aXRoIG1pZCwgcnRwUGFyYW1ldGVycyBhbmQgcnRwUmVjZWl2ZXIuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnU2FmYXJpMTEnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAncGxhbi1iJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKHtcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoe1xuICAgICAgICAgICAgICAgIHNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkdGxzUGFyYW1ldGVycy5yb2xlICYmIGR0bHNQYXJhbWV0ZXJzLnJvbGUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA9XG4gICAgICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9PT0gJ3NlcnZlcicgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ0BpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3J1bigpIHwgcGMuY29ubmVjdGlvblN0YXRlIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIHBjLmljZUNvbm5lY3Rpb25TdGF0ZScpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzZW5kKCkgfCBjb2RlYyBzZWxlY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiAlcyBoYW5kbGVyJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPSBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nICYmIGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAndmlkZW8nKTtcbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09IHRyYWNrLmtpbmQpO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gc2RwUGxhbkJVdGlscy5nZXRSdHBFbmNvZGluZ3Moe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0byBlYWNoXG4gICAgICAgIC8vIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgIC5nZXRTZW5kZXJzKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLnNldChsb2NhbElkLCBydHBTZW5kZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydHBTZW5kZXIudHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2socnRwU2VuZGVyLnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBwYXVzZVNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICAvLyBVbmltcGxlbWVudGVkLlxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcmVzdW1lU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFRyYWNrID0gcnRwU2VuZGVyLnRyYWNrO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuICAgICAgICBpZiAob2xkVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBydHBTZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwU2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKG9wdGlvbnNMaXN0KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBvcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgbWlkID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkIHx8IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHJhY2tJZCwgcnRwUGFyYW1ldGVycyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhY2tJZDtcbiAgICAgICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgocikgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSBsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghcnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBSZWNlaXZlciBub3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHtcbiAgICAgICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgICAgIHRyYWNrOiBydHBSZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoe1xuICAgICAgICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgcnRwUmVjZWl2ZXIgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnRwUmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VSZWNlaXZpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWRzKSB7XG4gICAgICAgIC8vIFVuaW1wbGVtZW50ZWQuXG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZHMpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZC5cbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIHNldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QsIH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdCkge1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIGFzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TYWZhcmkxMSA9IFNhZmFyaTExO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari11.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari12.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari12.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Safari12 = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\"));\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\"));\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\"));\nconst ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js\"));\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Safari12');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Safari12 extends HandlerInterface_1.HandlerInterface {\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Safari12();\n    }\n    constructor() {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    get name() {\n        return 'Safari12';\n    }\n    close() {\n        logger.debug('close()');\n        if (this._closed) {\n            return;\n        }\n        this._closed = true;\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n        this.emit('@close');\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                sdpObject,\n            });\n            // libwebrtc supports NACK for OPUS but doesn't announce it.\n            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS,\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {\n        this.assertNotClosed();\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n        });\n        this._sendingRtpParametersByKind = {\n            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),\n        };\n        this._sendingRemoteRtpParametersByKind = {\n            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),\n        };\n        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {\n            this._forcedLocalDtlsRole =\n                dtlsParameters.role === 'server' ? 'client' : 'server';\n        }\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings,\n        }, proprietaryConstraints);\n        this._pc.addEventListener('icegatheringstatechange', () => {\n            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);\n        });\n        if (this._pc.connectionState) {\n            this._pc.addEventListener('connectionstatechange', () => {\n                this.emit('@connectionstatechange', this._pc.connectionState);\n            });\n        }\n        else {\n            this._pc.addEventListener('iceconnectionstatechange', () => {\n                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');\n                switch (this._pc.iceConnectionState) {\n                    case 'checking': {\n                        this.emit('@connectionstatechange', 'connecting');\n                        break;\n                    }\n                    case 'connected':\n                    case 'completed': {\n                        this.emit('@connectionstatechange', 'connected');\n                        break;\n                    }\n                    case 'failed': {\n                        this.emit('@connectionstatechange', 'failed');\n                        break;\n                    }\n                    case 'disconnected': {\n                        this.emit('@connectionstatechange', 'disconnected');\n                        break;\n                    }\n                    case 'closed': {\n                        this.emit('@connectionstatechange', 'closed');\n                        break;\n                    }\n                }\n            });\n        }\n    }\n    async updateIceServers(iceServers) {\n        this.assertNotClosed();\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        this.assertNotClosed();\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady) {\n            return;\n        }\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        this.assertNotClosed();\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n        });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);\n        if (encodings && encodings.length > 1) {\n            logger.debug('send() | enabling legacy simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: encodings.length,\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n            offerMediaObject,\n        });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n            offerMediaObject,\n        });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx]) {\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                }\n            }\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                if (encoding.scalabilityMode) {\n                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;\n                }\n                else {\n                    encoding.scalabilityMode = 'L1T3';\n                }\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender,\n        };\n    }\n    async stopSending(localId) {\n        this.assertSendDirection();\n        if (this._closed) {\n            return;\n        }\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);\n        if (mediaSectionClosed) {\n            try {\n                transceiver.stop();\n            }\n            catch (error) { }\n        }\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        this._mapMidTransceiver.delete(localId);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async pauseSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('pauseSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'inactive';\n        this._remoteSdp.pauseMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async resumeSending(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('resumeSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        transceiver.direction = 'sendonly';\n        this._remoteSdp.resumeSendingMediaSection(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer) {\n                encoding.active = true;\n            }\n            else {\n                encoding.active = false;\n            }\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);\n        const offer = await this._pc.createOffer();\n        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async getSenderStats(localId) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');\n            if (!this._transportReady) {\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits,\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive(optionsList) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const results = [];\n        const mapLocalId = new Map();\n        for (const options of optionsList) {\n            const { trackId, kind, rtpParameters, streamId } = options;\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n            mapLocalId.set(trackId, localId);\n            this._remoteSdp.receive({\n                mid: localId,\n                kind,\n                offerRtpParameters: rtpParameters,\n                streamId: streamId || rtpParameters.rtcp.cname,\n                trackId,\n            });\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        for (const options of optionsList) {\n            const { trackId, rtpParameters } = options;\n            const localId = mapLocalId.get(trackId);\n            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);\n            // May need to modify codec parameters in the answer based on codec\n            // parameters in the offer.\n            sdpCommonUtils.applyCodecParameters({\n                offerRtpParameters: rtpParameters,\n                answerMediaObject,\n            });\n        }\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady) {\n            await this.setupTransport({\n                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                localSdpObject,\n            });\n        }\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const options of optionsList) {\n            const { trackId } = options;\n            const localId = mapLocalId.get(trackId);\n            const transceiver = this._pc\n                .getTransceivers()\n                .find((t) => t.mid === localId);\n            if (!transceiver) {\n                throw new Error('new RTCRtpTransceiver not found');\n            }\n            // Store in the map.\n            this._mapMidTransceiver.set(localId, transceiver);\n            results.push({\n                localId,\n                track: transceiver.receiver.track,\n                rtpReceiver: transceiver.receiver,\n            });\n        }\n        return results;\n    }\n    async stopReceiving(localIds) {\n        this.assertRecvDirection();\n        if (this._closed) {\n            return;\n        }\n        for (const localId of localIds) {\n            logger.debug('stopReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            this._remoteSdp.closeMediaSection(transceiver.mid);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        for (const localId of localIds) {\n            this._mapMidTransceiver.delete(localId);\n        }\n    }\n    async pauseReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('pauseReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'inactive';\n            this._remoteSdp.pauseMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async resumeReceiving(localIds) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        for (const localId of localIds) {\n            logger.debug('resumeReceiving() [localId:%s]', localId);\n            const transceiver = this._mapMidTransceiver.get(localId);\n            if (!transceiver) {\n                throw new Error('associated RTCRtpTransceiver not found');\n            }\n            transceiver.direction = 'recvonly';\n            this._remoteSdp.resumeReceivingMediaSection(localId);\n        }\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver) {\n            throw new Error('associated RTCRtpTransceiver not found');\n        }\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {\n        this.assertNotClosed();\n        this.assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this.setupTransport({\n                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',\n                    localSdpObject,\n                });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async setupTransport({ localDtlsRole, localSdpObject, }) {\n        if (!localSdpObject) {\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        }\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n            sdpObject: localSdpObject,\n        });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await new Promise((resolve, reject) => {\n            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);\n        });\n        this._transportReady = true;\n    }\n    assertNotClosed() {\n        if (this._closed) {\n            throw new errors_1.InvalidStateError('method called in a closed handler');\n        }\n    }\n    assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Safari12 = Safari12;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL1NhZmFyaTEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMscUhBQWU7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQVc7QUFDcEMsMkJBQTJCLG1CQUFPLENBQUMscUhBQVU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUhBQVM7QUFDM0Msb0NBQW9DLG1CQUFPLENBQUMsaUpBQW1CO0FBQy9ELHlDQUF5QyxtQkFBTyxDQUFDLDJKQUF3QjtBQUN6RSwrQkFBK0IsbUJBQU8sQ0FBQyx1SUFBYztBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx1SEFBVztBQUNwQywyQkFBMkIsbUJBQU8sQ0FBQyxtSkFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNklBQWlCO0FBQzdDLDJCQUEyQixtQkFBTyxDQUFDLDJJQUFxQjtBQUN4RDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrS0FBK0s7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBOEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUF3RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTIuanM/YzFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZhcmkxMiA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKSk7XG5jb25zdCBvcnRjVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Yy91dGlsc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3Qgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4uL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdTYWZhcmkxMicpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgU2FmYXJpMTIgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgU2FmYXJpMTIoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdTYWZhcmkxMic7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHtcbiAgICAgICAgICAgICAgICBzZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGxpYndlYnJ0YyBzdXBwb3J0cyBOQUNLIGZvciBPUFVTIGJ1dCBkb2Vzbid0IGFubm91bmNlIGl0LlxuICAgICAgICAgICAgb3J0Y1V0aWxzLmFkZE5hY2tTdXBwcG9ydEZvck9wdXMobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB9KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzLnJvbGUgJiYgZHRsc1BhcmFtZXRlcnMucm9sZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID1cbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID09PSAnc2VydmVyJyA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybigncnVuKCkgfCBwYy5jb25uZWN0aW9uU3RhdGUgbm90IHN1cHBvcnRlZCwgdXNpbmcgcGMuaWNlQ29ubmVjdGlvblN0YXRlJyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbklkeCA9IHRoaXMuX3JlbW90ZVNkcC5nZXROZXh0TWVkaWFTZWN0aW9uSWR4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgICAgIHN0cmVhbXM6IFt0aGlzLl9zZW5kU3RyZWFtXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFRyYW5zcG9ydCh7XG4gICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheWVycyA9ICgwLCBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2UpKChlbmNvZGluZ3MgfHwgW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9IHNkcENvbW1vblV0aWxzLmdldENuYW1lKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gc2RwVW5pZmllZFBsYW5VdGlscy5nZXRSdHBFbmNvZGluZ3Moe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSwgZW5jb2RpbmdzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGBMMVQke2xheWVycy50ZW1wb3JhbExheWVyc31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ0wxVDMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbkNsb3NlZCA9IHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBpZiAobWVkaWFTZWN0aW9uQ2xvc2VkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZGVsZXRlKGxvY2FsSWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgcGF1c2VTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2VTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyByZXN1bWVTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVTZW5kaW5nTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcikge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAubXV4TWVkaWFTZWN0aW9uU2ltdWxjYXN0KGxvY2FsSWQsIHBhcmFtZXRlcnMuZW5jb2RpbmdzKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5tdXhNZWRpYVNlY3Rpb25TaW11bGNhc3QobG9jYWxJZCwgcGFyYW1ldGVycy5lbmNvZGluZ3MpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgfSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbER0bHNSb2xlOiB0aGlzLl9mb3JjZWRMb2NhbER0bHNSb2xlID8/ICdjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZShvcHRpb25zTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBtYXBMb2NhbElkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycywgc3RyZWFtSWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCB8fCBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgICAgICBtYXBMb2NhbElkLnNldCh0cmFja0lkLCBsb2NhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICBtaWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkIHx8IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNrSWQsIHJ0cFBhcmFtZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbElkID0gbWFwTG9jYWxJZC5nZXQodHJhY2tJZCk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0dXBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGxvY2FsRHRsc1JvbGU6IHRoaXMuX2ZvcmNlZExvY2FsRHRsc1JvbGUgPz8gJ2NsaWVudCcsXG4gICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2tJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsSWQgPSBtYXBMb2NhbElkLmdldCh0cmFja0lkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGNcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWRzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsSWQgb2YgbG9jYWxJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXVzZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBhdXNlTWVkaWFTZWN0aW9uKGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZVJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZVJlY2VpdmluZyhsb2NhbElkcykge1xuICAgICAgICB0aGlzLmFzc2VydE5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLmFzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbElkIG9mIGxvY2FsSWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3VtZVJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZXN1bWVSZWNlaXZpbmdNZWRpYVNlY3Rpb24obG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWVSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wsIH0pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHVwVHJhbnNwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEdGxzUm9sZTogdGhpcy5fZm9yY2VkTG9jYWxEdGxzUm9sZSA/PyAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBzZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0LCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnROb3RDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbWV0aG9kIGNhbGxlZCBpbiBhIGNsb3NlZCBoYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNhZmFyaTEyID0gU2FmYXJpMTI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/Safari12.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mangleRtpParameters = exports.getCapabilities = void 0;\nconst utils = __importStar(__webpack_require__(/*! ../../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\n/**\n * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full\n * compliant ORTC RTCRtpCapabilities.\n */\nfunction getCapabilities() {\n    const nativeCaps = RTCRtpReceiver.getCapabilities();\n    const caps = utils.clone(nativeCaps);\n    for (const codec of caps.codecs ?? []) {\n        // Rename numChannels to channels.\n        // @ts-ignore\n        codec.channels = codec.numChannels;\n        // @ts-ignore\n        delete codec.numChannels;\n        // Add mimeType.\n        // @ts-ignore (due to codec.name).\n        codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;\n        // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.\n        if (codec.parameters) {\n            const parameters = codec.parameters;\n            if (parameters.apt) {\n                parameters.apt = Number(parameters.apt);\n            }\n            if (parameters['packetization-mode']) {\n                parameters['packetization-mode'] = Number(parameters['packetization-mode']);\n            }\n        }\n        // Delete emty parameter String in rtcpFeedback.\n        for (const feedback of codec.rtcpFeedback || []) {\n            if (!feedback.parameter) {\n                feedback.parameter = '';\n            }\n        }\n    }\n    return caps;\n}\nexports.getCapabilities = getCapabilities;\n/**\n * Generate RTCRtpParameters as ORTC based Edge likes.\n */\nfunction mangleRtpParameters(rtpParameters) {\n    const params = utils.clone(rtpParameters);\n    // Rename mid to muxId.\n    if (params.mid) {\n        // @ts-ignore (due to muxId).\n        params.muxId = params.mid;\n        delete params.mid;\n    }\n    for (const codec of params.codecs) {\n        // Rename channels to numChannels.\n        if (codec.channels) {\n            // @ts-ignore.\n            codec.numChannels = codec.channels;\n            delete codec.channels;\n        }\n        // Add codec.name (requried by Edge).\n        // @ts-ignore (due to name).\n        if (codec.mimeType && !codec.name) {\n            // @ts-ignore (due to name).\n            codec.name = codec.mimeType.split('/')[1];\n        }\n        // Remove mimeType.\n        // @ts-ignore\n        delete codec.mimeType;\n    }\n    return params;\n}\nexports.mangleRtpParameters = mangleRtpParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL29ydGMvZWRnZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyx1QkFBdUI7QUFDckQsMkJBQTJCLG1CQUFPLENBQUMsd0hBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsR0FBRyxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvb3J0Yy9lZGdlVXRpbHMuanM/ZjBmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYW5nbGVSdHBQYXJhbWV0ZXJzID0gZXhwb3J0cy5nZXRDYXBhYmlsaXRpZXMgPSB2b2lkIDA7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vdXRpbHNcIikpO1xuLyoqXG4gKiBOb3JtYWxpemUgT1JUQyBiYXNlZCBFZGdlJ3MgUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCkgdG8gcHJvZHVjZSBhIGZ1bGxcbiAqIGNvbXBsaWFudCBPUlRDIFJUQ1J0cENhcGFiaWxpdGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FwYWJpbGl0aWVzKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNhcHMgPSBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICBjb25zdCBjYXBzID0gdXRpbHMuY2xvbmUobmF0aXZlQ2Fwcyk7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBzLmNvZGVjcyA/PyBbXSkge1xuICAgICAgICAvLyBSZW5hbWUgbnVtQ2hhbm5lbHMgdG8gY2hhbm5lbHMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29kZWMuY2hhbm5lbHMgPSBjb2RlYy5udW1DaGFubmVscztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkZWxldGUgY29kZWMubnVtQ2hhbm5lbHM7XG4gICAgICAgIC8vIEFkZCBtaW1lVHlwZS5cbiAgICAgICAgLy8gQHRzLWlnbm9yZSAoZHVlIHRvIGNvZGVjLm5hbWUpLlxuICAgICAgICBjb2RlYy5taW1lVHlwZSA9IGNvZGVjLm1pbWVUeXBlIHx8IGAke2NvZGVjLmtpbmR9LyR7Y29kZWMubmFtZX1gO1xuICAgICAgICAvLyBOT1RFOiBFZGdlIHNldHMgc29tZSBudW1lcmljIHBhcmFtZXRlcnMgYXMgc3RyaW5nIHJhdGhlciB0aGFuIG51bWJlci4gRml4IHRoZW0uXG4gICAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gY29kZWMucGFyYW1ldGVycztcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYXB0ID0gTnVtYmVyKHBhcmFtZXRlcnMuYXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSkge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbJ3BhY2tldGl6YXRpb24tbW9kZSddID0gTnVtYmVyKHBhcmFtZXRlcnNbJ3BhY2tldGl6YXRpb24tbW9kZSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgZW10eSBwYXJhbWV0ZXIgU3RyaW5nIGluIHJ0Y3BGZWVkYmFjay5cbiAgICAgICAgZm9yIChjb25zdCBmZWVkYmFjayBvZiBjb2RlYy5ydGNwRmVlZGJhY2sgfHwgW10pIHtcbiAgICAgICAgICAgIGlmICghZmVlZGJhY2sucGFyYW1ldGVyKSB7XG4gICAgICAgICAgICAgICAgZmVlZGJhY2sucGFyYW1ldGVyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhcHM7XG59XG5leHBvcnRzLmdldENhcGFiaWxpdGllcyA9IGdldENhcGFiaWxpdGllcztcbi8qKlxuICogR2VuZXJhdGUgUlRDUnRwUGFyYW1ldGVycyBhcyBPUlRDIGJhc2VkIEVkZ2UgbGlrZXMuXG4gKi9cbmZ1bmN0aW9uIG1hbmdsZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLmNsb25lKHJ0cFBhcmFtZXRlcnMpO1xuICAgIC8vIFJlbmFtZSBtaWQgdG8gbXV4SWQuXG4gICAgaWYgKHBhcmFtcy5taWQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAoZHVlIHRvIG11eElkKS5cbiAgICAgICAgcGFyYW1zLm11eElkID0gcGFyYW1zLm1pZDtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy5taWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29kZWMgb2YgcGFyYW1zLmNvZGVjcykge1xuICAgICAgICAvLyBSZW5hbWUgY2hhbm5lbHMgdG8gbnVtQ2hhbm5lbHMuXG4gICAgICAgIGlmIChjb2RlYy5jaGFubmVscykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZS5cbiAgICAgICAgICAgIGNvZGVjLm51bUNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICBkZWxldGUgY29kZWMuY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNvZGVjLm5hbWUgKHJlcXVyaWVkIGJ5IEVkZ2UpLlxuICAgICAgICAvLyBAdHMtaWdub3JlIChkdWUgdG8gbmFtZSkuXG4gICAgICAgIGlmIChjb2RlYy5taW1lVHlwZSAmJiAhY29kZWMubmFtZSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAoZHVlIHRvIG5hbWUpLlxuICAgICAgICAgICAgY29kZWMubmFtZSA9IGNvZGVjLm1pbWVUeXBlLnNwbGl0KCcvJylbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIG1pbWVUeXBlLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSBjb2RlYy5taW1lVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmV4cG9ydHMubWFuZ2xlUnRwUGFyYW1ldGVycyA9IG1hbmdsZVJ0cFBhcmFtZXRlcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addNackSuppportForOpus = void 0;\n/**\n * This function adds RTCP NACK support for OPUS codec in given capabilities.\n */\nfunction addNackSuppportForOpus(rtpCapabilities) {\n    for (const codec of rtpCapabilities.codecs || []) {\n        if ((codec.mimeType.toLowerCase() === 'audio/opus' ||\n            codec.mimeType.toLowerCase() === 'audio/multiopus') &&\n            !codec.rtcpFeedback?.some(fb => fb.type === 'nack' && !fb.parameter)) {\n            if (!codec.rtcpFeedback) {\n                codec.rtcpFeedback = [];\n            }\n            codec.rtcpFeedback.push({ type: 'nack' });\n        }\n    }\n}\nexports.addNackSuppportForOpus = addNackSuppportForOpus;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL29ydGMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL29ydGMvdXRpbHMuanM/ZjI4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyA9IHZvaWQgMDtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGRzIFJUQ1AgTkFDSyBzdXBwb3J0IGZvciBPUFVTIGNvZGVjIGluIGdpdmVuIGNhcGFiaWxpdGllcy5cbiAqL1xuZnVuY3Rpb24gYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyhydHBDYXBhYmlsaXRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIHJ0cENhcGFiaWxpdGllcy5jb2RlY3MgfHwgW10pIHtcbiAgICAgICAgaWYgKChjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8vb3B1cycgfHxcbiAgICAgICAgICAgIGNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpby9tdWx0aW9wdXMnKSAmJlxuICAgICAgICAgICAgIWNvZGVjLnJ0Y3BGZWVkYmFjaz8uc29tZShmYiA9PiBmYi50eXBlID09PSAnbmFjaycgJiYgIWZiLnBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIGlmICghY29kZWMucnRjcEZlZWRiYWNrKSB7XG4gICAgICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaCh7IHR5cGU6ICduYWNrJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYWRkTmFja1N1cHBwb3J0Rm9yT3B1cyA9IGFkZE5hY2tTdXBwcG9ydEZvck9wdXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/ortc/utils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst utils = __importStar(__webpack_require__(/*! ../../utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nclass MediaSection {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false, }) {\n        this._mediaObject = {};\n        this._planB = planB;\n        if (iceParameters) {\n            this.setIceParameters(iceParameters);\n        }\n        if (iceCandidates) {\n            this._mediaObject.candidates = [];\n            for (const candidate of iceCandidates) {\n                const candidateObject = {};\n                // mediasoup does mandates rtcp-mux so candidates component is always\n                // RTP (1).\n                candidateObject.component = 1;\n                candidateObject.foundation = candidate.foundation;\n                candidateObject.ip = candidate.ip;\n                candidateObject.port = candidate.port;\n                candidateObject.priority = candidate.priority;\n                candidateObject.transport = candidate.protocol;\n                candidateObject.type = candidate.type;\n                if (candidate.tcpType) {\n                    candidateObject.tcptype = candidate.tcpType;\n                }\n                this._mediaObject.candidates.push(candidateObject);\n            }\n            this._mediaObject.endOfCandidates = 'end-of-candidates';\n            this._mediaObject.iceOptions = 'renomination';\n        }\n        if (dtlsParameters) {\n            this.setDtlsRole(dtlsParameters.role);\n        }\n    }\n    get mid() {\n        return String(this._mediaObject.mid);\n    }\n    get closed() {\n        return this._mediaObject.port === 0;\n    }\n    getObject() {\n        return this._mediaObject;\n    }\n    setIceParameters(iceParameters) {\n        this._mediaObject.iceUfrag = iceParameters.usernameFragment;\n        this._mediaObject.icePwd = iceParameters.password;\n    }\n    pause() {\n        this._mediaObject.direction = 'inactive';\n    }\n    disable() {\n        this.pause();\n        delete this._mediaObject.ext;\n        delete this._mediaObject.ssrcs;\n        delete this._mediaObject.ssrcGroups;\n        delete this._mediaObject.simulcast;\n        delete this._mediaObject.simulcast_03;\n        delete this._mediaObject.rids;\n        delete this._mediaObject.extmapAllowMixed;\n    }\n    close() {\n        this.disable();\n        this._mediaObject.port = 0;\n    }\n}\nexports.MediaSection = MediaSection;\nclass AnswerMediaSection extends MediaSection {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false, }) {\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\n        this._mediaObject.mid = String(offerMediaObject.mid);\n        this._mediaObject.type = offerMediaObject.type;\n        this._mediaObject.protocol = offerMediaObject.protocol;\n        if (!plainRtpParameters) {\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\n            this._mediaObject.port = 7;\n        }\n        else {\n            this._mediaObject.connection = {\n                ip: plainRtpParameters.ip,\n                version: plainRtpParameters.ipVersion,\n            };\n            this._mediaObject.port = plainRtpParameters.port;\n        }\n        switch (offerMediaObject.type) {\n            case 'audio':\n            case 'video': {\n                this._mediaObject.direction = 'recvonly';\n                this._mediaObject.rtp = [];\n                this._mediaObject.rtcpFb = [];\n                this._mediaObject.fmtp = [];\n                for (const codec of answerRtpParameters.codecs) {\n                    const rtp = {\n                        payload: codec.payloadType,\n                        codec: getCodecName(codec),\n                        rate: codec.clockRate,\n                    };\n                    if (codec.channels > 1) {\n                        rtp.encoding = codec.channels;\n                    }\n                    this._mediaObject.rtp.push(rtp);\n                    const codecParameters = utils.clone(codec.parameters) ?? {};\n                    let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];\n                    if (codecOptions) {\n                        const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate, } = codecOptions;\n                        const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);\n                        switch (codec.mimeType.toLowerCase()) {\n                            case 'audio/opus':\n                            case 'audio/multiopus': {\n                                if (opusStereo !== undefined) {\n                                    offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;\n                                    codecParameters.stereo = opusStereo ? 1 : 0;\n                                }\n                                if (opusFec !== undefined) {\n                                    offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;\n                                    codecParameters.useinbandfec = opusFec ? 1 : 0;\n                                }\n                                if (opusDtx !== undefined) {\n                                    offerCodec.parameters.usedtx = opusDtx ? 1 : 0;\n                                    codecParameters.usedtx = opusDtx ? 1 : 0;\n                                }\n                                if (opusMaxPlaybackRate !== undefined) {\n                                    codecParameters.maxplaybackrate = opusMaxPlaybackRate;\n                                }\n                                if (opusMaxAverageBitrate !== undefined) {\n                                    codecParameters.maxaveragebitrate = opusMaxAverageBitrate;\n                                }\n                                if (opusPtime !== undefined) {\n                                    offerCodec.parameters.ptime = opusPtime;\n                                    codecParameters.ptime = opusPtime;\n                                }\n                                // If opusNack is not set, we must remove NACK support for OPUS.\n                                // Otherwise it would be enabled for those handlers that artificially\n                                // announce it in their RTP capabilities.\n                                if (!opusNack) {\n                                    offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);\n                                    codecRtcpFeedback = codecRtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);\n                                }\n                                break;\n                            }\n                            case 'video/vp8':\n                            case 'video/vp9':\n                            case 'video/h264':\n                            case 'video/h265': {\n                                if (videoGoogleStartBitrate !== undefined) {\n                                    codecParameters['x-google-start-bitrate'] =\n                                        videoGoogleStartBitrate;\n                                }\n                                if (videoGoogleMaxBitrate !== undefined) {\n                                    codecParameters['x-google-max-bitrate'] =\n                                        videoGoogleMaxBitrate;\n                                }\n                                if (videoGoogleMinBitrate !== undefined) {\n                                    codecParameters['x-google-min-bitrate'] =\n                                        videoGoogleMinBitrate;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    const fmtp = {\n                        payload: codec.payloadType,\n                        config: '',\n                    };\n                    for (const key of Object.keys(codecParameters)) {\n                        if (fmtp.config) {\n                            fmtp.config += ';';\n                        }\n                        fmtp.config += `${key}=${codecParameters[key]}`;\n                    }\n                    if (fmtp.config) {\n                        this._mediaObject.fmtp.push(fmtp);\n                    }\n                    for (const fb of codecRtcpFeedback) {\n                        this._mediaObject.rtcpFb.push({\n                            payload: codec.payloadType,\n                            type: fb.type,\n                            subtype: fb.parameter,\n                        });\n                    }\n                }\n                this._mediaObject.payloads = answerRtpParameters.codecs\n                    .map((codec) => codec.payloadType)\n                    .join(' ');\n                this._mediaObject.ext = [];\n                for (const ext of answerRtpParameters.headerExtensions) {\n                    // Don't add a header extension if not present in the offer.\n                    const found = (offerMediaObject.ext || []).some((localExt) => localExt.uri === ext.uri);\n                    if (!found) {\n                        continue;\n                    }\n                    this._mediaObject.ext.push({\n                        uri: ext.uri,\n                        value: ext.id,\n                    });\n                }\n                // Allow both 1 byte and 2 bytes length header extensions.\n                if (extmapAllowMixed &&\n                    offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {\n                    this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';\n                }\n                // Simulcast.\n                if (offerMediaObject.simulcast) {\n                    this._mediaObject.simulcast = {\n                        dir1: 'recv',\n                        list1: offerMediaObject.simulcast.list1,\n                    };\n                    this._mediaObject.rids = [];\n                    for (const rid of offerMediaObject.rids || []) {\n                        if (rid.direction !== 'send') {\n                            continue;\n                        }\n                        this._mediaObject.rids.push({\n                            id: rid.id,\n                            direction: 'recv',\n                        });\n                    }\n                }\n                // Simulcast (draft version 03).\n                else if (offerMediaObject.simulcast_03) {\n                    // eslint-disable-next-line camelcase\n                    this._mediaObject.simulcast_03 = {\n                        value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv'),\n                    };\n                    this._mediaObject.rids = [];\n                    for (const rid of offerMediaObject.rids || []) {\n                        if (rid.direction !== 'send') {\n                            continue;\n                        }\n                        this._mediaObject.rids.push({\n                            id: rid.id,\n                            direction: 'recv',\n                        });\n                    }\n                }\n                this._mediaObject.rtcpMux = 'rtcp-mux';\n                this._mediaObject.rtcpRsize = 'rtcp-rsize';\n                if (this._planB && this._mediaObject.type === 'video') {\n                    this._mediaObject.xGoogleFlag = 'conference';\n                }\n                break;\n            }\n            case 'application': {\n                // New spec.\n                if (typeof offerMediaObject.sctpPort === 'number') {\n                    this._mediaObject.payloads = 'webrtc-datachannel';\n                    this._mediaObject.sctpPort = sctpParameters.port;\n                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\n                }\n                // Old spec.\n                else if (offerMediaObject.sctpmap) {\n                    this._mediaObject.payloads = sctpParameters.port;\n                    this._mediaObject.sctpmap = {\n                        app: 'webrtc-datachannel',\n                        sctpmapNumber: sctpParameters.port,\n                        maxMessageSize: sctpParameters.maxMessageSize,\n                    };\n                }\n                break;\n            }\n        }\n    }\n    setDtlsRole(role) {\n        switch (role) {\n            case 'client': {\n                this._mediaObject.setup = 'active';\n                break;\n            }\n            case 'server': {\n                this._mediaObject.setup = 'passive';\n                break;\n            }\n            case 'auto': {\n                this._mediaObject.setup = 'actpass';\n                break;\n            }\n        }\n    }\n    resume() {\n        this._mediaObject.direction = 'recvonly';\n    }\n    muxSimulcastStreams(encodings) {\n        if (!this._mediaObject.simulcast || !this._mediaObject.simulcast.list1) {\n            return;\n        }\n        const layers = {};\n        for (const encoding of encodings) {\n            if (encoding.rid) {\n                layers[encoding.rid] = encoding;\n            }\n        }\n        const raw = this._mediaObject.simulcast.list1;\n        const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);\n        for (const simulcastStream of simulcastStreams) {\n            for (const simulcastFormat of simulcastStream) {\n                simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;\n            }\n        }\n        this._mediaObject.simulcast.list1 = simulcastStreams\n            .map(simulcastFormats => simulcastFormats.map(f => `${f.paused ? '~' : ''}${f.scid}`).join(','))\n            .join(';');\n    }\n}\nexports.AnswerMediaSection = AnswerMediaSection;\nclass OfferMediaSection extends MediaSection {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false, }) {\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\n        this._mediaObject.mid = String(mid);\n        this._mediaObject.type = kind;\n        if (!plainRtpParameters) {\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\n            if (!sctpParameters) {\n                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';\n            }\n            else {\n                this._mediaObject.protocol = 'UDP/DTLS/SCTP';\n            }\n            this._mediaObject.port = 7;\n        }\n        else {\n            this._mediaObject.connection = {\n                ip: plainRtpParameters.ip,\n                version: plainRtpParameters.ipVersion,\n            };\n            this._mediaObject.protocol = 'RTP/AVP';\n            this._mediaObject.port = plainRtpParameters.port;\n        }\n        switch (kind) {\n            case 'audio':\n            case 'video': {\n                this._mediaObject.direction = 'sendonly';\n                this._mediaObject.rtp = [];\n                this._mediaObject.rtcpFb = [];\n                this._mediaObject.fmtp = [];\n                if (!this._planB) {\n                    this._mediaObject.msid = `${streamId || '-'} ${trackId}`;\n                }\n                for (const codec of offerRtpParameters.codecs) {\n                    const rtp = {\n                        payload: codec.payloadType,\n                        codec: getCodecName(codec),\n                        rate: codec.clockRate,\n                    };\n                    if (codec.channels > 1) {\n                        rtp.encoding = codec.channels;\n                    }\n                    this._mediaObject.rtp.push(rtp);\n                    const fmtp = {\n                        payload: codec.payloadType,\n                        config: '',\n                    };\n                    for (const key of Object.keys(codec.parameters)) {\n                        if (fmtp.config) {\n                            fmtp.config += ';';\n                        }\n                        fmtp.config += `${key}=${codec.parameters[key]}`;\n                    }\n                    if (fmtp.config) {\n                        this._mediaObject.fmtp.push(fmtp);\n                    }\n                    for (const fb of codec.rtcpFeedback) {\n                        this._mediaObject.rtcpFb.push({\n                            payload: codec.payloadType,\n                            type: fb.type,\n                            subtype: fb.parameter,\n                        });\n                    }\n                }\n                this._mediaObject.payloads = offerRtpParameters.codecs\n                    .map((codec) => codec.payloadType)\n                    .join(' ');\n                this._mediaObject.ext = [];\n                for (const ext of offerRtpParameters.headerExtensions) {\n                    this._mediaObject.ext.push({\n                        uri: ext.uri,\n                        value: ext.id,\n                    });\n                }\n                this._mediaObject.rtcpMux = 'rtcp-mux';\n                this._mediaObject.rtcpRsize = 'rtcp-rsize';\n                const encoding = offerRtpParameters.encodings[0];\n                const ssrc = encoding.ssrc;\n                const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;\n                this._mediaObject.ssrcs = [];\n                this._mediaObject.ssrcGroups = [];\n                if (offerRtpParameters.rtcp.cname) {\n                    this._mediaObject.ssrcs.push({\n                        id: ssrc,\n                        attribute: 'cname',\n                        value: offerRtpParameters.rtcp.cname,\n                    });\n                }\n                if (this._planB) {\n                    this._mediaObject.ssrcs.push({\n                        id: ssrc,\n                        attribute: 'msid',\n                        value: `${streamId || '-'} ${trackId}`,\n                    });\n                }\n                if (rtxSsrc) {\n                    if (offerRtpParameters.rtcp.cname) {\n                        this._mediaObject.ssrcs.push({\n                            id: rtxSsrc,\n                            attribute: 'cname',\n                            value: offerRtpParameters.rtcp.cname,\n                        });\n                    }\n                    if (this._planB) {\n                        this._mediaObject.ssrcs.push({\n                            id: rtxSsrc,\n                            attribute: 'msid',\n                            value: `${streamId || '-'} ${trackId}`,\n                        });\n                    }\n                    // Associate original and retransmission SSRCs.\n                    this._mediaObject.ssrcGroups.push({\n                        semantics: 'FID',\n                        ssrcs: `${ssrc} ${rtxSsrc}`,\n                    });\n                }\n                break;\n            }\n            case 'application': {\n                // New spec.\n                if (!oldDataChannelSpec) {\n                    this._mediaObject.payloads = 'webrtc-datachannel';\n                    this._mediaObject.sctpPort = sctpParameters.port;\n                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\n                }\n                // Old spec.\n                else {\n                    this._mediaObject.payloads = sctpParameters.port;\n                    this._mediaObject.sctpmap = {\n                        app: 'webrtc-datachannel',\n                        sctpmapNumber: sctpParameters.port,\n                        maxMessageSize: sctpParameters.maxMessageSize,\n                    };\n                }\n                break;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setDtlsRole(role) {\n        // Always 'actpass'.\n        this._mediaObject.setup = 'actpass';\n    }\n    resume() {\n        this._mediaObject.direction = 'sendonly';\n    }\n    planBReceive({ offerRtpParameters, streamId, trackId, }) {\n        const encoding = offerRtpParameters.encodings[0];\n        const ssrc = encoding.ssrc;\n        const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;\n        const payloads = this._mediaObject.payloads.split(' ');\n        for (const codec of offerRtpParameters.codecs) {\n            if (payloads.includes(String(codec.payloadType))) {\n                continue;\n            }\n            const rtp = {\n                payload: codec.payloadType,\n                codec: getCodecName(codec),\n                rate: codec.clockRate,\n            };\n            if (codec.channels > 1) {\n                rtp.encoding = codec.channels;\n            }\n            this._mediaObject.rtp.push(rtp);\n            const fmtp = {\n                payload: codec.payloadType,\n                config: '',\n            };\n            for (const key of Object.keys(codec.parameters)) {\n                if (fmtp.config) {\n                    fmtp.config += ';';\n                }\n                fmtp.config += `${key}=${codec.parameters[key]}`;\n            }\n            if (fmtp.config) {\n                this._mediaObject.fmtp.push(fmtp);\n            }\n            for (const fb of codec.rtcpFeedback) {\n                this._mediaObject.rtcpFb.push({\n                    payload: codec.payloadType,\n                    type: fb.type,\n                    subtype: fb.parameter,\n                });\n            }\n        }\n        this._mediaObject.payloads += ` ${offerRtpParameters.codecs\n            .filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType))\n            .map((codec) => codec.payloadType)\n            .join(' ')}`;\n        this._mediaObject.payloads = this._mediaObject.payloads.trim();\n        if (offerRtpParameters.rtcp.cname) {\n            this._mediaObject.ssrcs.push({\n                id: ssrc,\n                attribute: 'cname',\n                value: offerRtpParameters.rtcp.cname,\n            });\n        }\n        this._mediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'msid',\n            value: `${streamId || '-'} ${trackId}`,\n        });\n        if (rtxSsrc) {\n            if (offerRtpParameters.rtcp.cname) {\n                this._mediaObject.ssrcs.push({\n                    id: rtxSsrc,\n                    attribute: 'cname',\n                    value: offerRtpParameters.rtcp.cname,\n                });\n            }\n            this._mediaObject.ssrcs.push({\n                id: rtxSsrc,\n                attribute: 'msid',\n                value: `${streamId || '-'} ${trackId}`,\n            });\n            // Associate original and retransmission SSRCs.\n            this._mediaObject.ssrcGroups.push({\n                semantics: 'FID',\n                ssrcs: `${ssrc} ${rtxSsrc}`,\n            });\n        }\n    }\n    planBStopReceiving({ offerRtpParameters, }) {\n        const encoding = offerRtpParameters.encodings[0];\n        const ssrc = encoding.ssrc;\n        const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;\n        this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s) => s.id !== ssrc && s.id !== rtxSsrc);\n        if (rtxSsrc) {\n            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);\n        }\n    }\n}\nexports.OfferMediaSection = OfferMediaSection;\nfunction getCodecName(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    return mimeTypeMatch[2];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9NZWRpYVNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLG9CQUFvQjtBQUM3RSxrQ0FBa0MsbUJBQU8sQ0FBQyxxSEFBZTtBQUN6RCwyQkFBMkIsbUJBQU8sQ0FBQyx3SEFBYTtBQUNoRDtBQUNBLGtCQUFrQiw4REFBOEQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrQkFBa0IscU1BQXFNO0FBQ3ZOLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3S0FBd0s7QUFDeE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSwwQ0FBMEMsSUFBSSxHQUFHLHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQixFQUFFLE9BQU87QUFDL0Ysb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxrQkFBa0IsZ0xBQWdMO0FBQ2xNLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUIsRUFBRSxRQUFRO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSwwQ0FBMEMsSUFBSSxHQUFHLHNCQUFzQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUIsRUFBRSxRQUFRO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQixFQUFFLFFBQVE7QUFDakUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU0sRUFBRSxRQUFRO0FBQ2xELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGtDQUFrQyxJQUFJLEdBQUcsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQixFQUFFLFFBQVE7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUIsRUFBRSxRQUFRO0FBQ3JELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLFFBQVE7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsTUFBTSxFQUFFLFFBQVE7QUFDN0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9NZWRpYVNlY3Rpb24uanM/NzU3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PZmZlck1lZGlhU2VjdGlvbiA9IGV4cG9ydHMuQW5zd2VyTWVkaWFTZWN0aW9uID0gZXhwb3J0cy5NZWRpYVNlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpKTtcbmNsYXNzIE1lZGlhU2VjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeyBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgcGxhbkIgPSBmYWxzZSwgfSkge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdCA9IHt9O1xuICAgICAgICB0aGlzLl9wbGFuQiA9IHBsYW5CO1xuICAgICAgICBpZiAoaWNlUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5zZXRJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY2VDYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jYW5kaWRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBpY2VDYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlT2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgLy8gbWVkaWFzb3VwIGRvZXMgbWFuZGF0ZXMgcnRjcC1tdXggc28gY2FuZGlkYXRlcyBjb21wb25lbnQgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gUlRQICgxKS5cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QuY29tcG9uZW50ID0gMTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QuZm91bmRhdGlvbiA9IGNhbmRpZGF0ZS5mb3VuZGF0aW9uO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5pcCA9IGNhbmRpZGF0ZS5pcDtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QucG9ydCA9IGNhbmRpZGF0ZS5wb3J0O1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5wcmlvcml0eSA9IGNhbmRpZGF0ZS5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QudHJhbnNwb3J0ID0gY2FuZGlkYXRlLnByb3RvY29sO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC50eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC50Y3B0eXBlID0gY2FuZGlkYXRlLnRjcFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGVPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZW5kT2ZDYW5kaWRhdGVzID0gJ2VuZC1vZi1jYW5kaWRhdGVzJztcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmljZU9wdGlvbnMgPSAncmVub21pbmF0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHRsc1JvbGUoZHRsc1BhcmFtZXRlcnMucm9sZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1pZCgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLl9tZWRpYU9iamVjdC5taWQpO1xuICAgIH1cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFPYmplY3QucG9ydCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0T2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFPYmplY3Q7XG4gICAgfVxuICAgIHNldEljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5pY2VVZnJhZyA9IGljZVBhcmFtZXRlcnMudXNlcm5hbWVGcmFnbWVudDtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuaWNlUHdkID0gaWNlUGFyYW1ldGVycy5wYXNzd29yZDtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LmV4dDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdF8wMztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnJpZHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5leHRtYXBBbGxvd01peGVkO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSAwO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFTZWN0aW9uID0gTWVkaWFTZWN0aW9uO1xuY2xhc3MgQW5zd2VyTWVkaWFTZWN0aW9uIGV4dGVuZHMgTWVkaWFTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgcGxhaW5SdHBQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlLCBvZmZlck1lZGlhT2JqZWN0LCBvZmZlclJ0cFBhcmFtZXRlcnMsIGFuc3dlclJ0cFBhcmFtZXRlcnMsIGNvZGVjT3B0aW9ucywgZXh0bWFwQWxsb3dNaXhlZCA9IGZhbHNlLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHBsYW5CIH0pO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5taWQgPSBTdHJpbmcob2ZmZXJNZWRpYU9iamVjdC5taWQpO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC50eXBlID0gb2ZmZXJNZWRpYU9iamVjdC50eXBlO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9IG9mZmVyTWVkaWFPYmplY3QucHJvdG9jb2w7XG4gICAgICAgIGlmICghcGxhaW5SdHBQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBpcDogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucG9ydCA9IHBsYWluUnRwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAob2ZmZXJNZWRpYU9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGFuc3dlclJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ0cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWM6IGdldENvZGVjTmFtZShjb2RlYyksXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRlOiBjb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlYy5jaGFubmVscyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0cC5lbmNvZGluZyA9IGNvZGVjLmNoYW5uZWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cC5wdXNoKHJ0cCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKGNvZGVjLnBhcmFtZXRlcnMpID8/IHt9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZWNSdGNwRmVlZGJhY2sgPSB1dGlscy5jbG9uZShjb2RlYy5ydGNwRmVlZGJhY2spID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9wdXNTdGVyZW8sIG9wdXNGZWMsIG9wdXNEdHgsIG9wdXNNYXhQbGF5YmFja1JhdGUsIG9wdXNNYXhBdmVyYWdlQml0cmF0ZSwgb3B1c1B0aW1lLCBvcHVzTmFjaywgdmlkZW9Hb29nbGVTdGFydEJpdHJhdGUsIHZpZGVvR29vZ2xlTWF4Qml0cmF0ZSwgdmlkZW9Hb29nbGVNaW5CaXRyYXRlLCB9ID0gY29kZWNPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2ZmZXJDb2RlYyA9IG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3MuZmluZCgoYykgPT4gYy5wYXlsb2FkVHlwZSA9PT0gY29kZWMucGF5bG9hZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXVkaW8vb3B1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXVkaW8vbXVsdGlvcHVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c1N0ZXJlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnNbJ3Nwcm9wLXN0ZXJlbyddID0gb3B1c1N0ZXJlbyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnN0ZXJlbyA9IG9wdXNTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c0ZlYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMudXNlaW5iYW5kZmVjID0gb3B1c0ZlYyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnVzZWluYmFuZGZlYyA9IG9wdXNGZWMgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c0R0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMudXNlZHR4ID0gb3B1c0R0eCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnVzZWR0eCA9IG9wdXNEdHggPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c01heFBsYXliYWNrUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnMubWF4cGxheWJhY2tyYXRlID0gb3B1c01heFBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c01heEF2ZXJhZ2VCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5tYXhhdmVyYWdlYml0cmF0ZSA9IG9wdXNNYXhBdmVyYWdlQml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c1B0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZmVyQ29kZWMucGFyYW1ldGVycy5wdGltZSA9IG9wdXNQdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5wdGltZSA9IG9wdXNQdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvcHVzTmFjayBpcyBub3Qgc2V0LCB3ZSBtdXN0IHJlbW92ZSBOQUNLIHN1cHBvcnQgZm9yIE9QVVMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCB3b3VsZCBiZSBlbmFibGVkIGZvciB0aG9zZSBoYW5kbGVycyB0aGF0IGFydGlmaWNpYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm5vdW5jZSBpdCBpbiB0aGVpciBSVFAgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdXNOYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnJ0Y3BGZWVkYmFjayA9IG9mZmVyQ29kZWMucnRjcEZlZWRiYWNrLmZpbHRlcihmYiA9PiBmYi50eXBlICE9PSAnbmFjaycgfHwgZmIucGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUnRjcEZlZWRiYWNrID0gY29kZWNSdGNwRmVlZGJhY2suZmlsdGVyKGZiID0+IGZiLnR5cGUgIT09ICduYWNrJyB8fCBmYi5wYXJhbWV0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aWRlby92cDgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZGVvL3ZwOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlkZW8vaDI2NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlkZW8vaDI2NSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvR29vZ2xlU3RhcnRCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtc3RhcnQtYml0cmF0ZSddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0dvb2dsZVN0YXJ0Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9Hb29nbGVNYXhCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtbWF4LWJpdHJhdGUnXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9Hb29nbGVNYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb0dvb2dsZU1pbkJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzWyd4LWdvb2dsZS1taW4tYml0cmF0ZSddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0dvb2dsZU1pbkJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZtdHAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogJycsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjUGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlY1BhcmFtZXRlcnNba2V5XX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cC5wdXNoKGZtdHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmIgb2YgY29kZWNSdGNwRmVlZGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGU6IGZiLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gYW5zd2VyUnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIGFuc3dlclJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgYSBoZWFkZXIgZXh0ZW5zaW9uIGlmIG5vdCBwcmVzZW50IGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSAob2ZmZXJNZWRpYU9iamVjdC5leHQgfHwgW10pLnNvbWUoKGxvY2FsRXh0KSA9PiBsb2NhbEV4dC51cmkgPT09IGV4dC51cmkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IGV4dC51cmksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXh0LmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgYm90aCAxIGJ5dGUgYW5kIDIgYnl0ZXMgbGVuZ3RoIGhlYWRlciBleHRlbnNpb25zLlxuICAgICAgICAgICAgICAgIGlmIChleHRtYXBBbGxvd01peGVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QuZXh0bWFwQWxsb3dNaXhlZCA9PT0gJ2V4dG1hcC1hbGxvdy1taXhlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZXh0bWFwQWxsb3dNaXhlZCA9ICdleHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW11bGNhc3QuXG4gICAgICAgICAgICAgICAgaWYgKG9mZmVyTWVkaWFPYmplY3Quc2ltdWxjYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcjE6ICdyZWN2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QxOiBvZmZlck1lZGlhT2JqZWN0LnNpbXVsY2FzdC5saXN0MSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucmlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJpZCBvZiBvZmZlck1lZGlhT2JqZWN0LnJpZHMgfHwgW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWQuZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJpZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbXVsY2FzdCAoZHJhZnQgdmVyc2lvbiAwMykuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmZXJNZWRpYU9iamVjdC5zaW11bGNhc3RfMDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3RfMDMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJNZWRpYU9iamVjdC5zaW11bGNhc3RfMDMudmFsdWUucmVwbGFjZSgvc2VuZC9nLCAncmVjdicpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5yaWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmlkIG9mIG9mZmVyTWVkaWFPYmplY3QucmlkcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZC5kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Qucmlkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcmlkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcE11eCA9ICdydGNwLW11eCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcFJzaXplID0gJ3J0Y3AtcnNpemUnO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFuQiAmJiB0aGlzLl9tZWRpYU9iamVjdC50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnhHb29nbGVGbGFnID0gJ2NvbmZlcmVuY2UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uJzoge1xuICAgICAgICAgICAgICAgIC8vIE5ldyBzcGVjLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2ZmZXJNZWRpYU9iamVjdC5zY3RwUG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgPSAnd2VicnRjLWRhdGFjaGFubmVsJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2N0cFBvcnQgPSBzY3RwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5tYXhNZXNzYWdlU2l6ZSA9IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbGQgc3BlYy5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmZlck1lZGlhT2JqZWN0LnNjdHBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgPSBzY3RwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zY3RwbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwOiAnd2VicnRjLWRhdGFjaGFubmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjdHBtYXBOdW1iZXI6IHNjdHBQYXJhbWV0ZXJzLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhNZXNzYWdlU2l6ZTogc2N0cFBhcmFtZXRlcnMubWF4TWVzc2FnZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldER0bHNSb2xlKHJvbGUpIHtcbiAgICAgICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICAgICAgICBjYXNlICdjbGllbnQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAnYWN0aXZlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NlcnZlcic6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zZXR1cCA9ICdwYXNzaXZlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2F1dG8nOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAnYWN0cGFzcyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgIH1cbiAgICBtdXhTaW11bGNhc3RTdHJlYW1zKGVuY29kaW5ncykge1xuICAgICAgICBpZiAoIXRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdCB8fCAhdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0Lmxpc3QxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5ZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcucmlkKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW2VuY29kaW5nLnJpZF0gPSBlbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXcgPSB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3QubGlzdDE7XG4gICAgICAgIGNvbnN0IHNpbXVsY2FzdFN0cmVhbXMgPSBzZHBUcmFuc2Zvcm0ucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0KHJhdyk7XG4gICAgICAgIGZvciAoY29uc3Qgc2ltdWxjYXN0U3RyZWFtIG9mIHNpbXVsY2FzdFN0cmVhbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2ltdWxjYXN0Rm9ybWF0IG9mIHNpbXVsY2FzdFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHNpbXVsY2FzdEZvcm1hdC5wYXVzZWQgPSAhbGF5ZXJzW3NpbXVsY2FzdEZvcm1hdC5zY2lkXT8uYWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdC5saXN0MSA9IHNpbXVsY2FzdFN0cmVhbXNcbiAgICAgICAgICAgIC5tYXAoc2ltdWxjYXN0Rm9ybWF0cyA9PiBzaW11bGNhc3RGb3JtYXRzLm1hcChmID0+IGAke2YucGF1c2VkID8gJ34nIDogJyd9JHtmLnNjaWR9YCkuam9pbignLCcpKVxuICAgICAgICAgICAgLmpvaW4oJzsnKTtcbiAgICB9XG59XG5leHBvcnRzLkFuc3dlck1lZGlhU2VjdGlvbiA9IEFuc3dlck1lZGlhU2VjdGlvbjtcbmNsYXNzIE9mZmVyTWVkaWFTZWN0aW9uIGV4dGVuZHMgTWVkaWFTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgcGxhaW5SdHBQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlLCBtaWQsIGtpbmQsIG9mZmVyUnRwUGFyYW1ldGVycywgc3RyZWFtSWQsIHRyYWNrSWQsIG9sZERhdGFDaGFubmVsU3BlYyA9IGZhbHNlLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHBsYW5CIH0pO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5taWQgPSBTdHJpbmcobWlkKTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QudHlwZSA9IGtpbmQ7XG4gICAgICAgIGlmICghcGxhaW5SdHBQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcbiAgICAgICAgICAgIGlmICghc2N0cFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdVRFAvVExTL1JUUC9TQVZQRic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdVRFAvRFRMUy9TQ1RQJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBpcDogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucHJvdG9jb2wgPSAnUlRQL0FWUCc7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wb3J0ID0gcGxhaW5SdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BsYW5CKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0Lm1zaWQgPSBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnRwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlYzogZ2V0Q29kZWNOYW1lKGNvZGVjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGU6IGNvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVjLmNoYW5uZWxzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnRwLmVuY29kaW5nID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRwLnB1c2gocnRwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm10cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlYy5wYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm10cC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcEZiLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGZiLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZTogZmIucGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgPSBvZmZlclJ0cFBhcmFtZXRlcnMuY29kZWNzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGNvZGVjKSA9PiBjb2RlYy5wYXlsb2FkVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4dCBvZiBvZmZlclJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IGV4dC51cmksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXh0LmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcE11eCA9ICdydGNwLW11eCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcFJzaXplID0gJ3J0Y3AtcnNpemUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzc3JjID0gZW5jb2Rpbmcuc3NyYztcbiAgICAgICAgICAgICAgICBjb25zdCBydHhTc3JjID0gZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjID8gZW5jb2RpbmcucnR4LnNzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhbkIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkIHx8ICctJ30gJHt0cmFja0lkfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhbkIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzb2NpYXRlIG9yaWdpbmFsIGFuZCByZXRyYW5zbWlzc2lvbiBTU1JDcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWFudGljczogJ0ZJRCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzc3JjczogYCR7c3NyY30gJHtydHhTc3JjfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uJzoge1xuICAgICAgICAgICAgICAgIC8vIE5ldyBzcGVjLlxuICAgICAgICAgICAgICAgIGlmICghb2xkRGF0YUNoYW5uZWxTcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gJ3dlYnJ0Yy1kYXRhY2hhbm5lbCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNjdHBQb3J0ID0gc2N0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubWF4TWVzc2FnZVNpemUgPSBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT2xkIHNwZWMuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gc2N0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2N0cG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcDogJ3dlYnJ0Yy1kYXRhY2hhbm5lbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3RwbWFwTnVtYmVyOiBzY3RwUGFyYW1ldGVycy5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemU6IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgc2V0RHRsc1JvbGUocm9sZSkge1xuICAgICAgICAvLyBBbHdheXMgJ2FjdHBhc3MnLlxuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zZXR1cCA9ICdhY3RwYXNzJztcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgIH1cbiAgICBwbGFuQlJlY2VpdmUoeyBvZmZlclJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkLCB0cmFja0lkLCB9KSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcbiAgICAgICAgY29uc3Qgc3NyYyA9IGVuY29kaW5nLnNzcmM7XG4gICAgICAgIGNvbnN0IHJ0eFNzcmMgPSBlbmNvZGluZy5ydHggJiYgZW5jb2RpbmcucnR4LnNzcmMgPyBlbmNvZGluZy5ydHguc3NyYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2Fkcy5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2Fkcy5pbmNsdWRlcyhTdHJpbmcoY29kZWMucGF5bG9hZFR5cGUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcnRwID0ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGVjOiBnZXRDb2RlY05hbWUoY29kZWMpLFxuICAgICAgICAgICAgICAgIHJhdGU6IGNvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29kZWMuY2hhbm5lbHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgcnRwLmVuY29kaW5nID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydHAucHVzaChydHApO1xuICAgICAgICAgICAgY29uc3QgZm10cCA9IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBjb25maWc6ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gYCR7a2V5fT0ke2NvZGVjLnBhcmFtZXRlcnNba2V5XX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cC5wdXNoKGZtdHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBmYiBvZiBjb2RlYy5ydGNwRmVlZGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwRmIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlOiBmYi5wYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgKz0gYCAke29mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvZGVjKSA9PiAhdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMuaW5jbHVkZXMoY29kZWMucGF5bG9hZFR5cGUpKVxuICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuICAgICAgICAgICAgLmpvaW4oJyAnKX1gO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9IHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzLnRyaW0oKTtcbiAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkIHx8ICctJ30gJHt0cmFja0lkfWAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgb3JpZ2luYWwgYW5kIHJldHJhbnNtaXNzaW9uIFNTUkNzLlxuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgICAgIHNzcmNzOiBgJHtzc3JjfSAke3J0eFNzcmN9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBsYW5CU3RvcFJlY2VpdmluZyh7IG9mZmVyUnRwUGFyYW1ldGVycywgfSkge1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IG9mZmVyUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG4gICAgICAgIGNvbnN0IHNzcmMgPSBlbmNvZGluZy5zc3JjO1xuICAgICAgICBjb25zdCBydHhTc3JjID0gZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjID8gZW5jb2RpbmcucnR4LnNzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzID0gdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MuZmlsdGVyKChzKSA9PiBzLmlkICE9PSBzc3JjICYmIHMuaWQgIT09IHJ0eFNzcmMpO1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcyA9IHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHMuZmlsdGVyKChncm91cCkgPT4gZ3JvdXAuc3NyY3MgIT09IGAke3NzcmN9ICR7cnR4U3NyY31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT2ZmZXJNZWRpYVNlY3Rpb24gPSBPZmZlck1lZGlhU2VjdGlvbjtcbmZ1bmN0aW9uIGdldENvZGVjTmFtZShjb2RlYykge1xuICAgIGNvbnN0IE1pbWVUeXBlUmVnZXggPSBuZXcgUmVnRXhwKCdeKGF1ZGlvfHZpZGVvKS8oLispJywgJ2knKTtcbiAgICBjb25zdCBtaW1lVHlwZU1hdGNoID0gTWltZVR5cGVSZWdleC5leGVjKGNvZGVjLm1pbWVUeXBlKTtcbiAgICBpZiAoIW1pbWVUeXBlTWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjb2RlYy5taW1lVHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gbWltZVR5cGVNYXRjaFsyXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteSdp = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\nconst Logger_1 = __webpack_require__(/*! ../../Logger */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Logger.js\");\nconst MediaSection_1 = __webpack_require__(/*! ./MediaSection */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js\");\nconst logger = new Logger_1.Logger('RemoteSdp');\nclass RemoteSdp {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, }) {\n        // MediaSection instances with same order as in the SDP.\n        this._mediaSections = [];\n        // MediaSection indices indexed by MID.\n        this._midToIndex = new Map();\n        this._iceParameters = iceParameters;\n        this._iceCandidates = iceCandidates;\n        this._dtlsParameters = dtlsParameters;\n        this._sctpParameters = sctpParameters;\n        this._plainRtpParameters = plainRtpParameters;\n        this._planB = planB;\n        this._sdpObject = {\n            version: 0,\n            origin: {\n                address: '0.0.0.0',\n                ipVer: 4,\n                netType: 'IN',\n                sessionId: 10000,\n                sessionVersion: 0,\n                username: 'mediasoup-client',\n            },\n            name: '-',\n            timing: { start: 0, stop: 0 },\n            media: [],\n        };\n        // If ICE parameters are given, add ICE-Lite indicator.\n        if (iceParameters && iceParameters.iceLite) {\n            this._sdpObject.icelite = 'ice-lite';\n        }\n        // If DTLS parameters are given, assume WebRTC and BUNDLE.\n        if (dtlsParameters) {\n            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };\n            // NOTE: We take the latest fingerprint.\n            const numFingerprints = this._dtlsParameters.fingerprints.length;\n            this._sdpObject.fingerprint = {\n                type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n                hash: dtlsParameters.fingerprints[numFingerprints - 1].value,\n            };\n            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];\n        }\n        // If there are plain RPT parameters, override SDP origin.\n        if (plainRtpParameters) {\n            this._sdpObject.origin.address = plainRtpParameters.ip;\n            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;\n        }\n    }\n    updateIceParameters(iceParameters) {\n        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);\n        this._iceParameters = iceParameters;\n        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;\n        for (const mediaSection of this._mediaSections) {\n            mediaSection.setIceParameters(iceParameters);\n        }\n    }\n    updateDtlsRole(role) {\n        logger.debug('updateDtlsRole() [role:%s]', role);\n        this._dtlsParameters.role = role;\n        for (const mediaSection of this._mediaSections) {\n            mediaSection.setDtlsRole(role);\n        }\n    }\n    getNextMediaSectionIdx() {\n        // If a closed media section is found, return its index.\n        for (let idx = 0; idx < this._mediaSections.length; ++idx) {\n            const mediaSection = this._mediaSections[idx];\n            if (mediaSection.closed) {\n                return { idx, reuseMid: mediaSection.mid };\n            }\n        }\n        // If no closed media section is found, return next one.\n        return { idx: this._mediaSections.length };\n    }\n    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false, }) {\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\n            iceParameters: this._iceParameters,\n            iceCandidates: this._iceCandidates,\n            dtlsParameters: this._dtlsParameters,\n            plainRtpParameters: this._plainRtpParameters,\n            planB: this._planB,\n            offerMediaObject,\n            offerRtpParameters,\n            answerRtpParameters,\n            codecOptions,\n            extmapAllowMixed,\n        });\n        // Unified-Plan with closed media section replacement.\n        if (reuseMid) {\n            this._replaceMediaSection(mediaSection, reuseMid);\n        }\n        // Unified-Plan or Plan-B with different media kind.\n        else if (!this._midToIndex.has(mediaSection.mid)) {\n            this._addMediaSection(mediaSection);\n        }\n        // Plan-B with same media kind.\n        else {\n            this._replaceMediaSection(mediaSection);\n        }\n    }\n    receive({ mid, kind, offerRtpParameters, streamId, trackId, }) {\n        const idx = this._midToIndex.get(mid);\n        let mediaSection;\n        if (idx !== undefined) {\n            mediaSection = this._mediaSections[idx];\n        }\n        // Unified-Plan or different media kind.\n        if (!mediaSection) {\n            mediaSection = new MediaSection_1.OfferMediaSection({\n                iceParameters: this._iceParameters,\n                iceCandidates: this._iceCandidates,\n                dtlsParameters: this._dtlsParameters,\n                plainRtpParameters: this._plainRtpParameters,\n                planB: this._planB,\n                mid,\n                kind,\n                offerRtpParameters,\n                streamId,\n                trackId,\n            });\n            // Let's try to recycle a closed media section (if any).\n            // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.\n            const oldMediaSection = this._mediaSections.find(m => m.closed);\n            if (oldMediaSection) {\n                this._replaceMediaSection(mediaSection, oldMediaSection.mid);\n            }\n            else {\n                this._addMediaSection(mediaSection);\n            }\n        }\n        // Plan-B.\n        else {\n            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });\n            this._replaceMediaSection(mediaSection);\n        }\n    }\n    pauseMediaSection(mid) {\n        const mediaSection = this._findMediaSection(mid);\n        mediaSection.pause();\n    }\n    resumeSendingMediaSection(mid) {\n        const mediaSection = this._findMediaSection(mid);\n        mediaSection.resume();\n    }\n    resumeReceivingMediaSection(mid) {\n        const mediaSection = this._findMediaSection(mid);\n        mediaSection.resume();\n    }\n    disableMediaSection(mid) {\n        const mediaSection = this._findMediaSection(mid);\n        mediaSection.disable();\n    }\n    /**\n     * Closes media section. Returns true if the given MID corresponds to a m\n     * section that has been indeed closed. False otherwise.\n     *\n     * NOTE: Closing the first m section is a pain since it invalidates the bundled\n     * transport, so instead closing it we just disable it.\n     */\n    closeMediaSection(mid) {\n        const mediaSection = this._findMediaSection(mid);\n        // NOTE: Closing the first m section is a pain since it invalidates the\n        // bundled transport, so let's avoid it.\n        if (mid === this._firstMid) {\n            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);\n            this.disableMediaSection(mid);\n            return false;\n        }\n        mediaSection.close();\n        // Regenerate BUNDLE mids.\n        this._regenerateBundleMids();\n        return true;\n    }\n    muxMediaSectionSimulcast(mid, encodings) {\n        const mediaSection = this._findMediaSection(mid);\n        mediaSection.muxSimulcastStreams(encodings);\n        this._replaceMediaSection(mediaSection);\n    }\n    planBStopReceiving({ mid, offerRtpParameters, }) {\n        const mediaSection = this._findMediaSection(mid);\n        mediaSection.planBStopReceiving({ offerRtpParameters });\n        this._replaceMediaSection(mediaSection);\n    }\n    sendSctpAssociation({ offerMediaObject }) {\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\n            iceParameters: this._iceParameters,\n            iceCandidates: this._iceCandidates,\n            dtlsParameters: this._dtlsParameters,\n            sctpParameters: this._sctpParameters,\n            plainRtpParameters: this._plainRtpParameters,\n            offerMediaObject,\n        });\n        this._addMediaSection(mediaSection);\n    }\n    receiveSctpAssociation({ oldDataChannelSpec = false, } = {}) {\n        const mediaSection = new MediaSection_1.OfferMediaSection({\n            iceParameters: this._iceParameters,\n            iceCandidates: this._iceCandidates,\n            dtlsParameters: this._dtlsParameters,\n            sctpParameters: this._sctpParameters,\n            plainRtpParameters: this._plainRtpParameters,\n            mid: 'datachannel',\n            kind: 'application',\n            oldDataChannelSpec,\n        });\n        this._addMediaSection(mediaSection);\n    }\n    getSdp() {\n        // Increase SDP version.\n        this._sdpObject.origin.sessionVersion++;\n        return sdpTransform.write(this._sdpObject);\n    }\n    _addMediaSection(newMediaSection) {\n        if (!this._firstMid) {\n            this._firstMid = newMediaSection.mid;\n        }\n        // Add to the vector.\n        this._mediaSections.push(newMediaSection);\n        // Add to the map.\n        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);\n        // Add to the SDP object.\n        this._sdpObject.media.push(newMediaSection.getObject());\n        // Regenerate BUNDLE mids.\n        this._regenerateBundleMids();\n    }\n    _replaceMediaSection(newMediaSection, reuseMid) {\n        // Store it in the map.\n        if (typeof reuseMid === 'string') {\n            const idx = this._midToIndex.get(reuseMid);\n            if (idx === undefined) {\n                throw new Error(`no media section found for reuseMid '${reuseMid}'`);\n            }\n            const oldMediaSection = this._mediaSections[idx];\n            // Replace the index in the vector with the new media section.\n            this._mediaSections[idx] = newMediaSection;\n            // Update the map.\n            this._midToIndex.delete(oldMediaSection.mid);\n            this._midToIndex.set(newMediaSection.mid, idx);\n            // Update the SDP object.\n            this._sdpObject.media[idx] = newMediaSection.getObject();\n            // Regenerate BUNDLE mids.\n            this._regenerateBundleMids();\n        }\n        else {\n            const idx = this._midToIndex.get(newMediaSection.mid);\n            if (idx === undefined) {\n                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);\n            }\n            // Replace the index in the vector with the new media section.\n            this._mediaSections[idx] = newMediaSection;\n            // Update the SDP object.\n            this._sdpObject.media[idx] = newMediaSection.getObject();\n        }\n    }\n    _findMediaSection(mid) {\n        const idx = this._midToIndex.get(mid);\n        if (idx === undefined) {\n            throw new Error(`no media section found with mid '${mid}'`);\n        }\n        return this._mediaSections[idx];\n    }\n    _regenerateBundleMids() {\n        if (!this._dtlsParameters) {\n            return;\n        }\n        this._sdpObject.groups[0].mids = this._mediaSections\n            .filter((mediaSection) => !mediaSection.closed)\n            .map((mediaSection) => mediaSection.mid)\n            .join(' ');\n    }\n}\nexports.RemoteSdp = RemoteSdp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9SZW1vdGVTZHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixrQ0FBa0MsbUJBQU8sQ0FBQyxxSEFBZTtBQUN6RCxpQkFBaUIsbUJBQU8sQ0FBQywwSEFBYztBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQywrSUFBZ0I7QUFDL0M7QUFDQTtBQUNBLGtCQUFrQixrR0FBa0c7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVyw4R0FBOEc7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQW1EO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUNBQXVDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG9CQUFvQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9zZHAvUmVtb3RlU2RwLmpzPzk5ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3RlU2RwID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uLy4uL0xvZ2dlclwiKTtcbmNvbnN0IE1lZGlhU2VjdGlvbl8xID0gcmVxdWlyZShcIi4vTWVkaWFTZWN0aW9uXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignUmVtb3RlU2RwJyk7XG5jbGFzcyBSZW1vdGVTZHAge1xuICAgIGNvbnN0cnVjdG9yKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBwbGFpblJ0cFBhcmFtZXRlcnMsIHBsYW5CID0gZmFsc2UsIH0pIHtcbiAgICAgICAgLy8gTWVkaWFTZWN0aW9uIGluc3RhbmNlcyB3aXRoIHNhbWUgb3JkZXIgYXMgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fbWVkaWFTZWN0aW9ucyA9IFtdO1xuICAgICAgICAvLyBNZWRpYVNlY3Rpb24gaW5kaWNlcyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWlkVG9JbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faWNlUGFyYW1ldGVycyA9IGljZVBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX2ljZUNhbmRpZGF0ZXMgPSBpY2VDYW5kaWRhdGVzO1xuICAgICAgICB0aGlzLl9kdGxzUGFyYW1ldGVycyA9IGR0bHNQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9zY3RwUGFyYW1ldGVycyA9IHNjdHBQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMgPSBwbGFpblJ0cFBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3BsYW5CID0gcGxhbkI7XG4gICAgICAgIHRoaXMuX3NkcE9iamVjdCA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiAnMC4wLjAuMCcsXG4gICAgICAgICAgICAgICAgaXBWZXI6IDQsXG4gICAgICAgICAgICAgICAgbmV0VHlwZTogJ0lOJyxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IDEwMDAwLFxuICAgICAgICAgICAgICAgIHNlc3Npb25WZXJzaW9uOiAwLFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiAnbWVkaWFzb3VwLWNsaWVudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogJy0nLFxuICAgICAgICAgICAgdGltaW5nOiB7IHN0YXJ0OiAwLCBzdG9wOiAwIH0sXG4gICAgICAgICAgICBtZWRpYTogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIElDRSBwYXJhbWV0ZXJzIGFyZSBnaXZlbiwgYWRkIElDRS1MaXRlIGluZGljYXRvci5cbiAgICAgICAgaWYgKGljZVBhcmFtZXRlcnMgJiYgaWNlUGFyYW1ldGVycy5pY2VMaXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QuaWNlbGl0ZSA9ICdpY2UtbGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgRFRMUyBwYXJhbWV0ZXJzIGFyZSBnaXZlbiwgYXNzdW1lIFdlYlJUQyBhbmQgQlVORExFLlxuICAgICAgICBpZiAoZHRsc1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5tc2lkU2VtYW50aWMgPSB7IHNlbWFudGljOiAnV01TJywgdG9rZW46ICcqJyB9O1xuICAgICAgICAgICAgLy8gTk9URTogV2UgdGFrZSB0aGUgbGF0ZXN0IGZpbmdlcnByaW50LlxuICAgICAgICAgICAgY29uc3QgbnVtRmluZ2VycHJpbnRzID0gdGhpcy5fZHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5maW5nZXJwcmludCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0uYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgIGhhc2g6IGR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS52YWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QuZ3JvdXBzID0gW3sgdHlwZTogJ0JVTkRMRScsIG1pZHM6ICcnIH1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBwbGFpbiBSUFQgcGFyYW1ldGVycywgb3ZlcnJpZGUgU0RQIG9yaWdpbi5cbiAgICAgICAgaWYgKHBsYWluUnRwUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5hZGRyZXNzID0gcGxhaW5SdHBQYXJhbWV0ZXJzLmlwO1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5pcFZlciA9IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlUGFyYW1ldGVycygpIFtpY2VQYXJhbWV0ZXJzOiVvXScsIGljZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9pY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0LmljZWxpdGUgPSBpY2VQYXJhbWV0ZXJzLmljZUxpdGUgPyAnaWNlLWxpdGUnIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG1lZGlhU2VjdGlvbiBvZiB0aGlzLl9tZWRpYVNlY3Rpb25zKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24uc2V0SWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEdGxzUm9sZShyb2xlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlRHRsc1JvbGUoKSBbcm9sZTolc10nLCByb2xlKTtcbiAgICAgICAgdGhpcy5fZHRsc1BhcmFtZXRlcnMucm9sZSA9IHJvbGU7XG4gICAgICAgIGZvciAoY29uc3QgbWVkaWFTZWN0aW9uIG9mIHRoaXMuX21lZGlhU2VjdGlvbnMpIHtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbi5zZXREdGxzUm9sZShyb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROZXh0TWVkaWFTZWN0aW9uSWR4KCkge1xuICAgICAgICAvLyBJZiBhIGNsb3NlZCBtZWRpYSBzZWN0aW9uIGlzIGZvdW5kLCByZXR1cm4gaXRzIGluZGV4LlxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9tZWRpYVNlY3Rpb25zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIGlmIChtZWRpYVNlY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaWR4LCByZXVzZU1pZDogbWVkaWFTZWN0aW9uLm1pZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGNsb3NlZCBtZWRpYSBzZWN0aW9uIGlzIGZvdW5kLCByZXR1cm4gbmV4dCBvbmUuXG4gICAgICAgIHJldHVybiB7IGlkeDogdGhpcy5fbWVkaWFTZWN0aW9ucy5sZW5ndGggfTtcbiAgICB9XG4gICAgc2VuZCh7IG9mZmVyTWVkaWFPYmplY3QsIHJldXNlTWlkLCBvZmZlclJ0cFBhcmFtZXRlcnMsIGFuc3dlclJ0cFBhcmFtZXRlcnMsIGNvZGVjT3B0aW9ucywgZXh0bWFwQWxsb3dNaXhlZCA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IG5ldyBNZWRpYVNlY3Rpb25fMS5BbnN3ZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0aGlzLl9wbGFuQixcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICAgICAgZXh0bWFwQWxsb3dNaXhlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVuaWZpZWQtUGxhbiB3aXRoIGNsb3NlZCBtZWRpYSBzZWN0aW9uIHJlcGxhY2VtZW50LlxuICAgICAgICBpZiAocmV1c2VNaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uLCByZXVzZU1pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5pZmllZC1QbGFuIG9yIFBsYW4tQiB3aXRoIGRpZmZlcmVudCBtZWRpYSBraW5kLlxuICAgICAgICBlbHNlIGlmICghdGhpcy5fbWlkVG9JbmRleC5oYXMobWVkaWFTZWN0aW9uLm1pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBsYW4tQiB3aXRoIHNhbWUgbWVkaWEga2luZC5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjZWl2ZSh7IG1pZCwga2luZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCwgfSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChtaWQpO1xuICAgICAgICBsZXQgbWVkaWFTZWN0aW9uO1xuICAgICAgICBpZiAoaWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmlmaWVkLVBsYW4gb3IgZGlmZmVyZW50IG1lZGlhIGtpbmQuXG4gICAgICAgIGlmICghbWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IHRoaXMuX2ljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogdGhpcy5faWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhaW5SdHBQYXJhbWV0ZXJzOiB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhbkI6IHRoaXMuX3BsYW5CLFxuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgdG8gcmVjeWNsZSBhIGNsb3NlZCBtZWRpYSBzZWN0aW9uIChpZiBhbnkpLlxuICAgICAgICAgICAgLy8gTk9URTogWWVzLCB3ZSBjYW4gcmVjeWNsZSBhIGNsb3NlZCBtPWF1ZGlvIHNlY3Rpb24gd2l0aCBhIG5ldyBtPXZpZGVvLlxuICAgICAgICAgICAgY29uc3Qgb2xkTWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9ucy5maW5kKG0gPT4gbS5jbG9zZWQpO1xuICAgICAgICAgICAgaWYgKG9sZE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uLCBvbGRNZWRpYVNlY3Rpb24ubWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBsYW4tQi5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24ucGxhbkJSZWNlaXZlKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZU1lZGlhU2VjdGlvbihtaWQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgcmVzdW1lU2VuZGluZ01lZGlhU2VjdGlvbihtaWQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucmVzdW1lKCk7XG4gICAgfVxuICAgIHJlc3VtZVJlY2VpdmluZ01lZGlhU2VjdGlvbihtaWQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucmVzdW1lKCk7XG4gICAgfVxuICAgIGRpc2FibGVNZWRpYVNlY3Rpb24obWlkKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX2ZpbmRNZWRpYVNlY3Rpb24obWlkKTtcbiAgICAgICAgbWVkaWFTZWN0aW9uLmRpc2FibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIG1lZGlhIHNlY3Rpb24uIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlEIGNvcnJlc3BvbmRzIHRvIGEgbVxuICAgICAqIHNlY3Rpb24gdGhhdCBoYXMgYmVlbiBpbmRlZWQgY2xvc2VkLiBGYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDbG9zaW5nIHRoZSBmaXJzdCBtIHNlY3Rpb24gaXMgYSBwYWluIHNpbmNlIGl0IGludmFsaWRhdGVzIHRoZSBidW5kbGVkXG4gICAgICogdHJhbnNwb3J0LCBzbyBpbnN0ZWFkIGNsb3NpbmcgaXQgd2UganVzdCBkaXNhYmxlIGl0LlxuICAgICAqL1xuICAgIGNsb3NlTWVkaWFTZWN0aW9uKG1pZCkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSB0aGlzLl9maW5kTWVkaWFTZWN0aW9uKG1pZCk7XG4gICAgICAgIC8vIE5PVEU6IENsb3NpbmcgdGhlIGZpcnN0IG0gc2VjdGlvbiBpcyBhIHBhaW4gc2luY2UgaXQgaW52YWxpZGF0ZXMgdGhlXG4gICAgICAgIC8vIGJ1bmRsZWQgdHJhbnNwb3J0LCBzbyBsZXQncyBhdm9pZCBpdC5cbiAgICAgICAgaWYgKG1pZCA9PT0gdGhpcy5fZmlyc3RNaWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2VNZWRpYVNlY3Rpb24oKSB8IGNhbm5vdCBjbG9zZSBmaXJzdCBtZWRpYSBzZWN0aW9uLCBkaXNhYmxpbmcgaXQgaW5zdGVhZCBbbWlkOiVzXScsIG1pZCk7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVNZWRpYVNlY3Rpb24obWlkKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYVNlY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgLy8gUmVnZW5lcmF0ZSBCVU5ETEUgbWlkcy5cbiAgICAgICAgdGhpcy5fcmVnZW5lcmF0ZUJ1bmRsZU1pZHMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG11eE1lZGlhU2VjdGlvblNpbXVsY2FzdChtaWQsIGVuY29kaW5ncykge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSB0aGlzLl9maW5kTWVkaWFTZWN0aW9uKG1pZCk7XG4gICAgICAgIG1lZGlhU2VjdGlvbi5tdXhTaW11bGNhc3RTdHJlYW1zKGVuY29kaW5ncyk7XG4gICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgcGxhbkJTdG9wUmVjZWl2aW5nKHsgbWlkLCBvZmZlclJ0cFBhcmFtZXRlcnMsIH0pIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fZmluZE1lZGlhU2VjdGlvbihtaWQpO1xuICAgICAgICBtZWRpYVNlY3Rpb24ucGxhbkJTdG9wUmVjZWl2aW5nKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICB0aGlzLl9yZXBsYWNlTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgfVxuICAgIHNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pIHtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gbmV3IE1lZGlhU2VjdGlvbl8xLkFuc3dlck1lZGlhU2VjdGlvbih7XG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzOiB0aGlzLl9pY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogdGhpcy5faWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzOiB0aGlzLl9kdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzOiB0aGlzLl9zY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYWluUnRwUGFyYW1ldGVyczogdGhpcy5fcGxhaW5SdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgIH1cbiAgICByZWNlaXZlU2N0cEFzc29jaWF0aW9uKHsgb2xkRGF0YUNoYW5uZWxTcGVjID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyczogdGhpcy5fc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG1pZDogJ2RhdGFjaGFubmVsJyxcbiAgICAgICAgICAgIGtpbmQ6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgICBvbGREYXRhQ2hhbm5lbFNwZWMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hZGRNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0U2RwKCkge1xuICAgICAgICAvLyBJbmNyZWFzZSBTRFAgdmVyc2lvbi5cbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5zZXNzaW9uVmVyc2lvbisrO1xuICAgICAgICByZXR1cm4gc2RwVHJhbnNmb3JtLndyaXRlKHRoaXMuX3NkcE9iamVjdCk7XG4gICAgfVxuICAgIF9hZGRNZWRpYVNlY3Rpb24obmV3TWVkaWFTZWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlyc3RNaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWlkID0gbmV3TWVkaWFTZWN0aW9uLm1pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdG8gdGhlIHZlY3Rvci5cbiAgICAgICAgdGhpcy5fbWVkaWFTZWN0aW9ucy5wdXNoKG5ld01lZGlhU2VjdGlvbik7XG4gICAgICAgIC8vIEFkZCB0byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9taWRUb0luZGV4LnNldChuZXdNZWRpYVNlY3Rpb24ubWlkLCB0aGlzLl9tZWRpYVNlY3Rpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgICAvLyBBZGQgdG8gdGhlIFNEUCBvYmplY3QuXG4gICAgICAgIHRoaXMuX3NkcE9iamVjdC5tZWRpYS5wdXNoKG5ld01lZGlhU2VjdGlvbi5nZXRPYmplY3QoKSk7XG4gICAgICAgIC8vIFJlZ2VuZXJhdGUgQlVORExFIG1pZHMuXG4gICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVCdW5kbGVNaWRzKCk7XG4gICAgfVxuICAgIF9yZXBsYWNlTWVkaWFTZWN0aW9uKG5ld01lZGlhU2VjdGlvbiwgcmV1c2VNaWQpIHtcbiAgICAgICAgLy8gU3RvcmUgaXQgaW4gdGhlIG1hcC5cbiAgICAgICAgaWYgKHR5cGVvZiByZXVzZU1pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX21pZFRvSW5kZXguZ2V0KHJldXNlTWlkKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCBmb3IgcmV1c2VNaWQgJyR7cmV1c2VNaWR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkTWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9uc1tpZHhdO1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgaW5kZXggaW4gdGhlIHZlY3RvciB3aXRoIHRoZSBuZXcgbWVkaWEgc2VjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XSA9IG5ld01lZGlhU2VjdGlvbjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwLlxuICAgICAgICAgICAgdGhpcy5fbWlkVG9JbmRleC5kZWxldGUob2xkTWVkaWFTZWN0aW9uLm1pZCk7XG4gICAgICAgICAgICB0aGlzLl9taWRUb0luZGV4LnNldChuZXdNZWRpYVNlY3Rpb24ubWlkLCBpZHgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBTRFAgb2JqZWN0LlxuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm1lZGlhW2lkeF0gPSBuZXdNZWRpYVNlY3Rpb24uZ2V0T2JqZWN0KCk7XG4gICAgICAgICAgICAvLyBSZWdlbmVyYXRlIEJVTkRMRSBtaWRzLlxuICAgICAgICAgICAgdGhpcy5fcmVnZW5lcmF0ZUJ1bmRsZU1pZHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX21pZFRvSW5kZXguZ2V0KG5ld01lZGlhU2VjdGlvbi5taWQpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBtZWRpYSBzZWN0aW9uIGZvdW5kIHdpdGggbWlkICcke25ld01lZGlhU2VjdGlvbi5taWR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgaW5kZXggaW4gdGhlIHZlY3RvciB3aXRoIHRoZSBuZXcgbWVkaWEgc2VjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XSA9IG5ld01lZGlhU2VjdGlvbjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgU0RQIG9iamVjdC5cbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5tZWRpYVtpZHhdID0gbmV3TWVkaWFTZWN0aW9uLmdldE9iamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9maW5kTWVkaWFTZWN0aW9uKG1pZCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChtaWQpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCB3aXRoIG1pZCAnJHttaWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF07XG4gICAgfVxuICAgIF9yZWdlbmVyYXRlQnVuZGxlTWlkcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kdGxzUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NkcE9iamVjdC5ncm91cHNbMF0ubWlkcyA9IHRoaXMuX21lZGlhU2VjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKG1lZGlhU2VjdGlvbikgPT4gIW1lZGlhU2VjdGlvbi5jbG9zZWQpXG4gICAgICAgICAgICAubWFwKChtZWRpYVNlY3Rpb24pID0+IG1lZGlhU2VjdGlvbi5taWQpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU2RwID0gUmVtb3RlU2RwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\"));\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\nfunction extractRtpCapabilities({ sdpObject, }) {\n    // Map of RtpCodecParameters indexed by payload type.\n    const codecsMap = new Map();\n    // Array of RtpHeaderExtensions.\n    const headerExtensions = [];\n    // Whether a m=audio/video section has been already found.\n    let gotAudio = false;\n    let gotVideo = false;\n    for (const m of sdpObject.media) {\n        const kind = m.type;\n        switch (kind) {\n            case 'audio': {\n                if (gotAudio) {\n                    continue;\n                }\n                gotAudio = true;\n                break;\n            }\n            case 'video': {\n                if (gotVideo) {\n                    continue;\n                }\n                gotVideo = true;\n                break;\n            }\n            default: {\n                continue;\n            }\n        }\n        // Get codecs.\n        for (const rtp of m.rtp) {\n            const codec = {\n                kind: kind,\n                mimeType: `${kind}/${rtp.codec}`,\n                preferredPayloadType: rtp.payload,\n                clockRate: rtp.rate,\n                channels: rtp.encoding,\n                parameters: {},\n                rtcpFeedback: [],\n            };\n            codecsMap.set(codec.preferredPayloadType, codec);\n        }\n        // Get codec parameters.\n        for (const fmtp of m.fmtp || []) {\n            const parameters = sdpTransform.parseParams(fmtp.config);\n            const codec = codecsMap.get(fmtp.payload);\n            if (!codec) {\n                continue;\n            }\n            // Specials case to convert parameter value to string.\n            if (parameters && parameters.hasOwnProperty('profile-level-id')) {\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\n            }\n            codec.parameters = parameters;\n        }\n        // Get RTCP feedback for each codec.\n        for (const fb of m.rtcpFb || []) {\n            const feedback = {\n                type: fb.type,\n                parameter: fb.subtype,\n            };\n            if (!feedback.parameter) {\n                delete feedback.parameter;\n            }\n            // rtcp-fb payload is not '*', so just apply it to its corresponding\n            // codec.\n            if (fb.payload !== '*') {\n                const codec = codecsMap.get(fb.payload);\n                if (!codec) {\n                    continue;\n                }\n                codec.rtcpFeedback.push(feedback);\n            }\n            // If rtcp-fb payload is '*' it must be applied to all codecs with same\n            // kind (with some exceptions such as RTX codec).\n            else {\n                for (const codec of codecsMap.values()) {\n                    if (codec.kind === kind && !/.+\\/rtx$/i.test(codec.mimeType)) {\n                        codec.rtcpFeedback.push(feedback);\n                    }\n                }\n            }\n        }\n        // Get RTP header extensions.\n        for (const ext of m.ext || []) {\n            // Ignore encrypted extensions (not yet supported in mediasoup).\n            if (ext['encrypt-uri']) {\n                continue;\n            }\n            const headerExtension = {\n                kind: kind,\n                uri: ext.uri,\n                preferredId: ext.value,\n            };\n            headerExtensions.push(headerExtension);\n        }\n    }\n    const rtpCapabilities = {\n        codecs: Array.from(codecsMap.values()),\n        headerExtensions: headerExtensions,\n    };\n    return rtpCapabilities;\n}\nexports.extractRtpCapabilities = extractRtpCapabilities;\nfunction extractDtlsParameters({ sdpObject, }) {\n    let setup = sdpObject.setup;\n    let fingerprint = sdpObject.fingerprint;\n    if (!setup || !fingerprint) {\n        const mediaObject = (sdpObject.media || []).find((m) => m.port !== 0);\n        if (mediaObject) {\n            setup ?? (setup = mediaObject.setup);\n            fingerprint ?? (fingerprint = mediaObject.fingerprint);\n        }\n    }\n    if (!setup) {\n        throw new Error('no a=setup found at SDP session or media level');\n    }\n    else if (!fingerprint) {\n        throw new Error('no a=fingerprint found at SDP session or media level');\n    }\n    let role;\n    switch (setup) {\n        case 'active': {\n            role = 'client';\n            break;\n        }\n        case 'passive': {\n            role = 'server';\n            break;\n        }\n        case 'actpass': {\n            role = 'auto';\n            break;\n        }\n    }\n    const dtlsParameters = {\n        role,\n        fingerprints: [\n            {\n                algorithm: fingerprint.type,\n                value: fingerprint.hash,\n            },\n        ],\n    };\n    return dtlsParameters;\n}\nexports.extractDtlsParameters = extractDtlsParameters;\nfunction getCname({ offerMediaObject, }) {\n    const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine) {\n        return '';\n    }\n    return ssrcCnameLine.value;\n}\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject, }) {\n    for (const codec of offerRtpParameters.codecs) {\n        const mimeType = codec.mimeType.toLowerCase();\n        // Avoid parsing codec parameters for unhandled codecs.\n        if (mimeType !== 'audio/opus') {\n            continue;\n        }\n        const rtp = (answerMediaObject.rtp || []).find((r) => r.payload === codec.payloadType);\n        if (!rtp) {\n            continue;\n        }\n        // Just in case.\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n        let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);\n        if (!fmtp) {\n            fmtp = { payload: codec.payloadType, config: '' };\n            answerMediaObject.fmtp.push(fmtp);\n        }\n        const parameters = sdpTransform.parseParams(fmtp.config);\n        switch (mimeType) {\n            case 'audio/opus': {\n                const spropStereo = codec.parameters['sprop-stereo'];\n                if (spropStereo !== undefined) {\n                    parameters.stereo = spropStereo ? 1 : 0;\n                }\n                break;\n            }\n        }\n        // Write the codec fmtp.config back.\n        fmtp.config = '';\n        for (const key of Object.keys(parameters)) {\n            if (fmtp.config) {\n                fmtp.config += ';';\n            }\n            fmtp.config += `${key}=${parameters[key]}`;\n        }\n    }\n}\nexports.applyCodecParameters = applyCodecParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9jb21tb25VdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsZ0JBQWdCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCO0FBQ2hILGtDQUFrQyxtQkFBTyxDQUFDLHFIQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLLEdBQUcsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSw4QkFBOEIsSUFBSSxHQUFHLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9jb21tb25VdGlscy5qcz82ZmZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzID0gZXhwb3J0cy5nZXRDbmFtZSA9IGV4cG9ydHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzID0gZXhwb3J0cy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIFNEUCB3aXRoIDEgbT1hdWRpbyBhbmQgMSBtPXZpZGVvXG4gKiBzZWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7IHNkcE9iamVjdCwgfSkge1xuICAgIC8vIE1hcCBvZiBSdHBDb2RlY1BhcmFtZXRlcnMgaW5kZXhlZCBieSBwYXlsb2FkIHR5cGUuXG4gICAgY29uc3QgY29kZWNzTWFwID0gbmV3IE1hcCgpO1xuICAgIC8vIEFycmF5IG9mIFJ0cEhlYWRlckV4dGVuc2lvbnMuXG4gICAgY29uc3QgaGVhZGVyRXh0ZW5zaW9ucyA9IFtdO1xuICAgIC8vIFdoZXRoZXIgYSBtPWF1ZGlvL3ZpZGVvIHNlY3Rpb24gaGFzIGJlZW4gYWxyZWFkeSBmb3VuZC5cbiAgICBsZXQgZ290QXVkaW8gPSBmYWxzZTtcbiAgICBsZXQgZ290VmlkZW8gPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG0gb2Ygc2RwT2JqZWN0Lm1lZGlhKSB7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBtLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOiB7XG4gICAgICAgICAgICAgICAgaWYgKGdvdEF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnb3RBdWRpbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6IHtcbiAgICAgICAgICAgICAgICBpZiAoZ290VmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdvdFZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgY29kZWNzLlxuICAgICAgICBmb3IgKGNvbnN0IHJ0cCBvZiBtLnJ0cCkge1xuICAgICAgICAgICAgY29uc3QgY29kZWMgPSB7XG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYCR7a2luZH0vJHtydHAuY29kZWN9YCxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRQYXlsb2FkVHlwZTogcnRwLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgY2xvY2tSYXRlOiBydHAucmF0ZSxcbiAgICAgICAgICAgICAgICBjaGFubmVsczogcnRwLmVuY29kaW5nLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHJ0Y3BGZWVkYmFjazogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29kZWNzTWFwLnNldChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSwgY29kZWMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBjb2RlYyBwYXJhbWV0ZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbS5mbXRwIHx8IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gY29kZWNzTWFwLmdldChmbXRwLnBheWxvYWQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlYykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BlY2lhbHMgY2FzZSB0byBjb252ZXJ0IHBhcmFtZXRlciB2YWx1ZSB0byBzdHJpbmcuXG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KCdwcm9maWxlLWxldmVsLWlkJykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ10gPSBTdHJpbmcocGFyYW1ldGVyc1sncHJvZmlsZS1sZXZlbC1pZCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBSVENQIGZlZWRiYWNrIGZvciBlYWNoIGNvZGVjLlxuICAgICAgICBmb3IgKGNvbnN0IGZiIG9mIG0ucnRjcEZiIHx8IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcjogZmIuc3VidHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWZlZWRiYWNrLnBhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmZWVkYmFjay5wYXJhbWV0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBydGNwLWZiIHBheWxvYWQgaXMgbm90ICcqJywgc28ganVzdCBhcHBseSBpdCB0byBpdHMgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgLy8gY29kZWMuXG4gICAgICAgICAgICBpZiAoZmIucGF5bG9hZCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWMgPSBjb2RlY3NNYXAuZ2V0KGZiLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmICghY29kZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5wdXNoKGZlZWRiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHJ0Y3AtZmIgcGF5bG9hZCBpcyAnKicgaXQgbXVzdCBiZSBhcHBsaWVkIHRvIGFsbCBjb2RlY3Mgd2l0aCBzYW1lXG4gICAgICAgICAgICAvLyBraW5kICh3aXRoIHNvbWUgZXhjZXB0aW9ucyBzdWNoIGFzIFJUWCBjb2RlYykuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNvZGVjc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWMua2luZCA9PT0ga2luZCAmJiAhLy4rXFwvcnR4JC9pLnRlc3QoY29kZWMubWltZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmZWVkYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFJUUCBoZWFkZXIgZXh0ZW5zaW9ucy5cbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgbS5leHQgfHwgW10pIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbmNyeXB0ZWQgZXh0ZW5zaW9ucyAobm90IHlldCBzdXBwb3J0ZWQgaW4gbWVkaWFzb3VwKS5cbiAgICAgICAgICAgIGlmIChleHRbJ2VuY3J5cHQtdXJpJ10pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgIHVyaTogZXh0LnVyaSxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRJZDogZXh0LnZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlckV4dGVuc2lvbnMucHVzaChoZWFkZXJFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBBcnJheS5mcm9tKGNvZGVjc01hcC52YWx1ZXMoKSksXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IGhlYWRlckV4dGVuc2lvbnMsXG4gICAgfTtcbiAgICByZXR1cm4gcnRwQ2FwYWJpbGl0aWVzO1xufVxuZXhwb3J0cy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzID0gZXh0cmFjdFJ0cENhcGFiaWxpdGllcztcbmZ1bmN0aW9uIGV4dHJhY3REdGxzUGFyYW1ldGVycyh7IHNkcE9iamVjdCwgfSkge1xuICAgIGxldCBzZXR1cCA9IHNkcE9iamVjdC5zZXR1cDtcbiAgICBsZXQgZmluZ2VycHJpbnQgPSBzZHBPYmplY3QuZmluZ2VycHJpbnQ7XG4gICAgaWYgKCFzZXR1cCB8fCAhZmluZ2VycHJpbnQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFPYmplY3QgPSAoc2RwT2JqZWN0Lm1lZGlhIHx8IFtdKS5maW5kKChtKSA9PiBtLnBvcnQgIT09IDApO1xuICAgICAgICBpZiAobWVkaWFPYmplY3QpIHtcbiAgICAgICAgICAgIHNldHVwID8/IChzZXR1cCA9IG1lZGlhT2JqZWN0LnNldHVwKTtcbiAgICAgICAgICAgIGZpbmdlcnByaW50ID8/IChmaW5nZXJwcmludCA9IG1lZGlhT2JqZWN0LmZpbmdlcnByaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNldHVwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYT1zZXR1cCBmb3VuZCBhdCBTRFAgc2Vzc2lvbiBvciBtZWRpYSBsZXZlbCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICghZmluZ2VycHJpbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBhPWZpbmdlcnByaW50IGZvdW5kIGF0IFNEUCBzZXNzaW9uIG9yIG1lZGlhIGxldmVsJyk7XG4gICAgfVxuICAgIGxldCByb2xlO1xuICAgIHN3aXRjaCAoc2V0dXApIHtcbiAgICAgICAgY2FzZSAnYWN0aXZlJzoge1xuICAgICAgICAgICAgcm9sZSA9ICdjbGllbnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGFzc2l2ZSc6IHtcbiAgICAgICAgICAgIHJvbGUgPSAnc2VydmVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FjdHBhc3MnOiB7XG4gICAgICAgICAgICByb2xlID0gJ2F1dG8nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJvbGUsXG4gICAgICAgIGZpbmdlcnByaW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogZmluZ2VycHJpbnQudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmluZ2VycHJpbnQuaGFzaCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfTtcbiAgICByZXR1cm4gZHRsc1BhcmFtZXRlcnM7XG59XG5leHBvcnRzLmV4dHJhY3REdGxzUGFyYW1ldGVycyA9IGV4dHJhY3REdGxzUGFyYW1ldGVycztcbmZ1bmN0aW9uIGdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCwgfSkge1xuICAgIGNvbnN0IHNzcmNDbmFtZUxpbmUgPSAob2ZmZXJNZWRpYU9iamVjdC5zc3JjcyB8fCBbXSkuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgIGlmICghc3NyY0NuYW1lTGluZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzc3JjQ25hbWVMaW5lLnZhbHVlO1xufVxuZXhwb3J0cy5nZXRDbmFtZSA9IGdldENuYW1lO1xuLyoqXG4gKiBBcHBseSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBnaXZlbiBTRFAgbT0gc2VjdGlvbiBhbnN3ZXIgYmFzZWQgb24gdGhlXG4gKiBnaXZlbiBSVFAgcGFyYW1ldGVycyBvZiBhbiBvZmZlci5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDb2RlY1BhcmFtZXRlcnMoeyBvZmZlclJ0cFBhcmFtZXRlcnMsIGFuc3dlck1lZGlhT2JqZWN0LCB9KSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBvZmZlclJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gY29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gQXZvaWQgcGFyc2luZyBjb2RlYyBwYXJhbWV0ZXJzIGZvciB1bmhhbmRsZWQgY29kZWNzLlxuICAgICAgICBpZiAobWltZVR5cGUgIT09ICdhdWRpby9vcHVzJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnRwID0gKGFuc3dlck1lZGlhT2JqZWN0LnJ0cCB8fCBbXSkuZmluZCgocikgPT4gci5wYXlsb2FkID09PSBjb2RlYy5wYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmICghcnRwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKdXN0IGluIGNhc2UuXG4gICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LmZtdHAgPSBhbnN3ZXJNZWRpYU9iamVjdC5mbXRwIHx8IFtdO1xuICAgICAgICBsZXQgZm10cCA9IGFuc3dlck1lZGlhT2JqZWN0LmZtdHAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBjb2RlYy5wYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmICghZm10cCkge1xuICAgICAgICAgICAgZm10cCA9IHsgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsIGNvbmZpZzogJycgfTtcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgc3dpdGNoIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8vb3B1cyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJvcFN0ZXJlbyA9IGNvZGVjLnBhcmFtZXRlcnNbJ3Nwcm9wLXN0ZXJlbyddO1xuICAgICAgICAgICAgICAgIGlmIChzcHJvcFN0ZXJlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RlcmVvID0gc3Byb3BTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdGhlIGNvZGVjIGZtdHAuY29uZmlnIGJhY2suXG4gICAgICAgIGZtdHAuY29uZmlnID0gJyc7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICBpZiAoZm10cC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBgJHtrZXl9PSR7cGFyYW1ldGVyc1trZXldfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzID0gYXBwbHlDb2RlY1BhcmFtZXRlcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addLegacySimulcast = exports.getRtpEncodings = void 0;\nfunction getRtpEncodings({ offerMediaObject, track, }) {\n    // First media SSRC (or the only one).\n    let firstSsrc;\n    const ssrcs = new Set();\n    for (const line of offerMediaObject.ssrcs || []) {\n        if (line.attribute !== 'msid') {\n            continue;\n        }\n        const trackId = line.value.split(' ')[1];\n        if (trackId === track.id) {\n            const ssrc = line.id;\n            ssrcs.add(ssrc);\n            if (!firstSsrc) {\n                firstSsrc = ssrc;\n            }\n        }\n    }\n    if (ssrcs.size === 0) {\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\n    }\n    const ssrcToRtxSsrc = new Map();\n    // First assume RTX is used.\n    for (const line of offerMediaObject.ssrcGroups || []) {\n        if (line.semantics !== 'FID') {\n            continue;\n        }\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\n        ssrc = Number(ssrc);\n        rtxSsrc = Number(rtxSsrc);\n        if (ssrcs.has(ssrc)) {\n            // Remove both the SSRC and RTX SSRC from the set so later we know that they\n            // are already handled.\n            ssrcs.delete(ssrc);\n            ssrcs.delete(rtxSsrc);\n            // Add to the map.\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\n        }\n    }\n    // If the set of SSRCs is not empty it means that RTX is not being used, so take\n    // media SSRCs from there.\n    for (const ssrc of ssrcs) {\n        // Add to the map.\n        ssrcToRtxSsrc.set(ssrc, null);\n    }\n    const encodings = [];\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\n        const encoding = { ssrc };\n        if (rtxSsrc) {\n            encoding.rtx = { ssrc: rtxSsrc };\n        }\n        encodings.push(encoding);\n    }\n    return encodings;\n}\nexports.getRtpEncodings = getRtpEncodings;\n/**\n * Adds multi-ssrc based simulcast into the given SDP media section offer.\n */\nfunction addLegacySimulcast({ offerMediaObject, track, numStreams, }) {\n    if (numStreams <= 1) {\n        throw new TypeError('numStreams must be greater than 1');\n    }\n    let firstSsrc;\n    let firstRtxSsrc;\n    let streamId;\n    // Get the SSRC.\n    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {\n        if (line.attribute !== 'msid') {\n            return false;\n        }\n        const trackId = line.value.split(' ')[1];\n        if (trackId === track.id) {\n            firstSsrc = line.id;\n            streamId = line.value.split(' ')[0];\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    if (!ssrcMsidLine) {\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\n    }\n    // Get the SSRC for RTX.\n    (offerMediaObject.ssrcGroups || []).some((line) => {\n        if (line.semantics !== 'FID') {\n            return false;\n        }\n        const ssrcs = line.ssrcs.split(/\\s+/);\n        if (Number(ssrcs[0]) === firstSsrc) {\n            firstRtxSsrc = Number(ssrcs[1]);\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === 'cname' && line.id === firstSsrc);\n    if (!ssrcCnameLine) {\n        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);\n    }\n    const cname = ssrcCnameLine.value;\n    const ssrcs = [];\n    const rtxSsrcs = [];\n    for (let i = 0; i < numStreams; ++i) {\n        ssrcs.push(firstSsrc + i);\n        if (firstRtxSsrc) {\n            rtxSsrcs.push(firstRtxSsrc + i);\n        }\n    }\n    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];\n    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];\n    offerMediaObject.ssrcGroups.push({\n        semantics: 'SIM',\n        ssrcs: ssrcs.join(' '),\n    });\n    for (let i = 0; i < ssrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'cname',\n            value: cname,\n        });\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'msid',\n            value: `${streamId} ${track.id}`,\n        });\n    }\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        const rtxSsrc = rtxSsrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'cname',\n            value: cname,\n        });\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'msid',\n            value: `${streamId} ${track.id}`,\n        });\n        offerMediaObject.ssrcGroups.push({\n            semantics: 'FID',\n            ssrcs: `${ssrc} ${rtxSsrc}`,\n        });\n    }\n}\nexports.addLegacySimulcast = addLegacySimulcast;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9wbGFuQlV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHVCQUF1QjtBQUNwRCwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsU0FBUztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRkFBaUYsU0FBUztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrRkFBa0YsU0FBUztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVLEVBQUUsU0FBUztBQUMzQyxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVSxFQUFFLFNBQVM7QUFDM0MsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLFFBQVE7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9wbGFuQlV0aWxzLmpzP2ZmNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGV4cG9ydHMuZ2V0UnRwRW5jb2RpbmdzID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0UnRwRW5jb2RpbmdzKHsgb2ZmZXJNZWRpYU9iamVjdCwgdHJhY2ssIH0pIHtcbiAgICAvLyBGaXJzdCBtZWRpYSBTU1JDIChvciB0aGUgb25seSBvbmUpLlxuICAgIGxldCBmaXJzdFNzcmM7XG4gICAgY29uc3Qgc3NyY3MgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pIHtcbiAgICAgICAgaWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrSWQgPSBsaW5lLnZhbHVlLnNwbGl0KCcgJylbMV07XG4gICAgICAgIGlmICh0cmFja0lkID09PSB0cmFjay5pZCkge1xuICAgICAgICAgICAgY29uc3Qgc3NyYyA9IGxpbmUuaWQ7XG4gICAgICAgICAgICBzc3Jjcy5hZGQoc3NyYyk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0U3NyYykge1xuICAgICAgICAgICAgICAgIGZpcnN0U3NyYyA9IHNzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNzcmNzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhPXNzcmMgbGluZSB3aXRoIG1zaWQgaW5mb3JtYXRpb24gbm90IGZvdW5kIFt0cmFjay5pZDoke3RyYWNrLmlkfV1gKTtcbiAgICB9XG4gICAgY29uc3Qgc3NyY1RvUnR4U3NyYyA9IG5ldyBNYXAoKTtcbiAgICAvLyBGaXJzdCBhc3N1bWUgUlRYIGlzIHVzZWQuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSkge1xuICAgICAgICBpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW3NzcmMsIHJ0eFNzcmNdID0gbGluZS5zc3Jjcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBzc3JjID0gTnVtYmVyKHNzcmMpO1xuICAgICAgICBydHhTc3JjID0gTnVtYmVyKHJ0eFNzcmMpO1xuICAgICAgICBpZiAoc3NyY3MuaGFzKHNzcmMpKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYm90aCB0aGUgU1NSQyBhbmQgUlRYIFNTUkMgZnJvbSB0aGUgc2V0IHNvIGxhdGVyIHdlIGtub3cgdGhhdCB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgYWxyZWFkeSBoYW5kbGVkLlxuICAgICAgICAgICAgc3NyY3MuZGVsZXRlKHNzcmMpO1xuICAgICAgICAgICAgc3NyY3MuZGVsZXRlKHJ0eFNzcmMpO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgICAgICBzc3JjVG9SdHhTc3JjLnNldChzc3JjLCBydHhTc3JjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc2V0IG9mIFNTUkNzIGlzIG5vdCBlbXB0eSBpdCBtZWFucyB0aGF0IFJUWCBpcyBub3QgYmVpbmcgdXNlZCwgc28gdGFrZVxuICAgIC8vIG1lZGlhIFNTUkNzIGZyb20gdGhlcmUuXG4gICAgZm9yIChjb25zdCBzc3JjIG9mIHNzcmNzKSB7XG4gICAgICAgIC8vIEFkZCB0byB0aGUgbWFwLlxuICAgICAgICBzc3JjVG9SdHhTc3JjLnNldChzc3JjLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmdzID0gW107XG4gICAgZm9yIChjb25zdCBbc3NyYywgcnR4U3NyY10gb2Ygc3NyY1RvUnR4U3NyYykge1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHsgc3NyYyB9O1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiBydHhTc3JjIH07XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RpbmdzO1xufVxuZXhwb3J0cy5nZXRSdHBFbmNvZGluZ3MgPSBnZXRSdHBFbmNvZGluZ3M7XG4vKipcbiAqIEFkZHMgbXVsdGktc3NyYyBiYXNlZCBzaW11bGNhc3QgaW50byB0aGUgZ2l2ZW4gU0RQIG1lZGlhIHNlY3Rpb24gb2ZmZXIuXG4gKi9cbmZ1bmN0aW9uIGFkZExlZ2FjeVNpbXVsY2FzdCh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrLCBudW1TdHJlYW1zLCB9KSB7XG4gICAgaWYgKG51bVN0cmVhbXMgPD0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdudW1TdHJlYW1zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0U3NyYztcbiAgICBsZXQgZmlyc3RSdHhTc3JjO1xuICAgIGxldCBzdHJlYW1JZDtcbiAgICAvLyBHZXQgdGhlIFNTUkMuXG4gICAgY29uc3Qgc3NyY01zaWRMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pLmZpbmQoKGxpbmUpID0+IHtcbiAgICAgICAgaWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFja0lkID0gbGluZS52YWx1ZS5zcGxpdCgnICcpWzFdO1xuICAgICAgICBpZiAodHJhY2tJZCA9PT0gdHJhY2suaWQpIHtcbiAgICAgICAgICAgIGZpcnN0U3NyYyA9IGxpbmUuaWQ7XG4gICAgICAgICAgICBzdHJlYW1JZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFzc3JjTXNpZExpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhPXNzcmMgbGluZSB3aXRoIG1zaWQgaW5mb3JtYXRpb24gbm90IGZvdW5kIFt0cmFjay5pZDoke3RyYWNrLmlkfV1gKTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBTU1JDIGZvciBSVFguXG4gICAgKG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSkuc29tZSgobGluZSkgPT4ge1xuICAgICAgICBpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3NyY3MgPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmIChOdW1iZXIoc3NyY3NbMF0pID09PSBmaXJzdFNzcmMpIHtcbiAgICAgICAgICAgIGZpcnN0UnR4U3NyYyA9IE51bWJlcihzc3Jjc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNzcmNDbmFtZUxpbmUgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLmZpbmQoKGxpbmUpID0+IGxpbmUuYXR0cmlidXRlID09PSAnY25hbWUnICYmIGxpbmUuaWQgPT09IGZpcnN0U3NyYyk7XG4gICAgaWYgKCFzc3JjQ25hbWVMaW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYT1zc3JjIGxpbmUgd2l0aCBjbmFtZSBpbmZvcm1hdGlvbiBub3QgZm91bmQgW3RyYWNrLmlkOiR7dHJhY2suaWR9XWApO1xuICAgIH1cbiAgICBjb25zdCBjbmFtZSA9IHNzcmNDbmFtZUxpbmUudmFsdWU7XG4gICAgY29uc3Qgc3NyY3MgPSBbXTtcbiAgICBjb25zdCBydHhTc3JjcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3RyZWFtczsgKytpKSB7XG4gICAgICAgIHNzcmNzLnB1c2goZmlyc3RTc3JjICsgaSk7XG4gICAgICAgIGlmIChmaXJzdFJ0eFNzcmMpIHtcbiAgICAgICAgICAgIHJ0eFNzcmNzLnB1c2goZmlyc3RSdHhTc3JjICsgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzID0gb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdO1xuICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNzIHx8IFtdO1xuICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3Vwcy5wdXNoKHtcbiAgICAgICAgc2VtYW50aWNzOiAnU0lNJyxcbiAgICAgICAgc3NyY3M6IHNzcmNzLmpvaW4oJyAnKSxcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzcmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNzcmMgPSBzc3Jjc1tpXTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgdmFsdWU6IGNuYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWR9ICR7dHJhY2suaWR9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnR4U3NyY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc3NyYyA9IHNzcmNzW2ldO1xuICAgICAgICBjb25zdCBydHhTc3JjID0gcnR4U3NyY3NbaV07XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBjbmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkfSAke3RyYWNrLmlkfWAsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGFkZExlZ2FjeVNpbXVsY2FzdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addLegacySimulcast = exports.getRtpEncodings = void 0;\nfunction getRtpEncodings({ offerMediaObject, }) {\n    const ssrcs = new Set();\n    for (const line of offerMediaObject.ssrcs || []) {\n        const ssrc = line.id;\n        ssrcs.add(ssrc);\n    }\n    if (ssrcs.size === 0) {\n        throw new Error('no a=ssrc lines found');\n    }\n    const ssrcToRtxSsrc = new Map();\n    // First assume RTX is used.\n    for (const line of offerMediaObject.ssrcGroups || []) {\n        if (line.semantics !== 'FID') {\n            continue;\n        }\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\n        ssrc = Number(ssrc);\n        rtxSsrc = Number(rtxSsrc);\n        if (ssrcs.has(ssrc)) {\n            // Remove both the SSRC and RTX SSRC from the set so later we know\n            // that they are already handled.\n            ssrcs.delete(ssrc);\n            ssrcs.delete(rtxSsrc);\n            // Add to the map.\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\n        }\n    }\n    // If the set of SSRCs is not empty it means that RTX is not being used, so\n    // take media SSRCs from there.\n    for (const ssrc of ssrcs) {\n        // Add to the map.\n        ssrcToRtxSsrc.set(ssrc, null);\n    }\n    const encodings = [];\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\n        const encoding = { ssrc };\n        if (rtxSsrc) {\n            encoding.rtx = { ssrc: rtxSsrc };\n        }\n        encodings.push(encoding);\n    }\n    return encodings;\n}\nexports.getRtpEncodings = getRtpEncodings;\n/**\n * Adds multi-ssrc based simulcast into the given SDP media section offer.\n */\nfunction addLegacySimulcast({ offerMediaObject, numStreams, }) {\n    if (numStreams <= 1) {\n        throw new TypeError('numStreams must be greater than 1');\n    }\n    // Get the SSRC.\n    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === 'msid');\n    if (!ssrcMsidLine) {\n        throw new Error('a=ssrc line with msid information not found');\n    }\n    const [streamId, trackId] = ssrcMsidLine.value.split(' ');\n    const firstSsrc = ssrcMsidLine.id;\n    let firstRtxSsrc;\n    // Get the SSRC for RTX.\n    (offerMediaObject.ssrcGroups || []).some((line) => {\n        if (line.semantics !== 'FID') {\n            return false;\n        }\n        const ssrcs = line.ssrcs.split(/\\s+/);\n        if (Number(ssrcs[0]) === firstSsrc) {\n            firstRtxSsrc = Number(ssrcs[1]);\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine) {\n        throw new Error('a=ssrc line with cname information not found');\n    }\n    const cname = ssrcCnameLine.value;\n    const ssrcs = [];\n    const rtxSsrcs = [];\n    for (let i = 0; i < numStreams; ++i) {\n        ssrcs.push(firstSsrc + i);\n        if (firstRtxSsrc) {\n            rtxSsrcs.push(firstRtxSsrc + i);\n        }\n    }\n    offerMediaObject.ssrcGroups = [];\n    offerMediaObject.ssrcs = [];\n    offerMediaObject.ssrcGroups.push({\n        semantics: 'SIM',\n        ssrcs: ssrcs.join(' '),\n    });\n    for (let i = 0; i < ssrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'cname',\n            value: cname,\n        });\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'msid',\n            value: `${streamId} ${trackId}`,\n        });\n    }\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        const rtxSsrc = rtxSsrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'cname',\n            value: cname,\n        });\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'msid',\n            value: `${streamId} ${trackId}`,\n        });\n        offerMediaObject.ssrcGroups.push({\n            semantics: 'FID',\n            ssrcs: `${ssrc} ${rtxSsrc}`,\n        });\n    }\n}\nexports.addLegacySimulcast = addLegacySimulcast;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC91bmlmaWVkUGxhblV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHVCQUF1QjtBQUNwRCwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVSxFQUFFLFFBQVE7QUFDMUMsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsRUFBRSxRQUFRO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sRUFBRSxRQUFRO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9zZHAvdW5pZmllZFBsYW5VdGlscy5qcz85MDgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRMZWdhY3lTaW11bGNhc3QgPSBleHBvcnRzLmdldFJ0cEVuY29kaW5ncyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIH0pIHtcbiAgICBjb25zdCBzc3JjcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb2ZmZXJNZWRpYU9iamVjdC5zc3JjcyB8fCBbXSkge1xuICAgICAgICBjb25zdCBzc3JjID0gbGluZS5pZDtcbiAgICAgICAgc3NyY3MuYWRkKHNzcmMpO1xuICAgIH1cbiAgICBpZiAoc3NyY3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGE9c3NyYyBsaW5lcyBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBzc3JjVG9SdHhTc3JjID0gbmV3IE1hcCgpO1xuICAgIC8vIEZpcnN0IGFzc3VtZSBSVFggaXMgdXNlZC5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdKSB7XG4gICAgICAgIGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbc3NyYywgcnR4U3NyY10gPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHNzcmMgPSBOdW1iZXIoc3NyYyk7XG4gICAgICAgIHJ0eFNzcmMgPSBOdW1iZXIocnR4U3NyYyk7XG4gICAgICAgIGlmIChzc3Jjcy5oYXMoc3NyYykpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBib3RoIHRoZSBTU1JDIGFuZCBSVFggU1NSQyBmcm9tIHRoZSBzZXQgc28gbGF0ZXIgd2Uga25vd1xuICAgICAgICAgICAgLy8gdGhhdCB0aGV5IGFyZSBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUoc3NyYyk7XG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUocnR4U3NyYyk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIHJ0eFNzcmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzZXQgb2YgU1NSQ3MgaXMgbm90IGVtcHR5IGl0IG1lYW5zIHRoYXQgUlRYIGlzIG5vdCBiZWluZyB1c2VkLCBzb1xuICAgIC8vIHRha2UgbWVkaWEgU1NSQ3MgZnJvbSB0aGVyZS5cbiAgICBmb3IgKGNvbnN0IHNzcmMgb2Ygc3NyY3MpIHtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzc3JjLCBydHhTc3JjXSBvZiBzc3JjVG9SdHhTc3JjKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0geyBzc3JjIH07XG4gICAgICAgIGlmIChydHhTc3JjKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5ydHggPSB7IHNzcmM6IHJ0eFNzcmMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZ3MucHVzaChlbmNvZGluZyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGluZ3M7XG59XG5leHBvcnRzLmdldFJ0cEVuY29kaW5ncyA9IGdldFJ0cEVuY29kaW5ncztcbi8qKlxuICogQWRkcyBtdWx0aS1zc3JjIGJhc2VkIHNpbXVsY2FzdCBpbnRvIHRoZSBnaXZlbiBTRFAgbWVkaWEgc2VjdGlvbiBvZmZlci5cbiAqL1xuZnVuY3Rpb24gYWRkTGVnYWN5U2ltdWxjYXN0KHsgb2ZmZXJNZWRpYU9iamVjdCwgbnVtU3RyZWFtcywgfSkge1xuICAgIGlmIChudW1TdHJlYW1zIDw9IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtU3RyZWFtcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgU1NSQy5cbiAgICBjb25zdCBzc3JjTXNpZExpbmUgPSAob2ZmZXJNZWRpYU9iamVjdC5zc3JjcyB8fCBbXSkuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gICAgaWYgKCFzc3JjTXNpZExpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhPXNzcmMgbGluZSB3aXRoIG1zaWQgaW5mb3JtYXRpb24gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IFtzdHJlYW1JZCwgdHJhY2tJZF0gPSBzc3JjTXNpZExpbmUudmFsdWUuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBmaXJzdFNzcmMgPSBzc3JjTXNpZExpbmUuaWQ7XG4gICAgbGV0IGZpcnN0UnR4U3NyYztcbiAgICAvLyBHZXQgdGhlIFNTUkMgZm9yIFJUWC5cbiAgICAob2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdKS5zb21lKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzc3JjcyA9IGxpbmUuc3NyY3Muc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKE51bWJlcihzc3Jjc1swXSkgPT09IGZpcnN0U3NyYykge1xuICAgICAgICAgICAgZmlyc3RSdHhTc3JjID0gTnVtYmVyKHNzcmNzWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3NyY0NuYW1lTGluZSA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3MuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgIGlmICghc3NyY0NuYW1lTGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2E9c3NyYyBsaW5lIHdpdGggY25hbWUgaW5mb3JtYXRpb24gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGNuYW1lID0gc3NyY0NuYW1lTGluZS52YWx1ZTtcbiAgICBjb25zdCBzc3JjcyA9IFtdO1xuICAgIGNvbnN0IHJ0eFNzcmNzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TdHJlYW1zOyArK2kpIHtcbiAgICAgICAgc3NyY3MucHVzaChmaXJzdFNzcmMgKyBpKTtcbiAgICAgICAgaWYgKGZpcnN0UnR4U3NyYykge1xuICAgICAgICAgICAgcnR4U3NyY3MucHVzaChmaXJzdFJ0eFNzcmMgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBbXTtcbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzID0gW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICBzZW1hbnRpY3M6ICdTSU0nLFxuICAgICAgICBzc3Jjczogc3NyY3Muam9pbignICcpLFxuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3NyY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc3NyYyA9IHNzcmNzW2ldO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogY25hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFja0lkfWAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ0eFNzcmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNzcmMgPSBzc3Jjc1tpXTtcbiAgICAgICAgY29uc3QgcnR4U3NyYyA9IHJ0eFNzcmNzW2ldO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogY25hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFja0lkfWAsXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGFkZExlZ2FjeVNpbXVsY2FzdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/index.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(app-client)/./node_modules/.pnpm/debug@4.3.4_supports-color@9.4.0/node_modules/debug/src/browser.js\"));\nexports.debug = debug_1.default;\nconst Device_1 = __webpack_require__(/*! ./Device */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Device.js\");\nObject.defineProperty(exports, \"Device\", ({ enumerable: true, get: function () { return Device_1.Device; } }));\nObject.defineProperty(exports, \"detectDevice\", ({ enumerable: true, get: function () { return Device_1.detectDevice; } }));\nconst types = __importStar(__webpack_require__(/*! ./types */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/types.js\"));\nexports.types = types;\n/**\n * Expose mediasoup-client version.\n */\nexports.version = '3.7.2';\n/**\n * Expose parseScalabilityMode() function.\n */\nvar scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\");\nObject.defineProperty(exports, \"parseScalabilityMode\", ({ enumerable: true, get: function () { return scalabilityModes_1.parse; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGFBQWE7QUFDdEgsZ0NBQWdDLG1CQUFPLENBQUMsbUhBQU87QUFDL0MsYUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHNIQUFVO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1RyxnREFBK0MsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDeEgsMkJBQTJCLG1CQUFPLENBQUMsb0hBQVM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQywwSUFBb0I7QUFDckQsd0RBQXVELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9pbmRleC5qcz9hZTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlYnVnID0gZXhwb3J0cy5wYXJzZVNjYWxhYmlsaXR5TW9kZSA9IGV4cG9ydHMuZGV0ZWN0RGV2aWNlID0gZXhwb3J0cy5EZXZpY2UgPSBleHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLnR5cGVzID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdDtcbmNvbnN0IERldmljZV8xID0gcmVxdWlyZShcIi4vRGV2aWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGV2aWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZXZpY2VfMS5EZXZpY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXRlY3REZXZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERldmljZV8xLmRldGVjdERldmljZTsgfSB9KTtcbmNvbnN0IHR5cGVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpKTtcbmV4cG9ydHMudHlwZXMgPSB0eXBlcztcbi8qKlxuICogRXhwb3NlIG1lZGlhc291cC1jbGllbnQgdmVyc2lvbi5cbiAqL1xuZXhwb3J0cy52ZXJzaW9uID0gJzMuNy4yJztcbi8qKlxuICogRXhwb3NlIHBhcnNlU2NhbGFiaWxpdHlNb2RlKCkgZnVuY3Rpb24uXG4gKi9cbnZhciBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi9zY2FsYWJpbGl0eU1vZGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VTY2FsYWJpbGl0eU1vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\nconst h264 = __importStar(__webpack_require__(/*! h264-profile-level-id */ \"(app-client)/./node_modules/.pnpm/h264-profile-level-id@2.0.0_supports-color@9.4.0/node_modules/h264-profile-level-id/lib/index.js\"));\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\"));\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n    if (typeof caps !== 'object') {\n        throw new TypeError('caps is not an object');\n    }\n    // codecs is optional. If unset, fill with an empty array.\n    if (caps.codecs && !Array.isArray(caps.codecs)) {\n        throw new TypeError('caps.codecs is not an array');\n    }\n    else if (!caps.codecs) {\n        caps.codecs = [];\n    }\n    for (const codec of caps.codecs) {\n        validateRtpCodecCapability(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {\n        throw new TypeError('caps.headerExtensions is not an array');\n    }\n    else if (!caps.headerExtensions) {\n        caps.headerExtensions = [];\n    }\n    for (const ext of caps.headerExtensions) {\n        validateRtpHeaderExtension(ext);\n    }\n}\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object') {\n        throw new TypeError('codec is not an object');\n    }\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n        throw new TypeError('missing codec.mimeType');\n    }\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    // Just override kind with media component of mimeType.\n    codec.kind = mimeTypeMatch[1].toLowerCase();\n    // preferredPayloadType is optional.\n    if (codec.preferredPayloadType &&\n        typeof codec.preferredPayloadType !== 'number') {\n        throw new TypeError('invalid codec.preferredPayloadType');\n    }\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number') {\n        throw new TypeError('missing codec.clockRate');\n    }\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (codec.kind === 'audio') {\n        if (typeof codec.channels !== 'number') {\n            codec.channels = 1;\n        }\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object') {\n        codec.parameters = {};\n    }\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number') {\n                throw new TypeError('invalid codec apt parameter');\n            }\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n        codec.rtcpFeedback = [];\n    }\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n    if (typeof fb !== 'object') {\n        throw new TypeError('fb is not an object');\n    }\n    // type is mandatory.\n    if (!fb.type || typeof fb.type !== 'string') {\n        throw new TypeError('missing fb.type');\n    }\n    // parameter is optional. If unset set it to an empty string.\n    if (!fb.parameter || typeof fb.parameter !== 'string') {\n        fb.parameter = '';\n    }\n}\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n    if (typeof ext !== 'object') {\n        throw new TypeError('ext is not an object');\n    }\n    // kind is mandatory.\n    if (ext.kind !== 'audio' && ext.kind !== 'video') {\n        throw new TypeError('invalid ext.kind');\n    }\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string') {\n        throw new TypeError('missing ext.uri');\n    }\n    // preferredId is mandatory.\n    if (typeof ext.preferredId !== 'number') {\n        throw new TypeError('missing ext.preferredId');\n    }\n    // preferredEncrypt is optional. If unset set it to false.\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {\n        throw new TypeError('invalid ext.preferredEncrypt');\n    }\n    else if (!ext.preferredEncrypt) {\n        ext.preferredEncrypt = false;\n    }\n    // direction is optional. If unset set it to sendrecv.\n    if (ext.direction && typeof ext.direction !== 'string') {\n        throw new TypeError('invalid ext.direction');\n    }\n    else if (!ext.direction) {\n        ext.direction = 'sendrecv';\n    }\n}\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // mid is optional.\n    if (params.mid && typeof params.mid !== 'string') {\n        throw new TypeError('params.mid is not a string');\n    }\n    // codecs is mandatory.\n    if (!Array.isArray(params.codecs)) {\n        throw new TypeError('missing params.codecs');\n    }\n    for (const codec of params.codecs) {\n        validateRtpCodecParameters(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {\n        throw new TypeError('params.headerExtensions is not an array');\n    }\n    else if (!params.headerExtensions) {\n        params.headerExtensions = [];\n    }\n    for (const ext of params.headerExtensions) {\n        validateRtpHeaderExtensionParameters(ext);\n    }\n    // encodings is optional. If unset, fill with an empty array.\n    if (params.encodings && !Array.isArray(params.encodings)) {\n        throw new TypeError('params.encodings is not an array');\n    }\n    else if (!params.encodings) {\n        params.encodings = [];\n    }\n    for (const encoding of params.encodings) {\n        validateRtpEncodingParameters(encoding);\n    }\n    // rtcp is optional. If unset, fill with an empty object.\n    if (params.rtcp && typeof params.rtcp !== 'object') {\n        throw new TypeError('params.rtcp is not an object');\n    }\n    else if (!params.rtcp) {\n        params.rtcp = {};\n    }\n    validateRtcpParameters(params.rtcp);\n}\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object') {\n        throw new TypeError('codec is not an object');\n    }\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n        throw new TypeError('missing codec.mimeType');\n    }\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    // payloadType is mandatory.\n    if (typeof codec.payloadType !== 'number') {\n        throw new TypeError('missing codec.payloadType');\n    }\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number') {\n        throw new TypeError('missing codec.clockRate');\n    }\n    const kind = mimeTypeMatch[1].toLowerCase();\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (kind === 'audio') {\n        if (typeof codec.channels !== 'number') {\n            codec.channels = 1;\n        }\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object') {\n        codec.parameters = {};\n    }\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number') {\n                throw new TypeError('invalid codec apt parameter');\n            }\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n        codec.rtcpFeedback = [];\n    }\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n    if (typeof ext !== 'object') {\n        throw new TypeError('ext is not an object');\n    }\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string') {\n        throw new TypeError('missing ext.uri');\n    }\n    // id is mandatory.\n    if (typeof ext.id !== 'number') {\n        throw new TypeError('missing ext.id');\n    }\n    // encrypt is optional. If unset set it to false.\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {\n        throw new TypeError('invalid ext.encrypt');\n    }\n    else if (!ext.encrypt) {\n        ext.encrypt = false;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!ext.parameters || typeof ext.parameters !== 'object') {\n        ext.parameters = {};\n    }\n    for (const key of Object.keys(ext.parameters)) {\n        let value = ext.parameters[key];\n        if (value === undefined) {\n            ext.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError('invalid header extension parameter');\n        }\n    }\n}\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n    if (typeof encoding !== 'object') {\n        throw new TypeError('encoding is not an object');\n    }\n    // ssrc is optional.\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {\n        throw new TypeError('invalid encoding.ssrc');\n    }\n    // rid is optional.\n    if (encoding.rid && typeof encoding.rid !== 'string') {\n        throw new TypeError('invalid encoding.rid');\n    }\n    // rtx is optional.\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\n        throw new TypeError('invalid encoding.rtx');\n    }\n    else if (encoding.rtx) {\n        // RTX ssrc is mandatory if rtx is present.\n        if (typeof encoding.rtx.ssrc !== 'number') {\n            throw new TypeError('missing encoding.rtx.ssrc');\n        }\n    }\n    // dtx is optional. If unset set it to false.\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {\n        encoding.dtx = false;\n    }\n    // scalabilityMode is optional.\n    if (encoding.scalabilityMode &&\n        typeof encoding.scalabilityMode !== 'string') {\n        throw new TypeError('invalid encoding.scalabilityMode');\n    }\n}\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n    if (typeof rtcp !== 'object') {\n        throw new TypeError('rtcp is not an object');\n    }\n    // cname is optional.\n    if (rtcp.cname && typeof rtcp.cname !== 'string') {\n        throw new TypeError('invalid rtcp.cname');\n    }\n    // reducedSize is optional. If unset set it to true.\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {\n        rtcp.reducedSize = true;\n    }\n}\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n    if (typeof caps !== 'object') {\n        throw new TypeError('caps is not an object');\n    }\n    // numStreams is mandatory.\n    if (!caps.numStreams || typeof caps.numStreams !== 'object') {\n        throw new TypeError('missing caps.numStreams');\n    }\n    validateNumSctpStreams(caps.numStreams);\n}\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n    if (typeof numStreams !== 'object') {\n        throw new TypeError('numStreams is not an object');\n    }\n    // OS is mandatory.\n    if (typeof numStreams.OS !== 'number') {\n        throw new TypeError('missing numStreams.OS');\n    }\n    // MIS is mandatory.\n    if (typeof numStreams.MIS !== 'number') {\n        throw new TypeError('missing numStreams.MIS');\n    }\n}\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // port is mandatory.\n    if (typeof params.port !== 'number') {\n        throw new TypeError('missing params.port');\n    }\n    // OS is mandatory.\n    if (typeof params.OS !== 'number') {\n        throw new TypeError('missing params.OS');\n    }\n    // MIS is mandatory.\n    if (typeof params.MIS !== 'number') {\n        throw new TypeError('missing params.MIS');\n    }\n    // maxMessageSize is mandatory.\n    if (typeof params.maxMessageSize !== 'number') {\n        throw new TypeError('missing params.maxMessageSize');\n    }\n}\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // streamId is mandatory.\n    if (typeof params.streamId !== 'number') {\n        throw new TypeError('missing params.streamId');\n    }\n    // ordered is optional.\n    let orderedGiven = false;\n    if (typeof params.ordered === 'boolean') {\n        orderedGiven = true;\n    }\n    else {\n        params.ordered = true;\n    }\n    // maxPacketLifeTime is optional.\n    if (params.maxPacketLifeTime &&\n        typeof params.maxPacketLifeTime !== 'number') {\n        throw new TypeError('invalid params.maxPacketLifeTime');\n    }\n    // maxRetransmits is optional.\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {\n        throw new TypeError('invalid params.maxRetransmits');\n    }\n    if (params.maxPacketLifeTime && params.maxRetransmits) {\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n    }\n    if (orderedGiven &&\n        params.ordered &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n    }\n    else if (!orderedGiven &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        params.ordered = false;\n    }\n    // label is optional.\n    if (params.label && typeof params.label !== 'string') {\n        throw new TypeError('invalid params.label');\n    }\n    // protocol is optional.\n    if (params.protocol && typeof params.protocol !== 'string') {\n        throw new TypeError('invalid params.protocol');\n    }\n}\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n    const extendedRtpCapabilities = {\n        codecs: [],\n        headerExtensions: [],\n    };\n    // Match media codecs and keep the order preferred by remoteCaps.\n    for (const remoteCodec of remoteCaps.codecs || []) {\n        if (isRtxCodec(remoteCodec)) {\n            continue;\n        }\n        const matchingLocalCodec = (localCaps.codecs || []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));\n        if (!matchingLocalCodec) {\n            continue;\n        }\n        const extendedCodec = {\n            mimeType: matchingLocalCodec.mimeType,\n            kind: matchingLocalCodec.kind,\n            clockRate: matchingLocalCodec.clockRate,\n            channels: matchingLocalCodec.channels,\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\n            localRtxPayloadType: undefined,\n            remotePayloadType: remoteCodec.preferredPayloadType,\n            remoteRtxPayloadType: undefined,\n            localParameters: matchingLocalCodec.parameters,\n            remoteParameters: remoteCodec.parameters,\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),\n        };\n        extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n    // Match RTX codecs.\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) &&\n            localCodec.parameters.apt === extendedCodec.localPayloadType);\n        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) &&\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType);\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n            extendedCodec.localRtxPayloadType =\n                matchingLocalRtxCodec.preferredPayloadType;\n            extendedCodec.remoteRtxPayloadType =\n                matchingRemoteRtxCodec.preferredPayloadType;\n        }\n    }\n    // Match header extensions.\n    for (const remoteExt of remoteCaps.headerExtensions) {\n        const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));\n        if (!matchingLocalExt) {\n            continue;\n        }\n        const extendedExt = {\n            kind: remoteExt.kind,\n            uri: remoteExt.uri,\n            sendId: matchingLocalExt.preferredId,\n            recvId: remoteExt.preferredId,\n            encrypt: matchingLocalExt.preferredEncrypt,\n            direction: 'sendrecv',\n        };\n        switch (remoteExt.direction) {\n            case 'sendrecv': {\n                extendedExt.direction = 'sendrecv';\n                break;\n            }\n            case 'recvonly': {\n                extendedExt.direction = 'sendonly';\n                break;\n            }\n            case 'sendonly': {\n                extendedExt.direction = 'recvonly';\n                break;\n            }\n            case 'inactive': {\n                extendedExt.direction = 'inactive';\n                break;\n            }\n        }\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    }\n    return extendedRtpCapabilities;\n}\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n    const rtpCapabilities = {\n        codecs: [],\n        headerExtensions: [],\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remotePayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback,\n        };\n        rtpCapabilities.codecs.push(codec);\n        // Add RTX codec.\n        if (!extendedCodec.remoteRtxPayloadType) {\n            continue;\n        }\n        const rtxCodec = {\n            mimeType: `${extendedCodec.kind}/rtx`,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n            clockRate: extendedCodec.clockRate,\n            parameters: {\n                apt: extendedCodec.remotePayloadType,\n            },\n            rtcpFeedback: [],\n        };\n        rtpCapabilities.codecs.push(rtxCodec);\n        // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions not valid for receiving.\n        if (extendedExtension.direction !== 'sendrecv' &&\n            extendedExtension.direction !== 'recvonly') {\n            continue;\n        }\n        const ext = {\n            kind: extendedExtension.kind,\n            uri: extendedExtension.uri,\n            preferredId: extendedExtension.recvId,\n            preferredEncrypt: extendedExtension.encrypt,\n            direction: extendedExtension.direction,\n        };\n        rtpCapabilities.headerExtensions.push(ext);\n    }\n    return rtpCapabilities;\n}\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {},\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind) {\n            continue;\n        }\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback,\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType,\n                },\n                rtcpFeedback: [],\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {},\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    return rtpParameters;\n}\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {},\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind) {\n            continue;\n        }\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.remoteParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback,\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType,\n                },\n                rtcpFeedback: [],\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {},\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n    if (rtpParameters.headerExtensions.some(ext => ext.uri ===\n        'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== 'goog-remb');\n        }\n    }\n    else if (rtpParameters.headerExtensions.some(ext => ext.uri ===\n        'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'transport-cc');\n        }\n    }\n    else {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');\n        }\n    }\n    return rtpParameters;\n}\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n    const filteredCodecs = [];\n    // If no capability codec is given, take the first one (and RTX).\n    if (!capCodec) {\n        filteredCodecs.push(codecs[0]);\n        if (isRtxCodec(codecs[1])) {\n            filteredCodecs.push(codecs[1]);\n        }\n    }\n    // Otherwise look for a compatible set of codecs.\n    else {\n        for (let idx = 0; idx < codecs.length; ++idx) {\n            if (matchCodecs(codecs[idx], capCodec)) {\n                filteredCodecs.push(codecs[idx]);\n                if (isRtxCodec(codecs[idx + 1])) {\n                    filteredCodecs.push(codecs[idx + 1]);\n                }\n                break;\n            }\n        }\n        if (filteredCodecs.length === 0) {\n            throw new TypeError('no matching codec found');\n        }\n    }\n    return filteredCodecs;\n}\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n    // Clone given reference video RTP parameters.\n    videoRtpParameters = utils.clone(videoRtpParameters);\n    // This may throw.\n    validateRtpParameters(videoRtpParameters);\n    const rtpParameters = {\n        mid: RTP_PROBATOR_MID,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\n        rtcp: { cname: 'probator' },\n    };\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n    return rtpParameters;\n}\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n    return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);\n}\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n    // This may throw.\n    validateRtpParameters(rtpParameters);\n    if (rtpParameters.codecs.length === 0) {\n        return false;\n    }\n    const firstMediaCodec = rtpParameters.codecs[0];\n    return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\nexports.canReceive = canReceive;\nfunction isRtxCodec(codec) {\n    if (!codec) {\n        return false;\n    }\n    return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\n    const aMimeType = aCodec.mimeType.toLowerCase();\n    const bMimeType = bCodec.mimeType.toLowerCase();\n    if (aMimeType !== bMimeType) {\n        return false;\n    }\n    if (aCodec.clockRate !== bCodec.clockRate) {\n        return false;\n    }\n    if (aCodec.channels !== bCodec.channels) {\n        return false;\n    }\n    // Per codec special checks.\n    switch (aMimeType) {\n        case 'video/h264': {\n            if (strict) {\n                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n                if (aPacketizationMode !== bPacketizationMode) {\n                    return false;\n                }\n                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {\n                    return false;\n                }\n                let selectedProfileLevelId;\n                try {\n                    selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);\n                }\n                catch (error) {\n                    return false;\n                }\n                if (modify) {\n                    if (selectedProfileLevelId) {\n                        aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                        bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                    }\n                    else {\n                        delete aCodec.parameters['profile-level-id'];\n                        delete bCodec.parameters['profile-level-id'];\n                    }\n                }\n            }\n            break;\n        }\n        case 'video/vp9': {\n            if (strict) {\n                const aProfileId = aCodec.parameters['profile-id'] || 0;\n                const bProfileId = bCodec.parameters['profile-id'] || 0;\n                if (aProfileId !== bProfileId) {\n                    return false;\n                }\n            }\n            break;\n        }\n    }\n    return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {\n        return false;\n    }\n    if (aExt.uri !== bExt.uri) {\n        return false;\n    }\n    return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n    const reducedRtcpFeedback = [];\n    for (const aFb of codecA.rtcpFeedback || []) {\n        const matchingBFb = (codecB.rtcpFeedback || []).find((bFb) => bFb.type === aFb.type &&\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter)));\n        if (matchingBFb) {\n            reducedRtcpFeedback.push(matchingBFb);\n        }\n    }\n    return reducedRtcpFeedback;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL29ydGMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGVBQWUsR0FBRyxxQ0FBcUMsR0FBRyxvQkFBb0IsR0FBRyxxQ0FBcUMsR0FBRywrQkFBK0IsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0MsR0FBRyxvQ0FBb0MsR0FBRyw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyw4QkFBOEIsR0FBRyxxQ0FBcUMsR0FBRyw0Q0FBNEMsR0FBRyxrQ0FBa0MsR0FBRyw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRyw0QkFBNEIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0I7QUFDdnNCLDBCQUEwQixtQkFBTyxDQUFDLGlLQUF1QjtBQUN6RCwyQkFBMkIsbUJBQU8sQ0FBQyxvSEFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSSxXQUFXLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUksV0FBVyxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCw0QkFBNEI7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQyxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQyxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9vcnRjLmpzPzUyMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FuUmVjZWl2ZSA9IGV4cG9ydHMuY2FuU2VuZCA9IGV4cG9ydHMuZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnMgPSBleHBvcnRzLnJlZHVjZUNvZGVjcyA9IGV4cG9ydHMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSBleHBvcnRzLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gZXhwb3J0cy5nZXRSZWN2UnRwQ2FwYWJpbGl0aWVzID0gZXhwb3J0cy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IGV4cG9ydHMudmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycyA9IGV4cG9ydHMudmFsaWRhdGVTY3RwUGFyYW1ldGVycyA9IGV4cG9ydHMudmFsaWRhdGVOdW1TY3RwU3RyZWFtcyA9IGV4cG9ydHMudmFsaWRhdGVTY3RwQ2FwYWJpbGl0aWVzID0gZXhwb3J0cy52YWxpZGF0ZVJ0Y3BQYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGV4cG9ydHMudmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZVJ0cENvZGVjUGFyYW1ldGVycyA9IGV4cG9ydHMudmFsaWRhdGVSdHBQYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvbiA9IGV4cG9ydHMudmFsaWRhdGVSdGNwRmVlZGJhY2sgPSBleHBvcnRzLnZhbGlkYXRlUnRwQ29kZWNDYXBhYmlsaXR5ID0gZXhwb3J0cy52YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyA9IHZvaWQgMDtcbmNvbnN0IGgyNjQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImgyNjQtcHJvZmlsZS1sZXZlbC1pZFwiKSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBSVFBfUFJPQkFUT1JfTUlEID0gJ3Byb2JhdG9yJztcbmNvbnN0IFJUUF9QUk9CQVRPUl9TU1JDID0gMTIzNDtcbmNvbnN0IFJUUF9QUk9CQVRPUl9DT0RFQ19QQVlMT0FEX1RZUEUgPSAxMjc7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBDYXBhYmlsaXRpZXMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBDYXBhYmlsaXRpZXMoY2Fwcykge1xuICAgIGlmICh0eXBlb2YgY2FwcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FwcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIGNvZGVjcyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoY2Fwcy5jb2RlY3MgJiYgIUFycmF5LmlzQXJyYXkoY2Fwcy5jb2RlY3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuY29kZWNzIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY2Fwcy5jb2RlY3MpIHtcbiAgICAgICAgY2Fwcy5jb2RlY3MgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBzLmNvZGVjcykge1xuICAgICAgICB2YWxpZGF0ZVJ0cENvZGVjQ2FwYWJpbGl0eShjb2RlYyk7XG4gICAgfVxuICAgIC8vIGhlYWRlckV4dGVuc2lvbnMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBmaWxsIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucyAmJiAhQXJyYXkuaXNBcnJheShjYXBzLmhlYWRlckV4dGVuc2lvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuaGVhZGVyRXh0ZW5zaW9ucyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleHQgb2YgY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uKGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyA9IHZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwQ29kZWNDYXBhYmlsaXR5LiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwQ29kZWNDYXBhYmlsaXR5KGNvZGVjKSB7XG4gICAgY29uc3QgTWltZVR5cGVSZWdleCA9IG5ldyBSZWdFeHAoJ14oYXVkaW98dmlkZW8pLyguKyknLCAnaScpO1xuICAgIGlmICh0eXBlb2YgY29kZWMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvZGVjIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gbWltZVR5cGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghY29kZWMubWltZVR5cGUgfHwgdHlwZW9mIGNvZGVjLm1pbWVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IG1pbWVUeXBlTWF0Y2ggPSBNaW1lVHlwZVJlZ2V4LmV4ZWMoY29kZWMubWltZVR5cGUpO1xuICAgIGlmICghbWltZVR5cGVNYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgfVxuICAgIC8vIEp1c3Qgb3ZlcnJpZGUga2luZCB3aXRoIG1lZGlhIGNvbXBvbmVudCBvZiBtaW1lVHlwZS5cbiAgICBjb2RlYy5raW5kID0gbWltZVR5cGVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIHByZWZlcnJlZFBheWxvYWRUeXBlIGlzIG9wdGlvbmFsLlxuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAmJlxuICAgICAgICB0eXBlb2YgY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUnKTtcbiAgICB9XG4gICAgLy8gY2xvY2tSYXRlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIGNvZGVjLmNsb2NrUmF0ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjb2RlYy5jbG9ja1JhdGUnKTtcbiAgICB9XG4gICAgLy8gY2hhbm5lbHMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBzZXQgaXQgdG8gMSAoanVzdCBpZiBhdWRpbykuXG4gICAgaWYgKGNvZGVjLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlYy5jaGFubmVscyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvZGVjLmNoYW5uZWxzID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuICAgIH1cbiAgICAvLyBwYXJhbWV0ZXJzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIGFuIGVtcHR5IG9iamVjdC5cbiAgICBpZiAoIWNvZGVjLnBhcmFtZXRlcnMgfHwgdHlwZW9mIGNvZGVjLnBhcmFtZXRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29kZWMucGFyYW1ldGVyc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVyc1trZXldID0gJyc7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgY29kZWMgcGFyYW1ldGVyIFtrZXk6JHtrZXl9cywgdmFsdWU6JHt2YWx1ZX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lmaWMgcGFyYW1ldGVycyB2YWxpZGF0aW9uLlxuICAgICAgICBpZiAoa2V5ID09PSAnYXB0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjIGFwdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBydGNwRmVlZGJhY2sgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBzZXQgaXQgdG8gYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKCFjb2RlYy5ydGNwRmVlZGJhY2sgfHwgIUFycmF5LmlzQXJyYXkoY29kZWMucnRjcEZlZWRiYWNrKSkge1xuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmYiBvZiBjb2RlYy5ydGNwRmVlZGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVSdGNwRmVlZGJhY2soZmIpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVSdHBDb2RlY0NhcGFiaWxpdHkgPSB2YWxpZGF0ZVJ0cENvZGVjQ2FwYWJpbGl0eTtcbi8qKlxuICogVmFsaWRhdGVzIFJ0Y3BGZWVkYmFjay4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0Y3BGZWVkYmFjayhmYikge1xuICAgIGlmICh0eXBlb2YgZmIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gdHlwZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFmYi50eXBlIHx8IHR5cGVvZiBmYi50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGZiLnR5cGUnKTtcbiAgICB9XG4gICAgLy8gcGFyYW1ldGVyIGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICAgIGlmICghZmIucGFyYW1ldGVyIHx8IHR5cGVvZiBmYi5wYXJhbWV0ZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZiLnBhcmFtZXRlciA9ICcnO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVSdGNwRmVlZGJhY2sgPSB2YWxpZGF0ZVJ0Y3BGZWVkYmFjaztcbi8qKlxuICogVmFsaWRhdGVzIFJ0cEhlYWRlckV4dGVuc2lvbi4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvbihleHQpIHtcbiAgICBpZiAodHlwZW9mIGV4dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0IGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8ga2luZCBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKGV4dC5raW5kICE9PSAnYXVkaW8nICYmIGV4dC5raW5kICE9PSAndmlkZW8nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LmtpbmQnKTtcbiAgICB9XG4gICAgLy8gdXJpIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWV4dC51cmkgfHwgdHlwZW9mIGV4dC51cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LnVyaScpO1xuICAgIH1cbiAgICAvLyBwcmVmZXJyZWRJZCBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBleHQucHJlZmVycmVkSWQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LnByZWZlcnJlZElkJyk7XG4gICAgfVxuICAgIC8vIHByZWZlcnJlZEVuY3J5cHQgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBmYWxzZS5cbiAgICBpZiAoZXh0LnByZWZlcnJlZEVuY3J5cHQgJiYgdHlwZW9mIGV4dC5wcmVmZXJyZWRFbmNyeXB0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBleHQucHJlZmVycmVkRW5jcnlwdCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICghZXh0LnByZWZlcnJlZEVuY3J5cHQpIHtcbiAgICAgICAgZXh0LnByZWZlcnJlZEVuY3J5cHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gZGlyZWN0aW9uIGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gc2VuZHJlY3YuXG4gICAgaWYgKGV4dC5kaXJlY3Rpb24gJiYgdHlwZW9mIGV4dC5kaXJlY3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LmRpcmVjdGlvbicpO1xuICAgIH1cbiAgICBlbHNlIGlmICghZXh0LmRpcmVjdGlvbikge1xuICAgICAgICBleHQuZGlyZWN0aW9uID0gJ3NlbmRyZWN2JztcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uID0gdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb247XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gbWlkIGlzIG9wdGlvbmFsLlxuICAgIGlmIChwYXJhbXMubWlkICYmIHR5cGVvZiBwYXJhbXMubWlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMubWlkIGlzIG5vdCBhIHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBjb2RlY3MgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuY29kZWNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5jb2RlY3MnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBwYXJhbXMuY29kZWNzKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzKGNvZGVjKTtcbiAgICB9XG4gICAgLy8gaGVhZGVyRXh0ZW5zaW9ucyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAocGFyYW1zLmhlYWRlckV4dGVuc2lvbnMgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zLmhlYWRlckV4dGVuc2lvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcy5oZWFkZXJFeHRlbnNpb25zIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghcGFyYW1zLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgcGFyYW1zLmhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleHQgb2YgcGFyYW1zLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzKGV4dCk7XG4gICAgfVxuICAgIC8vIGVuY29kaW5ncyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAocGFyYW1zLmVuY29kaW5ncyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMuZW5jb2RpbmdzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMuZW5jb2RpbmdzIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghcGFyYW1zLmVuY29kaW5ncykge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgcGFyYW1zLmVuY29kaW5ncykge1xuICAgICAgICB2YWxpZGF0ZVJ0cEVuY29kaW5nUGFyYW1ldGVycyhlbmNvZGluZyk7XG4gICAgfVxuICAgIC8vIHJ0Y3AgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBmaWxsIHdpdGggYW4gZW1wdHkgb2JqZWN0LlxuICAgIGlmIChwYXJhbXMucnRjcCAmJiB0eXBlb2YgcGFyYW1zLnJ0Y3AgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcy5ydGNwIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXBhcmFtcy5ydGNwKSB7XG4gICAgICAgIHBhcmFtcy5ydGNwID0ge307XG4gICAgfVxuICAgIHZhbGlkYXRlUnRjcFBhcmFtZXRlcnMocGFyYW1zLnJ0Y3ApO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBDb2RlY1BhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBDb2RlY1BhcmFtZXRlcnMoY29kZWMpIHtcbiAgICBjb25zdCBNaW1lVHlwZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihhdWRpb3x2aWRlbykvKC4rKScsICdpJyk7XG4gICAgaWYgKHR5cGVvZiBjb2RlYyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29kZWMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICAvLyBtaW1lVHlwZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFjb2RlYy5taW1lVHlwZSB8fCB0eXBlb2YgY29kZWMubWltZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMubWltZVR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgbWltZVR5cGVNYXRjaCA9IE1pbWVUeXBlUmVnZXguZXhlYyhjb2RlYy5taW1lVHlwZSk7XG4gICAgaWYgKCFtaW1lVHlwZU1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMubWltZVR5cGUnKTtcbiAgICB9XG4gICAgLy8gcGF5bG9hZFR5cGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgY29kZWMucGF5bG9hZFR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMucGF5bG9hZFR5cGUnKTtcbiAgICB9XG4gICAgLy8gY2xvY2tSYXRlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIGNvZGVjLmNsb2NrUmF0ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjb2RlYy5jbG9ja1JhdGUnKTtcbiAgICB9XG4gICAgY29uc3Qga2luZCA9IG1pbWVUeXBlTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAvLyBjaGFubmVscyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byAxIChqdXN0IGlmIGF1ZGlvKS5cbiAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVjLmNoYW5uZWxzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29kZWMuY2hhbm5lbHMgPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgY29kZWMuY2hhbm5lbHM7XG4gICAgfVxuICAgIC8vIHBhcmFtZXRlcnMgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBzZXQgaXQgdG8gYW4gZW1wdHkgb2JqZWN0LlxuICAgIGlmICghY29kZWMucGFyYW1ldGVycyB8fCB0eXBlb2YgY29kZWMucGFyYW1ldGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IHt9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBjb2RlYy5wYXJhbWV0ZXJzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzW2tleV0gPSAnJztcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBjb2RlYyBwYXJhbWV0ZXIgW2tleToke2tleX1zLCB2YWx1ZToke3ZhbHVlfV1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWZpYyBwYXJhbWV0ZXJzIHZhbGlkYXRpb24uXG4gICAgICAgIGlmIChrZXkgPT09ICdhcHQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMgYXB0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJ0Y3BGZWVkYmFjayBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoIWNvZGVjLnJ0Y3BGZWVkYmFjayB8fCAhQXJyYXkuaXNBcnJheShjb2RlYy5ydGNwRmVlZGJhY2spKSB7XG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICB2YWxpZGF0ZVJ0Y3BGZWVkYmFjayhmYik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cENvZGVjUGFyYW1ldGVycyA9IHZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyhleHQpIHtcbiAgICBpZiAodHlwZW9mIGV4dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0IGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gdXJpIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWV4dC51cmkgfHwgdHlwZW9mIGV4dC51cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LnVyaScpO1xuICAgIH1cbiAgICAvLyBpZCBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBleHQuaWQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LmlkJyk7XG4gICAgfVxuICAgIC8vIGVuY3J5cHQgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBmYWxzZS5cbiAgICBpZiAoZXh0LmVuY3J5cHQgJiYgdHlwZW9mIGV4dC5lbmNyeXB0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBleHQuZW5jcnlwdCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICghZXh0LmVuY3J5cHQpIHtcbiAgICAgICAgZXh0LmVuY3J5cHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gcGFyYW1ldGVycyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKCFleHQucGFyYW1ldGVycyB8fCB0eXBlb2YgZXh0LnBhcmFtZXRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGV4dC5wYXJhbWV0ZXJzID0ge307XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGV4dC5wYXJhbWV0ZXJzKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBleHQucGFyYW1ldGVyc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXh0LnBhcmFtZXRlcnNba2V5XSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGhlYWRlciBleHRlbnNpb24gcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyA9IHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycztcbi8qKlxuICogVmFsaWRhdGVzIFJ0cEVuY29kaW5nUGFyYW1ldGVycy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cEVuY29kaW5nUGFyYW1ldGVycyhlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gc3NyYyBpcyBvcHRpb25hbC5cbiAgICBpZiAoZW5jb2Rpbmcuc3NyYyAmJiB0eXBlb2YgZW5jb2Rpbmcuc3NyYyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5zc3JjJyk7XG4gICAgfVxuICAgIC8vIHJpZCBpcyBvcHRpb25hbC5cbiAgICBpZiAoZW5jb2RpbmcucmlkICYmIHR5cGVvZiBlbmNvZGluZy5yaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZW5jb2RpbmcucmlkJyk7XG4gICAgfVxuICAgIC8vIHJ0eCBpcyBvcHRpb25hbC5cbiAgICBpZiAoZW5jb2RpbmcucnR4ICYmIHR5cGVvZiBlbmNvZGluZy5ydHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZW5jb2RpbmcucnR4Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuY29kaW5nLnJ0eCkge1xuICAgICAgICAvLyBSVFggc3NyYyBpcyBtYW5kYXRvcnkgaWYgcnR4IGlzIHByZXNlbnQuXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcucnR4LnNzcmMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGVuY29kaW5nLnJ0eC5zc3JjJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZHR4IGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gZmFsc2UuXG4gICAgaWYgKCFlbmNvZGluZy5kdHggfHwgdHlwZW9mIGVuY29kaW5nLmR0eCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGVuY29kaW5nLmR0eCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBzY2FsYWJpbGl0eU1vZGUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSAmJlxuICAgICAgICB0eXBlb2YgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZScpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0cEVuY29kaW5nUGFyYW1ldGVycztcbi8qKlxuICogVmFsaWRhdGVzIFJ0Y3BQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRjcFBhcmFtZXRlcnMocnRjcCkge1xuICAgIGlmICh0eXBlb2YgcnRjcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncnRjcCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIGNuYW1lIGlzIG9wdGlvbmFsLlxuICAgIGlmIChydGNwLmNuYW1lICYmIHR5cGVvZiBydGNwLmNuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJ0Y3AuY25hbWUnKTtcbiAgICB9XG4gICAgLy8gcmVkdWNlZFNpemUgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byB0cnVlLlxuICAgIGlmICghcnRjcC5yZWR1Y2VkU2l6ZSB8fCB0eXBlb2YgcnRjcC5yZWR1Y2VkU2l6ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJ0Y3AucmVkdWNlZFNpemUgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVSdGNwUGFyYW1ldGVycyA9IHZhbGlkYXRlUnRjcFBhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBTY3RwQ2FwYWJpbGl0aWVzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2N0cENhcGFiaWxpdGllcyhjYXBzKSB7XG4gICAgaWYgKHR5cGVvZiBjYXBzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYXBzIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gbnVtU3RyZWFtcyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFjYXBzLm51bVN0cmVhbXMgfHwgdHlwZW9mIGNhcHMubnVtU3RyZWFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjYXBzLm51bVN0cmVhbXMnKTtcbiAgICB9XG4gICAgdmFsaWRhdGVOdW1TY3RwU3RyZWFtcyhjYXBzLm51bVN0cmVhbXMpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXMgPSB2YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXM7XG4vKipcbiAqIFZhbGlkYXRlcyBOdW1TY3RwU3RyZWFtcy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU51bVNjdHBTdHJlYW1zKG51bVN0cmVhbXMpIHtcbiAgICBpZiAodHlwZW9mIG51bVN0cmVhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ251bVN0cmVhbXMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICAvLyBPUyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBudW1TdHJlYW1zLk9TICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIG51bVN0cmVhbXMuT1MnKTtcbiAgICB9XG4gICAgLy8gTUlTIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIG51bVN0cmVhbXMuTUlTICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIG51bVN0cmVhbXMuTUlTJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZU51bVNjdHBTdHJlYW1zID0gdmFsaWRhdGVOdW1TY3RwU3RyZWFtcztcbi8qKlxuICogVmFsaWRhdGVzIFNjdHBQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2N0cFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIHBvcnQgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnBvcnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgcGFyYW1zLnBvcnQnKTtcbiAgICB9XG4gICAgLy8gT1MgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLk9TICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5PUycpO1xuICAgIH1cbiAgICAvLyBNSVMgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLk1JUyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMuTUlTJyk7XG4gICAgfVxuICAgIC8vIG1heE1lc3NhZ2VTaXplIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5tYXhNZXNzYWdlU2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMubWF4TWVzc2FnZVNpemUnKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2N0cFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVNjdHBQYXJhbWV0ZXJzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgU2N0cFN0cmVhbVBhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gc3RyZWFtSWQgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnN0cmVhbUlkICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5zdHJlYW1JZCcpO1xuICAgIH1cbiAgICAvLyBvcmRlcmVkIGlzIG9wdGlvbmFsLlxuICAgIGxldCBvcmRlcmVkR2l2ZW4gPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5vcmRlcmVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3JkZXJlZEdpdmVuID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmFtcy5vcmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbWF4UGFja2V0TGlmZVRpbWUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSAmJlxuICAgICAgICB0eXBlb2YgcGFyYW1zLm1heFBhY2tldExpZmVUaW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZScpO1xuICAgIH1cbiAgICAvLyBtYXhSZXRyYW5zbWl0cyBpcyBvcHRpb25hbC5cbiAgICBpZiAocGFyYW1zLm1heFJldHJhbnNtaXRzICYmIHR5cGVvZiBwYXJhbXMubWF4UmV0cmFuc21pdHMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1zLm1heFJldHJhbnNtaXRzJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUgJiYgcGFyYW1zLm1heFJldHJhbnNtaXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBwcm92aWRlIGJvdGggbWF4UGFja2V0TGlmZVRpbWUgYW5kIG1heFJldHJhbnNtaXRzJyk7XG4gICAgfVxuICAgIGlmIChvcmRlcmVkR2l2ZW4gJiZcbiAgICAgICAgcGFyYW1zLm9yZGVyZWQgJiZcbiAgICAgICAgKHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSB8fCBwYXJhbXMubWF4UmV0cmFuc21pdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBiZSBvcmRlcmVkIHdpdGggbWF4UGFja2V0TGlmZVRpbWUgb3IgbWF4UmV0cmFuc21pdHMnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9yZGVyZWRHaXZlbiAmJlxuICAgICAgICAocGFyYW1zLm1heFBhY2tldExpZmVUaW1lIHx8IHBhcmFtcy5tYXhSZXRyYW5zbWl0cykpIHtcbiAgICAgICAgcGFyYW1zLm9yZGVyZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gbGFiZWwgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5sYWJlbCAmJiB0eXBlb2YgcGFyYW1zLmxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5sYWJlbCcpO1xuICAgIH1cbiAgICAvLyBwcm90b2NvbCBpcyBvcHRpb25hbC5cbiAgICBpZiAocGFyYW1zLnByb3RvY29sICYmIHR5cGVvZiBwYXJhbXMucHJvdG9jb2wgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1zLnByb3RvY29sJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzID0gdmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycztcbi8qKlxuICogR2VuZXJhdGUgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllcyBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nLlxuICovXG5mdW5jdGlvbiBnZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhsb2NhbENhcHMsIHJlbW90ZUNhcHMpIHtcbiAgICBjb25zdCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgfTtcbiAgICAvLyBNYXRjaCBtZWRpYSBjb2RlY3MgYW5kIGtlZXAgdGhlIG9yZGVyIHByZWZlcnJlZCBieSByZW1vdGVDYXBzLlxuICAgIGZvciAoY29uc3QgcmVtb3RlQ29kZWMgb2YgcmVtb3RlQ2Fwcy5jb2RlY3MgfHwgW10pIHtcbiAgICAgICAgaWYgKGlzUnR4Q29kZWMocmVtb3RlQ29kZWMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsQ29kZWMgPSAobG9jYWxDYXBzLmNvZGVjcyB8fCBbXSkuZmluZCgobG9jYWxDb2RlYykgPT4gbWF0Y2hDb2RlY3MobG9jYWxDb2RlYywgcmVtb3RlQ29kZWMsIHsgc3RyaWN0OiB0cnVlLCBtb2RpZnk6IHRydWUgfSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nTG9jYWxDb2RlYykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW5kZWRDb2RlYyA9IHtcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtYXRjaGluZ0xvY2FsQ29kZWMubWltZVR5cGUsXG4gICAgICAgICAgICBraW5kOiBtYXRjaGluZ0xvY2FsQ29kZWMua2luZCxcbiAgICAgICAgICAgIGNsb2NrUmF0ZTogbWF0Y2hpbmdMb2NhbENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBtYXRjaGluZ0xvY2FsQ29kZWMuY2hhbm5lbHMsXG4gICAgICAgICAgICBsb2NhbFBheWxvYWRUeXBlOiBtYXRjaGluZ0xvY2FsQ29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBsb2NhbFJ0eFBheWxvYWRUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZW1vdGVQYXlsb2FkVHlwZTogcmVtb3RlQ29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICByZW1vdGVSdHhQYXlsb2FkVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYWxQYXJhbWV0ZXJzOiBtYXRjaGluZ0xvY2FsQ29kZWMucGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlbW90ZVBhcmFtZXRlcnM6IHJlbW90ZUNvZGVjLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IHJlZHVjZVJ0Y3BGZWVkYmFjayhtYXRjaGluZ0xvY2FsQ29kZWMsIHJlbW90ZUNvZGVjKSxcbiAgICAgICAgfTtcbiAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnB1c2goZXh0ZW5kZWRDb2RlYyk7XG4gICAgfVxuICAgIC8vIE1hdGNoIFJUWCBjb2RlY3MuXG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsUnR4Q29kZWMgPSBsb2NhbENhcHMuY29kZWNzLmZpbmQoKGxvY2FsQ29kZWMpID0+IGlzUnR4Q29kZWMobG9jYWxDb2RlYykgJiZcbiAgICAgICAgICAgIGxvY2FsQ29kZWMucGFyYW1ldGVycy5hcHQgPT09IGV4dGVuZGVkQ29kZWMubG9jYWxQYXlsb2FkVHlwZSk7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUmVtb3RlUnR4Q29kZWMgPSByZW1vdGVDYXBzLmNvZGVjcy5maW5kKChyZW1vdGVDb2RlYykgPT4gaXNSdHhDb2RlYyhyZW1vdGVDb2RlYykgJiZcbiAgICAgICAgICAgIHJlbW90ZUNvZGVjLnBhcmFtZXRlcnMuYXB0ID09PSBleHRlbmRlZENvZGVjLnJlbW90ZVBheWxvYWRUeXBlKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nTG9jYWxSdHhDb2RlYyAmJiBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjKSB7XG4gICAgICAgICAgICBleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUgPVxuICAgICAgICAgICAgICAgIG1hdGNoaW5nTG9jYWxSdHhDb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgICAgICAgIGV4dGVuZGVkQ29kZWMucmVtb3RlUnR4UGF5bG9hZFR5cGUgPVxuICAgICAgICAgICAgICAgIG1hdGNoaW5nUmVtb3RlUnR4Q29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWF0Y2ggaGVhZGVyIGV4dGVuc2lvbnMuXG4gICAgZm9yIChjb25zdCByZW1vdGVFeHQgb2YgcmVtb3RlQ2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nTG9jYWxFeHQgPSBsb2NhbENhcHMuaGVhZGVyRXh0ZW5zaW9ucy5maW5kKChsb2NhbEV4dCkgPT4gbWF0Y2hIZWFkZXJFeHRlbnNpb25zKGxvY2FsRXh0LCByZW1vdGVFeHQpKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZ0xvY2FsRXh0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRlbmRlZEV4dCA9IHtcbiAgICAgICAgICAgIGtpbmQ6IHJlbW90ZUV4dC5raW5kLFxuICAgICAgICAgICAgdXJpOiByZW1vdGVFeHQudXJpLFxuICAgICAgICAgICAgc2VuZElkOiBtYXRjaGluZ0xvY2FsRXh0LnByZWZlcnJlZElkLFxuICAgICAgICAgICAgcmVjdklkOiByZW1vdGVFeHQucHJlZmVycmVkSWQsXG4gICAgICAgICAgICBlbmNyeXB0OiBtYXRjaGluZ0xvY2FsRXh0LnByZWZlcnJlZEVuY3J5cHQsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kcmVjdicsXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAocmVtb3RlRXh0LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnc2VuZHJlY3YnOiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRFeHQuZGlyZWN0aW9uID0gJ3NlbmRyZWN2JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JlY3Zvbmx5Jzoge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzZW5kb25seSc6IHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dC5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5hY3RpdmUnOiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRFeHQuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zLnB1c2goZXh0ZW5kZWRFeHQpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM7XG59XG5leHBvcnRzLmdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gZ2V0RXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM7XG4vKipcbiAqIEdlbmVyYXRlIFJUUCBjYXBhYmlsaXRpZXMgZm9yIHJlY2VpdmluZyBtZWRpYSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZXh0ZW5kZWRcbiAqIFJUUCBjYXBhYmlsaXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFJlY3ZSdHBDYXBhYmlsaXRpZXMoZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICBjb25zdCBydHBDYXBhYmlsaXRpZXMgPSB7XG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBjb2RlYyA9IHtcbiAgICAgICAgICAgIG1pbWVUeXBlOiBleHRlbmRlZENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAga2luZDogZXh0ZW5kZWRDb2RlYy5raW5kLFxuICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMucmVtb3RlUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgY2hhbm5lbHM6IGV4dGVuZGVkQ29kZWMuY2hhbm5lbHMsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBleHRlbmRlZENvZGVjLmxvY2FsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0Y3BGZWVkYmFjazogZXh0ZW5kZWRDb2RlYy5ydGNwRmVlZGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIHJ0cENhcGFiaWxpdGllcy5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAgIC8vIEFkZCBSVFggY29kZWMuXG4gICAgICAgIGlmICghZXh0ZW5kZWRDb2RlYy5yZW1vdGVSdHhQYXlsb2FkVHlwZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnR4Q29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogYCR7ZXh0ZW5kZWRDb2RlYy5raW5kfS9ydHhgLFxuICAgICAgICAgICAga2luZDogZXh0ZW5kZWRDb2RlYy5raW5kLFxuICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMucmVtb3RlUnR4UGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGFwdDogZXh0ZW5kZWRDb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBydHBDYXBhYmlsaXRpZXMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuICAgICAgICAvLyBUT0RPOiBJbiB0aGUgZnV0dXJlLCB3ZSBuZWVkIHRvIGFkZCBGRUMsIENOLCBldGMsIGNvZGVjcy5cbiAgICB9XG4gICAgZm9yIChjb25zdCBleHRlbmRlZEV4dGVuc2lvbiBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIC8vIElnbm9yZSBSVFAgZXh0ZW5zaW9ucyBub3QgdmFsaWQgZm9yIHJlY2VpdmluZy5cbiAgICAgICAgaWYgKGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyAmJlxuICAgICAgICAgICAgZXh0ZW5kZWRFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSB7XG4gICAgICAgICAgICBraW5kOiBleHRlbmRlZEV4dGVuc2lvbi5raW5kLFxuICAgICAgICAgICAgdXJpOiBleHRlbmRlZEV4dGVuc2lvbi51cmksXG4gICAgICAgICAgICBwcmVmZXJyZWRJZDogZXh0ZW5kZWRFeHRlbnNpb24ucmVjdklkLFxuICAgICAgICAgICAgcHJlZmVycmVkRW5jcnlwdDogZXh0ZW5kZWRFeHRlbnNpb24uZW5jcnlwdCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZXh0ZW5kZWRFeHRlbnNpb24uZGlyZWN0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBydHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBydHBDYXBhYmlsaXRpZXM7XG59XG5leHBvcnRzLmdldFJlY3ZSdHBDYXBhYmlsaXRpZXMgPSBnZXRSZWN2UnRwQ2FwYWJpbGl0aWVzO1xuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBmb3Igc2VuZGluZyBtZWRpYS5cbiAqIE5PVEU6IG1pZCwgZW5jb2RpbmdzIGFuZCBydGNwIGZpZWxkcyBhcmUgbGVmdCBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICBjb25zdCBydHBQYXJhbWV0ZXJzID0ge1xuICAgICAgICBtaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgIGVuY29kaW5nczogW10sXG4gICAgICAgIHJ0Y3A6IHt9LFxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5raW5kICE9PSBraW5kKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlYyA9IHtcbiAgICAgICAgICAgIG1pbWVUeXBlOiBleHRlbmRlZENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAgcGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMubG9jYWxQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgIGNsb2NrUmF0ZTogZXh0ZW5kZWRDb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICBjaGFubmVsczogZXh0ZW5kZWRDb2RlYy5jaGFubmVscyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGV4dGVuZGVkQ29kZWMubG9jYWxQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiBleHRlbmRlZENvZGVjLnJ0Y3BGZWVkYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAgIC8vIEFkZCBSVFggY29kZWMuXG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBgJHtleHRlbmRlZENvZGVjLmtpbmR9L3J0eGAsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMubG9jYWxSdHhQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXB0OiBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRFeHRlbnNpb24gb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAvLyBJZ25vcmUgUlRQIGV4dGVuc2lvbnMgb2YgYSBkaWZmZXJlbnQga2luZCBhbmQgdGhvc2Ugbm90IHZhbGlkIGZvciBzZW5kaW5nLlxuICAgICAgICBpZiAoKGV4dGVuZGVkRXh0ZW5zaW9uLmtpbmQgJiYgZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAhPT0ga2luZCkgfHxcbiAgICAgICAgICAgIChleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSB7XG4gICAgICAgICAgICB1cmk6IGV4dGVuZGVkRXh0ZW5zaW9uLnVyaSxcbiAgICAgICAgICAgIGlkOiBleHRlbmRlZEV4dGVuc2lvbi5zZW5kSWQsXG4gICAgICAgICAgICBlbmNyeXB0OiBleHRlbmRlZEV4dGVuc2lvbi5lbmNyeXB0LFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBydHBQYXJhbWV0ZXJzO1xufVxuZXhwb3J0cy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycyA9IGdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzO1xuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBzdWl0YWJsZSBmb3IgdGhlIHJlbW90ZSBTRFAgYW5zd2VyLlxuICovXG5mdW5jdGlvbiBnZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyhraW5kLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcykge1xuICAgIGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB7XG4gICAgICAgIG1pZDogdW5kZWZpbmVkLFxuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICAgICAgZW5jb2RpbmdzOiBbXSxcbiAgICAgICAgcnRjcDoge30sXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuZGVkQ29kZWMgb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmtpbmQgIT09IGtpbmQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGV4dGVuZGVkQ29kZWMubWltZVR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBleHRlbmRlZENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogZXh0ZW5kZWRDb2RlYy5yZW1vdGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiBleHRlbmRlZENvZGVjLnJ0Y3BGZWVkYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAgIC8vIEFkZCBSVFggY29kZWMuXG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBgJHtleHRlbmRlZENvZGVjLmtpbmR9L3J0eGAsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMubG9jYWxSdHhQYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXB0OiBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0ZW5kZWRFeHRlbnNpb24gb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAvLyBJZ25vcmUgUlRQIGV4dGVuc2lvbnMgb2YgYSBkaWZmZXJlbnQga2luZCBhbmQgdGhvc2Ugbm90IHZhbGlkIGZvciBzZW5kaW5nLlxuICAgICAgICBpZiAoKGV4dGVuZGVkRXh0ZW5zaW9uLmtpbmQgJiYgZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAhPT0ga2luZCkgfHxcbiAgICAgICAgICAgIChleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSB7XG4gICAgICAgICAgICB1cmk6IGV4dGVuZGVkRXh0ZW5zaW9uLnVyaSxcbiAgICAgICAgICAgIGlkOiBleHRlbmRlZEV4dGVuc2lvbi5zZW5kSWQsXG4gICAgICAgICAgICBlbmNyeXB0OiBleHRlbmRlZEV4dGVuc2lvbi5lbmNyeXB0LFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gICAgfVxuICAgIC8vIFJlZHVjZSBjb2RlY3MnIFJUQ1AgZmVlZGJhY2suIFVzZSBUcmFuc3BvcnQtQ0MgaWYgYXZhaWxhYmxlLCBSRU1CIG90aGVyd2lzZS5cbiAgICBpZiAocnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zLnNvbWUoZXh0ID0+IGV4dC51cmkgPT09XG4gICAgICAgICdodHRwOi8vd3d3LmlldGYub3JnL2lkL2RyYWZ0LWhvbG1lci1ybWNhdC10cmFuc3BvcnQtd2lkZS1jYy1leHRlbnNpb25zLTAxJykpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBydHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gKGNvZGVjLnJ0Y3BGZWVkYmFjayB8fCBbXSkuZmlsdGVyKChmYikgPT4gZmIudHlwZSAhPT0gJ2dvb2ctcmVtYicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5zb21lKGV4dCA9PiBleHQudXJpID09PVxuICAgICAgICAnaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLXNlbmQtdGltZScpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgcnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IChjb2RlYy5ydGNwRmVlZGJhY2sgfHwgW10pLmZpbHRlcihmYiA9PiBmYi50eXBlICE9PSAndHJhbnNwb3J0LWNjJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgcnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IChjb2RlYy5ydGNwRmVlZGJhY2sgfHwgW10pLmZpbHRlcigoZmIpID0+IGZiLnR5cGUgIT09ICd0cmFuc3BvcnQtY2MnICYmIGZiLnR5cGUgIT09ICdnb29nLXJlbWInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSBnZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycztcbi8qKlxuICogUmVkdWNlIGdpdmVuIGNvZGVjcyBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY29kZWNzIFwiY29tcGF0aWJsZVwiIHdpdGggdGhlXG4gKiBnaXZlbiBjYXBhYmlsaXR5IGNvZGVjLiBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdFxuICogb25lKHMpLlxuICpcbiAqIEdpdmVuIGNvZGVjcyBtdXN0IGJlIGdlbmVyYXRlZCBieSBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCkgb3JcbiAqIG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoKS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYXJyYXkgb2YgY29kZWNzIGFsc28gaW5jbHVkZSBhIFJUWCBjb2RlYyBpZiBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvZGVjcyhjb2RlY3MsIGNhcENvZGVjKSB7XG4gICAgY29uc3QgZmlsdGVyZWRDb2RlY3MgPSBbXTtcbiAgICAvLyBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdCBvbmUgKGFuZCBSVFgpLlxuICAgIGlmICghY2FwQ29kZWMpIHtcbiAgICAgICAgZmlsdGVyZWRDb2RlY3MucHVzaChjb2RlY3NbMF0pO1xuICAgICAgICBpZiAoaXNSdHhDb2RlYyhjb2RlY3NbMV0pKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZENvZGVjcy5wdXNoKGNvZGVjc1sxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGEgY29tcGF0aWJsZSBzZXQgb2YgY29kZWNzLlxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBjb2RlY3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoQ29kZWNzKGNvZGVjc1tpZHhdLCBjYXBDb2RlYykpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvZGVjcy5wdXNoKGNvZGVjc1tpZHhdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSdHhDb2RlYyhjb2RlY3NbaWR4ICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29kZWNzLnB1c2goY29kZWNzW2lkeCArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlcmVkQ29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gbWF0Y2hpbmcgY29kZWMgZm91bmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRDb2RlY3M7XG59XG5leHBvcnRzLnJlZHVjZUNvZGVjcyA9IHJlZHVjZUNvZGVjcztcbi8qKlxuICogQ3JlYXRlIFJUUCBwYXJhbWV0ZXJzIGZvciBhIENvbnN1bWVyIGZvciB0aGUgUlRQIHByb2JhdG9yLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyh2aWRlb1J0cFBhcmFtZXRlcnMpIHtcbiAgICAvLyBDbG9uZSBnaXZlbiByZWZlcmVuY2UgdmlkZW8gUlRQIHBhcmFtZXRlcnMuXG4gICAgdmlkZW9SdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodmlkZW9SdHBQYXJhbWV0ZXJzKTtcbiAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnModmlkZW9SdHBQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBydHBQYXJhbWV0ZXJzID0ge1xuICAgICAgICBtaWQ6IFJUUF9QUk9CQVRPUl9NSUQsXG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICBlbmNvZGluZ3M6IFt7IHNzcmM6IFJUUF9QUk9CQVRPUl9TU1JDIH1dLFxuICAgICAgICBydGNwOiB7IGNuYW1lOiAncHJvYmF0b3InIH0sXG4gICAgfTtcbiAgICBydHBQYXJhbWV0ZXJzLmNvZGVjcy5wdXNoKHZpZGVvUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0pO1xuICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzWzBdLnBheWxvYWRUeXBlID0gUlRQX1BST0JBVE9SX0NPREVDX1BBWUxPQURfVFlQRTtcbiAgICBydHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnMgPSB2aWRlb1J0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucztcbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnMgPSBnZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycztcbi8qKlxuICogV2hldGhlciBtZWRpYSBjYW4gYmUgc2VudCBiYXNlZCBvbiB0aGUgZ2l2ZW4gUlRQIGNhcGFiaWxpdGllcy5cbiAqL1xuZnVuY3Rpb24gY2FuU2VuZChraW5kLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcykge1xuICAgIHJldHVybiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3Muc29tZSgoY29kZWMpID0+IGNvZGVjLmtpbmQgPT09IGtpbmQpO1xufVxuZXhwb3J0cy5jYW5TZW5kID0gY2FuU2VuZDtcbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gUlRQIHBhcmFtZXRlcnMgY2FuIGJlIHJlY2VpdmVkIHdpdGggdGhlIGdpdmVuIFJUUFxuICogY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBjYW5SZWNlaXZlKHJ0cFBhcmFtZXRlcnMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgdmFsaWRhdGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgIGlmIChydHBQYXJhbWV0ZXJzLmNvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE1lZGlhQ29kZWMgPSBydHBQYXJhbWV0ZXJzLmNvZGVjc1swXTtcbiAgICByZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnNvbWUoKGNvZGVjKSA9PiBjb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSA9PT0gZmlyc3RNZWRpYUNvZGVjLnBheWxvYWRUeXBlKTtcbn1cbmV4cG9ydHMuY2FuUmVjZWl2ZSA9IGNhblJlY2VpdmU7XG5mdW5jdGlvbiBpc1J0eENvZGVjKGNvZGVjKSB7XG4gICAgaWYgKCFjb2RlYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAvLitcXC9ydHgkL2kudGVzdChjb2RlYy5taW1lVHlwZSk7XG59XG5mdW5jdGlvbiBtYXRjaENvZGVjcyhhQ29kZWMsIGJDb2RlYywgeyBzdHJpY3QgPSBmYWxzZSwgbW9kaWZ5ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgYU1pbWVUeXBlID0gYUNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYk1pbWVUeXBlID0gYkNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGFNaW1lVHlwZSAhPT0gYk1pbWVUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFDb2RlYy5jbG9ja1JhdGUgIT09IGJDb2RlYy5jbG9ja1JhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYUNvZGVjLmNoYW5uZWxzICE9PSBiQ29kZWMuY2hhbm5lbHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBQZXIgY29kZWMgc3BlY2lhbCBjaGVja3MuXG4gICAgc3dpdGNoIChhTWltZVR5cGUpIHtcbiAgICAgICAgY2FzZSAndmlkZW8vaDI2NCc6IHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhUGFja2V0aXphdGlvbk1vZGUgPSBhQ29kZWMucGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10gfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBiUGFja2V0aXphdGlvbk1vZGUgPSBiQ29kZWMucGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10gfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoYVBhY2tldGl6YXRpb25Nb2RlICE9PSBiUGFja2V0aXphdGlvbk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWgyNjQuaXNTYW1lUHJvZmlsZShhQ29kZWMucGFyYW1ldGVycywgYkNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkUHJvZmlsZUxldmVsSWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQcm9maWxlTGV2ZWxJZCA9IGgyNjQuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZFN0cmluZ0ZvckFuc3dlcihhQ29kZWMucGFyYW1ldGVycywgYkNvZGVjLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kaWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFByb2ZpbGVMZXZlbElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1sZXZlbC1pZCddID0gc2VsZWN0ZWRQcm9maWxlTGV2ZWxJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJDb2RlYy5wYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ10gPSBzZWxlY3RlZFByb2ZpbGVMZXZlbElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFDb2RlYy5wYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYkNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ZpZGVvL3ZwOSc6IHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhUHJvZmlsZUlkID0gYUNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtaWQnXSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJQcm9maWxlSWQgPSBiQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1pZCddIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGFQcm9maWxlSWQgIT09IGJQcm9maWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJFeHRlbnNpb25zKGFFeHQsIGJFeHQpIHtcbiAgICBpZiAoYUV4dC5raW5kICYmIGJFeHQua2luZCAmJiBhRXh0LmtpbmQgIT09IGJFeHQua2luZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhRXh0LnVyaSAhPT0gYkV4dC51cmkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVJ0Y3BGZWVkYmFjayhjb2RlY0EsIGNvZGVjQikge1xuICAgIGNvbnN0IHJlZHVjZWRSdGNwRmVlZGJhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFGYiBvZiBjb2RlY0EucnRjcEZlZWRiYWNrIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQkZiID0gKGNvZGVjQi5ydGNwRmVlZGJhY2sgfHwgW10pLmZpbmQoKGJGYikgPT4gYkZiLnR5cGUgPT09IGFGYi50eXBlICYmXG4gICAgICAgICAgICAoYkZiLnBhcmFtZXRlciA9PT0gYUZiLnBhcmFtZXRlciB8fCAoIWJGYi5wYXJhbWV0ZXIgJiYgIWFGYi5wYXJhbWV0ZXIpKSk7XG4gICAgICAgIGlmIChtYXRjaGluZ0JGYikge1xuICAgICAgICAgICAgcmVkdWNlZFJ0Y3BGZWVkYmFjay5wdXNoKG1hdGNoaW5nQkZiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVkdWNlZFJ0Y3BGZWVkYmFjaztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/ortc.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nconst ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\\\d{0,1})T([1-9]\\\\d{0,1})');\nfunction parse(scalabilityMode) {\n    const match = ScalabilityModeRegex.exec(scalabilityMode || '');\n    if (match) {\n        return {\n            spatialLayers: Number(match[1]),\n            temporalLayers: Number(match[2]),\n        };\n    }\n    else {\n        return {\n            spatialLayers: 1,\n            temporalLayers: 1,\n        };\n    }\n}\nexports.parse = parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL3NjYWxhYmlsaXR5TW9kZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLHdEQUF3RCxJQUFJLFlBQVksSUFBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9zY2FsYWJpbGl0eU1vZGVzLmpzP2I1ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gdm9pZCAwO1xuY29uc3QgU2NhbGFiaWxpdHlNb2RlUmVnZXggPSBuZXcgUmVnRXhwKCdeW0xTXShbMS05XVxcXFxkezAsMX0pVChbMS05XVxcXFxkezAsMX0pJyk7XG5mdW5jdGlvbiBwYXJzZShzY2FsYWJpbGl0eU1vZGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IFNjYWxhYmlsaXR5TW9kZVJlZ2V4LmV4ZWMoc2NhbGFiaWxpdHlNb2RlIHx8ICcnKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYXRpYWxMYXllcnM6IE51bWJlcihtYXRjaFsxXSksXG4gICAgICAgICAgICB0ZW1wb3JhbExheWVyczogTnVtYmVyKG1hdGNoWzJdKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGF0aWFsTGF5ZXJzOiAxLFxuICAgICAgICAgICAgdGVtcG9yYWxMYXllcnM6IDEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/scalabilityModes.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/types.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/types.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./Device */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Device.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Transport */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Transport.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Producer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Producer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Consumer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/Consumer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DataProducer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataProducer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DataConsumer */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/DataConsumer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./RtpParameters */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/RtpParameters.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SctpParameters */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/SctpParameters.js\"), exports);\n__exportStar(__webpack_require__(/*! ./handlers/HandlerInterface */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/errors.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxzSEFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsNEhBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDBIQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywwSEFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0lBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxrSUFBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLG9JQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsc0lBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyw0SkFBNkI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLHNIQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZWRpYXNvdXAtY2xpZW50QDMuNy4yL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi90eXBlcy5qcz9mMGU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGV2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9UcmFuc3BvcnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1Byb2R1Y2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db25zdW1lclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGF0YVByb2R1Y2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EYXRhQ29uc3VtZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1J0cFBhcmFtZXRlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1NjdHBQYXJhbWV0ZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oYW5kbGVycy9IYW5kbGVySW50ZXJmYWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/types.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateRandomNumber = exports.clone = void 0;\n/**\n * Clones the given value.\n */\nfunction clone(value) {\n    if (value === undefined) {\n        return undefined;\n    }\n    else if (Number.isNaN(value)) {\n        return NaN;\n    }\n    else if (typeof structuredClone === 'function') {\n        // Available in Node >= 18.\n        return structuredClone(value);\n    }\n    else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\nexports.clone = clone;\n/**\n * Generates a random positive integer.\n */\nfunction generateRandomNumber() {\n    return Math.round(Math.random() * 10000000);\n}\nexports.generateRandomNumber = generateRandomNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhc291cC1jbGllbnRAMy43LjIvbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWFzb3VwLWNsaWVudEAzLjcuMi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvdXRpbHMuanM/OTVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIgPSBleHBvcnRzLmNsb25lID0gdm9pZCAwO1xuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBBdmFpbGFibGUgaW4gTm9kZSA+PSAxOC5cbiAgICAgICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHBvc2l0aXZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tTnVtYmVyKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG59XG5leHBvcnRzLmdlbmVyYXRlUmFuZG9tTnVtYmVyID0gZ2VuZXJhdGVSYW5kb21OdW1iZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/utils.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21zQDIuMS4yL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNAMi4xLjIvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzP2E1MjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/polyfills/process.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/polyfills/process.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQywySkFBd0I7O0FBRXJQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzPzM0NGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2dsb2JhbF9wcm9jZXNzLCBfZ2xvYmFsX3Byb2Nlc3MxO1xubW9kdWxlLmV4cG9ydHMgPSAoKF9nbG9iYWxfcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzLmVudikgJiYgdHlwZW9mICgoX2dsb2JhbF9wcm9jZXNzMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwiLi4vLi4vY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2Fcommon%2FNavbar.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2FClientComponents%2FHuddleContextProvider.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fnode_modules%2F.pnpm%2Fnext%4013.4.6_biqbaboplfbrettd7655fr4n2y%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fapp%2Fglobals.css&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2Fcommon%2FNavbar.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2FClientComponents%2FHuddleContextProvider.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fnode_modules%2F.pnpm%2Fnext%4013.4.6_biqbaboplfbrettd7655fr4n2y%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fapp%2Fglobals.css&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/common/Navbar.tsx */ \"(app-client)/./src/components/common/Navbar.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ClientComponents/HuddleContextProvider.tsx */ \"(app-client)/./src/components/ClientComponents/HuddleContextProvider.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-client)/./src/app/globals.css\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnJhbWl0JTJGd29yayUyRmhlYWxwaGklMkZoZWFseXBoaSUyRkhlYWxQaGklMkZzcmMlMkZjb21wb25lbnRzJTJGY29tbW9uJTJGTmF2YmFyLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGcmFtaXQlMkZ3b3JrJTJGaGVhbHBoaSUyRmhlYWx5cGhpJTJGSGVhbFBoaSUyRnNyYyUyRmNvbXBvbmVudHMlMkZDbGllbnRDb21wb25lbnRzJTJGSHVkZGxlQ29udGV4dFByb3ZpZGVyLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGcmFtaXQlMkZ3b3JrJTJGaGVhbHBoaSUyRmhlYWx5cGhpJTJGSGVhbFBoaSUyRm5vZGVfbW9kdWxlcyUyRi5wbnBtJTJGbmV4dCU0MDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZmb250JTJGZ29vZ2xlJTJGdGFyZ2V0LmNzcyUzRiU3QiUyMnBhdGglMjIlM0ElMjJzcmMlMkZhcHAlMkZsYXlvdXQudHN4JTIyJTJDJTIyaW1wb3J0JTIyJTNBJTIySW50ZXIlMjIlMkMlMjJhcmd1bWVudHMlMjIlM0ElNUIlN0IlMjJzdWJzZXRzJTIyJTNBJTVCJTIybGF0aW4lMjIlNUQlN0QlNUQlMkMlMjJ2YXJpYWJsZU5hbWUlMjIlM0ElMjJpbnRlciUyMiU3RCZtb2R1bGVzPSUyRlVzZXJzJTJGcmFtaXQlMkZ3b3JrJTJGaGVhbHBoaSUyRmhlYWx5cGhpJTJGSGVhbFBoaSUyRnNyYyUyRmFwcCUyRmdsb2JhbHMuY3NzJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsdUxBQWdIO0FBQ2hILHlPQUF5STtBQUN6SSx1aUJBQThTO0FBQzlTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/Y2NjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9yYW1pdC93b3JrL2hlYWxwaGkvaGVhbHlwaGkvSGVhbFBoaS9zcmMvY29tcG9uZW50cy9jb21tb24vTmF2YmFyLnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3JhbWl0L3dvcmsvaGVhbHBoaS9oZWFseXBoaS9IZWFsUGhpL3NyYy9jb21wb25lbnRzL0NsaWVudENvbXBvbmVudHMvSHVkZGxlQ29udGV4dFByb3ZpZGVyLnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3JhbWl0L3dvcmsvaGVhbHBoaS9oZWFseXBoaS9IZWFsUGhpL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeS9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcXFwicGF0aFxcXCI6XFxcInNyYy9hcHAvbGF5b3V0LnRzeFxcXCIsXFxcImltcG9ydFxcXCI6XFxcIkludGVyXFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiaW50ZXJcXFwifVwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3JhbWl0L3dvcmsvaGVhbHBoaS9oZWFseXBoaS9IZWFsUGhpL3NyYy9hcHAvZ2xvYmFscy5jc3NcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2Fcommon%2FNavbar.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2FClientComponents%2FHuddleContextProvider.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fnode_modules%2F.pnpm%2Fnext%4013.4.6_biqbaboplfbrettd7655fr4n2y%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fapp%2Fglobals.css&server=false!\n"));

/***/ }),

/***/ "(app-client)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"035aa28c7f5b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9nbG9iYWxzLmNzcz9lMmI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMDM1YWEyOGM3ZjViXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/app-dynamic.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/app-dynamic.js ***!
  \********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return dynamic;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.5.1/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\"));\nconst _loadable = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./lazy-dynamic/loadable */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js\"));\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule(mod) {\n    return {\n        default: (mod == null ? void 0 : mod.default) || mod\n    };\n}\nfunction dynamic(dynamicOptions, options) {\n    const loadableFn = _loadable.default;\n    const loadableOptions = {\n        // A loading component is not required, so we default it\n        loading: (param)=>{\n            let { error, isLoading, pastDelay } = param;\n            if (!pastDelay) return null;\n            if (true) {\n                if (isLoading) {\n                    return null;\n                }\n                if (error) {\n                    return /*#__PURE__*/ _react.default.createElement(\"p\", null, error.message, /*#__PURE__*/ _react.default.createElement(\"br\", null), error.stack);\n                }\n            }\n            return null;\n        }\n    };\n    if (typeof dynamicOptions === \"function\") {\n        loadableOptions.loader = dynamicOptions;\n    }\n    Object.assign(loadableOptions, options);\n    const loaderFn = loadableOptions.loader;\n    const loader = ()=>loaderFn != null ? loaderFn().then(convertModule) : Promise.resolve(convertModule(()=>null));\n    return loadableFn({\n        ...loadableOptions,\n        loader: loader\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hcHAtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQywrSkFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsRUFBRUYsbUJBQU9BLENBQUMsbUpBQU87QUFDdkUsTUFBTUcsWUFBWSxXQUFXLEdBQUdKLHlCQUF5QkcsRUFBRUYsbUJBQU9BLENBQUMsb0tBQXlCO0FBQzVGLHlGQUF5RjtBQUN6RixxR0FBcUc7QUFDckcscUVBQXFFO0FBQ3JFLFNBQVNJLGNBQWNDLEdBQUc7SUFDdEIsT0FBTztRQUNIQyxTQUFTLENBQUNELE9BQU8sT0FBTyxLQUFLLElBQUlBLElBQUlDLE9BQU0sS0FBTUQ7SUFDckQ7QUFDSjtBQUNBLFNBQVNQLFFBQVFTLGNBQWMsRUFBRUMsT0FBTztJQUNwQyxNQUFNQyxhQUFhTixVQUFVRztJQUM3QixNQUFNSSxrQkFBa0I7UUFDcEIsd0RBQXdEO1FBQ3hEQyxTQUFTLENBQUNDO1lBQ04sSUFBSSxFQUFFQyxLQUFLLEVBQUdDLFNBQVMsRUFBR0MsU0FBUyxFQUFHLEdBQUdIO1lBQ3pDLElBQUksQ0FBQ0csV0FBVyxPQUFPO1lBQ3ZCLElBQUlDLElBQXFDLEVBQUU7Z0JBQ3ZDLElBQUlGLFdBQVc7b0JBQ1gsT0FBTztnQkFDWDtnQkFDQSxJQUFJRCxPQUFPO29CQUNQLE9BQU8sV0FBVyxHQUFHWixPQUFPSyxRQUFRVyxjQUFjLEtBQUssTUFBTUosTUFBTUssU0FBUyxXQUFXLEdBQUdqQixPQUFPSyxRQUFRVyxjQUFjLE1BQU0sT0FBT0osTUFBTU07Z0JBQzlJO1lBQ0o7WUFDQSxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUksT0FBT1osbUJBQW1CLFlBQVk7UUFDdENHLGdCQUFnQlUsU0FBU2I7SUFDN0I7SUFDQWYsT0FBTzZCLE9BQU9YLGlCQUFpQkY7SUFDL0IsTUFBTWMsV0FBV1osZ0JBQWdCVTtJQUNqQyxNQUFNQSxTQUFTLElBQUlFLFlBQVksT0FBT0EsV0FBV0MsS0FBS25CLGlCQUFpQm9CLFFBQVFDLFFBQVFyQixjQUFjLElBQUk7SUFDekcsT0FBT0ssV0FBVztRQUNkLEdBQUdDLGVBQWU7UUFDbEJVLFFBQVFBO0lBQ1o7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPMUIsUUFBUVksWUFBWSxjQUFlLE9BQU9aLFFBQVFZLFlBQVksWUFBWVosUUFBUVksWUFBWSxJQUFJLEtBQU0sT0FBT1osUUFBUVksUUFBUW9CLGVBQWUsYUFBYTtJQUNyS2xDLE9BQU9DLGVBQWVDLFFBQVFZLFNBQVMsY0FBYztRQUFFWCxPQUFPO0lBQUs7SUFDbkVILE9BQU82QixPQUFPM0IsUUFBUVksU0FBU1o7SUFDL0JpQyxPQUFPakMsVUFBVUEsUUFBUVk7QUFDM0IsRUFFQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hcHAtZHluYW1pYy5qcz81NmY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZHluYW1pYztcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfbG9hZGFibGUgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL2xhenktZHluYW1pYy9sb2FkYWJsZVwiKSk7XG4vLyBOb3JtYWxpemUgbG9hZGVyIHRvIHJldHVybiB0aGUgbW9kdWxlIGFzIGZvcm0geyBkZWZhdWx0OiBDb21wb25lbnQgfSBmb3IgYFJlYWN0LmxhenlgLlxuLy8gQWxzbyBmb3IgYmFja3dhcmQgY29tcGF0aWJsZSBzaW5jZSBuZXh0L2R5bmFtaWMgYWxsb3dzIHRvIHJlc29sdmUgYSBjb21wb25lbnQgZGlyZWN0bHkgd2l0aCBsb2FkZXJcbi8vIENsaWVudCBjb21wb25lbnQgcmVmZXJlbmNlIHByb3h5IG5lZWQgdG8gYmUgY29udmVydGVkIHRvIGEgbW9kdWxlLlxuZnVuY3Rpb24gY29udmVydE1vZHVsZShtb2QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0OiAobW9kID09IG51bGwgPyB2b2lkIDAgOiBtb2QuZGVmYXVsdCkgfHwgbW9kXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGR5bmFtaWMoZHluYW1pY09wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2FkYWJsZUZuID0gX2xvYWRhYmxlLmRlZmF1bHQ7XG4gICAgY29uc3QgbG9hZGFibGVPcHRpb25zID0ge1xuICAgICAgICAvLyBBIGxvYWRpbmcgY29tcG9uZW50IGlzIG5vdCByZXF1aXJlZCwgc28gd2UgZGVmYXVsdCBpdFxuICAgICAgICBsb2FkaW5nOiAocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyBlcnJvciAsIGlzTG9hZGluZyAsIHBhc3REZWxheSAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgaWYgKCFwYXN0RGVsYXkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBlcnJvci5tZXNzYWdlLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSwgZXJyb3Iuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGR5bmFtaWNPcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9hZGFibGVPcHRpb25zLmxvYWRlciA9IGR5bmFtaWNPcHRpb25zO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKGxvYWRhYmxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgbG9hZGVyRm4gPSBsb2FkYWJsZU9wdGlvbnMubG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9ICgpPT5sb2FkZXJGbiAhPSBudWxsID8gbG9hZGVyRm4oKS50aGVuKGNvbnZlcnRNb2R1bGUpIDogUHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRNb2R1bGUoKCk9Pm51bGwpKTtcbiAgICByZXR1cm4gbG9hZGFibGVGbih7XG4gICAgICAgIC4uLmxvYWRhYmxlT3B0aW9ucyxcbiAgICAgICAgbG9hZGVyOiBsb2FkZXJcbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImR5bmFtaWMiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9sb2FkYWJsZSIsImNvbnZlcnRNb2R1bGUiLCJtb2QiLCJkZWZhdWx0IiwiZHluYW1pY09wdGlvbnMiLCJvcHRpb25zIiwibG9hZGFibGVGbiIsImxvYWRhYmxlT3B0aW9ucyIsImxvYWRpbmciLCJwYXJhbSIsImVycm9yIiwiaXNMb2FkaW5nIiwicGFzdERlbGF5IiwicHJvY2VzcyIsImNyZWF0ZUVsZW1lbnQiLCJtZXNzYWdlIiwic3RhY2siLCJsb2FkZXIiLCJhc3NpZ24iLCJsb2FkZXJGbiIsInRoZW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/app-dynamic.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js ***!
  \************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    suspense: function() {\n        return suspense;\n    },\n    NoSSR: function() {\n        return NoSSR;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.5.1/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\"));\nconst _nossrerror = __webpack_require__(/*! ./no-ssr-error */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js\");\nfunction suspense() {\n    const error = new Error(_nossrerror.NEXT_DYNAMIC_NO_SSR_CODE);\n    error.digest = _nossrerror.NEXT_DYNAMIC_NO_SSR_CODE;\n    throw error;\n}\nfunction NoSSR(param) {\n    let { children } = param;\n    if (false) {}\n    return children;\n} //# sourceMappingURL=dynamic-no-ssr.js.map\n_c = NoSSR;\nvar _c;\n$RefreshReg$(_c, \"NoSSR\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1uby1zc3IuanMiLCJtYXBwaW5ncyI6InFEQUNhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBR047QUFDQSxTQUFTRyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVCxPQUFPQyxlQUFlTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7SUFDQUMsT0FBTztRQUNILE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDJCQUEyQkMsbUJBQU9BLENBQUMsK0pBQXlDO0FBQ2xGLE1BQU1DLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLEVBQUVGLG1CQUFPQSxDQUFDLG1KQUFPO0FBQ3ZFLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDLCtKQUFnQjtBQUU1QyxTQUFTVDtJQUNMLE1BQU1hLFFBQVEsSUFBSUMsTUFBTUYsWUFBWUc7SUFDcENGLE1BQU1HLFNBQVNKLFlBQVlHO0lBQzNCLE1BQU1GO0FBQ1Y7QUFDQSxTQUFTWixNQUFNZ0IsS0FBSztJQUNoQixJQUFJLEVBQUVDLFFBQVEsRUFBRyxHQUFHRDtJQUNwQixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDRCxPQUFPQztBQUNYLEVBRUEsMENBQTBDO0tBUmpDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1uby1zc3IuanM/NWIxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3VzcGVuc2U6IG51bGwsXG4gICAgTm9TU1I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc3VzcGVuc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3VzcGVuc2U7XG4gICAgfSxcbiAgICBOb1NTUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOb1NTUjtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfbm9zc3JlcnJvciA9IHJlcXVpcmUoXCIuL25vLXNzci1lcnJvclwiKTtcblxuZnVuY3Rpb24gc3VzcGVuc2UoKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoX25vc3NyZXJyb3IuTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFKTtcbiAgICBlcnJvci5kaWdlc3QgPSBfbm9zc3JlcnJvci5ORVhUX0RZTkFNSUNfTk9fU1NSX0NPREU7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBOb1NTUihwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuICB9ID0gcGFyYW07XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3VzcGVuc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljLW5vLXNzci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJzdXNwZW5zZSIsIk5vU1NSIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfbm9zc3JlcnJvciIsImVycm9yIiwiRXJyb3IiLCJORVhUX0RZTkFNSUNfTk9fU1NSX0NPREUiLCJkaWdlc3QiLCJwYXJhbSIsImNoaWxkcmVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js ***!
  \******************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.5.1/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\"));\nconst _dynamicnossr = __webpack_require__(/*! ./dynamic-no-ssr */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js\");\nfunction Loadable(options) {\n    const opts = Object.assign({\n        loader: null,\n        loading: null,\n        ssr: true\n    }, options);\n    opts.lazy = /*#__PURE__*/ _react.default.lazy(opts.loader);\n    function LoadableComponent(props) {\n        const Loading = opts.loading;\n        const fallbackElement = /*#__PURE__*/ _react.default.createElement(Loading, {\n            isLoading: true,\n            pastDelay: true,\n            error: null\n        });\n        const Wrap = opts.ssr ? _react.default.Fragment : _dynamicnossr.NoSSR;\n        const Lazy = opts.lazy;\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {\n            fallback: fallbackElement\n        }, /*#__PURE__*/ _react.default.createElement(Wrap, null, /*#__PURE__*/ _react.default.createElement(Lazy, props)));\n    }\n    LoadableComponent.displayName = \"LoadableComponent\";\n    return LoadableComponent;\n}\n_c = Loadable;\nconst _default = Loadable; //# sourceMappingURL=loadable.js.map\nvar _c;\n$RefreshReg$(_c, \"Loadable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvbG9hZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsK0pBQXlDO0FBQ2xGLE1BQU1DLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLEVBQUVGLG1CQUFPQSxDQUFDLG1KQUFPO0FBQ3ZFLE1BQU1HLGdCQUFnQkgsbUJBQU9BLENBQUMsbUtBQWtCO0FBQ2hELFNBQVNJLFNBQVNDLE9BQU87SUFDckIsTUFBTUMsT0FBT2QsT0FBT2UsT0FBTztRQUN2QkMsUUFBUTtRQUNSQyxTQUFTO1FBQ1RDLEtBQUs7SUFDVCxHQUFHTDtJQUNIQyxLQUFLSyxPQUFPLFdBQVcsR0FBR1YsT0FBT1csUUFBUUQsS0FBS0wsS0FBS0U7SUFDbkQsU0FBU0ssa0JBQWtCQyxLQUFLO1FBQzVCLE1BQU1DLFVBQVVULEtBQUtHO1FBQ3JCLE1BQU1PLGtCQUFrQixXQUFXLEdBQUdmLE9BQU9XLFFBQVFLLGNBQWNGLFNBQVM7WUFDeEVHLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxPQUFPO1FBQ1g7UUFDQSxNQUFNQyxPQUFPZixLQUFLSSxNQUFNVCxPQUFPVyxRQUFRVSxXQUFXbkIsY0FBY29CO1FBQ2hFLE1BQU1DLE9BQU9sQixLQUFLSztRQUNsQixPQUFPLFdBQVcsR0FBR1YsT0FBT1csUUFBUUssY0FBY2hCLE9BQU9XLFFBQVFhLFVBQVU7WUFDdkVDLFVBQVVWO1FBQ2QsR0FBRyxXQUFXLEdBQUdmLE9BQU9XLFFBQVFLLGNBQWNJLE1BQU0sTUFBTSxXQUFXLEdBQUdwQixPQUFPVyxRQUFRSyxjQUFjTyxNQUFNVjtJQUMvRztJQUNBRCxrQkFBa0JjLGNBQWM7SUFDaEMsT0FBT2Q7QUFDWDtLQXRCU1Q7QUF1QlQsTUFBTU4sV0FBV00sVUFFakIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2xvYWRhYmxlLmpzP2EwNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfZHluYW1pY25vc3NyID0gcmVxdWlyZShcIi4vZHluYW1pYy1uby1zc3JcIik7XG5mdW5jdGlvbiBMb2FkYWJsZShvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBsb2FkZXI6IG51bGwsXG4gICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgIHNzcjogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIG9wdHMubGF6eSA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQubGF6eShvcHRzLmxvYWRlcik7XG4gICAgZnVuY3Rpb24gTG9hZGFibGVDb21wb25lbnQocHJvcHMpIHtcbiAgICAgICAgY29uc3QgTG9hZGluZyA9IG9wdHMubG9hZGluZztcbiAgICAgICAgY29uc3QgZmFsbGJhY2tFbGVtZW50ID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExvYWRpbmcsIHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3REZWxheTogdHJ1ZSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBXcmFwID0gb3B0cy5zc3IgPyBfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCA6IF9keW5hbWljbm9zc3IuTm9TU1I7XG4gICAgICAgIGNvbnN0IExhenkgPSBvcHRzLmxhenk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiBmYWxsYmFja0VsZW1lbnRcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXAsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChMYXp5LCBwcm9wcykpKTtcbiAgICB9XG4gICAgTG9hZGFibGVDb21wb25lbnQuZGlzcGxheU5hbWUgPSBcIkxvYWRhYmxlQ29tcG9uZW50XCI7XG4gICAgcmV0dXJuIExvYWRhYmxlQ29tcG9uZW50O1xufVxuY29uc3QgX2RlZmF1bHQgPSBMb2FkYWJsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGFibGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfZHluYW1pY25vc3NyIiwiTG9hZGFibGUiLCJvcHRpb25zIiwib3B0cyIsImFzc2lnbiIsImxvYWRlciIsImxvYWRpbmciLCJzc3IiLCJsYXp5IiwiZGVmYXVsdCIsIkxvYWRhYmxlQ29tcG9uZW50IiwicHJvcHMiLCJMb2FkaW5nIiwiZmFsbGJhY2tFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImlzTG9hZGluZyIsInBhc3REZWxheSIsImVycm9yIiwiV3JhcCIsIkZyYWdtZW50IiwiTm9TU1IiLCJMYXp5IiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js\n"));

/***/ }),

/***/ "(app-client)/./src/components/ClientComponents/HuddleContextProvider.tsx":
/*!*******************************************************************!*\
  !*** ./src/components/ClientComponents/HuddleContextProvider.tsx ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-dev-runtime.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dynamic */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/app-dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _huddle01_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @huddle01/react */ \"(app-client)/./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nconst Toaster = next_dynamic__WEBPACK_IMPORTED_MODULE_1___default()(()=>__webpack_require__.e(/*! import() */ \"_app-client_node_modules_pnpm_react-hot-toast_2_4_1_biqbaboplfbrettd7655fr4n2y_node_modules_r-29f394\").then(__webpack_require__.bind(__webpack_require__, /*! react-hot-toast */ \"(app-client)/./node_modules/.pnpm/react-hot-toast@2.4.1_biqbaboplfbrettd7655fr4n2y/node_modules/react-hot-toast/dist/index.mjs\")).then((m)=>m.Toaster), {\n    loadableGenerated: {\n        modules: [\n            \"/Users/ramit/work/healphi/healyphi/HealPhi/src/components/ClientComponents/HuddleContextProvider.tsx -> \" + \"react-hot-toast\"\n        ]\n    },\n    ssr: false\n});\n_c = Toaster;\nconst HuddleContextProvider = (param)=>{\n    let { children } = param;\n    var _process_env_NEXT_PUBLIC_PROJECT_ID;\n    const huddleClient = new _huddle01_react__WEBPACK_IMPORTED_MODULE_3__.HuddleClient({\n        projectId: (_process_env_NEXT_PUBLIC_PROJECT_ID = \"wwDJoY9VrrUaROO_wtCVBd2layq4t5GJ\") !== null && _process_env_NEXT_PUBLIC_PROJECT_ID !== void 0 ? _process_env_NEXT_PUBLIC_PROJECT_ID : \"\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_huddle01_react__WEBPACK_IMPORTED_MODULE_3__.HuddleProvider, {\n        client: huddleClient,\n        children: [\n            children,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Toaster, {\n                position: \"bottom-right\",\n                containerStyle: {\n                    bottom: \"70px\",\n                    animation: \"ease-in-out\",\n                    animationFillMode: \"forwards\"\n                },\n                toastOptions: {\n                    style: {\n                        padding: \"1.2rem 1rem\"\n                    },\n                    duration: 5000,\n                    success: {\n                        style: {\n                            border: \"1px solid #3CCB7F\",\n                            backgroundColor: \"#121214\",\n                            color: \"#3CCB7F\"\n                        }\n                    },\n                    error: {\n                        style: {\n                            border: \"1px solid #F87171\",\n                            background: \"black\",\n                            color: \"#F87171\"\n                        }\n                    }\n                }\n            }, void 0, false, {\n                fileName: \"/Users/ramit/work/healphi/healyphi/HealPhi/src/components/ClientComponents/HuddleContextProvider.tsx\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ramit/work/healphi/healyphi/HealPhi/src/components/ClientComponents/HuddleContextProvider.tsx\",\n        lineNumber: 23,\n        columnNumber: 5\n    }, undefined);\n};\n_c1 = HuddleContextProvider;\n/* harmony default export */ __webpack_exports__[\"default\"] = (HuddleContextProvider);\nvar _c, _c1;\n$RefreshReg$(_c, \"Toaster\");\n$RefreshReg$(_c1, \"HuddleContextProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2NvbXBvbmVudHMvQ2xpZW50Q29tcG9uZW50cy9IdWRkbGVDb250ZXh0UHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRW1DO0FBQ1Q7QUFDcUM7QUFFL0QsTUFBTUksVUFBVUosbURBQU9BLENBQ3JCLElBQU0sMFZBQU8sQ0FBbUJLLEtBQUssQ0FBQ0MsSUFBTUEsRUFBRUY7Ozs7OztJQUU1Q0csS0FBSzs7S0FISEg7QUFXTixNQUFNSSx3QkFBZ0Q7UUFBQyxFQUFFQyxRQUFRLEVBQUU7UUFFZEM7SUFBbkQsTUFBTUMsZUFBZSxJQUFJVCx5REFBWUEsQ0FBQztRQUFFVSxXQUFXRixDQUFBQSxzQ0FBQUEsa0NBQWtDSSxjQUFsQ0osaURBQUFBLHNDQUFzQztJQUFHO0lBRTVGLHFCQUNFLDhEQUFDUCwyREFBY0E7UUFBQ1ksUUFBUUo7O1lBQ3JCRjswQkFDRCw4REFBQ0w7Z0JBQ0NZLFVBQVM7Z0JBQ1RDLGdCQUFnQjtvQkFDZEMsUUFBUTtvQkFDUkMsV0FBVztvQkFDWEMsbUJBQW1CO2dCQUNyQjtnQkFDQUMsY0FBYztvQkFDWkMsT0FBTzt3QkFDTEMsU0FBUztvQkFDWDtvQkFDQUMsVUFBVTtvQkFDVkMsU0FBUzt3QkFDUEgsT0FBTzs0QkFDTEksUUFBUTs0QkFDUkMsaUJBQWlCOzRCQUNqQkMsT0FBTzt3QkFDVDtvQkFDRjtvQkFDQUMsT0FBTzt3QkFDTFAsT0FBTzs0QkFDTEksUUFBUTs0QkFDUkksWUFBWTs0QkFDWkYsT0FBTzt3QkFDVDtvQkFDRjtnQkFDRjs7Ozs7Ozs7Ozs7O0FBSVI7TUFyQ01wQjtBQXNDTiwrREFBZUEscUJBQXFCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NsaWVudENvbXBvbmVudHMvSHVkZGxlQ29udGV4dFByb3ZpZGVyLnRzeD8zMDdlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBIdWRkbGVDbGllbnQsIEh1ZGRsZVByb3ZpZGVyIH0gZnJvbSAnQGh1ZGRsZTAxL3JlYWN0JztcblxuY29uc3QgVG9hc3RlciA9IGR5bmFtaWMoXG4gICgpID0+IGltcG9ydCgncmVhY3QtaG90LXRvYXN0JykudGhlbigobSkgPT4gbS5Ub2FzdGVyKSxcbiAge1xuICAgIHNzcjogZmFsc2UsXG4gIH1cbik7XG5cbnR5cGUgVG9hc3RlclByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufTtcblxuY29uc3QgSHVkZGxlQ29udGV4dFByb3ZpZGVyOiBSZWFjdC5GQzxUb2FzdGVyUHJvcHM+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuXG4gIGNvbnN0IGh1ZGRsZUNsaWVudCA9IG5ldyBIdWRkbGVDbGllbnQoeyBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BST0pFQ1RfSUQgPz8gJycgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8SHVkZGxlUHJvdmlkZXIgY2xpZW50PXtodWRkbGVDbGllbnR9PlxuICAgICAge2NoaWxkcmVufVxuICAgICAgPFRvYXN0ZXJcbiAgICAgICAgcG9zaXRpb249XCJib3R0b20tcmlnaHRcIlxuICAgICAgICBjb250YWluZXJTdHlsZT17e1xuICAgICAgICAgIGJvdHRvbTogJzcwcHgnLFxuICAgICAgICAgIGFuaW1hdGlvbjogJ2Vhc2UtaW4tb3V0JyxcbiAgICAgICAgICBhbmltYXRpb25GaWxsTW9kZTogJ2ZvcndhcmRzJyxcbiAgICAgICAgfX1cbiAgICAgICAgdG9hc3RPcHRpb25zPXt7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6ICcxLjJyZW0gMXJlbScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgIzNDQ0I3RicsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMxMjEyMTQnLFxuICAgICAgICAgICAgICBjb2xvcjogJyMzQ0NCN0YnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI0Y4NzE3MScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICAgICAgICAgIGNvbG9yOiAnI0Y4NzE3MScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIDwvSHVkZGxlUHJvdmlkZXI+XG4gICk7XG59O1xuZXhwb3J0IGRlZmF1bHQgSHVkZGxlQ29udGV4dFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbImR5bmFtaWMiLCJSZWFjdCIsIkh1ZGRsZUNsaWVudCIsIkh1ZGRsZVByb3ZpZGVyIiwiVG9hc3RlciIsInRoZW4iLCJtIiwic3NyIiwiSHVkZGxlQ29udGV4dFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJwcm9jZXNzIiwiaHVkZGxlQ2xpZW50IiwicHJvamVjdElkIiwiZW52IiwiTkVYVF9QVUJMSUNfUFJPSkVDVF9JRCIsImNsaWVudCIsInBvc2l0aW9uIiwiY29udGFpbmVyU3R5bGUiLCJib3R0b20iLCJhbmltYXRpb24iLCJhbmltYXRpb25GaWxsTW9kZSIsInRvYXN0T3B0aW9ucyIsInN0eWxlIiwicGFkZGluZyIsImR1cmF0aW9uIiwic3VjY2VzcyIsImJvcmRlciIsImJhY2tncm91bmRDb2xvciIsImNvbG9yIiwiZXJyb3IiLCJiYWNrZ3JvdW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./src/components/ClientComponents/HuddleContextProvider.tsx\n"));

/***/ }),

/***/ "(app-client)/./src/components/common/Navbar.tsx":
/*!******************************************!*\
  !*** ./src/components/common/Navbar.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst Navbar = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"border-b border-custom-1 w-full absolute top-0 left-0 h-16 flex items-center px-10 z-10 text-slate-100 justify-between\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n            className: \"font-bold text-xl\",\n            children: \"Healphi\"\n        }, void 0, false, {\n            fileName: \"/Users/ramit/work/healphi/healyphi/HealPhi/src/components/common/Navbar.tsx\",\n            lineNumber: 11,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/ramit/work/healphi/healyphi/HealPhi/src/components/common/Navbar.tsx\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Navbar;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Navbar);\nvar _c;\n$RefreshReg$(_c, \"Navbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL05hdmJhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFMEI7QUFLMUIsTUFBTUMsU0FBZ0M7SUFDcEMscUJBQ0UsOERBQUNDO1FBQU9DLFdBQVU7a0JBQ2hCLDRFQUFDQztZQUFFRCxXQUFVO3NCQUFvQjs7Ozs7Ozs7Ozs7QUFHdkM7S0FOTUY7QUFPTiwrREFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jb21tb24vTmF2YmFyLnRzeD82NTBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcblxudHlwZSBOYXZiYXJQcm9wcyA9IHt9O1xuXG5jb25zdCBOYXZiYXI6IFJlYWN0LkZDPE5hdmJhclByb3BzPiA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8aGVhZGVyIGNsYXNzTmFtZT1cImJvcmRlci1iIGJvcmRlci1jdXN0b20tMSB3LWZ1bGwgYWJzb2x1dGUgdG9wLTAgbGVmdC0wIGgtMTYgZmxleCBpdGVtcy1jZW50ZXIgcHgtMTAgei0xMCB0ZXh0LXNsYXRlLTEwMCBqdXN0aWZ5LWJldHdlZW5cIj5cbiAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtYm9sZCB0ZXh0LXhsXCI+SGVhbHBoaTwvcD5cbiAgICA8L2hlYWRlcj5cbiAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBOYXZiYXI7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJOYXZiYXIiLCJoZWFkZXIiLCJjbGFzc05hbWUiLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./src/components/common/Navbar.tsx\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={686:(e,r,t)=>{var n=t(808);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},808:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(686);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy40LjZfYmlxYmFib3BsZmJyZXR0ZDc2NTVmcjRuMnkvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanM/MjNmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17Njg2OihlLHIsdCk9Pnt2YXIgbj10KDgwOCk7dmFyIGk9T2JqZWN0LmNyZWF0ZShudWxsKTt2YXIgYT10eXBlb2YgZG9jdW1lbnQ9PT1cInVuZGVmaW5lZFwiO3ZhciBvPUFycmF5LnByb3RvdHlwZS5mb3JFYWNoO2Z1bmN0aW9uIGRlYm91bmNlKGUscil7dmFyIHQ9MDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzO3ZhciBpPWFyZ3VtZW50czt2YXIgYT1mdW5jdGlvbiBmdW5jdGlvbkNhbGwoKXtyZXR1cm4gZS5hcHBseShuLGkpfTtjbGVhclRpbWVvdXQodCk7dD1zZXRUaW1lb3V0KGEscil9fWZ1bmN0aW9uIG5vb3AoKXt9ZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFVybChlKXt2YXIgcj1pW2VdO2lmKCFyKXtpZihkb2N1bWVudC5jdXJyZW50U2NyaXB0KXtyPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjfWVsc2V7dmFyIHQ9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7dmFyIGE9dFt0Lmxlbmd0aC0xXTtpZihhKXtyPWEuc3JjfX1pW2VdPXJ9cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKCFyKXtyZXR1cm4gbnVsbH12YXIgdD1yLnNwbGl0KC8oW15cXFxcL10rKVxcLmpzJC8pO3ZhciBpPXQmJnRbMV07aWYoIWkpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfWlmKCFlKXtyZXR1cm5bci5yZXBsYWNlKFwiLmpzXCIsXCIuY3NzXCIpXX1yZXR1cm4gZS5zcGxpdChcIixcIikubWFwKChmdW5jdGlvbihlKXt2YXIgdD1uZXcgUmVnRXhwKFwiXCIuY29uY2F0KGksXCJcXFxcLmpzJFwiKSxcImdcIik7cmV0dXJuIG4oci5yZXBsYWNlKHQsXCJcIi5jb25jYXQoZS5yZXBsYWNlKC97ZmlsZU5hbWV9L2csaSksXCIuY3NzXCIpKSl9KSl9fWZ1bmN0aW9uIHVwZGF0ZUNzcyhlLHIpe2lmKCFyKXtpZighZS5ocmVmKXtyZXR1cm59cj1lLmhyZWYuc3BsaXQoXCI/XCIpWzBdfWlmKCFpc1VybFJlcXVlc3Qocikpe3JldHVybn1pZihlLmlzTG9hZGVkPT09ZmFsc2Upe3JldHVybn1pZighcnx8IShyLmluZGV4T2YoXCIuY3NzXCIpPi0xKSl7cmV0dXJufWUudmlzaXRlZD10cnVlO3ZhciB0PWUuY2xvbmVOb2RlKCk7dC5pc0xvYWRlZD1mYWxzZTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsKGZ1bmN0aW9uKCl7aWYodC5pc0xvYWRlZCl7cmV0dXJufXQuaXNMb2FkZWQ9dHJ1ZTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KSk7dC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmhyZWY9XCJcIi5jb25jYXQocixcIj9cIikuY29uY2F0KERhdGUubm93KCkpO2lmKGUubmV4dFNpYmxpbmcpe2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCxlLm5leHRTaWJsaW5nKX1lbHNle2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0KX19ZnVuY3Rpb24gZ2V0UmVsb2FkVXJsKGUscil7dmFyIHQ7ZT1uKGUse3N0cmlwV1dXOmZhbHNlfSk7ci5zb21lKChmdW5jdGlvbihuKXtpZihlLmluZGV4T2Yocik+LTEpe3Q9bn19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkU3R5bGUoZSl7aWYoIWUpe3JldHVybiBmYWxzZX12YXIgcj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1wiKTt2YXIgdD1mYWxzZTtvLmNhbGwociwoZnVuY3Rpb24ocil7aWYoIXIuaHJlZil7cmV0dXJufXZhciBuPWdldFJlbG9hZFVybChyLmhyZWYsZSk7aWYoIWlzVXJsUmVxdWVzdChuKSl7cmV0dXJufWlmKHIudmlzaXRlZD09PXRydWUpe3JldHVybn1pZihuKXt1cGRhdGVDc3MocixuKTt0PXRydWV9fSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlbG9hZEFsbCgpe3ZhciBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO28uY2FsbChlLChmdW5jdGlvbihlKXtpZihlLnZpc2l0ZWQ9PT10cnVlKXtyZXR1cm59dXBkYXRlQ3NzKGUpfSkpfWZ1bmN0aW9uIGlzVXJsUmVxdWVzdChlKXtpZighL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qOi8udGVzdChlKSl7cmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfWUuZXhwb3J0cz1mdW5jdGlvbihlLHIpe2lmKGEpe2NvbnNvbGUubG9nKFwibm8gd2luZG93LmRvY3VtZW50IGZvdW5kLCB3aWxsIG5vdCBITVIgQ1NTXCIpO3JldHVybiBub29wfXZhciB0PWdldEN1cnJlbnRTY3JpcHRVcmwoZSk7ZnVuY3Rpb24gdXBkYXRlKCl7dmFyIGU9dChyLmZpbGVuYW1lKTt2YXIgbj1yZWxvYWRTdHlsZShlKTtpZihyLmxvY2Fscyl7Y29uc29sZS5sb2coXCJbSE1SXSBEZXRlY3RlZCBsb2NhbCBjc3MgbW9kdWxlcy4gUmVsb2FkIGFsbCBjc3NcIik7cmVsb2FkQWxsKCk7cmV0dXJufWlmKG4pe2NvbnNvbGUubG9nKFwiW0hNUl0gY3NzIHJlbG9hZCAlc1wiLGUuam9pbihcIiBcIikpfWVsc2V7Y29uc29sZS5sb2coXCJbSE1SXSBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKX19cmV0dXJuIGRlYm91bmNlKHVwZGF0ZSw1MCl9fSw4MDg6ZT0+e2Z1bmN0aW9uIG5vcm1hbGl6ZVVybChlKXtyZXR1cm4gZS5yZWR1Y2UoKGZ1bmN0aW9uKGUscil7c3dpdGNoKHIpe2Nhc2VcIi4uXCI6ZS5wb3AoKTticmVhaztjYXNlXCIuXCI6YnJlYWs7ZGVmYXVsdDplLnB1c2gocil9cmV0dXJuIGV9KSxbXSkuam9pbihcIi9cIil9ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2U9ZS50cmltKCk7aWYoL15kYXRhOi9pLnRlc3QoZSkpe3JldHVybiBlfXZhciByPWUuaW5kZXhPZihcIi8vXCIpIT09LTE/ZS5zcGxpdChcIi8vXCIpWzBdK1wiLy9cIjpcIlwiO3ZhciB0PWUucmVwbGFjZShuZXcgUmVnRXhwKHIsXCJpXCIpLFwiXCIpLnNwbGl0KFwiL1wiKTt2YXIgbj10WzBdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFwuJC8sXCJcIik7dFswXT1cIlwiO3ZhciBpPW5vcm1hbGl6ZVVybCh0KTtyZXR1cm4gcituK2l9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbj1yW3RdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9clt0XT17ZXhwb3J0czp7fX07dmFyIGE9dHJ1ZTt0cnl7ZVt0XShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTthPWZhbHNlfWZpbmFsbHl7aWYoYSlkZWxldGUgclt0XX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDY4Nik7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/font/google/target.css?{"path":"src/app/layout.tsx","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_a64ecd', '__Inter_Fallback_a64ecd'\",\"fontStyle\":\"normal\"},\"className\":\"__className_a64ecd\"};\n    if(true) {\n      // 1705171216749\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjL2FwcC9sYXlvdXQudHN4XCIsXCJpbXBvcnRcIjpcIkludGVyXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcImludGVyXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsZ0ZBQWdGO0FBQzNHLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHFUQUEwTCxjQUFjLHNEQUFzRDtBQUM1UixNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeS9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzPzNlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fSW50ZXJfYTY0ZWNkJywgJ19fSW50ZXJfRmFsbGJhY2tfYTY0ZWNkJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2E2NGVjZFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzA1MTcxMjE2NzQ5XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9yYW1pdC93b3JrL2hlYWxwaGkvaGVhbHlwaGkvSGVhbFBoaS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy40LjZfYmlxYmFib3BsZmJyZXR0ZDc2NTVmcjRuMnkvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/process/browser.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/process/browser.js ***!
  \**********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy40LjZfYmlxYmFib3BsZmJyZXR0ZDc2NTVmcjRuMnkvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/Zjc5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-dev-runtime.development.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-dev-runtime.development.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react-experimental */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || type === REACT_CACHE_TYPE || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsbUxBQXVDOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUIscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsZ0RBQWdELE1BQU0sYUFBYTs7QUFFakg7QUFDQSwrQ0FBK0Msa0NBQWtDLE9BQU87O0FBRXhGLHVHQUF1RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXJRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MzgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsXCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgdHlwZSA9PT0gUkVBQ1RfQ0FDSEVfVFlQRSB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-runtime.development.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-runtime.development.js ***!
  \***********************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react-experimental */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || type === REACT_CACHE_TYPE || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx = jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs = jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxtTEFBdUM7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QixxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsMkRBQTJELFVBQVU7QUFDckUseUJBQXlCLFVBQVU7QUFDbkM7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUEsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxZQUFZO0FBQ1osR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWV4cGVyaW1lbnRhbC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/NzQyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1leHBlcmltZW50YWxcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zZXJ2ZXJfY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCB0eXBlID09PSBSRUFDVF9DQUNIRV9UWVBFIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0ganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4ID0ganN4O1xuZXhwb3J0cy5qc3hzID0ganN4cztcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-dev-runtime.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-dev-runtime.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsL2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOFBBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjQuNl9iaXFiYWJvcGxmYnJldHRkNzY1NWZyNG4yeS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWV4cGVyaW1lbnRhbC9qc3gtZGV2LXJ1bnRpbWUuanM/OTkzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-runtime.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-runtime.js ***!
  \*************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsL2pzeC1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxzUEFBa0U7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNC42X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZXhwZXJpbWVudGFsL2pzeC1ydW50aW1lLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-runtime.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3F1ZXVlLW1pY3JvdGFza0AxLjIuMy9ub2RlX21vZHVsZXMvcXVldWUtbWljcm90YXNrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUscUJBQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3F1ZXVlLW1pY3JvdGFza0AxLjIuMy9ub2RlX21vZHVsZXMvcXVldWUtbWljcm90YXNrL2luZGV4LmpzPzJiZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2VcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbidcbiAgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxuICAvLyByZXVzZSByZXNvbHZlZCBwcm9taXNlLCBhbmQgYWxsb2NhdGUgaXQgbGF6aWx5XG4gIDogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpXG4gICAgLnRoZW4oY2IpXG4gICAgLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyIH0sIDApKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/grammar.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/grammar.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%s trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push:'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name:'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += (o.id != null ? 'id=%s %s' : '%v%s');\n        str += (o.mediaClockValue != null ? '=%s' : '');\n        str += (o.rateNumerator != null ? ' rate=%s' : '');\n        str += (o.rateDenominator != null ? '/%s' : '');\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNC4xL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9ncmFtbWFyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCLFFBQVEscUJBQXFCO0FBQzdCLFFBQVEsYUFBYTtBQUNyQixRQUFRLGVBQWU7QUFDdkIsUUFBUSxlQUFlO0FBQ3ZCLFFBQVEsbUJBQW1CO0FBQzNCLFFBQVEsaUJBQWlCO0FBQ3pCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQyxlQUFlLFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3Qyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQ0FBc0M7QUFDdEMsMEJBQTBCO0FBQzFCLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLEVBQUU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2RwLXRyYW5zZm9ybUAyLjE0LjEvbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2dyYW1tYXIuanM/ZDE0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ3JhbW1hciA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB2OiBbe1xuICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICByZWc6IC9eKFxcZCopJC9cbiAgfV0sXG4gIG86IFt7XG4gICAgLy8gbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXG4gICAgbmFtZTogJ29yaWdpbicsXG4gICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXG4gIH1dLFxuICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcbiAgczogW3sgbmFtZTogJ25hbWUnIH1dLFxuICBpOiBbeyBuYW1lOiAnZGVzY3JpcHRpb24nIH1dLFxuICB1OiBbeyBuYW1lOiAndXJpJyB9XSxcbiAgZTogW3sgbmFtZTogJ2VtYWlsJyB9XSxcbiAgcDogW3sgbmFtZTogJ3Bob25lJyB9XSxcbiAgejogW3sgbmFtZTogJ3RpbWV6b25lcycgfV0sIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLi5cbiAgcjogW3sgbmFtZTogJ3JlcGVhdHMnIH1dLCAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAvLyBrOiBbe31dLCAvLyBvdXRkYXRlZCB0aGluZyBpZ25vcmVkXG4gIHQ6IFt7XG4gICAgLy8gdD0wIDBcbiAgICBuYW1lOiAndGltaW5nJyxcbiAgICByZWc6IC9eKFxcZCopIChcXGQqKS8sXG4gICAgbmFtZXM6IFsnc3RhcnQnLCAnc3RvcCddLFxuICAgIGZvcm1hdDogJyVkICVkJ1xuICB9XSxcbiAgYzogW3tcbiAgICAvLyBjPUlOIElQNCAxMC40Ny4xOTcuMjZcbiAgICBuYW1lOiAnY29ubmVjdGlvbicsXG4gICAgcmVnOiAvXklOIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd2ZXJzaW9uJywgJ2lwJ10sXG4gICAgZm9ybWF0OiAnSU4gSVAlZCAlcydcbiAgfV0sXG4gIGI6IFt7XG4gICAgLy8gYj1BUzo0MDAwXG4gICAgcHVzaDogJ2JhbmR3aWR0aCcsXG4gICAgcmVnOiAvXihUSUFTfEFTfENUfFJSfFJTKTooXFxkKikvLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAnbGltaXQnXSxcbiAgICBmb3JtYXQ6ICclczolcydcbiAgfV0sXG4gIG06IFt7XG4gICAgLy8gbT12aWRlbyA1MTc0NCBSVFAvQVZQIDEyNiA5NyA5OCAzNCAzMVxuICAgIC8vIE5COiBzcGVjaWFsIC0gcHVzaGVzIHRvIHNlc3Npb25cbiAgICAvLyBUT0RPOiBydHAvZm10cCBzaG91bGQgYmUgZmlsdGVyZWQgYnkgdGhlIHBheWxvYWRzIGZvdW5kIGhlcmU/XG4gICAgcmVnOiAvXihcXHcqKSAoXFxkKikgKFtcXHcvXSopKD86ICguKikpPy8sXG4gICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXG4gICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXG4gIH1dLFxuICBhOiBbXG4gICAge1xuICAgICAgLy8gYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgICAgcHVzaDogJ3J0cCcsXG4gICAgICByZWc6IC9ecnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5lbmNvZGluZylcbiAgICAgICAgICA/ICdydHBtYXA6JWQgJXMvJXMvJXMnXG4gICAgICAgICAgOiBvLnJhdGVcbiAgICAgICAgICAgID8gJ3J0cG1hcDolZCAlcy8lcydcbiAgICAgICAgICAgIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZtdHA6MTA4IHByb2ZpbGUtbGV2ZWwtaWQ9MjQ7b2JqZWN0PTIzO2JpdHJhdGU9NjQwMDBcbiAgICAgIC8vIGE9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXG4gICAgICBwdXNoOiAnZm10cCcsXG4gICAgICByZWc6IC9eZm10cDooXFxkKikgKFtcXFN8IF0qKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29udHJvbDpzdHJlYW1pZD0wXG4gICAgICBuYW1lOiAnY29udHJvbCcsXG4gICAgICByZWc6IC9eY29udHJvbDooLiopLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRyb2w6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICAgIG5hbWU6ICdydGNwJyxcbiAgICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uYWRkcmVzcyAhPSBudWxsKVxuICAgICAgICAgID8gJ3J0Y3A6JWQgJXMgSVAlZCAlcydcbiAgICAgICAgICA6ICdydGNwOiVkJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgICAgcHVzaDogJ3J0Y3BGYlRyckludCcsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3J0Y3AtZmI6JXMgdHJyLWludCAlZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICAgIHB1c2g6ICdydGNwRmInLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3R5cGUnLCAnc3VidHlwZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc3VidHlwZSAhPSBudWxsKVxuICAgICAgICAgID8gJ3J0Y3AtZmI6JXMgJXMgJXMnXG4gICAgICAgICAgOiAncnRjcC1mYjolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAgIC8vIGE9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICAgIHB1c2g6ICdleHQnLFxuICAgICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyg/OiAodXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCkpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAnZXh0bWFwOiVkJyArXG4gICAgICAgICAgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArXG4gICAgICAgICAgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICtcbiAgICAgICAgICAnICVzJyArXG4gICAgICAgICAgKG8uY29uZmlnID8gJyAlcycgOiAnJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZXh0bWFwLWFsbG93LW1peGVkXG4gICAgICBuYW1lOiAnZXh0bWFwQWxsb3dNaXhlZCcsXG4gICAgICByZWc6IC9eKGV4dG1hcC1hbGxvdy1taXhlZCkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgICAgcHVzaDogJ2NyeXB0bycsXG4gICAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5zZXNzaW9uQ29uZmlnICE9IG51bGwpXG4gICAgICAgICAgPyAnY3J5cHRvOiVkICVzICVzICVzJ1xuICAgICAgICAgIDogJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNldHVwOmFjdHBhc3NcbiAgICAgIG5hbWU6ICdzZXR1cCcsXG4gICAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcbiAgICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb25uZWN0aW9uOm5ld1xuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25UeXBlJyxcbiAgICAgIHJlZzogL15jb25uZWN0aW9uOihuZXd8ZXhpc3RpbmcpLyxcbiAgICAgIGZvcm1hdDogJ2Nvbm5lY3Rpb246JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1pZDoxXG4gICAgICBuYW1lOiAnbWlkJyxcbiAgICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ21pZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgICBuYW1lOiAnbXNpZCcsXG4gICAgICByZWc6IC9ebXNpZDooLiopLyxcbiAgICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXB0aW1lOjIwXG4gICAgICBuYW1lOiAncHRpbWUnLFxuICAgICAgcmVnOiAvXnB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdwdGltZTolZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXG4gICAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zZW5kcmVjdlxuICAgICAgbmFtZTogJ2RpcmVjdGlvbicsXG4gICAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLWxpdGVcbiAgICAgIG5hbWU6ICdpY2VsaXRlJyxcbiAgICAgIHJlZzogL14oaWNlLWxpdGUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtdWZyYWc6RjdnSVxuICAgICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLXB3ZDp4OWNtbC9ZemljaFYyK1hsaGlNdThnXG4gICAgICBuYW1lOiAnaWNlUHdkJyxcbiAgICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtcHdkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1maW5nZXJwcmludDpTSEEtMSAwMDoxMToyMjozMzo0NDo1NTo2Njo3Nzo4ODo5OTpBQTpCQjpDQzpERDpFRTpGRjowMDoxMToyMjozM1xuICAgICAgbmFtZTogJ2ZpbmdlcnByaW50JyxcbiAgICAgIHJlZzogL15maW5nZXJwcmludDooXFxTKikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnaGFzaCddLFxuICAgICAgZm9ybWF0OiAnZmluZ2VycHJpbnQ6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgcHVzaDonY2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXG4gICAgICBuYW1lczogWydmb3VuZGF0aW9uJywgJ2NvbXBvbmVudCcsICd0cmFuc3BvcnQnLCAncHJpb3JpdHknLCAnaXAnLCAncG9ydCcsICd0eXBlJywgJ3JhZGRyJywgJ3Jwb3J0JywgJ3RjcHR5cGUnLCAnZ2VuZXJhdGlvbicsICduZXR3b3JrLWlkJywgJ25ldHdvcmstY29zdCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xuXG4gICAgICAgIHN0ciArPSAoby5yYWRkciAhPSBudWxsKSA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAgIC8vIE5COiBjYW5kaWRhdGUgaGFzIHRocmVlIG9wdGlvbmFsIGNodW5rcywgc28gJXZvaWQgbWlkZGxlcyBvbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIHN0ciArPSAoby50Y3B0eXBlICE9IG51bGwpID8gJyB0Y3B0eXBlICVzJyA6ICcldic7XG5cbiAgICAgICAgaWYgKG8uZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gKG9bJ25ldHdvcmstaWQnXSAhPSBudWxsKSA/ICcgbmV0d29yay1pZCAlZCcgOiAnJXYnO1xuICAgICAgICBzdHIgKz0gKG9bJ25ldHdvcmstY29zdCddICE9IG51bGwpID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL14oZW5kLW9mLWNhbmRpZGF0ZXMpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1yZW1vdGUtY2FuZGlkYXRlczoxIDIwMy4wLjExMy4xIDU0NDAwIDIgMjAzLjAuMTEzLjEgNTQ0MDEgLi4uXG4gICAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdyZW1vdGUtY2FuZGlkYXRlczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLW9wdGlvbnM6Z29vZ2xlLWljZVxuICAgICAgbmFtZTogJ2ljZU9wdGlvbnMnLFxuICAgICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2Utb3B0aW9uczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c3NyYzoyNTY2MTA3NTY5IGNuYW1lOnQ5WVU4TTFVeFRGOFkxQTFcbiAgICAgIHB1c2g6ICdzc3JjcycsXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnYXR0cmlidXRlJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICAgIGlmIChvLmF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOiVzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMgMSAyXG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgICAgcHVzaDogJ3NzcmNHcm91cHMnLFxuICAgICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcbiAgICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpY3MnLCAnc3NyY3MnXSxcbiAgICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1zaWQtc2VtYW50aWM6IFdNUyBKdmxhbTVYM1NYMU9QNnBuMjB6V29ndmFLSno1SGpmOU9ubFZcbiAgICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgICAgcmVnOiAvXm1zaWQtc2VtYW50aWM6XFxzPyhcXHcqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWMnLCAndG9rZW4nXSxcbiAgICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgICBwdXNoOiAnZ3JvdXBzJyxcbiAgICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICAgIGZvcm1hdDogJ2dyb3VwOiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLW11eFxuICAgICAgbmFtZTogJ3J0Y3BNdXgnLFxuICAgICAgcmVnOiAvXihydGNwLW11eCkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtcnNpemVcbiAgICAgIG5hbWU6ICdydGNwUnNpemUnLFxuICAgICAgcmVnOiAvXihydGNwLXJzaXplKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XG4gICAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgICByZWc6IC9ec2N0cG1hcDooW1xcd18vXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbClcbiAgICAgICAgICA/ICdzY3RwbWFwOiVzICVzICVzJ1xuICAgICAgICAgIDogJ3NjdHBtYXA6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2VcbiAgICAgIG5hbWU6ICd4R29vZ2xlRmxhZycsXG4gICAgICByZWc6IC9eeC1nb29nbGUtZmxhZzooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAneC1nb29nbGUtZmxhZzolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cmlkOjEgc2VuZCBtYXgtd2lkdGg9MTI4MDttYXgtaGVpZ2h0PTcyMDttYXgtZnBzPTMwO2RlcGVuZD0wXG4gICAgICBwdXNoOiAncmlkcycsXG4gICAgICByZWc6IC9ecmlkOihbXFxkXFx3XSspIChcXHcrKSg/OiAoW1xcU3wgXSopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnZGlyZWN0aW9uJywgJ3BhcmFtcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ucGFyYW1zKSA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgLy8gYT1pbWFnZWF0dHI6KiBzZW5kIFt4PTgwMCx5PTY0MF0gcmVjdiAqXG4gICAgICAvLyBhPWltYWdlYXR0cjoxMDAgcmVjdiBbeD0zMjAseT0yNDBdXG4gICAgICBwdXNoOiAnaW1hZ2VhdHRycycsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3XG4gICAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgICAgIC8vIHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF1cbiAgICAgICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgICAnKD86W1xcXFxzXFxcXHRdKyhyZWN2fHNlbmQpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKikpPydcbiAgICAgICksXG4gICAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ2ltYWdlYXR0cjolcyAlcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgICAgLy8gYT1zaW11bGNhc3Q6cmVjdiAxOzQsNSBzZW5kIDY7N1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdCcsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGE9c2ltdWxjYXN0OlxuICAgICAgICAnXnNpbXVsY2FzdDonICtcbiAgICAgICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcbiAgICAgICAgLy8gc3BhY2UgKyByZWN2IDY7fjcsfjhcbiAgICAgICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAgICAgLy8gZW5kXG4gICAgICAgICckJ1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBvbGQgc2ltdWxjYXN0IGRyYWZ0IDAzIChpbXBsZW1lbnRlZCBieSBGaXJlZm94KVxuICAgICAgLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2RwLXNpbXVsY2FzdC0wM1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHNlbmQgcmlkPTU7Njs3IHBhdXNlZD02LDdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3RfMDMnLFxuICAgICAgcmVnOiAvXnNpbXVsY2FzdDpbXFxzXFx0XSsoW1xcUytcXHNcXHRdKykkLyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdzaW11bGNhc3Q6ICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mcmFtZXJhdGU6MjVcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI5Ljk3XG4gICAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICAgIHJlZzogL15mcmFtZXJhdGU6KFxcZCsoPzokfFxcLlxcZCspKS8sXG4gICAgICBmb3JtYXQ6ICdmcmFtZXJhdGU6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM0NTcwXG4gICAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgICBuYW1lOiAnc291cmNlRmlsdGVyJyxcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgICBmb3JtYXQ6ICdzb3VyY2UtZmlsdGVyOiAlcyAlcyAlcyAlcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9YnVuZGxlLW9ubHlcbiAgICAgIG5hbWU6ICdidW5kbGVPbmx5JyxcbiAgICAgIHJlZzogL14oYnVuZGxlLW9ubHkpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1sYWJlbDoxXG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgcmVnOiAvXmxhYmVsOiguKykvLFxuICAgICAgZm9ybWF0OiAnbGFiZWw6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTVcbiAgICAgIG5hbWU6ICdzY3RwUG9ydCcsXG4gICAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnc2N0cC1wb3J0OiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi02XG4gICAgICBuYW1lOiAnbWF4TWVzc2FnZVNpemUnLFxuICAgICAgcmVnOiAvXm1heC1tZXNzYWdlLXNpemU6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdtYXgtbWVzc2FnZS1zaXplOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcbiAgICAgIHB1c2g6J3RzUmVmQ2xvY2tzJyxcbiAgICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgICBuYW1lczogWydjbGtzcmMnLCAnY2xrc3JjRXh0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPW1lZGlhY2xrOmRpcmVjdD05NjMyMTQ0MjRcbiAgICAgIG5hbWU6J21lZGlhQ2xrJyxcbiAgICAgIHJlZzogL15tZWRpYWNsazooPzppZD0oXFxTKikpPyAqKFteXFxzPV0qKSg/Oj0oXFxTKikpPyg/OiAqcmF0ZT0oXFxkKylcXC8oXFxkKykpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdtZWRpYWNsazonO1xuICAgICAgICBzdHIgKz0gKG8uaWQgIT0gbnVsbCA/ICdpZD0lcyAlcycgOiAnJXYlcycpO1xuICAgICAgICBzdHIgKz0gKG8ubWVkaWFDbG9ja1ZhbHVlICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcbiAgICAgICAgc3RyICs9IChvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJyk7XG4gICAgICAgIHN0ciArPSAoby5yYXRlRGVub21pbmF0b3IgIT0gbnVsbCA/ICcvJXMnIDogJycpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1rZXl3ZHM6a2V5d29yZHNcbiAgICAgIG5hbWU6ICdrZXl3b3JkcycsXG4gICAgICByZWc6IC9ea2V5d2RzOiguKykkLyxcbiAgICAgIGZvcm1hdDogJ2tleXdkczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29udGVudDptYWluXG4gICAgICBuYW1lOiAnY29udGVudCcsXG4gICAgICByZWc6IC9eY29udGVudDooLispLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXG4gICAgfSxcbiAgICAvLyBCRkNQIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NTgzXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmN0cmw6Yy1zXG4gICAgICBuYW1lOiAnYmZjcEZsb29yQ3RybCcsXG4gICAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxuICAgICAgZm9ybWF0OiAnZmxvb3JjdHJsOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb25maWQ6MVxuICAgICAgbmFtZTogJ2JmY3BDb25mSWQnLFxuICAgICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAnY29uZmlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT11c2VyaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BVc2VySWQnLFxuICAgICAgcmVnOiAvXnVzZXJpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAndXNlcmlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JJZCcsXG4gICAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21TdHJlYW0nXSxcbiAgICAgIGZvcm1hdDogJ2Zsb29yaWQ6JXMgbXN0cm06JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXVxuICAgIH1cbiAgXVxufTtcblxuLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXG5PYmplY3Qua2V5cyhncmFtbWFyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG9ianMgPSBncmFtbWFyW2tleV07XG4gIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICBvYmoucmVnID0gLyguKikvO1xuICAgIH1cbiAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xuICAgIH1cbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/grammar.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var parser = __webpack_require__(/*! ./parser */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNC4xL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsaUhBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGlIQUFVOztBQUUvQixhQUFhO0FBQ2IsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQix1QkFBdUIsMkJBQTJCO0FBQ2xELHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2RwLXRyYW5zZm9ybUAyLjE0LjEvbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzP2NjMmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG52YXIgd3JpdGVyID0gcmVxdWlyZSgnLi93cml0ZXInKTtcblxuZXhwb3J0cy53cml0ZSA9IHdyaXRlcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZXIucGFyc2U7XG5leHBvcnRzLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/parser.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/parser.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNC4xL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsbUhBQVc7QUFDakM7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLHdDQUF3QztBQUN4Qzs7QUFFQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QixxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLDhFQUE4RTtBQUM5RSxHQUFHO0FBQ0g7O0FBRUEsZ0NBQWdDO0FBQ2hDLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2RwLXRyYW5zZm9ybUAyLjE0LjEvbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3BhcnNlci5qcz83N2QyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbn07XG5cbnZhciBhdHRhY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG1hdGNoLCBsb2NhdGlvbiwgbmFtZXMsIHJhd05hbWUpIHtcbiAgaWYgKHJhd05hbWUgJiYgIW5hbWVzKSB7XG4gICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAobWF0Y2hbaSsxXSAhPSBudWxsKSB7XG4gICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFyc2VSZWcgPSBmdW5jdGlvbiAob2JqLCBsb2NhdGlvbiwgY29udGVudCkge1xuICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICBsb2NhdGlvbltvYmoucHVzaF0gPSBbXTtcbiAgfVxuICBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgfVxuICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/XG4gICAge30gOiAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xuXG4gIGlmIChvYmoucHVzaCkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXS5wdXNoKGtleUxvY2F0aW9uKTtcbiAgfVxufTtcblxudmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcbnZhciB2YWxpZExpbmUgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihbYS16XSk9KC4qKS8pO1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICB2YXIgc2Vzc2lvbiA9IHt9XG4gICAgLCBtZWRpYSA9IFtdXG4gICAgLCBsb2NhdGlvbiA9IHNlc3Npb247IC8vIHBvaW50cyBhdCB3aGVyZSBwcm9wZXJ0aWVzIGdvIHVuZGVyIChvbmUgb2YgdGhlIGFib3ZlKVxuXG4gIC8vIHBhcnNlIGxpbmVzIHdlIHVuZGVyc3RhbmRcbiAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgIHZhciB0eXBlID0gbFswXTtcbiAgICB2YXIgY29udGVudCA9IGwuc2xpY2UoMik7XG4gICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgbWVkaWEucHVzaCh7cnRwOiBbXSwgZm10cDogW119KTtcbiAgICAgIGxvY2F0aW9uID0gbWVkaWFbbWVkaWEubGVuZ3RoLTFdOyAvLyBwb2ludCBhdCBsYXRlc3QgbWVkaWEgbGluZVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGdyYW1tYXJbdHlwZV0gfHwgW10pLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICB2YXIgb2JqID0gZ3JhbW1hclt0eXBlXVtqXTtcbiAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVnKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxudmFyIHBhcmFtUmVkdWNlciA9IGZ1bmN0aW9uIChhY2MsIGV4cHIpIHtcbiAgdmFyIHMgPSBleHByLnNwbGl0KC89KC4rKS8sIDIpO1xuICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICBhY2Nbc1swXV0gPSB0b0ludElmSW50KHNbMV0pO1xuICB9IGVsc2UgaWYgKHMubGVuZ3RoID09PSAxICYmIGV4cHIubGVuZ3RoID4gMSkge1xuICAgIGFjY1tzWzBdXSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYWNjO1xufTtcblxuZXhwb3J0cy5wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG59O1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIGFsaWFzIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuMFxuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuXG5leHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIudG9TdHJpbmcoKS5zcGxpdCgnICcpLm1hcChOdW1iZXIpO1xufTtcblxuZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgaXA6IHBhcnRzW2kgKyAxXSxcbiAgICAgIHBvcnQ6IHBhcnRzW2kgKyAyXVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aC0xKS5zcGxpdCgnLCcpLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICB2YXIgc2NpZCwgcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChmb3JtYXRbMF0gIT09ICd+Jykge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0LnN1YnN0cmluZygxLCBmb3JtYXQubGVuZ3RoKSk7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaWQ6IHNjaWQsXG4gICAgICAgIHBhdXNlZDogcGF1c2VkXG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/parser.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/writer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/writer.js ***!
  \******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var grammar = __webpack_require__(/*! ./grammar */ \"(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNC4xL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLG1IQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNC4xL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanM/NTNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xuXG4vLyBjdXN0b21pemVkIHV0aWwuZm9ybWF0IC0gZGlzY2FyZHMgZXhjZXNzIGFyZ3VtZW50cyBhbmQgY2FuIHZvaWQgbWlkZGxlIG9uZXNcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZHYlXS9nO1xudmFyIGZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXRTdHIpIHtcbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICByZXR1cm4gZm9ybWF0U3RyLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgIGlmIChpID49IGxlbikge1xuICAgICAgcmV0dXJuIHg7IC8vIG1pc3NpbmcgYXJndW1lbnRcbiAgICB9XG4gICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgaSArPSAxO1xuICAgIHN3aXRjaCAoeCkge1xuICAgIGNhc2UgJyUlJzpcbiAgICAgIHJldHVybiAnJSc7XG4gICAgY2FzZSAnJXMnOlxuICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xuICAgIGNhc2UgJyVkJzpcbiAgICAgIHJldHVybiBOdW1iZXIoYXJnKTtcbiAgICBjYXNlICcldic6XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9KTtcbiAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxufTtcblxudmFyIG1ha2VMaW5lID0gZnVuY3Rpb24gKHR5cGUsIG9iaiwgbG9jYXRpb24pIHtcbiAgdmFyIHN0ciA9IG9iai5mb3JtYXQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/XG4gICAgKG9iai5mb3JtYXQob2JqLnB1c2ggPyBsb2NhdGlvbiA6IGxvY2F0aW9uW29iai5uYW1lXSkpIDpcbiAgICBvYmouZm9ybWF0O1xuXG4gIHZhciBhcmdzID0gW3R5cGUgKyAnPScgKyBzdHJdO1xuICBpZiAob2JqLm5hbWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBuID0gb2JqLm5hbWVzW2ldO1xuICAgICAgaWYgKG9iai5uYW1lKSB7XG4gICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV1bbl0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIGZvciBtTGluZSBhbmQgcHVzaCBhdHRyaWJ1dGVzXG4gICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdC5hcHBseShudWxsLCBhcmdzKTtcbn07XG5cbi8vIFJGQyBzcGVjaWZpZWQgb3JkZXJcbi8vIFRPRE86IGV4dGVuZCB0aGlzIHdpdGggYWxsIHRoZSByZXN0XG52YXIgZGVmYXVsdE91dGVyT3JkZXIgPSBbXG4gICd2JywgJ28nLCAncycsICdpJyxcbiAgJ3UnLCAnZScsICdwJywgJ2MnLFxuICAnYicsICd0JywgJ3InLCAneicsICdhJ1xuXTtcbnZhciBkZWZhdWx0SW5uZXJPcmRlciA9IFsnaScsICdjJywgJ2InLCAnYSddO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIC8vIGVuc3VyZSBjZXJ0YWluIHByb3BlcnRpZXMgZXhpc3RcbiAgaWYgKHNlc3Npb24udmVyc2lvbiA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi52ZXJzaW9uID0gMDsgLy8gJ3Y9MCcgbXVzdCBiZSB0aGVyZSAob25seSBkZWZpbmVkIHZlcnNpb24gYXRtKVxuICB9XG4gIGlmIChzZXNzaW9uLm5hbWUgPT0gbnVsbCkge1xuICAgIHNlc3Npb24ubmFtZSA9ICcgJzsgLy8gJ3M9ICcgbXVzdCBiZSB0aGVyZSBpZiBubyBtZWFuaW5nZnVsIG5hbWUgc2V0XG4gIH1cbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIGlmIChtTGluZS5wYXlsb2FkcyA9PSBudWxsKSB7XG4gICAgICBtTGluZS5wYXlsb2FkcyA9ICcnO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIG91dGVyT3JkZXIgPSBvcHRzLm91dGVyT3JkZXIgfHwgZGVmYXVsdE91dGVyT3JkZXI7XG4gIHZhciBpbm5lck9yZGVyID0gb3B0cy5pbm5lck9yZGVyIHx8IGRlZmF1bHRJbm5lck9yZGVyO1xuICB2YXIgc2RwID0gW107XG5cbiAgLy8gbG9vcCB0aHJvdWdoIG91dGVyT3JkZXIgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMgb24gc2Vzc2lvblxuICBvdXRlck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKG9iai5uYW1lIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIHNlc3Npb24pKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iai5wdXNoIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICBzZXNzaW9uW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHRoZW4gZm9yIGVhY2ggbWVkaWEgbGluZSwgZm9sbG93IHRoZSBpbm5lck9yZGVyXG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBzZHAucHVzaChtYWtlTGluZSgnbScsIGdyYW1tYXIubVswXSwgbUxpbmUpKTtcblxuICAgIGlubmVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iai5uYW1lIGluIG1MaW5lICYmIG1MaW5lW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBtTGluZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5wdXNoIGluIG1MaW5lICYmIG1MaW5lW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgICAgbUxpbmVbb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gc2RwLmpvaW4oJ1xcclxcbicpICsgJ1xcclxcbic7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/sdp-transform@2.14.1/node_modules/sdp-transform/lib/writer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/ua-parser-js@1.0.37/node_modules/ua-parser-js/src/ua-parser.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/ua-parser-js@1.0.37/node_modules/ua-parser-js/src/ua-parser.js ***!
  \*******************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////\n/* UAParser.js v1.0.37\n   Copyright  2012-2021 Faisal Salman <f@faisalman.com>\n   MIT License *//*\n   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.\n   Supports browser & node.js environment. \n   Demo   : https://faisalman.github.io/ua-parser-js\n   Source : https://github.com/faisalman/ua-parser-js */\n/////////////////////////////////////////////////////////////////////////////////\n\n(function (window, undefined) {\n\n    'use strict';\n\n    //////////////\n    // Constants\n    /////////////\n\n\n    var LIBVERSION  = '1.0.37',\n        EMPTY       = '',\n        UNKNOWN     = '?',\n        FUNC_TYPE   = 'function',\n        UNDEF_TYPE  = 'undefined',\n        OBJ_TYPE    = 'object',\n        STR_TYPE    = 'string',\n        MAJOR       = 'major',\n        MODEL       = 'model',\n        NAME        = 'name',\n        TYPE        = 'type',\n        VENDOR      = 'vendor',\n        VERSION     = 'version',\n        ARCHITECTURE= 'architecture',\n        CONSOLE     = 'console',\n        MOBILE      = 'mobile',\n        TABLET      = 'tablet',\n        SMARTTV     = 'smarttv',\n        WEARABLE    = 'wearable',\n        EMBEDDED    = 'embedded',\n        UA_MAX_LENGTH = 500;\n\n    var AMAZON  = 'Amazon',\n        APPLE   = 'Apple',\n        ASUS    = 'ASUS',\n        BLACKBERRY = 'BlackBerry',\n        BROWSER = 'Browser',\n        CHROME  = 'Chrome',\n        EDGE    = 'Edge',\n        FIREFOX = 'Firefox',\n        GOOGLE  = 'Google',\n        HUAWEI  = 'Huawei',\n        LG      = 'LG',\n        MICROSOFT = 'Microsoft',\n        MOTOROLA  = 'Motorola',\n        OPERA   = 'Opera',\n        SAMSUNG = 'Samsung',\n        SHARP   = 'Sharp',\n        SONY    = 'Sony',\n        XIAOMI  = 'Xiaomi',\n        ZEBRA   = 'Zebra',\n        FACEBOOK    = 'Facebook',\n        CHROMIUM_OS = 'Chromium OS',\n        MAC_OS  = 'Mac OS';\n\n    ///////////\n    // Helper\n    //////////\n\n    var extend = function (regexes, extensions) {\n            var mergedRegexes = {};\n            for (var i in regexes) {\n                if (extensions[i] && extensions[i].length % 2 === 0) {\n                    mergedRegexes[i] = extensions[i].concat(regexes[i]);\n                } else {\n                    mergedRegexes[i] = regexes[i];\n                }\n            }\n            return mergedRegexes;\n        },\n        enumerize = function (arr) {\n            var enums = {};\n            for (var i=0; i<arr.length; i++) {\n                enums[arr[i].toUpperCase()] = arr[i];\n            }\n            return enums;\n        },\n        has = function (str1, str2) {\n            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;\n        },\n        lowerize = function (str) {\n            return str.toLowerCase();\n        },\n        majorize = function (version) {\n            return typeof(version) === STR_TYPE ? version.replace(/[^\\d\\.]/g, EMPTY).split('.')[0] : undefined;\n        },\n        trim = function (str, len) {\n            if (typeof(str) === STR_TYPE) {\n                str = str.replace(/^\\s\\s*/, EMPTY);\n                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);\n            }\n    };\n\n    ///////////////\n    // Map helper\n    //////////////\n\n    var rgxMapper = function (ua, arrays) {\n\n            var i = 0, j, k, p, q, matches, match;\n\n            // loop through all regexes maps\n            while (i < arrays.length && !matches) {\n\n                var regex = arrays[i],       // even sequence (0,2,4,..)\n                    props = arrays[i + 1];   // odd sequence (1,3,5,..)\n                j = k = 0;\n\n                // try matching uastring with regexes\n                while (j < regex.length && !matches) {\n\n                    if (!regex[j]) { break; }\n                    matches = regex[j++].exec(ua);\n\n                    if (!!matches) {\n                        for (p = 0; p < props.length; p++) {\n                            match = matches[++k];\n                            q = props[p];\n                            // check if given property is actually array\n                            if (typeof q === OBJ_TYPE && q.length > 0) {\n                                if (q.length === 2) {\n                                    if (typeof q[1] == FUNC_TYPE) {\n                                        // assign modified match\n                                        this[q[0]] = q[1].call(this, match);\n                                    } else {\n                                        // assign given value, ignore regex match\n                                        this[q[0]] = q[1];\n                                    }\n                                } else if (q.length === 3) {\n                                    // check whether function or regex\n                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                                        // call function (usually string mapper)\n                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;\n                                    } else {\n                                        // sanitize match using given regex\n                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;\n                                    }\n                                } else if (q.length === 4) {\n                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;\n                                }\n                            } else {\n                                this[q] = match ? match : undefined;\n                            }\n                        }\n                    }\n                }\n                i += 2;\n            }\n        },\n\n        strMapper = function (str, map) {\n\n            for (var i in map) {\n                // check if current value is array\n                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n                    for (var j = 0; j < map[i].length; j++) {\n                        if (has(map[i][j], str)) {\n                            return (i === UNKNOWN) ? undefined : i;\n                        }\n                    }\n                } else if (has(map[i], str)) {\n                    return (i === UNKNOWN) ? undefined : i;\n                }\n            }\n            return str;\n    };\n\n    ///////////////\n    // String map\n    //////////////\n\n    // Safari < 3.0\n    var oldSafariMap = {\n            '1.0'   : '/8',\n            '1.2'   : '/1',\n            '1.3'   : '/3',\n            '2.0'   : '/412',\n            '2.0.2' : '/416',\n            '2.0.3' : '/417',\n            '2.0.4' : '/419',\n            '?'     : '/'\n        },\n        windowsVersionMap = {\n            'ME'        : '4.90',\n            'NT 3.11'   : 'NT3.51',\n            'NT 4.0'    : 'NT4.0',\n            '2000'      : 'NT 5.0',\n            'XP'        : ['NT 5.1', 'NT 5.2'],\n            'Vista'     : 'NT 6.0',\n            '7'         : 'NT 6.1',\n            '8'         : 'NT 6.2',\n            '8.1'       : 'NT 6.3',\n            '10'        : ['NT 6.4', 'NT 10.0'],\n            'RT'        : 'ARM'\n    };\n\n    //////////////\n    // Regex map\n    /////////////\n\n    var regexes = {\n\n        browser : [[\n\n            /\\b(?:crmo|crios)\\/([\\w\\.]+)/i                                      // Chrome for Android/iOS\n            ], [VERSION, [NAME, 'Chrome']], [\n            /edg(?:e|ios|a)?\\/([\\w\\.]+)/i                                       // Microsoft Edge\n            ], [VERSION, [NAME, 'Edge']], [\n\n            // Presto based\n            /(opera mini)\\/([-\\w\\.]+)/i,                                        // Opera Mini\n            /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,                 // Opera Mobi/Tablet\n            /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i                           // Opera\n            ], [NAME, VERSION], [\n            /opios[\\/ ]+([\\w\\.]+)/i                                             // Opera mini on iphone >= 8.0\n            ], [VERSION, [NAME, OPERA+' Mini']], [\n            /\\bopr\\/([\\w\\.]+)/i                                                 // Opera Webkit\n            ], [VERSION, [NAME, OPERA]], [\n\n            // Mixed\n            /\\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\\/ ]?([\\w\\.]+)/i            // Baidu\n            ], [VERSION, [NAME, 'Baidu']], [\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i,      // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n            // Trident based\n            /(avant|iemobile|slim)\\s?(?:browser)?[\\/ ]?([\\w\\.]*)/i,             // Avant/IEMobile/SlimBrowser\n            /(?:ms|\\()(ie) ([\\w\\.]+)/i,                                         // Internet Explorer\n\n            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n            /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i,\n                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ\n            /(heytap|ovi)browser\\/([\\d\\.]+)/i,                                  // Heytap/Ovi\n            /(weibo)__([\\d\\.]+)/i                                               // Weibo\n            ], [NAME, VERSION], [\n            /(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i                 // UCBrowser\n            ], [VERSION, [NAME, 'UC'+BROWSER]], [\n            /microm.+\\bqbcore\\/([\\w\\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser\n            /\\bqbcore\\/([\\w\\.]+).+microm/i,\n            /micromessenger\\/([\\w\\.]+)/i                                        // WeChat\n            ], [VERSION, [NAME, 'WeChat']], [\n            /konqueror\\/([\\w\\.]+)/i                                             // Konqueror\n            ], [VERSION, [NAME, 'Konqueror']], [\n            /trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i                       // IE11\n            ], [VERSION, [NAME, 'IE']], [\n            /ya(?:search)?browser\\/([\\w\\.]+)/i                                  // Yandex\n            ], [VERSION, [NAME, 'Yandex']], [\n            /slbrowser\\/([\\w\\.]+)/i                                             // Smart Lenovo Browser\n            ], [VERSION, [NAME, 'Smart Lenovo '+BROWSER]], [\n            /(avast|avg)\\/([\\w\\.]+)/i                                           // Avast/AVG Secure Browser\n            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [\n            /\\bfocus\\/([\\w\\.]+)/i                                               // Firefox Focus\n            ], [VERSION, [NAME, FIREFOX+' Focus']], [\n            /\\bopt\\/([\\w\\.]+)/i                                                 // Opera Touch\n            ], [VERSION, [NAME, OPERA+' Touch']], [\n            /coc_coc\\w+\\/([\\w\\.]+)/i                                            // Coc Coc Browser\n            ], [VERSION, [NAME, 'Coc Coc']], [\n            /dolfin\\/([\\w\\.]+)/i                                                // Dolphin\n            ], [VERSION, [NAME, 'Dolphin']], [\n            /coast\\/([\\w\\.]+)/i                                                 // Opera Coast\n            ], [VERSION, [NAME, OPERA+' Coast']], [\n            /miuibrowser\\/([\\w\\.]+)/i                                           // MIUI Browser\n            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [\n            /fxios\\/([-\\w\\.]+)/i                                                // Firefox for iOS\n            ], [VERSION, [NAME, FIREFOX]], [\n            /\\bqihu|(qi?ho?o?|360)browser/i                                     // 360\n            ], [[NAME, '360 ' + BROWSER]], [\n            /(oculus|sailfish|huawei|vivo)browser\\/([\\w\\.]+)/i\n            ], [[NAME, /(.+)/, '$1 ' + BROWSER], VERSION], [                    // Oculus/Sailfish/HuaweiBrowser/VivoBrowser\n            /samsungbrowser\\/([\\w\\.]+)/i                                        // Samsung Internet\n            ], [VERSION, [NAME, SAMSUNG + ' Internet']], [\n            /(comodo_dragon)\\/([\\w\\.]+)/i                                       // Comodo Dragon\n            ], [[NAME, /_/g, ' '], VERSION], [\n            /metasr[\\/ ]?([\\d\\.]+)/i                                            // Sogou Explorer\n            ], [VERSION, [NAME, 'Sogou Explorer']], [\n            /(sogou)mo\\w+\\/([\\d\\.]+)/i                                          // Sogou Mobile\n            ], [[NAME, 'Sogou Mobile'], VERSION], [\n            /(electron)\\/([\\w\\.]+) safari/i,                                    // Electron-based App\n            /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,                   // Tesla\n            /m?(qqbrowser|2345Explorer)[\\/ ]?([\\w\\.]+)/i                        // QQBrowser/2345 Browser\n            ], [NAME, VERSION], [\n            /(lbbrowser)/i,                                                     // LieBao Browser\n            /\\[(linkedin)app\\]/i                                                // LinkedIn App for iOS & Android\n            ], [NAME], [\n\n            // WebView\n            /((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i       // Facebook App for iOS & Android\n            ], [[NAME, FACEBOOK], VERSION], [\n            /(Klarna)\\/([\\w\\.]+)/i,                                             // Klarna Shopping Browser for iOS & Android\n            /(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i,                             // Kakao App\n            /(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i,                                  // Naver InApp\n            /safari (line)\\/([\\w\\.]+)/i,                                        // Line App for iOS\n            /\\b(line)\\/([\\w\\.]+)\\/iab/i,                                        // Line App for Android\n            /(alipay)client\\/([\\w\\.]+)/i,                                       // Alipay\n            /(chromium|instagram|snapchat)[\\/ ]([-\\w\\.]+)/i                     // Chromium/Instagram/Snapchat\n            ], [NAME, VERSION], [\n            /\\bgsa\\/([\\w\\.]+) .*safari\\//i                                      // Google Search Appliance on iOS\n            ], [VERSION, [NAME, 'GSA']], [\n            /musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i                        // TikTok\n            ], [VERSION, [NAME, 'TikTok']], [\n\n            /headlesschrome(?:\\/([\\w\\.]+)| )/i                                  // Chrome Headless\n            ], [VERSION, [NAME, CHROME+' Headless']], [\n\n            / wv\\).+(chrome)\\/([\\w\\.]+)/i                                       // Chrome WebView\n            ], [[NAME, CHROME+' WebView'], VERSION], [\n\n            /droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i           // Android Browser\n            ], [VERSION, [NAME, 'Android '+BROWSER]], [\n\n            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia\n            ], [NAME, VERSION], [\n\n            /version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i                      // Mobile Safari\n            ], [VERSION, [NAME, 'Mobile Safari']], [\n            /version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i                // Safari & Safari Mobile\n            ], [VERSION, NAME], [\n            /webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i                      // Safari < 3.0\n            ], [NAME, [VERSION, strMapper, oldSafariMap]], [\n\n            /(webkit|khtml)\\/([\\w\\.]+)/i\n            ], [NAME, VERSION], [\n\n            // Gecko based\n            /(navigator|netscape\\d?)\\/([-\\w\\.]+)/i                              // Netscape\n            ], [[NAME, 'Netscape'], VERSION], [\n            /mobile vr; rv:([\\w\\.]+)\\).+firefox/i                               // Firefox Reality\n            ], [VERSION, [NAME, FIREFOX+' Reality']], [\n            /ekiohf.+(flow)\\/([\\w\\.]+)/i,                                       // Flow\n            /(swiftfox)/i,                                                      // Swiftfox\n            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i,\n                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar\n            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,\n                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n            /(firefox)\\/([\\w\\.]+)/i,                                            // Other Firefox-based\n            /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,                         // Mozilla\n\n            // Other\n            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,\n                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser\n            /(links) \\(([\\w\\.]+)/i,                                             // Links\n            /panasonic;(viera)/i                                                // Panasonic Viera\n            ], [NAME, VERSION], [\n            \n            /(cobalt)\\/([\\w\\.]+)/i                                              // Cobalt\n            ], [NAME, [VERSION, /master.|lts./, \"\"]]\n        ],\n\n        cpu : [[\n\n            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i                     // AMD64 (x64)\n            ], [[ARCHITECTURE, 'amd64']], [\n\n            /(ia32(?=;))/i                                                      // IA32 (quicktime)\n            ], [[ARCHITECTURE, lowerize]], [\n\n            /((?:i[346]|x)86)[;\\)]/i                                            // IA32 (x86)\n            ], [[ARCHITECTURE, 'ia32']], [\n\n            /\\b(aarch64|arm(v?8e?l?|_?64))\\b/i                                 // ARM64\n            ], [[ARCHITECTURE, 'arm64']], [\n\n            /\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i                                   // ARMHF\n            ], [[ARCHITECTURE, 'armhf']], [\n\n            // PocketPC mistakenly identified as PowerPC\n            /windows (ce|mobile); ppc;/i\n            ], [[ARCHITECTURE, 'arm']], [\n\n            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i                            // PowerPC\n            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [\n\n            /(sun4\\w)[;\\)]/i                                                    // SPARC\n            ], [[ARCHITECTURE, 'sparc']], [\n\n            /((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i\n                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n            ], [[ARCHITECTURE, lowerize]]\n        ],\n\n        device : [[\n\n            //////////////////////////\n            // MOBILES & TABLETS\n            /////////////////////////\n\n            // Samsung\n            /\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [\n            /\\b((?:s[cgp]h|gt|sm)-\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i,\n            /samsung[- ]([-\\w]+)/i,\n            /sec-(sgh\\w+)/i\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [\n\n            // Apple\n            /(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i                          // iPod/iPhone\n            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [\n            /\\((ipad);[-\\w\\),; ]+apple/i,                                       // iPad\n            /applecoremedia\\/[\\w\\.]+ \\((ipad)/i,\n            /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i\n            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [\n            /(macintosh);/i\n            ], [MODEL, [VENDOR, APPLE]], [\n\n            // Sharp\n            /\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i\n            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [\n\n            // Huawei\n            /\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i\n            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [\n            /(?:huawei|honor)([-\\w ]+)[;\\)]/i,\n            /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i\n            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [\n\n            // Xiaomi\n            /\\b(poco[\\w ]+|m2\\d{3}j\\d\\d[a-z]{2})(?: bui|\\))/i,                  // Xiaomi POCO\n            /\\b; (\\w+) build\\/hm\\1/i,                                           // Xiaomi Hongmi 'numeric' models\n            /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,                             // Xiaomi Hongmi\n            /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,                   // Xiaomi Redmi\n            /oid[^\\)]+; (m?[12][0-389][01]\\w{3,6}[c-y])( bui|; wv|\\))/i,        // Xiaomi Redmi 'numeric' models\n            /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i // Xiaomi Mi\n            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [\n            /oid[^\\)]+; (2\\d{4}(283|rpbf)[cgl])( bui|\\))/i,                     // Redmi Pad\n            /\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i                        // Mi Pad tablets\n            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [\n\n            // OPPO\n            /; (\\w+) bui.+ oppo/i,\n            /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i\n            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [\n\n            // Vivo\n            /vivo (\\w+)(?: bui|\\))/i,\n            /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i\n            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [\n\n            // Realme\n            /\\b(rmx[1-3]\\d{3})(?: bui|;|\\))/i\n            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [\n\n            // Motorola\n            /\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,\n            /\\bmot(?:orola)?[- ](\\w*)/i,\n            /((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [\n            /\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [\n\n            // LG\n            /((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i\n            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [\n            /(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i,\n            /\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i,\n            /\\blg-?([\\d\\w]+) bui/i\n            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [\n\n            // Lenovo\n            /(ideatab[-\\w ]+)/i,\n            /lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i\n            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [\n\n            // Nokia\n            /(?:maemo|nokia).*(n900|lumia \\d+)/i,\n            /nokia[-_ ]?([-\\w\\.]*)/i\n            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [\n\n            // Google\n            /(pixel c)\\b/i                                                      // Google Pixel C\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [\n            /droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i                         // Google Pixel\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [\n\n            // Sony\n            /droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [\n            /sony tablet [ps]/i,\n            /\\b(?:sony)?sgp\\w+(?: bui|\\))/i\n            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [\n\n            // OnePlus\n            / (kb2005|in20[12]5|be20[12][59])\\b/i,\n            /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i\n            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [\n\n            // Amazon\n            /(alexa)webm/i,\n            /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\\))/i,                             // Kindle Fire without Silk / Echo Show\n            /(kf[a-z]+)( bui|\\)).+silk\\//i                                      // Kindle Fire HD\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [\n            /((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i                     // Fire Phone\n            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [\n\n            // BlackBerry\n            /(playbook);[-\\w\\),; ]+(rim)/i                                      // BlackBerry PlayBook\n            ], [MODEL, VENDOR, [TYPE, TABLET]], [\n            /\\b((?:bb[a-f]|st[hv])100-\\d)/i,\n            /\\(bb10; (\\w+)/i                                                    // BlackBerry 10\n            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [\n\n            // Asus\n            /(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i\n            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [\n            / (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i\n            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [\n\n            // HTC\n            /(nexus 9)/i                                                        // HTC Nexus 9\n            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [\n            /(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,                         // HTC\n\n            // ZTE\n            /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,\n            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [\n\n            // Acer\n            /droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i\n            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [\n\n            // Meizu\n            /droid.+; (m[1-5] note) bui/i,\n            /\\bmz-([-\\w]{2,})/i\n            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [\n                \n            // Ulefone\n            /; ((?:power )?armor(?:[\\w ]{0,8}))(?: bui|\\))/i\n            ], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [\n\n            // MIXED\n            /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\\w]*)/i,\n                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron\n            /(hp) ([\\w ]+\\w)/i,                                                 // HP iPAQ\n            /(asus)-?(\\w+)/i,                                                   // Asus\n            /(microsoft); (lumia[\\w ]+)/i,                                      // Microsoft Lumia\n            /(lenovo)[-_ ]?([-\\w]+)/i,                                          // Lenovo\n            /(jolla)/i,                                                         // Jolla\n            /(oppo) ?([\\w ]+) bui/i                                             // OPPO\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /(kobo)\\s(ereader|touch)/i,                                         // Kobo\n            /(archos) (gamepad2?)/i,                                            // Archos\n            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(nook)[\\w ]+build\\/(\\w+)/i,                                        // Nook\n            /(dell) (strea[kpr\\d ]*[\\dko])/i,                                   // Dell Streak\n            /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,                                  // Le Pan Tablets\n            /(trinity)[- ]*(t\\d{3}) bui/i,                                      // Trinity Tablets\n            /(gigaset)[- ]+(q\\w{1,9}) bui/i,                                    // Gigaset Tablets\n            /(vodafone) ([\\w ]+)(?:\\)| bui)/i                                   // Vodafone\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /(surface duo)/i                                                    // Surface Duo\n            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [\n            /droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i                                 // Fairphone\n            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [\n            /(u304aa)/i                                                         // AT&T\n            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [\n            /\\bsie-(\\w*)/i                                                      // Siemens\n            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [\n            /\\b(rct\\w+) b/i                                                     // RCA Tablets\n            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [\n            /\\b(venue[\\d ]{2,7}) b/i                                            // Dell Venue Tablets\n            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [\n            /\\b(q(?:mv|ta)\\w+) b/i                                              // Verizon Tablet\n            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [\n            /\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i                       // Barnes & Noble Tablet\n            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [\n            /\\b(tm\\d{3}\\w+) b/i\n            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [\n            /\\b(k88) b/i                                                        // ZTE K Series Tablet\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [\n            /\\b(nx\\d{3}j) b/i                                                   // ZTE Nubia\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [\n            /\\b(gen\\d{3}) b.+49h/i                                              // Swiss GEN Mobile\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [\n            /\\b(zur\\d{3}) b/i                                                   // Swiss ZUR Tablet\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [\n            /\\b((zeki)?tb.*\\b) b/i                                              // Zeki Tablets\n            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [\n            /\\b([yr]\\d{2}) b/i,\n            /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i                                // Dragon Touch Tablet\n            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [\n            /\\b(ns-?\\w{0,9}) b/i                                                // Insignia Tablets\n            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [\n            /\\b((nxa|next)-?\\w{0,9}) b/i                                        // NextBook Tablets\n            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [\n            /\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones\n            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [\n            /\\b(lvtel\\-)?(v1[12]) b/i                                           // LvTel Phones\n            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [\n            /\\b(ph-1) /i                                                        // Essential PH-1\n            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [\n            /\\b(v(100md|700na|7011|917g).*\\b) b/i                               // Envizen Tablets\n            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [\n            /\\b(trio[-\\w\\. ]+) b/i                                              // MachSpeed Tablets\n            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [\n            /\\btu_(1491) b/i                                                    // Rotor Tablets\n            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [\n            /(shield[\\w ]+) b/i                                                 // Nvidia Shield Tablets\n            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [\n            /(sprint) (\\w+)/i                                                   // Sprint Phones\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n            /(kin\\.[onetw]{3})/i                                                // Microsoft Kin\n            ], [[MODEL, /\\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [\n            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i             // Zebra\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [\n            /droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [\n\n            ///////////////////\n            // SMARTTVS\n            ///////////////////\n\n            /smart-tv.+(samsung)/i                                              // Samsung\n            ], [VENDOR, [TYPE, SMARTTV]], [\n            /hbbtv.+maple;(\\d+)/i\n            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [\n            /(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i        // LG SmartTV\n            ], [[VENDOR, LG], [TYPE, SMARTTV]], [\n            /(apple) ?tv/i                                                      // Apple TV\n            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [\n            /crkey/i                                                            // Google Chromecast\n            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [\n            /droid.+aft(\\w+)( bui|\\))/i                                         // Fire TV\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [\n            /\\(dtv[\\);].+(aquos)/i,\n            /(aquos-tv[\\w ]+)\\)/i                                               // Sharp\n            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[\n            /(bravia[\\w ]+)( bui|\\))/i                                              // Sony\n            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [\n            /(mitv-\\w{5}) bui/i                                                 // Xiaomi\n            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [\n            /Hbbtv.*(technisat) (.*);/i                                         // TechniSAT\n            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [\n            /\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,                          // Roku\n            /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i         // HbbTV devices\n            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [\n            /\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i                   // SmartTV from Unidentified Vendors\n            ], [[TYPE, SMARTTV]], [\n\n            ///////////////////\n            // CONSOLES\n            ///////////////////\n\n            /(ouya)/i,                                                          // Ouya\n            /(nintendo) ([wids3utch]+)/i                                        // Nintendo\n            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n            /droid.+; (shield) bui/i                                            // Nvidia\n            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [\n            /(playstation [345portablevi]+)/i                                   // Playstation\n            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [\n            /\\b(xbox(?: one)?(?!; xbox))[\\); ]/i                                // Microsoft Xbox\n            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [\n\n            ///////////////////\n            // WEARABLES\n            ///////////////////\n\n            /((pebble))app/i                                                    // Pebble\n            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n            /(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i                              // Apple Watch\n            ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [\n            /droid.+; (glass) \\d/i                                              // Google Glass\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [\n            /droid.+; (wt63?0{2,3})\\)/i\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [\n            /(quest( 2| pro)?)/i                                                // Oculus Quest\n            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [\n\n            ///////////////////\n            // EMBEDDED\n            ///////////////////\n\n            /(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i                              // Tesla\n            ], [VENDOR, [TYPE, EMBEDDED]], [\n            /(aeobc)\\b/i                                                        // Echo Dot\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [\n\n            ////////////////////\n            // MIXED (GENERIC)\n            ///////////////////\n\n            /droid .+?; ([^;]+?)(?: bui|; wv\\)|\\) applew).+? mobile safari/i    // Android Phones from Unidentified Vendors\n            ], [MODEL, [TYPE, MOBILE]], [\n            /droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors\n            ], [MODEL, [TYPE, TABLET]], [\n            /\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i                      // Unidentifiable Tablet\n            ], [[TYPE, TABLET]], [\n            /(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile\n            ], [[TYPE, MOBILE]], [\n            /(android[-\\w\\. ]{0,9});.+buil/i                                    // Generic Android Device\n            ], [MODEL, [VENDOR, 'Generic']]\n        ],\n\n        engine : [[\n\n            /windows.+ edge\\/([\\w\\.]+)/i                                       // EdgeHTML\n            ], [VERSION, [NAME, EDGE+'HTML']], [\n\n            /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i                         // Blink\n            ], [VERSION, [NAME, 'Blink']], [\n\n            /(presto)\\/([\\w\\.]+)/i,                                             // Presto\n            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna\n            /ekioh(flow)\\/([\\w\\.]+)/i,                                          // Flow\n            /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,                           // KHTML/Tasman/Links\n            /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i,                                      // iCab\n            /\\b(libweb)/i\n            ], [NAME, VERSION], [\n\n            /rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i                                     // Gecko\n            ], [VERSION, NAME]\n        ],\n\n        os : [[\n\n            // Windows\n            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)\n            ], [NAME, VERSION], [\n            /(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i             // Windows Phone\n            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [\n            /windows nt 6\\.2; (arm)/i,                                        // Windows RT\n            /windows[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i,\n            /(?:win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i\n            ], [[VERSION, strMapper, windowsVersionMap], [NAME, 'Windows']], [\n\n            // iOS/macOS\n            /ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i,              // iOS\n            /(?:ios;fbsv\\/|iphone.+ios[\\/ ])([\\d\\.]+)/i,\n            /cfnetwork\\/.+darwin/i\n            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [\n            /(mac os x) ?([\\w\\. ]*)/i,\n            /(macintosh|mac_powerpc\\b)(?!.+haiku)/i                             // Mac OS\n            ], [[NAME, MAC_OS], [VERSION, /_/g, '.']], [\n\n            // Mobile OSes\n            /droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i                    // Android-x86/HarmonyOS\n            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS\n            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i,\n            /(blackberry)\\w*\\/([\\w\\.]*)/i,                                      // Blackberry\n            /(tizen|kaios)[\\/ ]([\\w\\.]+)/i,                                     // Tizen/KaiOS\n            /\\((series40);/i                                                    // Series 40\n            ], [NAME, VERSION], [\n            /\\(bb(10);/i                                                        // BlackBerry 10\n            ], [VERSION, [NAME, BLACKBERRY]], [\n            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i         // Symbian\n            ], [VERSION, [NAME, 'Symbian']], [\n            /mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i // Firefox OS\n            ], [VERSION, [NAME, FIREFOX+' OS']], [\n            /web0s;.+rt(tv)/i,\n            /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i                              // WebOS\n            ], [VERSION, [NAME, 'webOS']], [\n            /watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i                              // watchOS\n            ], [VERSION, [NAME, 'watchOS']], [\n\n            // Google Chromecast\n            /crkey\\/([\\d\\.]+)/i                                                 // Google Chromecast\n            ], [VERSION, [NAME, CHROME+'cast']], [\n            /(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i                                  // Chromium OS\n            ], [[NAME, CHROMIUM_OS], VERSION],[\n\n            // Smart TVs\n            /panasonic;(viera)/i,                                               // Panasonic Viera\n            /(netrange)mmh/i,                                                   // Netrange\n            /(nettv)\\/(\\d+\\.[\\w\\.]+)/i,                                         // NetTV\n\n            // Console\n            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation\n            /(xbox); +xbox ([^\\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)\n\n            // Other\n            /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,                            // Joli/Palm\n            /(mint)[\\/\\(\\) ]?(\\w*)/i,                                           // Mint\n            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux\n            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,\n                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire\n            /(hurd|linux) ?([\\w\\.]*)/i,                                         // Hurd/Linux\n            /(gnu) ?([\\w\\.]*)/i,                                                // GNU\n            /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly\n            /(haiku) (\\w+)/i                                                    // Haiku\n            ], [NAME, VERSION], [\n            /(sunos) ?([\\w\\.\\d]*)/i                                             // Solaris\n            ], [[NAME, 'Solaris'], VERSION], [\n            /((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,                              // Solaris\n            /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,                                  // AIX\n            /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS\n            /(unix) ?([\\w\\.]*)/i                                                // UNIX\n            ], [NAME, VERSION]\n        ]\n    };\n\n    /////////////////\n    // Constructor\n    ////////////////\n\n    var UAParser = function (ua, extensions) {\n\n        if (typeof ua === OBJ_TYPE) {\n            extensions = ua;\n            ua = undefined;\n        }\n\n        if (!(this instanceof UAParser)) {\n            return new UAParser(ua, extensions).getResult();\n        }\n\n        var _navigator = (typeof window !== UNDEF_TYPE && window.navigator) ? window.navigator : undefined;\n        var _ua = ua || ((_navigator && _navigator.userAgent) ? _navigator.userAgent : EMPTY);\n        var _uach = (_navigator && _navigator.userAgentData) ? _navigator.userAgentData : undefined;\n        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;\n        var _isSelfNav = _navigator && _navigator.userAgent == _ua;\n\n        this.getBrowser = function () {\n            var _browser = {};\n            _browser[NAME] = undefined;\n            _browser[VERSION] = undefined;\n            rgxMapper.call(_browser, _ua, _rgxmap.browser);\n            _browser[MAJOR] = majorize(_browser[VERSION]);\n            // Brave-specific detection\n            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {\n                _browser[NAME] = 'Brave';\n            }\n            return _browser;\n        };\n        this.getCPU = function () {\n            var _cpu = {};\n            _cpu[ARCHITECTURE] = undefined;\n            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);\n            return _cpu;\n        };\n        this.getDevice = function () {\n            var _device = {};\n            _device[VENDOR] = undefined;\n            _device[MODEL] = undefined;\n            _device[TYPE] = undefined;\n            rgxMapper.call(_device, _ua, _rgxmap.device);\n            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {\n                _device[TYPE] = MOBILE;\n            }\n            // iPadOS-specific detection: identified as Mac, but has some iOS-only properties\n            if (_isSelfNav && _device[MODEL] == 'Macintosh' && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {\n                _device[MODEL] = 'iPad';\n                _device[TYPE] = TABLET;\n            }\n            return _device;\n        };\n        this.getEngine = function () {\n            var _engine = {};\n            _engine[NAME] = undefined;\n            _engine[VERSION] = undefined;\n            rgxMapper.call(_engine, _ua, _rgxmap.engine);\n            return _engine;\n        };\n        this.getOS = function () {\n            var _os = {};\n            _os[NAME] = undefined;\n            _os[VERSION] = undefined;\n            rgxMapper.call(_os, _ua, _rgxmap.os);\n            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != 'Unknown') {\n                _os[NAME] = _uach.platform  \n                                    .replace(/chrome os/i, CHROMIUM_OS)\n                                    .replace(/macos/i, MAC_OS);           // backward compatibility\n            }\n            return _os;\n        };\n        this.getResult = function () {\n            return {\n                ua      : this.getUA(),\n                browser : this.getBrowser(),\n                engine  : this.getEngine(),\n                os      : this.getOS(),\n                device  : this.getDevice(),\n                cpu     : this.getCPU()\n            };\n        };\n        this.getUA = function () {\n            return _ua;\n        };\n        this.setUA = function (ua) {\n            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;\n            return this;\n        };\n        this.setUA(_ua);\n        return this;\n    };\n\n    UAParser.VERSION = LIBVERSION;\n    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);\n    UAParser.CPU = enumerize([ARCHITECTURE]);\n    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);\n    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);\n\n    ///////////\n    // Export\n    //////////\n\n    // check js environment\n    if (typeof(exports) !== UNDEF_TYPE) {\n        // nodejs env\n        if (\"object\" !== UNDEF_TYPE && module.exports) {\n            exports = module.exports = UAParser;\n        }\n        exports.UAParser = UAParser;\n    } else {\n        // requirejs env (optional)\n        if (\"function\" === FUNC_TYPE && __webpack_require__.amdO) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n                return UAParser;\n            }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else if (typeof window !== UNDEF_TYPE) {\n            // browser env\n            window.UAParser = UAParser;\n        }\n    }\n\n    // jQuery/Zepto specific (optional)\n    // Note:\n    //   In AMD env the global scope should be kept clean, but jQuery is an exception.\n    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,\n    //   and we should catch that.\n    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);\n    if ($ && !$.ua) {\n        var parser = new UAParser();\n        $.ua = parser.getResult();\n        $.ua.get = function () {\n            return parser.getUA();\n        };\n        $.ua.set = function (ua) {\n            parser.setUA(ua);\n            var result = parser.getResult();\n            for (var prop in result) {\n                $.ua[prop] = result[prop];\n            }\n        };\n    }\n\n})(typeof window === 'object' ? window : this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3VhLXBhcnNlci1qc0AxLjAuMzcvbm9kZV9tb2R1bGVzL3VhLXBhcnNlci1qcy9zcmMvdWEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsR0FBRztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0RBQXNEO0FBQ3REOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQSwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsSUFBSSxXQUFXLElBQUk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxFQUFFO0FBQzFEO0FBQ0Esd0NBQXdDO0FBQ3hDLDRCQUE0QixJQUFJO0FBQ2hDOztBQUVBO0FBQ0EsZ0NBQWdDLEVBQUUsV0FBVyxFQUFFO0FBQy9DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQixJQUFJLGNBQWM7QUFDL0Q7QUFDQTtBQUNBLHdCQUF3QixLQUFLLEVBQUU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZiwwQkFBMEIsRUFBRTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsaUJBQWlCO0FBQzNDOztBQUVBO0FBQ0EsMkJBQTJCLEVBQUUsVUFBVTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDOztBQUVBO0FBQ0EsZ0NBQWdDLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxhQUFhLElBQUk7QUFDeEU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxXQUFXLEVBQUU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWUsSUFBSTtBQUN6Qzs7QUFFQTtBQUNBLGdDQUFnQyxFQUFFLFdBQVcsRUFBRSx5REFBeUQsSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUUsWUFBWSxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxJQUFJOztBQUU3QjtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLElBQUk7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QyxnQ0FBZ0MsRUFBRTtBQUNsQyxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsK0NBQStDLFdBQVcsSUFBSSxJQUFJO0FBQ2xFO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCLFFBQVEsSUFBSTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsSUFBSSxjQUFjO0FBQzFDO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw4QkFBOEIsSUFBSSxFQUFFO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsSUFBSSw2QkFBNkI7QUFDekQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTs7QUFFakM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUksbUNBQW1DLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQWE7QUFDekI7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCLE1BQU07QUFDTjtBQUNBLFlBQVksVUFBYyxrQkFBa0Isd0JBQVU7QUFDdEQsWUFBWSxtQ0FBTztBQUNuQjtBQUNBLGFBQWE7QUFBQSxrR0FBQztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3VhLXBhcnNlci1qc0AxLjAuMzcvbm9kZV9tb2R1bGVzL3VhLXBhcnNlci1qcy9zcmMvdWEtcGFyc2VyLmpzPzAyNTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKiBVQVBhcnNlci5qcyB2MS4wLjM3XG4gICBDb3B5cmlnaHQgwqkgMjAxMi0yMDIxIEZhaXNhbCBTYWxtYW4gPGZAZmFpc2FsbWFuLmNvbT5cbiAgIE1JVCBMaWNlbnNlICovLypcbiAgIERldGVjdCBCcm93c2VyLCBFbmdpbmUsIE9TLCBDUFUsIGFuZCBEZXZpY2UgdHlwZS9tb2RlbCBmcm9tIFVzZXItQWdlbnQgZGF0YS5cbiAgIFN1cHBvcnRzIGJyb3dzZXIgJiBub2RlLmpzIGVudmlyb25tZW50LiBcbiAgIERlbW8gICA6IGh0dHBzOi8vZmFpc2FsbWFuLmdpdGh1Yi5pby91YS1wYXJzZXItanNcbiAgIFNvdXJjZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWlzYWxtYW4vdWEtcGFyc2VyLWpzICovXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uICh3aW5kb3csIHVuZGVmaW5lZCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBDb25zdGFudHNcbiAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciBMSUJWRVJTSU9OICA9ICcxLjAuMzcnLFxuICAgICAgICBFTVBUWSAgICAgICA9ICcnLFxuICAgICAgICBVTktOT1dOICAgICA9ICc/JyxcbiAgICAgICAgRlVOQ19UWVBFICAgPSAnZnVuY3Rpb24nLFxuICAgICAgICBVTkRFRl9UWVBFICA9ICd1bmRlZmluZWQnLFxuICAgICAgICBPQkpfVFlQRSAgICA9ICdvYmplY3QnLFxuICAgICAgICBTVFJfVFlQRSAgICA9ICdzdHJpbmcnLFxuICAgICAgICBNQUpPUiAgICAgICA9ICdtYWpvcicsXG4gICAgICAgIE1PREVMICAgICAgID0gJ21vZGVsJyxcbiAgICAgICAgTkFNRSAgICAgICAgPSAnbmFtZScsXG4gICAgICAgIFRZUEUgICAgICAgID0gJ3R5cGUnLFxuICAgICAgICBWRU5ET1IgICAgICA9ICd2ZW5kb3InLFxuICAgICAgICBWRVJTSU9OICAgICA9ICd2ZXJzaW9uJyxcbiAgICAgICAgQVJDSElURUNUVVJFPSAnYXJjaGl0ZWN0dXJlJyxcbiAgICAgICAgQ09OU09MRSAgICAgPSAnY29uc29sZScsXG4gICAgICAgIE1PQklMRSAgICAgID0gJ21vYmlsZScsXG4gICAgICAgIFRBQkxFVCAgICAgID0gJ3RhYmxldCcsXG4gICAgICAgIFNNQVJUVFYgICAgID0gJ3NtYXJ0dHYnLFxuICAgICAgICBXRUFSQUJMRSAgICA9ICd3ZWFyYWJsZScsXG4gICAgICAgIEVNQkVEREVEICAgID0gJ2VtYmVkZGVkJyxcbiAgICAgICAgVUFfTUFYX0xFTkdUSCA9IDUwMDtcblxuICAgIHZhciBBTUFaT04gID0gJ0FtYXpvbicsXG4gICAgICAgIEFQUExFICAgPSAnQXBwbGUnLFxuICAgICAgICBBU1VTICAgID0gJ0FTVVMnLFxuICAgICAgICBCTEFDS0JFUlJZID0gJ0JsYWNrQmVycnknLFxuICAgICAgICBCUk9XU0VSID0gJ0Jyb3dzZXInLFxuICAgICAgICBDSFJPTUUgID0gJ0Nocm9tZScsXG4gICAgICAgIEVER0UgICAgPSAnRWRnZScsXG4gICAgICAgIEZJUkVGT1ggPSAnRmlyZWZveCcsXG4gICAgICAgIEdPT0dMRSAgPSAnR29vZ2xlJyxcbiAgICAgICAgSFVBV0VJICA9ICdIdWF3ZWknLFxuICAgICAgICBMRyAgICAgID0gJ0xHJyxcbiAgICAgICAgTUlDUk9TT0ZUID0gJ01pY3Jvc29mdCcsXG4gICAgICAgIE1PVE9ST0xBICA9ICdNb3Rvcm9sYScsXG4gICAgICAgIE9QRVJBICAgPSAnT3BlcmEnLFxuICAgICAgICBTQU1TVU5HID0gJ1NhbXN1bmcnLFxuICAgICAgICBTSEFSUCAgID0gJ1NoYXJwJyxcbiAgICAgICAgU09OWSAgICA9ICdTb255JyxcbiAgICAgICAgWElBT01JICA9ICdYaWFvbWknLFxuICAgICAgICBaRUJSQSAgID0gJ1plYnJhJyxcbiAgICAgICAgRkFDRUJPT0sgICAgPSAnRmFjZWJvb2snLFxuICAgICAgICBDSFJPTUlVTV9PUyA9ICdDaHJvbWl1bSBPUycsXG4gICAgICAgIE1BQ19PUyAgPSAnTWFjIE9TJztcblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gSGVscGVyXG4gICAgLy8vLy8vLy8vL1xuXG4gICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChyZWdleGVzLCBleHRlbnNpb25zKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkUmVnZXhlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByZWdleGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbaV0gJiYgZXh0ZW5zaW9uc1tpXS5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlZ2V4ZXNbaV0gPSBleHRlbnNpb25zW2ldLmNvbmNhdChyZWdleGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZWdleGVzW2ldID0gcmVnZXhlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkUmVnZXhlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyaXplID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIGVudW1zID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZW51bXNbYXJyW2ldLnRvVXBwZXJDYXNlKCldID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudW1zO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgPSBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdHIxID09PSBTVFJfVFlQRSA/IGxvd2VyaXplKHN0cjIpLmluZGV4T2YobG93ZXJpemUoc3RyMSkpICE9PSAtMSA6IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JpemUgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCBFTVBUWSkuc3BsaXQoJy4nKVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpbSA9IGZ1bmN0aW9uIChzdHIsIGxlbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihzdHIpID09PSBTVFJfVFlQRSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sIEVNUFRZKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mKGxlbikgPT09IFVOREVGX1RZUEUgPyBzdHIgOiBzdHIuc3Vic3RyaW5nKDAsIFVBX01BWF9MRU5HVEgpO1xuICAgICAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBNYXAgaGVscGVyXG4gICAgLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciByZ3hNYXBwZXIgPSBmdW5jdGlvbiAodWEsIGFycmF5cykge1xuXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGosIGssIHAsIHEsIG1hdGNoZXMsIG1hdGNoO1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIHJlZ2V4ZXMgbWFwc1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBhcnJheXMubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBhcnJheXNbaV0sICAgICAgIC8vIGV2ZW4gc2VxdWVuY2UgKDAsMiw0LC4uKVxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFycmF5c1tpICsgMV07ICAgLy8gb2RkIHNlcXVlbmNlICgxLDMsNSwuLilcbiAgICAgICAgICAgICAgICBqID0gayA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgbWF0Y2hpbmcgdWFzdHJpbmcgd2l0aCByZWdleGVzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCByZWdleC5sZW5ndGggJiYgIW1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4W2pdKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleFtqKytdLmV4ZWModWEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1srK2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcm9wc1twXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBnaXZlbiBwcm9wZXJ0eSBpcyBhY3R1YWxseSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcSA9PT0gT0JKX1RZUEUgJiYgcS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxWzFdID09IEZVTkNfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBtb2RpZmllZCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBxWzFdLmNhbGwodGhpcywgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gZ2l2ZW4gdmFsdWUsIGlnbm9yZSByZWdleCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBxWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHFbMV0gPT09IEZVTkNfVFlQRSAmJiAhKHFbMV0uZXhlYyAmJiBxWzFdLnRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiAodXN1YWxseSBzdHJpbmcgbWFwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIG1hdGNoIHVzaW5nIGdpdmVuIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbM10uY2FsbCh0aGlzLCBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcV0gPSBtYXRjaCA/IG1hdGNoIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyTWFwcGVyID0gZnVuY3Rpb24gKHN0ciwgbWFwKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgY3VycmVudCB2YWx1ZSBpcyBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW2ldID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhcyhtYXBbaV1bal0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGkgPT09IFVOS05PV04pID8gdW5kZWZpbmVkIDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzKG1hcFtpXSwgc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGkgPT09IFVOS05PV04pID8gdW5kZWZpbmVkIDogaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdHJpbmcgbWFwXG4gICAgLy8vLy8vLy8vLy8vLy9cblxuICAgIC8vIFNhZmFyaSA8IDMuMFxuICAgIHZhciBvbGRTYWZhcmlNYXAgPSB7XG4gICAgICAgICAgICAnMS4wJyAgIDogJy84JyxcbiAgICAgICAgICAgICcxLjInICAgOiAnLzEnLFxuICAgICAgICAgICAgJzEuMycgICA6ICcvMycsXG4gICAgICAgICAgICAnMi4wJyAgIDogJy80MTInLFxuICAgICAgICAgICAgJzIuMC4yJyA6ICcvNDE2JyxcbiAgICAgICAgICAgICcyLjAuMycgOiAnLzQxNycsXG4gICAgICAgICAgICAnMi4wLjQnIDogJy80MTknLFxuICAgICAgICAgICAgJz8nICAgICA6ICcvJ1xuICAgICAgICB9LFxuICAgICAgICB3aW5kb3dzVmVyc2lvbk1hcCA9IHtcbiAgICAgICAgICAgICdNRScgICAgICAgIDogJzQuOTAnLFxuICAgICAgICAgICAgJ05UIDMuMTEnICAgOiAnTlQzLjUxJyxcbiAgICAgICAgICAgICdOVCA0LjAnICAgIDogJ05UNC4wJyxcbiAgICAgICAgICAgICcyMDAwJyAgICAgIDogJ05UIDUuMCcsXG4gICAgICAgICAgICAnWFAnICAgICAgICA6IFsnTlQgNS4xJywgJ05UIDUuMiddLFxuICAgICAgICAgICAgJ1Zpc3RhJyAgICAgOiAnTlQgNi4wJyxcbiAgICAgICAgICAgICc3JyAgICAgICAgIDogJ05UIDYuMScsXG4gICAgICAgICAgICAnOCcgICAgICAgICA6ICdOVCA2LjInLFxuICAgICAgICAgICAgJzguMScgICAgICAgOiAnTlQgNi4zJyxcbiAgICAgICAgICAgICcxMCcgICAgICAgIDogWydOVCA2LjQnLCAnTlQgMTAuMCddLFxuICAgICAgICAgICAgJ1JUJyAgICAgICAgOiAnQVJNJ1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIFJlZ2V4IG1hcFxuICAgIC8vLy8vLy8vLy8vLy9cblxuICAgIHZhciByZWdleGVzID0ge1xuXG4gICAgICAgIGJyb3dzZXIgOiBbW1xuXG4gICAgICAgICAgICAvXFxiKD86Y3Jtb3xjcmlvcylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQvaU9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdDaHJvbWUnXV0sIFtcbiAgICAgICAgICAgIC9lZGcoPzplfGlvc3xhKT9cXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEVkZ2VcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0VkZ2UnXV0sIFtcblxuICAgICAgICAgICAgLy8gUHJlc3RvIGJhc2VkXG4gICAgICAgICAgICAvKG9wZXJhIG1pbmkpXFwvKFstXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1pbmlcbiAgICAgICAgICAgIC8ob3BlcmEgW21vYmlsZXRhYl17Myw2fSlcXGIuK3ZlcnNpb25cXC8oWy1cXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1vYmkvVGFibGV0XG4gICAgICAgICAgICAvKG9wZXJhKSg/Oi4rdmVyc2lvblxcL3xbXFwvIF0rKShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvb3Bpb3NbXFwvIF0rKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIG1pbmkgb24gaXBob25lID49IDguMFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBPUEVSQSsnIE1pbmknXV0sIFtcbiAgICAgICAgICAgIC9cXGJvcHJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFdlYmtpdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBPUEVSQV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1peGVkXG4gICAgICAgICAgICAvXFxiYlthaV0qZCg/OnVoZHxbdWJdKlthZWtvcHJzd3hdezUsNn0pW1xcLyBdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAvLyBCYWlkdVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQmFpZHUnXV0sIFtcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC8gXT8oW1xcd1xcLl0qKS9pLCAgICAgIC8vIEx1bmFzY2FwZS9NYXh0aG9uL05ldGZyb250L0phc21pbmUvQmxhemVyXG4gICAgICAgICAgICAvLyBUcmlkZW50IGJhc2VkXG4gICAgICAgICAgICAvKGF2YW50fGllbW9iaWxlfHNsaW0pXFxzPyg/OmJyb3dzZXIpP1tcXC8gXT8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAvLyBBdmFudC9JRU1vYmlsZS9TbGltQnJvd3NlclxuICAgICAgICAgICAgLyg/Om1zfFxcKCkoaWUpIChbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlclxuXG4gICAgICAgICAgICAvLyBXZWJraXQvS0hUTUwgYmFzZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb2NrL1JvY2tNZWx0L01pZG9yaS9FcGlwaGFueS9TaWxrL1NreWZpcmUvQm9sdC9Jcm9uL0lyaWRpdW0vUGhhbnRvbUpTL0Jvd3Nlci9RdXBaaWxsYS9GYWxrb25cbiAgICAgICAgICAgIC8oZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxib2x0fGlyb258dml2YWxkaXxpcmlkaXVtfHBoYW50b21qc3xib3dzZXJ8cXVhcmt8cXVwemlsbGF8ZmFsa29ufHJla29ucXxwdWZmaW58YnJhdmV8d2hhbGUoPyEuK25hdmVyKXxxcWJyb3dzZXJsaXRlfHFxfGR1Y2tkdWNrZ28pXFwvKFstXFx3XFwuXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJla29ucS9QdWZmaW4vQnJhdmUvV2hhbGUvUVFCcm93c2VyTGl0ZS9RUSwgYWthIFNob3VRXG4gICAgICAgICAgICAvKGhleXRhcHxvdmkpYnJvd3NlclxcLyhbXFxkXFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhleXRhcC9PdmlcbiAgICAgICAgICAgIC8od2VpYm8pX18oW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWlib1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKD86XFxidWM/ID9icm93c2VyfCg/Omp1Yy4rKXVjd2ViKVtcXC8gXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAvLyBVQ0Jyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1VDJytCUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC9taWNyb20uK1xcYnFiY29yZVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdCBEZXNrdG9wIGZvciBXaW5kb3dzIEJ1aWx0LWluIEJyb3dzZXJcbiAgICAgICAgICAgIC9cXGJxYmNvcmVcXC8oW1xcd1xcLl0rKS4rbWljcm9tL2ksXG4gICAgICAgICAgICAvbWljcm9tZXNzZW5nZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnV2VDaGF0J11dLCBbXG4gICAgICAgICAgICAva29ucXVlcm9yXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtvbnF1ZXJvclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnS29ucXVlcm9yJ11dLCBbXG4gICAgICAgICAgICAvdHJpZGVudC4rcnZbOiBdKFtcXHdcXC5dezEsOX0pXFxiLitsaWtlIGdlY2tvL2kgICAgICAgICAgICAgICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0lFJ11dLCBbXG4gICAgICAgICAgICAveWEoPzpzZWFyY2gpP2Jyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlhbmRleFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnWWFuZGV4J11dLCBbXG4gICAgICAgICAgICAvc2xicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNtYXJ0IExlbm92byBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdTbWFydCBMZW5vdm8gJytCUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC8oYXZhc3R8YXZnKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhc3QvQVZHIFNlY3VyZSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxIFNlY3VyZSAnK0JST1dTRVJdLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL1xcYmZvY3VzXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBGb2N1c1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YKycgRm9jdXMnXV0sIFtcbiAgICAgICAgICAgIC9cXGJvcHRcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFRvdWNoXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgVG91Y2gnXV0sIFtcbiAgICAgICAgICAgIC9jb2NfY29jXFx3K1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvYyBDb2MgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQ29jIENvYyddXSwgW1xuICAgICAgICAgICAgL2RvbGZpblxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2xwaGluXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdEb2xwaGluJ11dLCBbXG4gICAgICAgICAgICAvY29hc3RcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIENvYXN0XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgQ29hc3QnXV0sIFtcbiAgICAgICAgICAgIC9taXVpYnJvd3NlclxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNSVVJICcrQlJPV1NFUl1dLCBbXG4gICAgICAgICAgICAvZnhpb3NcXC8oWy1cXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZm9yIGlPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YXV0sIFtcbiAgICAgICAgICAgIC9cXGJxaWh1fChxaT9obz9vP3wzNjApYnJvd3Nlci9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDM2MFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnMzYwICcgKyBCUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC8ob2N1bHVzfHNhaWxmaXNofGh1YXdlaXx2aXZvKWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxICcgKyBCUk9XU0VSXSwgVkVSU0lPTl0sIFsgICAgICAgICAgICAgICAgICAgIC8vIE9jdWx1cy9TYWlsZmlzaC9IdWF3ZWlCcm93c2VyL1Zpdm9Ccm93c2VyXG4gICAgICAgICAgICAvc2Ftc3VuZ2Jyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgSW50ZXJuZXRcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgU0FNU1VORyArICcgSW50ZXJuZXQnXV0sIFtcbiAgICAgICAgICAgIC8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tb2RvIERyYWdvblxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL21ldGFzcltcXC8gXT8oW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2dvdSBFeHBsb3JlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnU29nb3UgRXhwbG9yZXInXV0sIFtcbiAgICAgICAgICAgIC8oc29nb3UpbW9cXHcrXFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvZ291IE1vYmlsZVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnU29nb3UgTW9iaWxlJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKGVsZWN0cm9uKVxcLyhbXFx3XFwuXSspIHNhZmFyaS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZWN0cm9uLWJhc2VkIEFwcFxuICAgICAgICAgICAgLyh0ZXNsYSkoPzogcXRjYXJicm93c2VyfFxcLygyMFxcZFxcZFxcLlstXFx3XFwuXSspKS9pLCAgICAgICAgICAgICAgICAgICAvLyBUZXNsYVxuICAgICAgICAgICAgL20/KHFxYnJvd3NlcnwyMzQ1RXhwbG9yZXIpW1xcLyBdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAvLyBRUUJyb3dzZXIvMjM0NSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8obGJicm93c2VyKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGllQmFvIEJyb3dzZXJcbiAgICAgICAgICAgIC9cXFsobGlua2VkaW4pYXBwXFxdL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5rZWRJbiBBcHAgZm9yIGlPUyAmIEFuZHJvaWRcbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAvLyBXZWJWaWV3XG4gICAgICAgICAgICAvKCg/OmZiYW5cXC9mYmlvc3xmYl9pYWJcXC9mYjRhKSg/IS4rZmJhdil8O2ZiYXZcXC8oW1xcd1xcLl0rKTspL2kgICAgICAgLy8gRmFjZWJvb2sgQXBwIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICBdLCBbW05BTUUsIEZBQ0VCT09LXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oS2xhcm5hKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2xhcm5hIFNob3BwaW5nIEJyb3dzZXIgZm9yIGlPUyAmIEFuZHJvaWRcbiAgICAgICAgICAgIC8oa2FrYW8oPzp0YWxrfHN0b3J5KSlbXFwvIF0oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2FrYW8gQXBwXG4gICAgICAgICAgICAvKG5hdmVyKVxcKC4qPyhcXGQrXFwuW1xcd1xcLl0rKS4qXFwpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hdmVyIEluQXBwXG4gICAgICAgICAgICAvc2FmYXJpIChsaW5lKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgQXBwIGZvciBpT1NcbiAgICAgICAgICAgIC9cXGIobGluZSlcXC8oW1xcd1xcLl0rKVxcL2lhYi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIEFwcCBmb3IgQW5kcm9pZFxuICAgICAgICAgICAgLyhhbGlwYXkpY2xpZW50XFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGlwYXlcbiAgICAgICAgICAgIC8oY2hyb21pdW18aW5zdGFncmFtfHNuYXBjaGF0KVtcXC8gXShbLVxcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0vSW5zdGFncmFtL1NuYXBjaGF0XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9cXGJnc2FcXC8oW1xcd1xcLl0rKSAuKnNhZmFyaVxcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgU2VhcmNoIEFwcGxpYW5jZSBvbiBpT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0dTQSddXSwgW1xuICAgICAgICAgICAgL211c2ljYWxfbHkoPzouK2FwcF8/dmVyc2lvblxcL3xfKShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaWtUb2tcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1Rpa1RvayddXSwgW1xuXG4gICAgICAgICAgICAvaGVhZGxlc3NjaHJvbWUoPzpcXC8oW1xcd1xcLl0rKXwgKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBIZWFkbGVzc1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBDSFJPTUUrJyBIZWFkbGVzcyddXSwgW1xuXG4gICAgICAgICAgICAvIHd2XFwpLisoY2hyb21lKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgV2ViVmlld1xuICAgICAgICAgICAgXSwgW1tOQU1FLCBDSFJPTUUrJyBXZWJWaWV3J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9kcm9pZC4rIHZlcnNpb25cXC8oW1xcd1xcLl0rKVxcYi4rKD86bW9iaWxlIHNhZmFyaXxzYWZhcmkpL2kgICAgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQW5kcm9pZCAnK0JST1dTRVJdXSwgW1xuXG4gICAgICAgICAgICAvKGNocm9tZXxvbW5pd2VifGFyb3JhfFt0aXplbm9rYV17NX0gP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pICAgICAgIC8vIENocm9tZS9PbW5pV2ViL0Fyb3JhL1RpemVuL05va2lhXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLlxcLF0rKSAuKm1vYmlsZVxcL1xcdysgKHNhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgICAvLyBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNb2JpbGUgU2FmYXJpJ11dLCBbXG4gICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3KFxcLnxcXCwpXSspIC4qKG1vYmlsZSA/c2FmYXJpfHNhZmFyaSkvaSAgICAgICAgICAgICAgICAvLyBTYWZhcmkgJiBTYWZhcmkgTW9iaWxlXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV0sIFtcbiAgICAgICAgICAgIC93ZWJraXQuKz8obW9iaWxlID9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMy4wXG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIHN0ck1hcHBlciwgb2xkU2FmYXJpTWFwXV0sIFtcblxuICAgICAgICAgICAgLyh3ZWJraXR8a2h0bWwpXFwvKFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIEdlY2tvIGJhc2VkXG4gICAgICAgICAgICAvKG5hdmlnYXRvcnxuZXRzY2FwZVxcZD8pXFwvKFstXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRzY2FwZVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnTmV0c2NhcGUnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9tb2JpbGUgdnI7IHJ2OihbXFx3XFwuXSspXFwpLitmaXJlZm94L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBSZWFsaXR5XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEZJUkVGT1grJyBSZWFsaXR5J11dLCBbXG4gICAgICAgICAgICAvZWtpb2hmLisoZmxvdylcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb3dcbiAgICAgICAgICAgIC8oc3dpZnRmb3gpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpZnRmb3hcbiAgICAgICAgICAgIC8oaWNlZHJhZ29ufGljZXdlYXNlbHxjYW1pbm98Y2hpbWVyYXxmZW5uZWN8bWFlbW8gYnJvd3NlcnxtaW5pbW98Y29ua2Vyb3J8a2xhcilbXFwvIF0/KFtcXHdcXC5cXCtdKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWNlRHJhZ29uL0ljZXdlYXNlbC9DYW1pbm8vQ2hpbWVyYS9GZW5uZWMvTWFlbW8vTWluaW1vL0Nvbmtlcm9yL0tsYXJcbiAgICAgICAgICAgIC8oc2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peHxwYWxlbW9vbnxiYXNpbGlza3x3YXRlcmZveClcXC8oWy1cXHdcXC5dKykkL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3gvU2VhTW9ua2V5L0stTWVsZW9uL0ljZUNhdC9JY2VBcGUvRmlyZWJpcmQvUGhvZW5peFxuICAgICAgICAgICAgLyhmaXJlZm94KVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBGaXJlZm94LWJhc2VkXG4gICAgICAgICAgICAvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykgLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vemlsbGFcblxuICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgIC8ocG9sYXJpc3xseW54fGRpbGxvfGljYWJ8ZG9yaXN8YW1heWF8dzNtfG5ldHN1cmZ8c2xlaXBuaXJ8b2JpZ298bW9zYWljfCg/OmdvfGljZXx1cClbXFwuIF0/YnJvd3NlcilbLVxcLyBdP3Y/KFtcXHdcXC5dKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sYXJpcy9MeW54L0RpbGxvL2lDYWIvRG9yaXMvQW1heWEvdzNtL05ldFN1cmYvU2xlaXBuaXIvT2JpZ28vTW9zYWljL0dvL0lDRS9VUC5Ccm93c2VyXG4gICAgICAgICAgICAvKGxpbmtzKSBcXCgoW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmtzXG4gICAgICAgICAgICAvcGFuYXNvbmljOyh2aWVyYSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhbmFzb25pYyBWaWVyYVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8oY29iYWx0KVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29iYWx0XG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIC9tYXN0ZXIufGx0cy4vLCBcIlwiXV1cbiAgICAgICAgXSxcblxuICAgICAgICBjcHUgOiBbW1xuXG4gICAgICAgICAgICAvKD86KGFtZHx4KD86KD86ODZ8NjQpWy1fXSk/fHdvd3x3aW4pNjQpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAvLyBBTUQ2NCAoeDY0KVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhbWQ2NCddXSwgW1xuXG4gICAgICAgICAgICAvKGlhMzIoPz07KSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzIgKHF1aWNrdGltZSlcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCBsb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8oKD86aVszNDZdfHgpODYpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzIgKHg4NilcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnaWEzMiddXSwgW1xuXG4gICAgICAgICAgICAvXFxiKGFhcmNoNjR8YXJtKHY/OGU/bD98Xz82NCkpXFxiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBUk02NFxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhcm02NCddXSwgW1xuXG4gICAgICAgICAgICAvXFxiKGFybSg/OnZbNjddKT9odD9uP1tmbF1wPylcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJNSEZcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtaGYnXV0sIFtcblxuICAgICAgICAgICAgLy8gUG9ja2V0UEMgbWlzdGFrZW5seSBpZGVudGlmaWVkIGFzIFBvd2VyUENcbiAgICAgICAgICAgIC93aW5kb3dzIChjZXxtb2JpbGUpOyBwcGM7L2lcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtJ11dLCBbXG5cbiAgICAgICAgICAgIC8oKD86cHBjfHBvd2VycGMpKD86NjQpPykoPzogbWFjfDt8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvd2VyUENcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAvb3dlci8sIEVNUFRZLCBsb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8oc3VuNFxcdylbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTUEFSQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdzcGFyYyddXSwgW1xuXG4gICAgICAgICAgICAvKCg/OmF2cjMyfGlhNjQoPz07KSl8NjhrKD89XFwpKXxcXGJhcm0oPz12KD86WzEtN118WzUtN10xKWw/fDt8ZWFiaSl8KD89YXRtZWwgKWF2cnwoPzppcml4fG1pcHN8c3BhcmMpKD86NjQpP1xcYnxwYS1yaXNjKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBNjQsIDY4SywgQVJNLzY0LCBBVlIvMzIsIElSSVgvNjQsIE1JUFMvNjQsIFNQQVJDLzY0LCBQQS1SSVNDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgbG93ZXJpemVdXVxuICAgICAgICBdLFxuXG4gICAgICAgIGRldmljZSA6IFtbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBNT0JJTEVTICYgVEFCTEVUU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvLyBTYW1zdW5nXG4gICAgICAgICAgICAvXFxiKHNjaC1pWzg5XTBcXGR8c2h3LW0zODBzfHNtLVtwdHhdXFx3ezIsNH18Z3QtW3BuXVxcZHsyLDR9fHNnaC10OFs1Nl05fG5leHVzIDEwKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNBTVNVTkddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKD86c1tjZ3BdaHxndHxzbSktXFx3K3xzY1tnLV0/W1xcZF0rYT98Z2FsYXh5IG5leHVzKS9pLFxuICAgICAgICAgICAgL3NhbXN1bmdbLSBdKFstXFx3XSspL2ksXG4gICAgICAgICAgICAvc2VjLShzZ2hcXHcrKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNBTVNVTkddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQXBwbGVcbiAgICAgICAgICAgIC8oPzpcXC98XFwoKShpcCg/OmhvbmV8b2QpW1xcdywgXSopKD86XFwvfDspL2kgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlQb2QvaVBob25lXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFQUExFXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFwoKGlwYWQpO1stXFx3XFwpLDsgXSthcHBsZS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlQYWRcbiAgICAgICAgICAgIC9hcHBsZWNvcmVtZWRpYVxcL1tcXHdcXC5dKyBcXCgoaXBhZCkvaSxcbiAgICAgICAgICAgIC9cXGIoaXBhZClcXGRcXGQ/LFxcZFxcZD9bO1xcXV0uK2lvcy9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFQUExFXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKG1hY2ludG9zaCk7L2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVBQTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBTaGFycFxuICAgICAgICAgICAgL1xcYihzaC0/W2FsdHZ6XT9cXGRcXGRbYS1la21dPykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTSEFSUF0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBIdWF3ZWlcbiAgICAgICAgICAgIC9cXGIoKD86YWdbcnNdWzIzXT98YmFoMj98c2h0P3xidHYpLWE/W2x3XVxcZHsyfSlcXGIoPyEuK2RcXC9zKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEhVQVdFSV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyg/Omh1YXdlaXxob25vcikoWy1cXHcgXSspWztcXCldL2ksXG4gICAgICAgICAgICAvXFxiKG5leHVzIDZwfFxcd3syLDR9ZT8tW2F0dV0/W2xuXVtcXGR4XVswMTIzNTljXVthZG5dPylcXGIoPyEuK2RcXC9zKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEhVQVdFSV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBYaWFvbWlcbiAgICAgICAgICAgIC9cXGIocG9jb1tcXHcgXSt8bTJcXGR7M31qXFxkXFxkW2Etel17Mn0pKD86IGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIFBPQ09cbiAgICAgICAgICAgIC9cXGI7IChcXHcrKSBidWlsZFxcL2htXFwxL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgL1xcYihobVstXyBdP25vdGU/W18gXT8oPzpcXGRcXHcpPykgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBYaWFvbWkgSG9uZ21pXG4gICAgICAgICAgICAvXFxiKHJlZG1pW1xcLV8gXT8oPzpub3RlfGspP1tcXHdfIF0rKSg/OiBidWl8XFwpKS9pLCAgICAgICAgICAgICAgICAgICAvLyBYaWFvbWkgUmVkbWlcbiAgICAgICAgICAgIC9vaWRbXlxcKV0rOyAobT9bMTJdWzAtMzg5XVswMV1cXHd7Myw2fVtjLXldKSggYnVpfDsgd3Z8XFwpKS9pLCAgICAgICAgLy8gWGlhb21pIFJlZG1pICdudW1lcmljJyBtb2RlbHNcbiAgICAgICAgICAgIC9cXGIobWlbLV8gXT8oPzphXFxkfG9uZXxvbmVbXyBdcGx1c3xub3RlIGx0ZXxtYXh8Y2MpP1tfIF0/KD86XFxkP1xcdz8pW18gXT8oPzpwbHVzfHNlfGxpdGUpPykoPzogYnVpfFxcKSkvaSAvLyBYaWFvbWkgTWlcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsIFhJQU9NSV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL29pZFteXFwpXSs7ICgyXFxkezR9KDI4M3xycGJmKVtjZ2xdKSggYnVpfFxcKSkvaSwgICAgICAgICAgICAgICAgICAgICAvLyBSZWRtaSBQYWRcbiAgICAgICAgICAgIC9cXGIobWlbLV8gXT8oPzpwYWQpKD86W1xcd18gXSspKSg/OiBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWkgUGFkIHRhYmxldHNcbiAgICAgICAgICAgIF0sW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgWElBT01JXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE9QUE9cbiAgICAgICAgICAgIC87IChcXHcrKSBidWkuKyBvcHBvL2ksXG4gICAgICAgICAgICAvXFxiKGNwaFsxMl1cXGR7M318cCg/OmFmfGNbYWxdfGRcXHd8ZVthcl0pW210XVxcZDB8eDkwMDd8YTEwMW9wKVxcYi9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdPUFBPJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBWaXZvXG4gICAgICAgICAgICAvdml2byAoXFx3KykoPzogYnVpfFxcKSkvaSxcbiAgICAgICAgICAgIC9cXGIodlsxMl1cXGR7M31cXHc/W2F0XSkoPzogYnVpfDspL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1Zpdm8nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIFJlYWxtZVxuICAgICAgICAgICAgL1xcYihybXhbMS0zXVxcZHszfSkoPzogYnVpfDt8XFwpKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSZWFsbWUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1vdG9yb2xhXG4gICAgICAgICAgICAvXFxiKG1pbGVzdG9uZXxkcm9pZCg/OlsyLTR4XXwgKD86YmlvbmljfHgyfHByb3xyYXpyKSk/Oj8oIDRnKT8pXFxiW1xcdyBdK2J1aWxkXFwvL2ksXG4gICAgICAgICAgICAvXFxibW90KD86b3JvbGEpP1stIF0oXFx3KikvaSxcbiAgICAgICAgICAgIC8oKD86bW90b1tcXHdcXChcXCkgXSt8eHRcXGR7Myw0fXxuZXh1cyA2KSg/PSBidWl8XFwpKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBNT1RPUk9MQV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihtejYwXFxkfHhvb21bMiBdezAsMn0pIGJ1aWxkXFwvL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTU9UT1JPTEFdLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLy8gTEdcbiAgICAgICAgICAgIC8oKD89bGcpP1t2bF1rXFwtP1xcZHszfSkgYnVpfCAzXFwuWy1cXHc7IF17MTB9bGc/LShbMDZjdjldezMsNH0pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTEddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8obG0oPzotP2YxMDBbbnZdP3wtW1xcd1xcLl0rKSg/PSBidWl8XFwpKXxuZXh1cyBbNDVdKS9pLFxuICAgICAgICAgICAgL1xcYmxnWy1lO1xcLyBdKygoPyFicm93c2VyfG5ldGNhc3R8YW5kcm9pZCB0dilcXHcrKS9pLFxuICAgICAgICAgICAgL1xcYmxnLT8oW1xcZFxcd10rKSBidWkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBMR10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBMZW5vdm9cbiAgICAgICAgICAgIC8oaWRlYXRhYlstXFx3IF0rKS9pLFxuICAgICAgICAgICAgL2xlbm92byA/KHNbNTZdMDAwWy1cXHddK3x0YWIoPzpbXFx3IF0rKXx5dFstXFxkXFx3XXs2fXx0YlstXFxkXFx3XXs2fSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTGVub3ZvJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvLyBOb2tpYVxuICAgICAgICAgICAgLyg/Om1hZW1vfG5va2lhKS4qKG45MDB8bHVtaWEgXFxkKykvaSxcbiAgICAgICAgICAgIC9ub2tpYVstXyBdPyhbLVxcd1xcLl0qKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXy9nLCAnICddLCBbVkVORE9SLCAnTm9raWEnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEdvb2dsZVxuICAgICAgICAgICAgLyhwaXhlbCBjKVxcYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIFBpeGVsIENcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgR09PR0xFXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKHBpeGVsW1xcZGF4bCBdezAsNn0pKD86IGJ1aXxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIFBpeGVsXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEdPT0dMRV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBTb255XG4gICAgICAgICAgICAvZHJvaWQuKyAoYT9cXGRbMC0yXXsyfXNvfFtjLWddXFxkezR9fHNvWy1nbF1cXHcrfHhxLWFcXHdbNC03XVsxMl0pKD89IGJ1aXxcXCkuK2Nocm9tZVxcLyg/IVsxLTZdezAsMX1cXGRcXC4pKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNPTlldLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9zb255IHRhYmxldCBbcHNdL2ksXG4gICAgICAgICAgICAvXFxiKD86c29ueSk/c2dwXFx3Kyg/OiBidWl8XFwpKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE9uZVBsdXNcbiAgICAgICAgICAgIC8gKGtiMjAwNXxpbjIwWzEyXTV8YmUyMFsxMl1bNTldKVxcYi9pLFxuICAgICAgICAgICAgLyg/Om9uZSk/KD86cGx1cyk/IChhXFxkMFxcZFxcZCkoPzogYnxcXCkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ09uZVBsdXMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEFtYXpvblxuICAgICAgICAgICAgLyhhbGV4YSl3ZWJtL2ksXG4gICAgICAgICAgICAvKGtmW2Etel17Mn13aXxhZW9bYy1yXXsyfSkoIGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSB3aXRob3V0IFNpbGsgLyBFY2hvIFNob3dcbiAgICAgICAgICAgIC8oa2ZbYS16XSspKCBidWl8XFwpKS4rc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSBIRFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oKD86c2R8a2YpWzAzNDloaWpvcnN0dXddKykoIGJ1aXxcXCkpLitzaWxrXFwvL2kgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFBob25lXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvKC4rKS9nLCAnRmlyZSBQaG9uZSAkMSddLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQmxhY2tCZXJyeVxuICAgICAgICAgICAgLyhwbGF5Ym9vayk7Wy1cXHdcXCksOyBdKyhyaW0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgUGxheUJvb2tcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKD86YmJbYS1mXXxzdFtodl0pMTAwLVxcZCkvaSxcbiAgICAgICAgICAgIC9cXChiYjEwOyAoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEJMQUNLQkVSUlldLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQXN1c1xuICAgICAgICAgICAgLyg/OlxcYnxhc3VzXykodHJhbnNmb1twcmltZSBdezQsMTB9IFxcdyt8ZWVlcGN8c2xpZGVyIFxcdyt8bmV4dXMgN3xwYWRmb25lfHAwMFtjal0pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVNVU10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyAoeltiZXNdNlswMjddWzAxMl1ba21dW2xzXXx6ZW5mb25lIFxcZFxcdz8pXFxiL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVNVU10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBIVENcbiAgICAgICAgICAgIC8obmV4dXMgOSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDIE5leHVzIDlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0hUQyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oaHRjKVstO18gXXsxLDJ9KFtcXHcgXSsoPz1cXCl8IGJ1aSl8XFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDXG5cbiAgICAgICAgICAgIC8vIFpURVxuICAgICAgICAgICAgLyh6dGUpWy0gXShbXFx3IF0rPykoPzogYnVpfFxcL3xcXCkpL2ksXG4gICAgICAgICAgICAvKGFsY2F0ZWx8Z2Vla3NwaG9uZXxuZXhpYW58cGFuYXNvbmljKD8hKD86O3xcXC4pKXxzb255KD8hLWJyYSkpWy1fIF0/KFstXFx3XSopL2kgICAgICAgICAvLyBBbGNhdGVsL0dlZWtzUGhvbmUvTmV4aWFuL1BhbmFzb25pYy9Tb255XG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbTU9ERUwsIC9fL2csICcgJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBBY2VyXG4gICAgICAgICAgICAvZHJvaWQuKzsgKFthYl1bMS03XS0/WzAxNzhhXVxcZFxcZD8pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FjZXInXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1laXp1XG4gICAgICAgICAgICAvZHJvaWQuKzsgKG1bMS01XSBub3RlKSBidWkvaSxcbiAgICAgICAgICAgIC9cXGJtei0oWy1cXHddezIsfSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWVpenUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVbGVmb25lXG4gICAgICAgICAgICAvOyAoKD86cG93ZXIgKT9hcm1vcig/OltcXHcgXXswLDh9KSkoPzogYnVpfFxcKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVWxlZm9uZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gTUlYRURcbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeXxiZW5xfHBhbG0oPz1cXC0pfHNvbnllcmljc3NvbnxhY2VyfGFzdXN8ZGVsbHxtZWl6dXxtb3Rvcm9sYXxwb2x5dHJvbnxpbmZpbml4fHRlY25vKVstXyBdPyhbLVxcd10qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5L0JlblEvUGFsbS9Tb255LUVyaWNzc29uL0FjZXIvQXN1cy9EZWxsL01laXp1L01vdG9yb2xhL1BvbHl0cm9uXG4gICAgICAgICAgICAvKGhwKSAoW1xcdyBdK1xcdykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgaVBBUVxuICAgICAgICAgICAgLyhhc3VzKS0/KFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXN1c1xuICAgICAgICAgICAgLyhtaWNyb3NvZnQpOyAobHVtaWFbXFx3IF0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEx1bWlhXG4gICAgICAgICAgICAvKGxlbm92bylbLV8gXT8oWy1cXHddKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5vdm9cbiAgICAgICAgICAgIC8oam9sbGEpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9sbGFcbiAgICAgICAgICAgIC8ob3BwbykgPyhbXFx3IF0rKSBidWkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9QUE9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhrb2JvKVxccyhlcmVhZGVyfHRvdWNoKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS29ib1xuICAgICAgICAgICAgLyhhcmNob3MpIChnYW1lcGFkMj8pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcmNob3NcbiAgICAgICAgICAgIC8oaHApLisodG91Y2hwYWQoPyEuK3RhYmxldCl8dGFibGV0KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgVG91Y2hQYWRcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvKG5vb2spW1xcdyBdK2J1aWxkXFwvKFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vb2tcbiAgICAgICAgICAgIC8oZGVsbCkgKHN0cmVhW2twclxcZCBdKltcXGRrb10pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxsIFN0cmVha1xuICAgICAgICAgICAgLyhsZVstIF0rcGFuKVstIF0rKFxcd3sxLDl9KSBidWkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGUgUGFuIFRhYmxldHNcbiAgICAgICAgICAgIC8odHJpbml0eSlbLSBdKih0XFxkezN9KSBidWkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaW5pdHkgVGFibGV0c1xuICAgICAgICAgICAgLyhnaWdhc2V0KVstIF0rKHFcXHd7MSw5fSkgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2lnYXNldCBUYWJsZXRzXG4gICAgICAgICAgICAvKHZvZGFmb25lKSAoW1xcdyBdKykoPzpcXCl8IGJ1aSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVm9kYWZvbmVcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhzdXJmYWNlIGR1bykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXJmYWNlIER1b1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBNSUNST1NPRlRdLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZCBbXFxkXFwuXSs7IChmcFxcZHU/KSg/OiBifFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhaXJwaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRmFpcnBob25lJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyh1MzA0YWEpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBVCZUXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBVCZUJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYnNpZS0oXFx3KikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpZW1lbnNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NpZW1lbnMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHJjdFxcdyspIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkNBIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JDQSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIodmVudWVbXFxkIF17Miw3fSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxsIFZlbnVlIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0RlbGwnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKHEoPzptdnx0YSlcXHcrKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaXpvbiBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1Zlcml6b24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKD86YmFybmVzWyYgXStub2JsZSB8Ym5bcnRdKShbXFx3XFwrIF0qKSBiL2kgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhcm5lcyAmIE5vYmxlIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQmFybmVzICYgTm9ibGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKHRtXFxkezN9XFx3KykgYi9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOdVZpc2lvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoazg4KSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpURSBLIFNlcmllcyBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1pURSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIobnhcXGR7M31qKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgTnViaWFcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1pURSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIoZ2VuXFxkezN9KSBiLis0OWgvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBHRU4gTW9iaWxlXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIoenVyXFxkezN9KSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBaVVIgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKHpla2kpP3RiLipcXGIpIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaZWtpIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1pla2knXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKFt5cl1cXGR7Mn0pIGIvaSxcbiAgICAgICAgICAgIC9cXGIoZHJhZ29uWy0gXSt0b3VjaCB8ZHQpKFxcd3s1fSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEcmFnb24gVG91Y2ggVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0RyYWdvbiBUb3VjaCddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKG5zLT9cXHd7MCw5fSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zaWduaWEgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSW5zaWduaWEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKChueGF8bmV4dCktP1xcd3swLDl9KSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV4dEJvb2sgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTmV4dEJvb2snXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKHh0cmVtZVxcXyk/KHYoMVswNDVdfDJbMDE1XXxbMzQ2OV0wfDdbMDVdKSkgYi9pICAgICAgICAgICAgICAgICAgLy8gVm9pY2UgWHRyZW1lIFBob25lc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdWb2ljZSddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKGx2dGVsXFwtKT8odjFbMTJdKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTHZUZWwgUGhvbmVzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0x2VGVsJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIocGgtMSkgL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbCBQSC0xXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdFc3NlbnRpYWwnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHYoMTAwbWR8NzAwbmF8NzAxMXw5MTdnKS4qXFxiKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW52aXplbiBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdFbnZpemVuJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYih0cmlvWy1cXHdcXC4gXSspIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWNoU3BlZWQgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWFjaFNwZWVkJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYnR1XygxNDkxKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90b3IgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnUm90b3InXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKHNoaWVsZFtcXHcgXSspIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOdmlkaWEgU2hpZWxkIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ052aWRpYSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oc3ByaW50KSAoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwcmludCBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8oa2luXFwuW29uZXR3XXszfSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBLaW5cbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9cXC4vZywgJyAnXSwgW1ZFTkRPUiwgTUlDUk9TT0ZUXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKGNjNjY2Nj98ZXQ1WzE2XXxtY1syMzldWzIzXXg/fHZjOFswM114PylcXCkvaSAgICAgICAgICAgICAvLyBaZWJyYVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBaRUJSQV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7IChlYzMwfHBzMjB8dGNbMi04XVxcZFtreF0pXFwpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgWkVCUkFdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gU01BUlRUVlNcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgL3NtYXJ0LXR2Lisoc2Ftc3VuZykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvaGJidHYuK21hcGxlOyhcXGQrKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXi8sICdTbWFydFRWJ10sIFtWRU5ET1IsIFNBTVNVTkddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvKG51eDsgbmV0Y2FzdC4rc21hcnR0dnxsZyAobmV0Y2FzdFxcLnR2LTIwMVxcZHxhbmRyb2lkIHR2KSkvaSAgICAgICAgLy8gTEcgU21hcnRUVlxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIExHXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgLyhhcHBsZSkgP3R2L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsZSBUVlxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgW01PREVMLCBBUFBMRSsnIFRWJ10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9jcmtleS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIENocm9tZWNhc3RcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIENIUk9NRSsnY2FzdCddLCBbVkVORE9SLCBHT09HTEVdLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuK2FmdChcXHcrKSggYnVpfFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBUVlxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvXFwoZHR2W1xcKTtdLisoYXF1b3MpL2ksXG4gICAgICAgICAgICAvKGFxdW9zLXR2W1xcdyBdKylcXCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhcnBcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU0hBUlBdLCBbVFlQRSwgU01BUlRUVl1dLFtcbiAgICAgICAgICAgIC8oYnJhdmlhW1xcdyBdKykoIGJ1aXxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgLyhtaXR2LVxcd3s1fSkgYnVpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFhJQU9NSV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9IYmJ0di4qKHRlY2huaXNhdCkgKC4qKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVjaG5pU0FUXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgL1xcYihyb2t1KVtcXGR4XSpbXFwpXFwvXSgoPzpkdnAtKT9bXFxkXFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb2t1XG4gICAgICAgICAgICAvaGJidHZcXC9cXGQrXFwuXFxkK1xcLlxcZCsgK1xcKFtcXHdcXCsgXSo7ICooW1xcd1xcZF1bXjtdKik7KFteO10qKS9pICAgICAgICAgLy8gSGJiVFYgZGV2aWNlc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIHRyaW1dLCBbTU9ERUwsIHRyaW1dLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvXFxiKGFuZHJvaWQgdHZ8c21hcnRbLSBdP3R2fG9wZXJhIHR2fHR2OyBydjopXFxiL2kgICAgICAgICAgICAgICAgICAgLy8gU21hcnRUViBmcm9tIFVuaWRlbnRpZmllZCBWZW5kb3JzXG4gICAgICAgICAgICBdLCBbW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBDT05TT0xFU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvKG91eWEpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91eWFcbiAgICAgICAgICAgIC8obmludGVuZG8pIChbd2lkczN1dGNoXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmludGVuZG9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgQ09OU09MRV1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKHNoaWVsZCkgYnVpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE52aWRpYVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnZpZGlhJ10sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC8ocGxheXN0YXRpb24gWzM0NXBvcnRhYmxldmldKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxheXN0YXRpb25cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU09OWV0sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC9cXGIoeGJveCg/OiBvbmUpPyg/ITsgeGJveCkpW1xcKTsgXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgWGJveFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBNSUNST1NPRlRdLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIFdFQVJBQkxFU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvKChwZWJibGUpKWFwcC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlYmJsZVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG4gICAgICAgICAgICAvKHdhdGNoKSg/OiA/b3NbLFxcL118XFxkLFxcZFxcLylbXFxkXFwuXSsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIFdhdGNoXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFQUExFXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoZ2xhc3MpIFxcZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBHbGFzc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBHT09HTEVdLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7ICh3dDYzPzB7MiwzfSlcXCkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBaRUJSQV0sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG4gICAgICAgICAgICAvKHF1ZXN0KCAyfCBwcm8pPykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9jdWx1cyBRdWVzdFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBGQUNFQk9PS10sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIEVNQkVEREVEXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC8odGVzbGEpKD86IHF0Y2FyYnJvd3NlcnxcXC9bLVxcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzbGFcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtUWVBFLCBFTUJFRERFRF1dLCBbXG4gICAgICAgICAgICAvKGFlb2JjKVxcYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFY2hvIERvdFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgRU1CRURERURdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gTUlYRUQgKEdFTkVSSUMpXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC9kcm9pZCAuKz87IChbXjtdKz8pKD86IGJ1aXw7IHd2XFwpfFxcKSBhcHBsZXcpLis/IG1vYmlsZSBzYWZhcmkvaSAgICAvLyBBbmRyb2lkIFBob25lcyBmcm9tIFVuaWRlbnRpZmllZCBWZW5kb3JzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkIC4rPzsgKFteO10rPykoPzogYnVpfFxcKSBhcHBsZXcpLis/KD8hIG1vYmlsZSkgc2FmYXJpL2kgICAgICAgLy8gQW5kcm9pZCBUYWJsZXRzIGZyb20gVW5pZGVudGlmaWVkIFZlbmRvcnNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKCh0YWJsZXR8dGFiKVs7XFwvXXxmb2N1c1xcL1xcZCg/IS4rbW9iaWxlKSkvaSAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlkZW50aWZpYWJsZSBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8ocGhvbmV8bW9iaWxlKD86WztcXC9dfCBbIFxcd1xcL1xcLl0qc2FmYXJpKXxwZGEoPz0uK3dpbmRvd3MgY2UpKS9pICAgIC8vIFVuaWRlbnRpZmlhYmxlIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1tUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhhbmRyb2lkWy1cXHdcXC4gXXswLDl9KTsuK2J1aWwvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgQW5kcm9pZCBEZXZpY2VcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dlbmVyaWMnXV1cbiAgICAgICAgXSxcblxuICAgICAgICBlbmdpbmUgOiBbW1xuXG4gICAgICAgICAgICAvd2luZG93cy4rIGVkZ2VcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZUhUTUxcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgRURHRSsnSFRNTCddXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0XFwvNTM3XFwuMzYuK2Nocm9tZVxcLyg/ITI3KShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxpbmtcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0JsaW5rJ11dLCBbXG5cbiAgICAgICAgICAgIC8ocHJlc3RvKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc3RvXG4gICAgICAgICAgICAvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M218Z29hbm5hKVxcLyhbXFx3XFwuXSspL2ksIC8vIFdlYktpdC9UcmlkZW50L05ldEZyb250L05ldFN1cmYvQW1heWEvTHlueC93M20vR29hbm5hXG4gICAgICAgICAgICAvZWtpb2goZmxvdylcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb3dcbiAgICAgICAgICAgIC8oa2h0bWx8dGFzbWFufGxpbmtzKVtcXC8gXVxcKD8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtIVE1ML1Rhc21hbi9MaW5rc1xuICAgICAgICAgICAgLyhpY2FiKVtcXC8gXShbMjNdXFwuW1xcZFxcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaUNhYlxuICAgICAgICAgICAgL1xcYihsaWJ3ZWIpL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvcnZcXDooW1xcd1xcLl17MSw5fSlcXGIuKyhnZWNrbykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZWNrb1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3MgOiBbW1xuXG4gICAgICAgICAgICAvLyBXaW5kb3dzXG4gICAgICAgICAgICAvbWljcm9zb2Z0ICh3aW5kb3dzKSAodmlzdGF8eHApL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgKGlUdW5lcylcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyh3aW5kb3dzICg/OnBob25lKD86IG9zKT98bW9iaWxlKSlbXFwvIF0/KFtcXGRcXC5cXHcgXSopL2kgICAgICAgICAgICAgLy8gV2luZG93cyBQaG9uZVxuICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBzdHJNYXBwZXIsIHdpbmRvd3NWZXJzaW9uTWFwXV0sIFtcbiAgICAgICAgICAgIC93aW5kb3dzIG50IDZcXC4yOyAoYXJtKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFJUXG4gICAgICAgICAgICAvd2luZG93c1tcXC8gXT8oW250Y2VcXGRcXC4gXStcXHcpKD8hLit4Ym94KS9pLFxuICAgICAgICAgICAgLyg/Ondpbig/PTN8OXxuKXx3aW4gOXggKShbbnRcXGRcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tWRVJTSU9OLCBzdHJNYXBwZXIsIHdpbmRvd3NWZXJzaW9uTWFwXSwgW05BTUUsICdXaW5kb3dzJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIGlPUy9tYWNPU1xuICAgICAgICAgICAgL2lwW2hvbmVhZF17Miw0fVxcYig/Oi4qb3MgKFtcXHddKykgbGlrZSBtYWN8OyBvcGVyYSkvaSwgICAgICAgICAgICAgIC8vIGlPU1xuICAgICAgICAgICAgLyg/OmlvcztmYnN2XFwvfGlwaG9uZS4raW9zW1xcLyBdKShbXFxkXFwuXSspL2ksXG4gICAgICAgICAgICAvY2ZuZXR3b3JrXFwvLitkYXJ3aW4vaVxuICAgICAgICAgICAgXSwgW1tWRVJTSU9OLCAvXy9nLCAnLiddLCBbTkFNRSwgJ2lPUyddXSwgW1xuICAgICAgICAgICAgLyhtYWMgb3MgeCkgPyhbXFx3XFwuIF0qKS9pLFxuICAgICAgICAgICAgLyhtYWNpbnRvc2h8bWFjX3Bvd2VycGNcXGIpKD8hLitoYWlrdSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjIE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsIE1BQ19PU10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuXG4gICAgICAgICAgICAvLyBNb2JpbGUgT1Nlc1xuICAgICAgICAgICAgL2Ryb2lkIChbXFx3XFwuXSspXFxiLisoYW5kcm9pZFstIF14ODZ8aGFybW9ueW9zKS9pICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkLXg4Ni9IYXJtb255T1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgWyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kcm9pZC9XZWJPUy9RTlgvQmFkYS9SSU0vTWFlbW8vTWVlR28vU2FpbGZpc2ggT1NcbiAgICAgICAgICAgIC8oYW5kcm9pZHx3ZWJvc3xxbnh8YmFkYXxyaW0gdGFibGV0IG9zfG1hZW1vfG1lZWdvfHNhaWxmaXNoKVstXFwvIF0/KFtcXHdcXC5dKikvaSxcbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlcXHcqXFwvKFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnlcbiAgICAgICAgICAgIC8odGl6ZW58a2Fpb3MpW1xcLyBdKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGl6ZW4vS2FpT1NcbiAgICAgICAgICAgIC9cXCgoc2VyaWVzNDApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcmllcyA0MFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvXFwoYmIoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEJMQUNLQkVSUlldXSwgW1xuICAgICAgICAgICAgLyg/OnN5bWJpYW4gP29zfHN5bWJvc3xzNjAoPz07KXxzZXJpZXM2MClbLVxcLyBdPyhbXFx3XFwuXSopL2kgICAgICAgICAvLyBTeW1iaWFuXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdTeW1iaWFuJ11dLCBbXG4gICAgICAgICAgICAvbW96aWxsYVxcL1tcXGRcXC5dKyBcXCgoPzptb2JpbGV8dGFibGV0fHR2fG1vYmlsZTsgW1xcdyBdKyk7IHJ2Oi4rIGdlY2tvXFwvKFtcXHdcXC5dKykvaSAvLyBGaXJlZm94IE9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEZJUkVGT1grJyBPUyddXSwgW1xuICAgICAgICAgICAgL3dlYjBzOy4rcnQodHYpL2ksXG4gICAgICAgICAgICAvXFxiKD86aHApP3dvcyg/OmJyb3dzZXIpP1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWJPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnd2ViT1MnXV0sIFtcbiAgICAgICAgICAgIC93YXRjaCg/OiA/b3NbLFxcL118XFxkLFxcZFxcLykoW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2F0Y2hPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnd2F0Y2hPUyddXSwgW1xuXG4gICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgL2Nya2V5XFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBDSFJPTUUrJ2Nhc3QnXV0sIFtcbiAgICAgICAgICAgIC8oY3JvcykgW1xcd10rKD86XFwpfCAoW1xcd1xcLl0rKVxcYikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCBDSFJPTUlVTV9PU10sIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgLy8gU21hcnQgVFZzXG4gICAgICAgICAgICAvcGFuYXNvbmljOyh2aWVyYSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhbmFzb25pYyBWaWVyYVxuICAgICAgICAgICAgLyhuZXRyYW5nZSltbWgvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRyYW5nZVxuICAgICAgICAgICAgLyhuZXR0dilcXC8oXFxkK1xcLltcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldFRWXG5cbiAgICAgICAgICAgIC8vIENvbnNvbGVcbiAgICAgICAgICAgIC8obmludGVuZG98cGxheXN0YXRpb24pIChbd2lkczM0NXBvcnRhYmxldnVjaF0rKS9pLCAgICAgICAgICAgICAgICAgLy8gTmludGVuZG8vUGxheXN0YXRpb25cbiAgICAgICAgICAgIC8oeGJveCk7ICt4Ym94IChbXlxcKTtdKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBYYm94ICgzNjAsIE9uZSwgWCwgUywgU2VyaWVzIFgsIFNlcmllcyBTKVxuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgL1xcYihqb2xpfHBhbG0pXFxiID8oPzpvcyk/XFwvPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvbGkvUGFsbVxuICAgICAgICAgICAgLyhtaW50KVtcXC9cXChcXCkgXT8oXFx3KikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWludFxuICAgICAgICAgICAgLyhtYWdlaWF8dmVjdG9ybGludXgpWzsgXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWdlaWEvVmVjdG9yTGludXhcbiAgICAgICAgICAgIC8oW2t4bG5dP3VidW50dXxkZWJpYW58c3VzZXxvcGVuc3VzZXxnZW50b298YXJjaCg/PSBsaW51eCl8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZCA/aGF0fHplbndhbGt8bGlucHVzfHJhc3BiaWFufHBsYW4gOXxtaW5peHxyaXNjIG9zfGNvbnRpa2l8ZGVlcGlufG1hbmphcm98ZWxlbWVudGFyeSBvc3xzYWJheW9ufGxpbnNwaXJlKSg/OiBnbnVcXC9saW51eCk/KD86IGVudGVycHJpc2UpPyg/OlstIF1saW51eCk/KD86LWdudSk/Wy1cXC8gXT8oPyFjaHJvbXxwYWNrYWdlKShbLVxcd1xcLl0qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVYnVudHUvRGViaWFuL1NVU0UvR2VudG9vL0FyY2gvU2xhY2t3YXJlL0ZlZG9yYS9NYW5kcml2YS9DZW50T1MvUENMaW51eE9TL1JlZEhhdC9aZW53YWxrL0xpbnB1cy9SYXNwYmlhbi9QbGFuOS9NaW5peC9SSVNDT1MvQ29udGlraS9EZWVwaW4vTWFuamFyby9lbGVtZW50YXJ5L1NhYmF5b24vTGluc3BpcmVcbiAgICAgICAgICAgIC8oaHVyZHxsaW51eCkgPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIdXJkL0xpbnV4XG4gICAgICAgICAgICAvKGdudSkgPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR05VXG4gICAgICAgICAgICAvXFxiKFstZnJlbnRvcGNnaHNdezAsNX1ic2R8ZHJhZ29uZmx5KVtcXC8gXT8oPyFhbWR8W2l4MzQ2XXsxLDJ9ODYpKFtcXHdcXC5dKikvaSwgLy8gRnJlZUJTRC9OZXRCU0QvT3BlbkJTRC9QQy1CU0QvR2hvc3RCU0QvRHJhZ29uRmx5XG4gICAgICAgICAgICAvKGhhaWt1KSAoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYWlrdVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHN1bm9zKSA/KFtcXHdcXC5cXGRdKikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1NvbGFyaXMnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oKD86b3Blbik/c29sYXJpcylbLVxcLyBdPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgLyhhaXgpICgoXFxkKSg/PVxcLnxcXCl8IClbXFx3XFwuXSkqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFJWFxuICAgICAgICAgICAgL1xcYihiZW9zfG9zXFwvMnxhbWlnYW9zfG1vcnBob3N8b3BlbnZtc3xmdWNoc2lhfGhwLXV4fHNlcmVuaXR5b3MpL2ksIC8vIEJlT1MvT1MyL0FtaWdhT1MvTW9ycGhPUy9PcGVuVk1TL0Z1Y2hzaWEvSFAtVVgvU2VyZW5pdHlPU1xuICAgICAgICAgICAgLyh1bml4KSA/KFtcXHdcXC5dKikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVOSVhcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuICAgICAgICBdXG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgVUFQYXJzZXIgPSBmdW5jdGlvbiAodWEsIGV4dGVuc2lvbnMpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHVhID09PSBPQkpfVFlQRSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IHVhO1xuICAgICAgICAgICAgdWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVUFQYXJzZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVBUGFyc2VyKHVhLCBleHRlbnNpb25zKS5nZXRSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbmF2aWdhdG9yID0gKHR5cGVvZiB3aW5kb3cgIT09IFVOREVGX1RZUEUgJiYgd2luZG93Lm5hdmlnYXRvcikgPyB3aW5kb3cubmF2aWdhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgX3VhID0gdWEgfHwgKChfbmF2aWdhdG9yICYmIF9uYXZpZ2F0b3IudXNlckFnZW50KSA/IF9uYXZpZ2F0b3IudXNlckFnZW50IDogRU1QVFkpO1xuICAgICAgICB2YXIgX3VhY2ggPSAoX25hdmlnYXRvciAmJiBfbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpID8gX25hdmlnYXRvci51c2VyQWdlbnREYXRhIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgX3JneG1hcCA9IGV4dGVuc2lvbnMgPyBleHRlbmQocmVnZXhlcywgZXh0ZW5zaW9ucykgOiByZWdleGVzO1xuICAgICAgICB2YXIgX2lzU2VsZk5hdiA9IF9uYXZpZ2F0b3IgJiYgX25hdmlnYXRvci51c2VyQWdlbnQgPT0gX3VhO1xuXG4gICAgICAgIHRoaXMuZ2V0QnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYnJvd3NlciA9IHt9O1xuICAgICAgICAgICAgX2Jyb3dzZXJbTkFNRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfYnJvd3NlcltWRVJTSU9OXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJneE1hcHBlci5jYWxsKF9icm93c2VyLCBfdWEsIF9yZ3htYXAuYnJvd3Nlcik7XG4gICAgICAgICAgICBfYnJvd3NlcltNQUpPUl0gPSBtYWpvcml6ZShfYnJvd3NlcltWRVJTSU9OXSk7XG4gICAgICAgICAgICAvLyBCcmF2ZS1zcGVjaWZpYyBkZXRlY3Rpb25cbiAgICAgICAgICAgIGlmIChfaXNTZWxmTmF2ICYmIF9uYXZpZ2F0b3IgJiYgX25hdmlnYXRvci5icmF2ZSAmJiB0eXBlb2YgX25hdmlnYXRvci5icmF2ZS5pc0JyYXZlID09IEZVTkNfVFlQRSkge1xuICAgICAgICAgICAgICAgIF9icm93c2VyW05BTUVdID0gJ0JyYXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfYnJvd3NlcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDUFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2NwdSA9IHt9O1xuICAgICAgICAgICAgX2NwdVtBUkNISVRFQ1RVUkVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2NwdSwgX3VhLCBfcmd4bWFwLmNwdSk7XG4gICAgICAgICAgICByZXR1cm4gX2NwdTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2RldmljZSA9IHt9O1xuICAgICAgICAgICAgX2RldmljZVtWRU5ET1JdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX2RldmljZVtNT0RFTF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfZGV2aWNlW1RZUEVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2RldmljZSwgX3VhLCBfcmd4bWFwLmRldmljZSk7XG4gICAgICAgICAgICBpZiAoX2lzU2VsZk5hdiAmJiAhX2RldmljZVtUWVBFXSAmJiBfdWFjaCAmJiBfdWFjaC5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICBfZGV2aWNlW1RZUEVdID0gTU9CSUxFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaVBhZE9TLXNwZWNpZmljIGRldGVjdGlvbjogaWRlbnRpZmllZCBhcyBNYWMsIGJ1dCBoYXMgc29tZSBpT1Mtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoX2lzU2VsZk5hdiAmJiBfZGV2aWNlW01PREVMXSA9PSAnTWFjaW50b3NoJyAmJiBfbmF2aWdhdG9yICYmIHR5cGVvZiBfbmF2aWdhdG9yLnN0YW5kYWxvbmUgIT09IFVOREVGX1RZUEUgJiYgX25hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBfbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMikge1xuICAgICAgICAgICAgICAgIF9kZXZpY2VbTU9ERUxdID0gJ2lQYWQnO1xuICAgICAgICAgICAgICAgIF9kZXZpY2VbVFlQRV0gPSBUQUJMRVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2RldmljZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2VuZ2luZSA9IHt9O1xuICAgICAgICAgICAgX2VuZ2luZVtOQU1FXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF9lbmdpbmVbVkVSU0lPTl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfZW5naW5lLCBfdWEsIF9yZ3htYXAuZW5naW5lKTtcbiAgICAgICAgICAgIHJldHVybiBfZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9TID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9vcyA9IHt9O1xuICAgICAgICAgICAgX29zW05BTUVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX29zW1ZFUlNJT05dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX29zLCBfdWEsIF9yZ3htYXAub3MpO1xuICAgICAgICAgICAgaWYgKF9pc1NlbGZOYXYgJiYgIV9vc1tOQU1FXSAmJiBfdWFjaCAmJiBfdWFjaC5wbGF0Zm9ybSAhPSAnVW5rbm93bicpIHtcbiAgICAgICAgICAgICAgICBfb3NbTkFNRV0gPSBfdWFjaC5wbGF0Zm9ybSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvY2hyb21lIG9zL2ksIENIUk9NSVVNX09TKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL21hY29zL2ksIE1BQ19PUyk7ICAgICAgICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX29zO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWEgICAgICA6IHRoaXMuZ2V0VUEoKSxcbiAgICAgICAgICAgICAgICBicm93c2VyIDogdGhpcy5nZXRCcm93c2VyKCksXG4gICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICAgICAgb3MgICAgICA6IHRoaXMuZ2V0T1MoKSxcbiAgICAgICAgICAgICAgICBkZXZpY2UgIDogdGhpcy5nZXREZXZpY2UoKSxcbiAgICAgICAgICAgICAgICBjcHUgICAgIDogdGhpcy5nZXRDUFUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdWE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VUEgPSBmdW5jdGlvbiAodWEpIHtcbiAgICAgICAgICAgIF91YSA9ICh0eXBlb2YgdWEgPT09IFNUUl9UWVBFICYmIHVhLmxlbmd0aCA+IFVBX01BWF9MRU5HVEgpID8gdHJpbSh1YSwgVUFfTUFYX0xFTkdUSCkgOiB1YTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFVBKF91YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBVQVBhcnNlci5WRVJTSU9OID0gTElCVkVSU0lPTjtcbiAgICBVQVBhcnNlci5CUk9XU0VSID0gIGVudW1lcml6ZShbTkFNRSwgVkVSU0lPTiwgTUFKT1JdKTtcbiAgICBVQVBhcnNlci5DUFUgPSBlbnVtZXJpemUoW0FSQ0hJVEVDVFVSRV0pO1xuICAgIFVBUGFyc2VyLkRFVklDRSA9IGVudW1lcml6ZShbTU9ERUwsIFZFTkRPUiwgVFlQRSwgQ09OU09MRSwgTU9CSUxFLCBTTUFSVFRWLCBUQUJMRVQsIFdFQVJBQkxFLCBFTUJFRERFRF0pO1xuICAgIFVBUGFyc2VyLkVOR0lORSA9IFVBUGFyc2VyLk9TID0gZW51bWVyaXplKFtOQU1FLCBWRVJTSU9OXSk7XG5cbiAgICAvLy8vLy8vLy8vL1xuICAgIC8vIEV4cG9ydFxuICAgIC8vLy8vLy8vLy9cblxuICAgIC8vIGNoZWNrIGpzIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZihleHBvcnRzKSAhPT0gVU5ERUZfVFlQRSkge1xuICAgICAgICAvLyBub2RlanMgZW52XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBVTkRFRl9UWVBFICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBVQVBhcnNlcjtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZWpzIGVudiAob3B0aW9uYWwpXG4gICAgICAgIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gRlVOQ19UWVBFICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVBUGFyc2VyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZfVFlQRSkge1xuICAgICAgICAgICAgLy8gYnJvd3NlciBlbnZcbiAgICAgICAgICAgIHdpbmRvdy5VQVBhcnNlciA9IFVBUGFyc2VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8galF1ZXJ5L1plcHRvIHNwZWNpZmljIChvcHRpb25hbClcbiAgICAvLyBOb3RlOlxuICAgIC8vICAgSW4gQU1EIGVudiB0aGUgZ2xvYmFsIHNjb3BlIHNob3VsZCBiZSBrZXB0IGNsZWFuLCBidXQgalF1ZXJ5IGlzIGFuIGV4Y2VwdGlvbi5cbiAgICAvLyAgIGpRdWVyeSBhbHdheXMgZXhwb3J0cyB0byBnbG9iYWwgc2NvcGUsIHVubGVzcyBqUXVlcnkubm9Db25mbGljdCh0cnVlKSBpcyB1c2VkLFxuICAgIC8vICAgYW5kIHdlIHNob3VsZCBjYXRjaCB0aGF0LlxuICAgIHZhciAkID0gdHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZfVFlQRSAmJiAod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8pO1xuICAgIGlmICgkICYmICEkLnVhKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgVUFQYXJzZXIoKTtcbiAgICAgICAgJC51YSA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICAgICAgJC51YS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldFVBKCk7XG4gICAgICAgIH07XG4gICAgICAgICQudWEuc2V0ID0gZnVuY3Rpb24gKHVhKSB7XG4gICAgICAgICAgICBwYXJzZXIuc2V0VUEodWEpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgJC51YVtwcm9wXSA9IHJlc3VsdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDogdGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/ua-parser-js@1.0.37/node_modules/ua-parser-js/src/ua-parser.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/chunk-IL7JOYA6.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/chunk-IL7JOYA6.js ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HuddleProvider: function() { return /* binding */ HuddleProvider; },\n/* harmony export */   __commonJS: function() { return /* binding */ __commonJS; },\n/* harmony export */   __toESM: function() { return /* binding */ __toESM; },\n/* harmony export */   useHuddle01: function() { return /* binding */ useHuddle01; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-experimental/jsx-runtime.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// src/utils/createGenericContext.tsx\n\nvar createGenericContext = () => {\n  const genericContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\n  const useGenericContext = () => {\n    const contextIsDefined = react__WEBPACK_IMPORTED_MODULE_0__.useContext(genericContext);\n    if (!contextIsDefined) {\n      throw new Error(\"\\u274C Nezuko client must be used within a NezukoProvider\");\n    }\n    return contextIsDefined;\n  };\n  return [useGenericContext, genericContext.Provider];\n};\n\n// src/HuddleContext.tsx\n\nvar [useHuddle01, HuddleContextProvider] = createGenericContext();\nvar HuddleProvider = ({ children, client }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(HuddleContextProvider, { value: { huddleClient: client }, children });\n\n\n//# sourceMappingURL=chunk-IL7JOYA6.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMStyZWFjdEAxLjAuMC1kZXYuNDlfcWp3Mm40YzJmdHN1N2t3cm5ycHR2eGIyZHUvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS9yZWFjdC9kaXN0L2NodW5rLUlMN0pPWUE2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBOztBQUVBO0FBQzBCO0FBQzFCO0FBQ0EseUJBQXlCLGdEQUFtQjtBQUM1QztBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDd0M7QUFDeEM7QUFDQSx3QkFBd0Isa0JBQWtCLHFCQUFxQixzREFBRywwQkFBMEIsU0FBUyxzQkFBc0IsWUFBWTs7QUFPckk7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGh1ZGRsZTAxK3JlYWN0QDEuMC4wLWRldi40OV9xancybjRjMmZ0c3U3a3dybnJwdHZ4YjJkdS9ub2RlX21vZHVsZXMvQGh1ZGRsZTAxL3JlYWN0L2Rpc3QvY2h1bmstSUw3Sk9ZQTYuanM/ZDA3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG4vLyBzcmMvdXRpbHMvY3JlYXRlR2VuZXJpY0NvbnRleHQudHN4XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgY3JlYXRlR2VuZXJpY0NvbnRleHQgPSAoKSA9PiB7XG4gIGNvbnN0IGdlbmVyaWNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuICBjb25zdCB1c2VHZW5lcmljQ29udGV4dCA9ICgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0SXNEZWZpbmVkID0gUmVhY3QudXNlQ29udGV4dChnZW5lcmljQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0SXNEZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIE5lenVrbyBjbGllbnQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIE5lenVrb1Byb3ZpZGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dElzRGVmaW5lZDtcbiAgfTtcbiAgcmV0dXJuIFt1c2VHZW5lcmljQ29udGV4dCwgZ2VuZXJpY0NvbnRleHQuUHJvdmlkZXJdO1xufTtcblxuLy8gc3JjL0h1ZGRsZUNvbnRleHQudHN4XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBbdXNlSHVkZGxlMDEsIEh1ZGRsZUNvbnRleHRQcm92aWRlcl0gPSBjcmVhdGVHZW5lcmljQ29udGV4dCgpO1xudmFyIEh1ZGRsZVByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGNsaWVudCB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KEh1ZGRsZUNvbnRleHRQcm92aWRlciwgeyB2YWx1ZTogeyBodWRkbGVDbGllbnQ6IGNsaWVudCB9LCBjaGlsZHJlbiB9KTtcblxuZXhwb3J0IHtcbiAgX19jb21tb25KUyxcbiAgX190b0VTTSxcbiAgdXNlSHVkZGxlMDEsXG4gIEh1ZGRsZVByb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstSUw3Sk9ZQTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/chunk-IL7JOYA6.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/index.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/index.js ***!
  \*******************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HuddleClient: function() { return /* reexport safe */ _huddle01_web_core__WEBPACK_IMPORTED_MODULE_1__.HuddleClient; },\n/* harmony export */   HuddleProvider: function() { return /* reexport safe */ _chunk_IL7JOYA6_js__WEBPACK_IMPORTED_MODULE_0__.HuddleProvider; }\n/* harmony export */ });\n/* harmony import */ var _chunk_IL7JOYA6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-IL7JOYA6.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/chunk-IL7JOYA6.js\");\n/* harmony import */ var _huddle01_web_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @huddle01/web-core */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/index.js\");\n\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMStyZWFjdEAxLjAuMC1kZXYuNDlfcWp3Mm40YzJmdHN1N2t3cm5ycHR2eGIyZHUvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFNkI7O0FBRTdCO0FBQ2tEO0FBSWhEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMStyZWFjdEAxLjAuMC1kZXYuNDlfcWp3Mm40YzJmdHN1N2t3cm5ycHR2eGIyZHUvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS9yZWFjdC9kaXN0L2luZGV4LmpzPzEyMjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSHVkZGxlUHJvdmlkZXJcbn0gZnJvbSBcIi4vY2h1bmstSUw3Sk9ZQTYuanNcIjtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBIdWRkbGVDbGllbnQgfSBmcm9tIFwiQGh1ZGRsZTAxL3dlYi1jb3JlXCI7XG5leHBvcnQge1xuICBIdWRkbGVDbGllbnQsXG4gIEh1ZGRsZVByb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+react@1.0.0-dev.49_qjw2n4c2ftsu7kwrnrptvxb2du/node_modules/@huddle01/react/dist/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancedEventEmitter: function() { return /* binding */ EnhancedEventEmitter; }\n/* harmony export */ });\n/* harmony import */ var _chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-UXIASGQL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js\");\n\n\n// ../../node_modules/events/events.js\nvar require_events = (0,_chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({\n  \"../../node_modules/events/events.js\"(exports, module) {\n    \"use strict\";\n    var R = typeof Reflect === \"object\" ? Reflect : null;\n    var ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply2(target, receiver, args) {\n      return Function.prototype.apply.call(target, receiver, args);\n    };\n    var ReflectOwnKeys;\n    if (R && typeof R.ownKeys === \"function\") {\n      ReflectOwnKeys = R.ownKeys;\n    } else if (Object.getOwnPropertySymbols) {\n      ReflectOwnKeys = function ReflectOwnKeys2(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n      };\n    } else {\n      ReflectOwnKeys = function ReflectOwnKeys2(target) {\n        return Object.getOwnPropertyNames(target);\n      };\n    }\n    function ProcessEmitWarning(warning) {\n      if (console && console.warn)\n        console.warn(warning);\n    }\n    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {\n      return value !== value;\n    };\n    function EventEmitter2() {\n      EventEmitter2.init.call(this);\n    }\n    module.exports = EventEmitter2;\n    module.exports.once = once;\n    EventEmitter2.EventEmitter = EventEmitter2;\n    EventEmitter2.prototype._events = void 0;\n    EventEmitter2.prototype._eventsCount = 0;\n    EventEmitter2.prototype._maxListeners = void 0;\n    var defaultMaxListeners = 10;\n    function checkListener(listener) {\n      if (typeof listener !== \"function\") {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n    }\n    Object.defineProperty(EventEmitter2, \"defaultMaxListeners\", {\n      enumerable: true,\n      get: function() {\n        return defaultMaxListeners;\n      },\n      set: function(arg) {\n        if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n          throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n        }\n        defaultMaxListeners = arg;\n      }\n    });\n    EventEmitter2.init = function() {\n      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = /* @__PURE__ */ Object.create(null);\n        this._eventsCount = 0;\n      }\n      this._maxListeners = this._maxListeners || void 0;\n    };\n    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {\n      if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n        throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n      }\n      this._maxListeners = n;\n      return this;\n    };\n    function _getMaxListeners(that) {\n      if (that._maxListeners === void 0)\n        return EventEmitter2.defaultMaxListeners;\n      return that._maxListeners;\n    }\n    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {\n      return _getMaxListeners(this);\n    };\n    EventEmitter2.prototype.emit = function emit(type) {\n      var args = [];\n      for (var i = 1; i < arguments.length; i++)\n        args.push(arguments[i]);\n      var doError = type === \"error\";\n      var events = this._events;\n      if (events !== void 0)\n        doError = doError && events.error === void 0;\n      else if (!doError)\n        return false;\n      if (doError) {\n        var er;\n        if (args.length > 0)\n          er = args[0];\n        if (er instanceof Error) {\n          throw er;\n        }\n        var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n        err.context = er;\n        throw err;\n      }\n      var handler = events[type];\n      if (handler === void 0)\n        return false;\n      if (typeof handler === \"function\") {\n        ReflectApply(handler, this, args);\n      } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler, len);\n        for (var i = 0; i < len; ++i)\n          ReflectApply(listeners[i], this, args);\n      }\n      return true;\n    };\n    function _addListener(target, type, listener, prepend) {\n      var m;\n      var events;\n      var existing;\n      checkListener(listener);\n      events = target._events;\n      if (events === void 0) {\n        events = target._events = /* @__PURE__ */ Object.create(null);\n        target._eventsCount = 0;\n      } else {\n        if (events.newListener !== void 0) {\n          target.emit(\n            \"newListener\",\n            type,\n            listener.listener ? listener.listener : listener\n          );\n          events = target._events;\n        }\n        existing = events[type];\n      }\n      if (existing === void 0) {\n        existing = events[type] = listener;\n        ++target._eventsCount;\n      } else {\n        if (typeof existing === \"function\") {\n          existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n        } else if (prepend) {\n          existing.unshift(listener);\n        } else {\n          existing.push(listener);\n        }\n        m = _getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n          existing.warned = true;\n          var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n          w.name = \"MaxListenersExceededWarning\";\n          w.emitter = target;\n          w.type = type;\n          w.count = existing.length;\n          ProcessEmitWarning(w);\n        }\n      }\n      return target;\n    }\n    EventEmitter2.prototype.addListener = function addListener(type, listener) {\n      return _addListener(this, type, listener, false);\n    };\n    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;\n    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n    function onceWrapper() {\n      if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0)\n          return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n      }\n    }\n    function _onceWrap(target, type, listener) {\n      var state = { fired: false, wrapFn: void 0, target, type, listener };\n      var wrapped = onceWrapper.bind(state);\n      wrapped.listener = listener;\n      state.wrapFn = wrapped;\n      return wrapped;\n    }\n    EventEmitter2.prototype.once = function once2(type, listener) {\n      checkListener(listener);\n      this.on(type, _onceWrap(this, type, listener));\n      return this;\n    };\n    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n      checkListener(listener);\n      events = this._events;\n      if (events === void 0)\n        return this;\n      list = events[type];\n      if (list === void 0)\n        return this;\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = /* @__PURE__ */ Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit(\"removeListener\", type, list.listener || listener);\n        }\n      } else if (typeof list !== \"function\") {\n        position = -1;\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n        if (position < 0)\n          return this;\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n        if (list.length === 1)\n          events[type] = list[0];\n        if (events.removeListener !== void 0)\n          this.emit(\"removeListener\", type, originalListener || listener);\n      }\n      return this;\n    };\n    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;\n    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {\n      var listeners, events, i;\n      events = this._events;\n      if (events === void 0)\n        return this;\n      if (events.removeListener === void 0) {\n        if (arguments.length === 0) {\n          this._events = /* @__PURE__ */ Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== void 0) {\n          if (--this._eventsCount === 0)\n            this._events = /* @__PURE__ */ Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === \"removeListener\")\n            continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners(\"removeListener\");\n        this._events = /* @__PURE__ */ Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n      listeners = events[type];\n      if (typeof listeners === \"function\") {\n        this.removeListener(type, listeners);\n      } else if (listeners !== void 0) {\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n      return this;\n    };\n    function _listeners(target, type, unwrap) {\n      var events = target._events;\n      if (events === void 0)\n        return [];\n      var evlistener = events[type];\n      if (evlistener === void 0)\n        return [];\n      if (typeof evlistener === \"function\")\n        return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n    }\n    EventEmitter2.prototype.listeners = function listeners(type) {\n      return _listeners(this, type, true);\n    };\n    EventEmitter2.prototype.rawListeners = function rawListeners(type) {\n      return _listeners(this, type, false);\n    };\n    EventEmitter2.listenerCount = function(emitter, type) {\n      if (typeof emitter.listenerCount === \"function\") {\n        return emitter.listenerCount(type);\n      } else {\n        return listenerCount.call(emitter, type);\n      }\n    };\n    EventEmitter2.prototype.listenerCount = listenerCount;\n    function listenerCount(type) {\n      var events = this._events;\n      if (events !== void 0) {\n        var evlistener = events[type];\n        if (typeof evlistener === \"function\") {\n          return 1;\n        } else if (evlistener !== void 0) {\n          return evlistener.length;\n        }\n      }\n      return 0;\n    }\n    EventEmitter2.prototype.eventNames = function eventNames() {\n      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n    };\n    function arrayClone(arr, n) {\n      var copy = new Array(n);\n      for (var i = 0; i < n; ++i)\n        copy[i] = arr[i];\n      return copy;\n    }\n    function spliceOne(list, index) {\n      for (; index + 1 < list.length; index++)\n        list[index] = list[index + 1];\n      list.pop();\n    }\n    function unwrapListeners(arr) {\n      var ret = new Array(arr.length);\n      for (var i = 0; i < ret.length; ++i) {\n        ret[i] = arr[i].listener || arr[i];\n      }\n      return ret;\n    }\n    function once(emitter, name) {\n      return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n          emitter.removeListener(name, resolver);\n          reject(err);\n        }\n        function resolver() {\n          if (typeof emitter.removeListener === \"function\") {\n            emitter.removeListener(\"error\", errorListener);\n          }\n          resolve([].slice.call(arguments));\n        }\n        ;\n        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n        if (name !== \"error\") {\n          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n        }\n      });\n    }\n    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n      if (typeof emitter.on === \"function\") {\n        eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n      }\n    }\n    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n      if (typeof emitter.on === \"function\") {\n        if (flags.once) {\n          emitter.once(name, listener);\n        } else {\n          emitter.on(name, listener);\n        }\n      } else if (typeof emitter.addEventListener === \"function\") {\n        emitter.addEventListener(name, function wrapListener(arg) {\n          if (flags.once) {\n            emitter.removeEventListener(name, wrapListener);\n          }\n          listener(arg);\n        });\n      } else {\n        throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n      }\n    }\n  }\n});\n\n// src/common-js/EnhancedEventEmitter.ts\nvar import_events = (0,_chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_0__.__toESM)(require_events(), 1);\nvar EnhancedEventEmitter = class {\n  emitter;\n  constructor() {\n    this.emitter = new import_events.EventEmitter();\n    this.emitter.setMaxListeners(Infinity);\n  }\n  on(eventName, listener) {\n    this.emitter.on(\n      eventName,\n      // biome-ignore lint/suspicious/noExplicitAny: need to override the type because default it's any[ and we cannot assign E[K] to any[]\n      listener\n    );\n    return this;\n  }\n  off(eventName, listener) {\n    this.emitter.off(\n      eventName,\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n      listener\n    );\n    return this;\n  }\n  listenerCount(eventName) {\n    return this.emitter.listenerCount(eventName);\n  }\n  listeners(eventName) {\n    return this.emitter.listeners(eventName);\n  }\n  emit(eventName, ...args) {\n    return this.emitter.emit(eventName, ...args);\n  }\n  safeEmit(eventName, ...args) {\n    return this.emitter.emit(eventName, ...args);\n  }\n  once(eventName, listener) {\n    this.emitter.once(\n      eventName,\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n      listener\n    );\n    return this;\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.emitter.removeAllListeners(eventName);\n    } else {\n      this.emitter.removeAllListeners();\n    }\n    return this;\n  }\n};\n\n\n//# sourceMappingURL=chunk-7OTQAFXE.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLTdPVFFBRlhFLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRzZCOztBQUU3QjtBQUNBLHFCQUFxQiw4REFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0JBQW9CLDJEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLTdPVFFBRlhFLmpzPzYyNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19jb21tb25KUyxcbiAgX190b0VTTVxufSBmcm9tIFwiLi9jaHVuay1VWElBU0dRTC5qc1wiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1xudmFyIHJlcXVpcmVfZXZlbnRzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiID8gUmVmbGVjdCA6IG51bGw7XG4gICAgdmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09IFwiZnVuY3Rpb25cIiA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkyKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgICB9O1xuICAgIHZhciBSZWZsZWN0T3duS2V5cztcbiAgICBpZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5czIodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5czIodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybilcbiAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbiAgICB2YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyMigpIHtcbiAgICAgIEV2ZW50RW1pdHRlcjIuaW5pdC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjI7XG4gICAgbW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG4gICAgRXZlbnRFbWl0dGVyMi5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXIyO1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLl9ldmVudHMgPSB2b2lkIDA7XG4gICAgRXZlbnRFbWl0dGVyMi5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG4gICAgZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyMiwgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIiB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBFdmVudEVtaXR0ZXIyLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9ldmVudHMgPT09IHZvaWQgMCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdm9pZCAwO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyMi5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgICAgIGlmICh0eXBlb2YgbiAhPT0gXCJudW1iZXJcIiB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgXCIuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gICAgICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXIyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB2YXIgZG9FcnJvciA9IHR5cGUgPT09IFwiZXJyb3JcIjtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzICE9PSB2b2lkIDApXG4gICAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdm9pZCAwO1xuICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICAgIHZhciBlcjtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgICAgICBlciA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBlcnJvci5cIiArIChlciA/IFwiIChcIiArIGVyLm1lc3NhZ2UgKyBcIilcIiA6IFwiXCIpKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoaGFuZGxlciA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIHZhciBldmVudHM7XG4gICAgICB2YXIgZXhpc3Rpbmc7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGFyZ2V0LmVtaXQoXG4gICAgICAgICAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIGlmIChleGlzdGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciB3ID0gbmV3IEVycm9yKFwiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiBcIiArIGV4aXN0aW5nLmxlbmd0aCArIFwiIFwiICsgU3RyaW5nKHR5cGUpICsgXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKTtcbiAgICAgICAgICB3Lm5hbWUgPSBcIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiO1xuICAgICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgICAgIGlmICghdGhpcy5maXJlZCkge1xuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICAgICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHZvaWQgMCwgdGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciB9O1xuICAgICAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgICAgIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9XG4gICAgRXZlbnRFbWl0dGVyMi5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB2b2lkIDApXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJyZW1vdmVMaXN0ZW5lclwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcInJlbW92ZUxpc3RlbmVyXCIpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICAgICAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChldmxpc3RlbmVyID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG4gICAgICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG4gICAgfVxuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gICAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gICAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyMi5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gICAgICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICBjb3B5W2ldID0gYXJyW2ldO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICAgICAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgICAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgICAgIGxpc3QucG9wKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgICAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGlmIChuYW1lICE9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIFwiZXJyb3JcIiwgaGFuZGxlciwgZmxhZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0ZW5lcihhcmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2NvbW1vbi1qcy9FbmhhbmNlZEV2ZW50RW1pdHRlci50c1xudmFyIGltcG9ydF9ldmVudHMgPSBfX3RvRVNNKHJlcXVpcmVfZXZlbnRzKCksIDEpO1xudmFyIEVuaGFuY2VkRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBlbWl0dGVyO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgaW1wb3J0X2V2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLmVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcbiAgfVxuICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uKFxuICAgICAgZXZlbnROYW1lLFxuICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiBuZWVkIHRvIG92ZXJyaWRlIHRoZSB0eXBlIGJlY2F1c2UgZGVmYXVsdCBpdCdzIGFueVsgYW5kIHdlIGNhbm5vdCBhc3NpZ24gRVtLXSB0byBhbnlbXVxuICAgICAgbGlzdGVuZXJcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9mZihcbiAgICAgIGV2ZW50TmFtZSxcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogPGV4cGxhbmF0aW9uPlxuICAgICAgbGlzdGVuZXJcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XG4gIH1cbiAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIubGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gIH1cbiAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgfVxuICBzYWZlRW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgfVxuICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmVtaXR0ZXIub25jZShcbiAgICAgIGV2ZW50TmFtZSxcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogPGV4cGxhbmF0aW9uPlxuICAgICAgbGlzdGVuZXJcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmV4cG9ydCB7XG4gIEVuaGFuY2VkRXZlbnRFbWl0dGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstN09UUUFGWEUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7PO7E25R.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7PO7E25R.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancedMap: function() { return /* binding */ EnhancedMap; },\n/* harmony export */   defaultCompareFn: function() { return /* binding */ defaultCompareFn; }\n/* harmony export */ });\n// src/common-js/EnhancedMap.ts\nvar defaultCompareFn = (a, b) => {\n  if (a < b) {\n    return false;\n  }\n  if (a > b) {\n    return true;\n  }\n  return false;\n};\nvar EnhancedMap = class {\n  map;\n  compareFn;\n  getKey = (a, b) => {\n    const key = this.compareFn(a, b) ? `${a}_${b}` : `${b}_${a}`;\n    return key;\n  };\n  get size() {\n    return this.map.size;\n  }\n  get = (a, b) => {\n    const key = this.getKey(a, b);\n    const value = this.map.get(key);\n    return value;\n  };\n  set = (a, b, value) => {\n    const key = this.getKey(a, b);\n    this.map.set(key, value);\n    return value;\n  };\n  delete = (a, b) => {\n    const key = this.getKey(a, b);\n    return this.map.delete(key);\n  };\n  clear = () => {\n    this.map.clear();\n  };\n  constructor(data) {\n    this.map = /* @__PURE__ */ new Map();\n    if (data.compareFn)\n      this.compareFn = data.compareFn;\n    else\n      this.compareFn = defaultCompareFn;\n  }\n};\n\n\n//# sourceMappingURL=chunk-7PO7E25R.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLTdQTzdFMjVSLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaHVkZGxlMDErd2ViLWNvcmVAMS4wLjAtZGV2LjY2L25vZGVfbW9kdWxlcy9AaHVkZGxlMDEvd2ViLWNvcmUvZGlzdC9jaHVuay03UE83RTI1Ui5qcz84ZmY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21tb24tanMvRW5oYW5jZWRNYXAudHNcbnZhciBkZWZhdWx0Q29tcGFyZUZuID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhID4gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgRW5oYW5jZWRNYXAgPSBjbGFzcyB7XG4gIG1hcDtcbiAgY29tcGFyZUZuO1xuICBnZXRLZXkgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuY29tcGFyZUZuKGEsIGIpID8gYCR7YX1fJHtifWAgOiBgJHtifV8ke2F9YDtcbiAgICByZXR1cm4ga2V5O1xuICB9O1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuc2l6ZTtcbiAgfVxuICBnZXQgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KGEsIGIpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBzZXQgPSAoYSwgYiwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleShhLCBiKTtcbiAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBkZWxldGUgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KGEsIGIpO1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgfTtcbiAgY2xlYXIgPSAoKSA9PiB7XG4gICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgfTtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMubWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZGF0YS5jb21wYXJlRm4pXG4gICAgICB0aGlzLmNvbXBhcmVGbiA9IGRhdGEuY29tcGFyZUZuO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuY29tcGFyZUZuID0gZGVmYXVsdENvbXBhcmVGbjtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdENvbXBhcmVGbixcbiAgRW5oYW5jZWRNYXBcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay03UE83RTI1Ui5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7PO7E25R.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-BDLAILV7.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-BDLAILV7.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalPeer_default: function() { return /* binding */ LocalPeer_default; },\n/* harmony export */   RemotePeer_default: function() { return /* binding */ RemotePeer_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_OKUP6CWC_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-OKUP6CWC.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-OKUP6CWC.js\");\n/* harmony import */ var _chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-G7SIQXZ4.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-G7SIQXZ4.js\");\n/* harmony import */ var _chunk_LU7T3V5U_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-LU7T3V5U.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-LU7T3V5U.js\");\n/* harmony import */ var _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-NEW4FEHE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-NEW4FEHE.js\");\n/* harmony import */ var _chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-V4S3N66D.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-V4S3N66D.js\");\n/* harmony import */ var _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-HVBBMWHF.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js\");\n/* harmony import */ var _chunk_SSCVNXAL_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-SSCVNXAL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SSCVNXAL.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! mediasoup-client */ \"(app-client)/./node_modules/.pnpm/mediasoup-client@3.7.2/node_modules/mediasoup-client/lib/index.js\");\n\n\n\n\n\n\n\n\n\n\n// src/LocalPeer.ts\n\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_7__.mainLogger.createSubLogger(\"LocalPeer\");\nvar MAX_DATA_MESSAGE_SIZE = 1 * 1024;\nvar LocalPeer = class _LocalPeer extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_8__.EnhancedEventEmitter {\n  /**\n   * LocalPeer Instance, Singleton class, only one instance of this class can be created\n   */\n  static __instance = null;\n  /**\n   * PeerId of the current client, specific to the Local Peer who joined the meeting\n   *\n   * `NOTE: Until you dont join the room, this will be *null*`\n   */\n  peerId = null;\n  /**\n   * Current Devices of the current client\n   * e.g. Chrome, Firefox, Safari, ReactNative\n   */\n  __device = null;\n  /**\n   * SendTransport handles the sending of media from the client to the server\n   */\n  __sendTransport = null;\n  /**\n   * RecvTransport handles the receiving of media from the server to the client\n   */\n  __recvTransport = null;\n  /**\n   * Returns the room instance, throws an error if the room is not created\n   *\n   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room in the LocalPeer\n   */\n  get room() {\n    const room = _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_3__.Room_default.getInstance();\n    if (!room)\n      throw new Error(\"\\u274C Room Not Initialized\");\n    return room;\n  }\n  /**\n   * Returns the underlying socket connection\n   * @throws { Error } If the socket connection is not initialized\n   */\n  get socket() {\n    const socket = _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_5__.Socket_default.getInstance();\n    if (!socket)\n      throw new Error(\"\\u274C Socket Not Initialized\");\n    return socket;\n  }\n  /**\n   * Remote Peers Map, Stores all the remote peers\n   */\n  get __remotePeers() {\n    return this.room.remotePeers;\n  }\n  /**\n   * Turn Server used for this client\n   */\n  __turn = [\n    {\n      username: \"test-turn\",\n      urls: \"turn:turn.huddle01.com:443?transport=udp\",\n      credential: \"test-turn\"\n    },\n    {\n      username: \"test-turn\",\n      urls: \"turn:turn.huddle01.com:443?transport=tcp\",\n      credential: \"test-turn\"\n    }\n  ];\n  /**\n   * Get the current device ( chrome, firefox, safari, reactnative ) for this client\n   *\n   * @throws { Error } If the device is not initialized\n   */\n  get device() {\n    if (!this.__device)\n      throw new Error(\"Device Not Initialized\");\n    const loaded = this.__device.loaded;\n    if (!loaded)\n      throw new Error(\"Device Not Loaded\");\n    return this.__device;\n  }\n  // !important\n  // Consumer creation tasks awaiting to be processed.\n  // Stores the lables of the pending consumers { producerId: string ==> Promise<Consumer> }\n  __pendingConsumerTasks = /* @__PURE__ */ new Map();\n  // !important\n  // Producer creation tasks awaiting to be processed.\n  // Stores the lables of the pending producers { label: string }\n  // Used to handle transport callbacks most important;\n  __pendingProducerTasks = /* @__PURE__ */ new Map();\n  // !important\n  // Map to store pending tasks, Stores the label and the promise of the task\n  __pendingTasks = /* @__PURE__ */ new Map();\n  /**\n   * Pending Transport Tasks, Stores the transportType and the promise of the transport\n   *\n   * `NOTE: Useful to check if the transport is already being created and pause all producing\n   * and consuming until the transport is created`\n   */\n  __pendingTransportTasks = /* @__PURE__ */ new Map();\n  /**\n   * Stores all the pending fetching stream tasks which are awaiting to be processed\n   * If fetching called multiple times at once, it will handle the concurrency issues\n   */\n  __pendingFetchingStream = /* @__PURE__ */ new Map();\n  /**\n   * Stores all the pending produce tasks which are awaiting to be processed\n   * Mostly used when the room is not joined and produce functionality needs to be handled\n   *\n   * Cases such as socket experiencing a reconnect and produce is called.\n   * Or in the cases where room is not joined and enableVideo or enableAudio is called\n   */\n  __waitingToProduce = /* @__PURE__ */ new Map();\n  /**\n   * Stores all the pending consume tasks which are waiting for recv transport to be re-connected\n   */\n  __waitingToConsume = [];\n  /**\n   * DeviceHandler Instance, Handles the media devices for this client\n   * e.g. Camera, Microphone\n   */\n  deviceHandler = new _chunk_LU7T3V5U_js__WEBPACK_IMPORTED_MODULE_2__.DeviceHandler_default();\n  /**\n   * ActiveStream Map holds MediaStream as Value and Key as Label\n   */\n  __activeStreams = /* @__PURE__ */ new Map();\n  /**\n   * Handle the Client Side Permission for the Local Peer.\n   */\n  __permissions = _chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.Permissions_default.createInstance();\n  /**\n   * Stores the Metadata for the Local Peer.\n   */\n  __metadata = null;\n  /**\n   * Variable to check if the user has joined the room\n   */\n  joined = false;\n  /**\n   * Return the labels of the Media Stream that the Local Peer is producing to the room\n   */\n  get labels() {\n    const sendTransport = this.__sendTransport;\n    if (sendTransport) {\n      const labels = Array.from(sendTransport.labelToProducerId.keys());\n      return labels;\n    }\n    return [];\n  }\n  /**\n   * Get the Permissions of the Local Peer. (e.g canProduce, canConsume, canSendData, canRecvData etc)\n   */\n  get permissions() {\n    const acl = this.__permissions.acl;\n    return acl;\n  }\n  /**\n   * Get the Role of the Local Peer.\n   */\n  get role() {\n    return this.__permissions.role;\n  }\n  /**\n   * Returns the token of the current socket connection, specific to the Local Peer who joined the meeting\n   */\n  get token() {\n    return this.socket.token;\n  }\n  /**\n   * Returns the roomId of the current joined room.\n   */\n  get roomId() {\n    return this.room.roomId;\n  }\n  /**\n   * Returns the SendTransport\n   * @returns { Transport } SendTransport\n   * @throws { Error } If the SendTransport is not initialized\n   */\n  get sendTransport() {\n    if (!this.__sendTransport)\n      throw new Error(\"Send Transport Not Initialized\");\n    return this.__sendTransport;\n  }\n  /**\n   * Returns the recvTransport\n   * @returns { Transport } recvTransport\n   * @throws { Error } If the recvTransport is not initialized\n   */\n  get recvTransport() {\n    if (!this.__recvTransport)\n      throw new Error(\"Recv Transport Not Initialized\");\n    return this.__recvTransport;\n  }\n  /**\n   * Returns the metadata associated to the LocalPeer\n   */\n  getMetadata() {\n    const data = JSON.parse(this.__metadata || \"{}\");\n    return data;\n  }\n  /**\n   * getStream returns the stream with the given label\n   */\n  getStream = (data) => {\n    const stream = this.__activeStreams.get(data.label);\n    if (stream === void 0) {\n      return null;\n    }\n    return stream;\n  };\n  /**\n   * Updates the metadata associated to the LocalPeer, Triggers the `metadata-updated` event\n   * @param metadata\n   */\n  __updateMetadata = (metadata) => {\n    this.__metadata = metadata;\n    const parse = JSON.parse(metadata);\n    this.emit(\"metadata-updated\", {\n      metadata: parse\n    });\n  };\n  /**\n   * Returns the producer with the given label\n   * @param label - Identifier of the producer\n   * @returns { Producer } Producer\n   * @returns { null } If the producer is not found\n   */\n  getProducerWithLabel = (label) => {\n    try {\n      const producerId = this.__sendTransport?.labelToProducerId.get(label);\n      if (producerId) {\n        const producer = this.sendTransport.getProducerById(producerId);\n        return producer;\n      }\n      return null;\n    } catch (error) {\n      logger.error(\"\\u274C Cannot Find Producer With Identifier: \", label);\n      logger.error(error);\n      return null;\n    }\n  };\n  /**\n   * Registers the event handlers for the socket connection\n   * @param socket - Socket Instance\n   */\n  __registerHandlerEvents = (socket) => {\n    let cnt = 0;\n    const keys = Object.keys(this.__handler);\n    for (const key of keys) {\n      try {\n        const fn = this.__handler[key];\n        if (fn)\n          socket.subscribe(key, fn);\n      } catch (error) {\n        logger.error(`\\u274C Error Registered For Event: ${key}`);\n        logger.error(error);\n      }\n      cnt++;\n    }\n    logger.info(\"\\u2705 LocalPeerEventHandler Registered\");\n  };\n  static create() {\n    if (_LocalPeer.__instance) {\n      return _LocalPeer.__instance;\n    }\n    _LocalPeer.__instance = new _LocalPeer();\n    return _LocalPeer.__instance;\n  }\n  static getInstance() {\n    if (!_LocalPeer.__instance) {\n      throw new Error(\"LocalPeer not initialized\");\n    }\n    return _LocalPeer.__instance;\n  }\n  constructor() {\n    super();\n    this.__registerHandlerEvents(this.socket);\n    this.socket.on(\"reconnected\", () => {\n      this.__registerHandlerEvents(this.socket);\n      this.socket.publish(\"syncMeetingState\", void 0);\n      if (this.__sendTransport) {\n        this.socket.publish(\"restartTransportIce\", {\n          transportId: this.__sendTransport.mediasoupTransport.id,\n          transportType: \"send\"\n        });\n      }\n      if (this.__recvTransport) {\n        this.socket.publish(\"restartTransportIce\", {\n          transportId: this.__recvTransport.mediasoupTransport.id,\n          transportType: \"recv\"\n        });\n      }\n    });\n  }\n  /**\n   * Destroy the current peer, closes all the transports, producers and consumers\n   *\n   * @param code - Close Code\n   */\n  close = () => {\n    this.__device = null;\n    this.__pendingConsumerTasks.clear();\n    this.__pendingProducerTasks.clear();\n    this.__pendingTransportTasks.clear();\n    this.__pendingFetchingStream.clear();\n    this.__waitingToProduce.clear();\n    for (const stream of this.__activeStreams.values()) {\n      for (const track of stream.getTracks())\n        track.stop();\n    }\n    this.joined = false;\n    this.deviceHandler.destroy();\n    if (this.__sendTransport) {\n      this.__sendTransport.close({ retries: 3 });\n    }\n    if (this.__recvTransport) {\n      this.__recvTransport.close({ retries: 3 });\n    }\n    this.__sendTransport = null;\n    this.__recvTransport = null;\n    this.__permissions.reset();\n    this.emit(\"permissions-updated\", {\n      permissions: this.permissions,\n      role: this.role ?? \"\"\n    });\n  };\n  /**\n   * LocalPeer Handler Functions Begins Here \n   */\n  /**\n   * Produce a stream with a given label and appData to all the Remote Peers\n   *\n   * `canProduce must be true to produce a stream`\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has started producing and they should start consuming it if they want to`\n   *\n   * @param data - Data to produce a stream\n   *  - `label` - Unique Identifier for the stream ( string )\n   *  - `stream` - MediaStream to produce ( MediaStream )\n   *  - `stopTrackOnClose` - If true, it will stop the track when the producer is closed using stopProducing ( boolean )\n   *  - `appData` - Application level custom data which can be added to the producer for the LocalPeer, this data will be available in the producer object and can be used only by the LocalPeer. ( Unknown Object )\n   *\n   * @summary This function is used to produce a stream with a given label and appData to all the Remote Peers if the send transport is not initialised\n   * it will create a send transport and then produce the stream with the given label and appData to all the Remote Peers\n   *\n   * Send Transport is a secure channel which is used to send media from LocalPeer to all the RemotePeers in the room\n   *\n   * `localPeer.on('new-producer', ({label: string; producer: Producer}) => {})`\n   */\n  produce = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    canProduce: true\n  }).validate(\n    async (data) => {\n      const track = data.stream.getTracks()[0];\n      if (track) {\n        track.addEventListener(\"ended\", () => {\n          this.stopProducing({ label: data.label });\n        });\n      }\n      if (!this.joined || this.__sendTransport && this.__sendTransport?.connectionState !== \"connected\") {\n        return new Promise((resolve) => {\n          const fn = async () => {\n            const producer2 = await this.produce(data).then((data2) => {\n              resolve(data2);\n              return data2;\n            }).finally(() => {\n              this.__pendingProducerTasks.delete(data.label);\n            });\n            return producer2;\n          };\n          this.__waitingToProduce.set(data.label, fn);\n        });\n      }\n      const { stream } = data;\n      const producerPromise = this.__pendingProducerTasks.get(data.label);\n      if (producerPromise) {\n        logger.info(\n          \"\\u{1F514} Producer Task Already Pending for this label \",\n          data.label\n        );\n        const producer2 = await producerPromise;\n        return producer2;\n      }\n      if (!this.__sendTransport) {\n        await this.__createTransportOnServer({\n          transportType: \"send\"\n        });\n      }\n      const ongoingPromise = this.__pendingProducerTasks.get(data.label);\n      if (ongoingPromise) {\n        const producer2 = await ongoingPromise;\n        return producer2;\n      }\n      const promise = this.__createProducer({\n        stream,\n        label: data.label,\n        appData: { ...data.appData, label: data.label }\n      });\n      this.__pendingProducerTasks.set(data.label, promise);\n      const producer = await promise.catch(() => {\n        logger.error(\"\\u274C Error Create Producer Failed\");\n        throw new Error(\"\\u274C Error Create Producer Failed\");\n      }).finally(() => {\n        this.__pendingProducerTasks.delete(data.label);\n      });\n      return producer;\n    }\n  );\n  /**\n   * Enables the local web cam and starts producing the stream with the label `video`\n   *\n   * @summary This functions handle the producing of media streams to all the remote peers in the room.\n   * it enables the local web cam fetches the stream opens you web cam indicator light on the device\n   * upon successfull fetching of the stream it produces the stream with the label `video` and `stopTrackOnClose: true` to all the remote peers in the room.\n   * when closing using disableVideo it will stop the local track and close the producer which will notify all the RemotePeers that this producer has stopped producing\n   * and they should stop consuming it.\n   *\n   * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will throw an error`\n   *\n   * @throws { Error } If the stream is not found\n   */\n  enableVideo = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    canProduce: true\n  }).validate(async (customVideoStream) => {\n    try {\n      if (!this.permissions.canProduceSources.cam) {\n        logger.error(\"\\u274C Cannot Enable Video, Permission Denied\");\n        throw new Error(\"\\u274C Cannot Enable Video, Permission Denied\");\n      }\n      const existingStream = this.__activeStreams.get(\"video\");\n      if (existingStream) {\n        logger.warn(\"\\u{1F514} Cam Stream Already Enabled\");\n        return;\n      }\n      let stream;\n      if (customVideoStream) {\n        stream = customVideoStream;\n      } else {\n        const ongoingStreamPromise = this.__pendingFetchingStream.get(\"cam\");\n        if (ongoingStreamPromise) {\n          await ongoingStreamPromise;\n        } else {\n          const streamPromise = this.deviceHandler.fetchStream({\n            mediaDeviceKind: \"cam\"\n          });\n          this.__pendingFetchingStream.set(\"cam\", streamPromise);\n        }\n        const pendingPromise = this.__pendingFetchingStream.get(\"cam\");\n        if (!pendingPromise) {\n          logger.info(\"\\u{1F514} Pending Promise Not Found\");\n          return;\n        }\n        const { stream: fetchedStream, error } = await pendingPromise;\n        if (error) {\n          logger.error(\"\\u274C Error Fetching Stream From Device\");\n          logger.error(error);\n          throw new Error(\"\\u274C Error Fetching Stream From Device\");\n        }\n        if (!fetchedStream) {\n          logger.error(\"\\u274C Stream Not Found, cannot do enableVideo\");\n          throw new Error(\"\\u274C Stream Not Found\");\n        }\n        stream = fetchedStream;\n      }\n      this.__activeStreams.set(\"video\", stream);\n      this.emit(\"stream-fetched\", {\n        mediaKind: \"cam\",\n        label: \"video\",\n        stream\n      });\n      this.produce({\n        label: \"video\",\n        stream,\n        appData: {\n          producerPeerId: this.peerId\n        },\n        stopTrackOnClose: true\n      }).then(() => {\n        this.__pendingProducerTasks.delete(\"video\");\n      }).catch((error) => {\n        logger.error(\"\\u274C Error Producing Video\");\n        this.deviceHandler.stopStream(this.__activeStreams.get(\"video\"));\n        this.__activeStreams.delete(\"video\");\n        this.__pendingFetchingStream.delete(\"cam\");\n        logger.error(error);\n      });\n      this.__pendingFetchingStream.delete(\"cam\");\n      return stream;\n    } catch (error) {\n      logger.error(\"\\u274C Error Enabling Video\");\n      logger.error(error);\n      this.deviceHandler.stopStream(this.__activeStreams.get(\"video\"));\n      this.__activeStreams.delete(\"video\");\n      this.__pendingFetchingStream.delete(\"cam\");\n      throw error;\n    }\n  });\n  /**\n   * Enables the local screen share  and starts producing the screen sharing stream\n   *\n   *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`\n   *\n   * @summary This functions handle the producing of media streams to all the remote peers in the room.\n   * it enables the local mic fetches the stream opens you mic active indicator light on the device\n   * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.\n   * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing\n   * and they should stop consuming it.\n   *\n   *\n   */\n  startScreenShare = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({ canProduce: true }).validate(\n    async () => {\n      try {\n        if (!this.permissions.canProduceSources.screen) {\n          logger.error(\"\\u274C Cannot Enable Screen Share, Permission Denied\");\n          throw new Error(\"\\u274C Cannot Enable Screen Share, Permission Denied\");\n        }\n        const existingStream = this.__activeStreams.get(\"screen-share\");\n        if (existingStream) {\n          logger.warn(\"\\u{1F514} Screen Stream Already Enabled\");\n          return;\n        }\n        const onGoingStreamPromise = this.__pendingFetchingStream.get(\"screen-share\");\n        if (onGoingStreamPromise) {\n          await onGoingStreamPromise;\n        } else {\n          const streamPromise = this.deviceHandler.fetchScreen();\n          this.__pendingFetchingStream.set(\"screen-share\", streamPromise);\n        }\n        const pendingPromise = this.__pendingFetchingStream.get(\"screen-share\");\n        if (!pendingPromise) {\n          logger.info(\"\\u{1F514} Pending Screen Share Promise Not Found\");\n          return;\n        }\n        const { stream, error } = await pendingPromise;\n        if (error) {\n          logger.error(\"\\u274C Error Fetching Screen Share Stream From Device\");\n          logger.error(error);\n          throw new Error(\"\\u274C Error Fetching Screen ShareStream From Device\");\n        }\n        if (!stream) {\n          logger.error(\"\\u274C Stream Not Found, cannot do startScreenShare\");\n          throw new Error(\"\\u274C Stream Not Found, cannot do startScreenShare\");\n        }\n        this.__activeStreams.set(\"screen-share\", stream);\n        this.emit(\"stream-fetched\", {\n          mediaKind: \"screen\",\n          label: \"screen-share\",\n          stream\n        });\n        const videoTrack = stream.getVideoTracks()?.[0];\n        const audioTrack = stream.getAudioTracks()?.[0];\n        const videoProduce = async () => {\n          return this.produce({\n            label: \"screen-share-video\",\n            stream: new MediaStream([videoTrack]),\n            appData: {\n              producerPeerId: this.peerId\n            },\n            stopTrackOnClose: true\n          });\n        };\n        const audioProduce = async () => {\n          return this.produce({\n            label: \"screen-share-audio\",\n            stream: new MediaStream([audioTrack]),\n            appData: {\n              producerPeerId: this.peerId\n            },\n            stopTrackOnClose: true\n          });\n        };\n        if (videoTrack) {\n          videoProduce().then(() => {\n            this.__pendingProducerTasks.delete(\"screen-share-video\");\n          }).catch((error2) => {\n            logger.error(\"\\u274C Error Producing Screen Share Video\");\n            this.deviceHandler.stopStream(\n              this.__activeStreams.get(\"screen-share\")\n            );\n            this.__activeStreams.delete(\"screen-share\");\n            logger.error(error2);\n          });\n        }\n        if (audioTrack) {\n          audioProduce().then(() => {\n            this.__pendingProducerTasks.delete(\"screen-share-audio\");\n          }).catch((error2) => {\n            logger.error(\"\\u274C Error Producing Audio\");\n            this.deviceHandler.stopStream(\n              this.__activeStreams.get(\"screen-share\")\n            );\n            this.__activeStreams.delete(\"screen-share\");\n            logger.error(error2);\n          });\n        }\n        this.__pendingFetchingStream.delete(\"screen-share\");\n        return stream;\n      } catch (error) {\n        logger.error(\"\\u274C Error Enabling Screen Share\");\n        logger.error(error);\n        this.deviceHandler.stopStream(this.__activeStreams.get(\"screen-share\"));\n        this.__activeStreams.delete(\"screen-share\");\n        this.__pendingFetchingStream.delete(\"screen-share\");\n        throw error;\n      }\n    }\n  );\n  /**\n   * Enables the local mic and starts producing the stream with the label `audio`\n   *\n   *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`\n   *\n   * @summary This functions handle the producing of media streams to all the remote peers in the room.\n   * it enables the local mic fetches the stream opens you mic active indicator light on the device\n   * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.\n   * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing\n   * and they should stop consuming it.\n   */\n  enableAudio = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    canProduce: true\n  }).validate(async (customAudioStream) => {\n    try {\n      if (!this.permissions.canProduceSources.mic) {\n        logger.error(\"\\u274C Cannot Enable Audio, Permission Denied\");\n        throw new Error(\"\\u274C Cannot Enable Audio, Permission Denied\");\n      }\n      const existingStream = this.__activeStreams.get(\"audio\");\n      if (existingStream) {\n        logger.warn(\"\\u{1F514} Mic Stream Already Enabled\");\n        return;\n      }\n      let stream;\n      if (customAudioStream) {\n        stream = customAudioStream;\n      } else {\n        const ongoingStreamPromise = this.__pendingFetchingStream.get(\"mic\");\n        if (ongoingStreamPromise) {\n          await ongoingStreamPromise;\n        } else {\n          const streamPromise = this.deviceHandler.fetchStream({\n            mediaDeviceKind: \"mic\"\n          });\n          this.__pendingFetchingStream.set(\"mic\", streamPromise);\n        }\n        const pendingPromise = this.__pendingFetchingStream.get(\"mic\");\n        if (!pendingPromise) {\n          logger.info(\"\\u{1F514} Pending Mic Promise Not Found\");\n          return;\n        }\n        const { stream: fetchedStream, error } = await pendingPromise;\n        if (error) {\n          logger.error(\"\\u274C Error Fetching Stream From Device\");\n          logger.error(error);\n          throw new Error(\"\\u274C Error Fetching Stream From Device\");\n        }\n        if (!fetchedStream) {\n          logger.error(\"\\u274C Stream Not Found, cannot do enableAudio\");\n          throw new Error(\"\\u274C Stream Not Found\");\n        }\n        stream = fetchedStream;\n      }\n      this.__activeStreams.set(\"audio\", stream);\n      this.emit(\"stream-fetched\", {\n        mediaKind: \"mic\",\n        stream,\n        label: \"audio\"\n      });\n      this.produce({\n        label: \"audio\",\n        stream,\n        appData: {\n          producerPeerId: this.peerId\n        },\n        stopTrackOnClose: true\n      }).then(() => {\n        this.__pendingProducerTasks.delete(\"audio\");\n      }).catch((error) => {\n        logger.error(\"\\u274C Error Producing Audio\");\n        this.deviceHandler.stopStream(this.__activeStreams.get(\"audio\"));\n        this.__activeStreams.delete(\"audio\");\n        logger.error(error);\n      });\n      this.__pendingFetchingStream.delete(\"mic\");\n      return stream;\n    } catch (error) {\n      logger.error(\"\\u274C Error Enabling Audio\");\n      logger.error(error);\n      this.deviceHandler.stopStream(this.__activeStreams.get(\"audio\"));\n      this.__activeStreams.delete(\"audio\");\n      this.__pendingFetchingStream.delete(\"mic\");\n      throw error;\n    }\n  });\n  /**\n   * Stops the underlying producing of a stream for a particular label\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`\n   *\n   * @param data Data to stop producing { label: string }\n   */\n  stopProducing = (data) => {\n    this.__waitingToProduce.delete(data.label);\n    this.__pendingProducerTasks.delete(data.label);\n    let closedStream = false;\n    const producer = this.getProducerWithLabel(data.label);\n    if (producer) {\n      logger.info(\"\\u{1F514} Closing Producer\", {\n        label: data.label,\n        producerId: producer.id\n      });\n      producer.close();\n      producer.on(\"trackended\", () => {\n        console.debug(\"\\u{1F514} Track Ended For the Producer\");\n      });\n      this.__sendTransport?.removeProducerById(producer.id);\n      closedStream = true;\n      this.socket.publish(\"closeProducer\", {\n        producerId: producer.id\n      });\n    }\n    const closedStreamLabel = data.label.startsWith(\"screen-share\") ? \"screen-share\" : data.label;\n    const stream = this.__activeStreams.get(closedStreamLabel);\n    if (stream) {\n      this.deviceHandler.stopStream(stream);\n      this.__activeStreams.delete(closedStreamLabel);\n      closedStream = true;\n    }\n    if (closedStream) {\n      this.emit(\"stream-closed\", {\n        label: data.label,\n        reason: {\n          code: 1200,\n          tag: \"STREAM_CLOSED\",\n          message: \"Stopped Streaming\"\n        }\n      });\n    }\n  };\n  /**\n   * Stops the underlying producing of a camera stream, stops the local track and closes the producer\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`\n   *\n   * @param data Data to stop producing { label: string }\n   */\n  disableVideo = async () => {\n    this.stopProducing({\n      label: \"video\"\n    });\n  };\n  /**\n   * Replaces the current video stream with the new stream\n   *\n   * if you have produced a stream with label `video` or used the default function `enableVideo` and you want to replace it with a new stream\n   * @param stream - New Video Stream\n   */\n  replaceVideoStream = async (stream) => {\n    await this.replaceStream({\n      label: \"video\",\n      newStream: stream\n    });\n  };\n  /**\n   * Changes the Video source to the given deviceId, sets the preferred cam device as the given deviceId\n   * @param deviceId\n   */\n  changeVideoSource = async (deviceId) => {\n    this.deviceHandler.setPreferredDevice({\n      deviceId,\n      deviceKind: \"cam\"\n    });\n    const stream = this.__activeStreams.get(\"video\");\n    if (!stream) {\n      return;\n    }\n    const { stream: newStream } = await this.deviceHandler.fetchStream({\n      mediaDeviceKind: \"cam\"\n    });\n    if (!newStream)\n      return;\n    await this.replaceVideoStream(newStream);\n  };\n  /**\n   * Replaces the current audio stream with the new stream\n   * if you have produced a stream with label `audio` or used the default function `enableAudio` and you want to replace it with a new stream\n   * @param stream - New Audio Stream\n   *\n   */\n  replaceAudioStream = async (stream) => {\n    await this.replaceStream({\n      label: \"audio\",\n      newStream: stream\n    });\n  };\n  /**\n   * Replace the current stream with the new stream based on the label used to produce the stream\n   *\n   * @example\n   * For Video\n   * await localPeer.replaceStream({\n   *  label: 'video',\n   *  newStream: newStream\n   * })\n   *\n   * For Screen-Share\n   * await localPeer.replaceStream({\n   *  label: 'screen-share-video',\n   *  newStream: newStream\n   * })\n   *\n   * If any custom label used\n   * await localPeer.replaceStream({\n   *  label: 'custom',\n   *  newStream: newStream\n   * })\n   *\n   * @param data - { label: string, newStream: MediaStream }\n   */\n  replaceStream = async (data) => {\n    logger.info(`\\u{1F514} Replacing ${data.label} Stream `);\n    const producer = this.getProducerWithLabel(data.label);\n    const track = data.newStream.getTracks()[0];\n    if (track) {\n      track.addEventListener(\"ended\", () => {\n        this.stopProducing({ label: data.label });\n      });\n    }\n    if (producer) {\n      await producer.replaceTrack({ track });\n    }\n    const closedStreamLabel = data.label.startsWith(\"screen-share\") ? \"screen-share\" : data.label;\n    const prevStream = this.__activeStreams.get(closedStreamLabel);\n    if (prevStream && !this.__waitingToProduce.has(closedStreamLabel)) {\n      this.deviceHandler.stopStream(prevStream);\n      this.__activeStreams.delete(closedStreamLabel);\n      this.__activeStreams.set(closedStreamLabel, data.newStream);\n    } else if (prevStream && this.__waitingToProduce.has(closedStreamLabel)) {\n      for (const track2 of prevStream.getTracks()) {\n        prevStream.removeTrack(track2);\n        track2.stop();\n      }\n      for (const track2 of data.newStream.getTracks()) {\n        prevStream.addTrack(track2);\n      }\n    }\n    const mediaDeviceKind = (0,_chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_1__.getMediaDeviceKind)(track);\n    this.emit(\"stream-fetched\", {\n      label: data.label,\n      stream: data.newStream,\n      mediaKind: mediaDeviceKind\n    });\n  };\n  /**\n   * Changes the Audio source to the given deviceId, sets the preferred mic device as the given deviceId\n   * @param deviceId\n   */\n  changeAudioSource = async (deviceId) => {\n    this.deviceHandler.setPreferredDevice({\n      deviceId,\n      deviceKind: \"mic\"\n    });\n    const stream = this.__activeStreams.get(\"audio\");\n    if (!stream) {\n      return;\n    }\n    const { stream: newStream } = await this.deviceHandler.fetchStream({\n      mediaDeviceKind: \"mic\"\n    });\n    if (!newStream)\n      return;\n    await this.replaceAudioStream(newStream);\n  };\n  /**\n   * Stops the underlying producing of a microphone stream, stops the local track and closes the producer\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`\n   */\n  disableAudio = async () => {\n    this.stopProducing({\n      label: \"audio\"\n    });\n  };\n  /**\n   * Stops the underlying producing of a screen-share stream, stops the local track and closes the producer\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`\n   */\n  stopScreenShare = async () => {\n    try {\n      this.stopProducing({\n        label: \"screen-share-video\"\n      });\n      this.stopProducing({\n        label: \"screen-share-audio\"\n      });\n    } catch (error) {\n      logger.error(error);\n      logger.error(\"Error Disabling Screen Share\");\n    }\n  };\n  /**\n   * Consumes a stream with the producerId and peerId of the RemotePeer, appData is application level custom data which\n   * can be added to the consumer for the LocalPeer, this data will be available in the consumer object and can be used only by the LocalPeer.\n   *\n   * `NOTE: This will not notify the RemotePeers that you are consuming a stream, you have to notify them manually`\n   * @summary Every time a RemotePeer is producing a Media in the Room, LocalPeer will be notified about it and it will be able to consume it.\n   * Consuming is a process where the media is received from the RemotePeer and the stream can be played on the LocalPeers device.\n   *\n   * To get the consumer back you can use\n   *\n   * const remotePeer = this.room.getRemotePeerById(data.peerId);\n   *\n   * `remotePeer.on('stream-playable', ({ label: string; consumer: Consumer }) => {})`\n   *\n   * @param data - {peerId: string, label: string, appData: Record<string, unknown>}\n   *\n   */\n  consume = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    canConsume: true\n  }).validate(\n    async (data) => {\n      const remotePeer = this.__remotePeers.get(data.peerId);\n      if (!remotePeer) {\n        throw new Error(`Remote Peer Not Found with PeerId ${data.peerId}`);\n      }\n      const labelData = remotePeer.getLabelData(data.label);\n      if (!labelData) {\n        throw new Error(\n          `Remote Peer is not producing with Label ${data.label}`\n        );\n      }\n      const consumerExists = remotePeer.getConsumer(data.label);\n      if (consumerExists?.consuming) {\n        logger.warn(\"\\u{1F514} Consumer Already Exists with label \", data.label);\n        return consumerExists;\n      }\n      const pendingPromise = this.__pendingConsumerTasks.get(\n        labelData?.producerId\n      );\n      if (pendingPromise) {\n        logger.warn(\n          `\\u{1F514} Consumer Task Pending to be Consumed with label ${data.label}, Returning`\n        );\n        const consumer2 = await pendingPromise;\n        return consumer2;\n      }\n      logger.info(\"\\u{1F514} Consuming Stream with label \", data.label);\n      if (!this.__recvTransport) {\n        logger.info(\n          \"\\u{1F514} Recv Transport Not Initialized, Creaitng RecvTransport\"\n        );\n        await this.__createTransportOnServer({\n          transportType: \"recv\"\n        });\n      }\n      const consumerPromise = new Promise((resolve) => {\n        const handleStreamPlayable = (streamData) => {\n          if (streamData.label === data.label) {\n            remotePeer.off(\"stream-playable\", handleStreamPlayable);\n            resolve(streamData.consumer);\n          }\n        };\n        remotePeer.once(\"stream-playable\", handleStreamPlayable);\n        this.socket.publish(\"consume\", {\n          createConsumerData: {\n            appData: data.appData,\n            producerId: labelData.producerId,\n            producerPeerId: data.peerId\n          }\n        });\n      });\n      this.__pendingConsumerTasks.set(labelData.producerId, consumerPromise);\n      const consumer = await consumerPromise.catch((error) => {\n        logger.error(\"\\u274C Error Consuming Stream\");\n        logger.error(error);\n        throw error;\n      }).finally(() => {\n        this.__pendingConsumerTasks.delete(labelData.producerId);\n      });\n      return consumer;\n    }\n  );\n  /**\n   * Stops the underlying consuming of a stream for a particular label\n   *\n   * `NOTE: This does not notify the remote peers that you are not consuming a stream`\n   *\n   * @param data\n   */\n  stopConsuming = (data) => {\n    const remotePeer = this.room.getRemotePeerById(data.peerId);\n    if (!remotePeer.hasLabel(data.label)) {\n      logger.error(\n        `\\u274C Remote Peer is not producing anything with label: ${data.label}`\n      );\n      return;\n    }\n    const consumer = this.recvTransport.getConsumer(data);\n    if (!consumer) {\n      logger.error(\"\\u274C Consumer Not Found\", data);\n      return;\n    }\n    if (!consumer.consuming) {\n      logger.error(\"\\u274C You are not Consuming any Stream, Consumer Not Found\");\n      return;\n    }\n    const consumerId = consumer.id;\n    if (!consumerId) {\n      logger.error(\"\\u274C ConsumerId Not Found\");\n      return;\n    }\n    this.socket.publish(\"closeConsumer\", {\n      consumerId: consumer.id\n    });\n    remotePeer.emit(\"stream-closed\", {\n      label: data.label\n    });\n    this.recvTransport.closeConsumer(data);\n  };\n  /**\n   * Function to activate the volatile data messaging\n   * @throws {Error} If activation of notification fails.\n   */\n  activateSpeakerNotification = async () => {\n    logger.info(\"\\u{1F514} Activating Speaker Notification, size: '9'\");\n    const botDataProducer = this.__sendTransport?.dataProducers.get(\"bot\");\n    if (botDataProducer) {\n      logger.info(\"\\u{1F514} Bot Data Producer Already Exists\");\n      return;\n    }\n    const ongoingActiveSpeakerPromise = this.__pendingTasks.get(\"bot\");\n    if (ongoingActiveSpeakerPromise) {\n      logger.info(\"\\u{1F514} Bot Data Producer Task Already Pending\");\n      await ongoingActiveSpeakerPromise;\n    } else {\n      const activateNotificationPromise = async () => {\n        if (!this.__recvTransport) {\n          logger.info(\n            \"\\u{1F514} Recv Transport Not Initialized, Creating RecvTransport\"\n          );\n          await this.__createTransportOnServer({\n            transportType: \"recv\"\n          });\n        }\n        this.socket.publish(\"activateSpeakerNotification\", {\n          size: this.room.activeSpeakers.size\n        });\n      };\n      const promise = activateNotificationPromise();\n      this.__pendingTasks.set(\"bot\", promise);\n      await promise;\n    }\n  };\n  sendData = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    canSendData: true\n  }).validate(\n    (data) => {\n      if ((0,_chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_1__.estimateSize)(data.payload) > MAX_DATA_MESSAGE_SIZE) {\n        logger.error(\"\\u274C Data message exceeds 1kb in size\");\n        return;\n      }\n      this.socket.publish(\"sendData\", data);\n    }\n  );\n  produceData = () => {\n    logger.info(\"\\u{1F514} Producing Data,\");\n  };\n  /**\n   * Send Message to update the metadata of the Local Peer\n   *\n   * `NOTE: This will notify every user in the room about the metadata update`\n   */\n  updateMetadata = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    canUpdateMetadata: true\n  }).validate((data) => {\n    if (!this.joined) {\n      logger.error(\n        \"\\u274C Cannot Update Metadata, You have not joined the room yet\"\n      );\n      return;\n    }\n    const peerId = this.peerId;\n    if (!peerId) {\n      logger.error(\"\\u274C Cannot Update Metadata, PeerId Not Found\");\n      return;\n    }\n    const newMetadata = JSON.stringify(data);\n    this.socket.publish(\"updatePeerMetadata\", {\n      peerId,\n      metadata: newMetadata\n    });\n  });\n  /**\n   * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.\n   */\n  updateRole = (data) => {\n    try {\n      if (!this.joined) {\n        throw new Error(\n          \"\\u274C Cannot Update Role, You have not joined the room yet\"\n        );\n      }\n      if (data.role === this.role) {\n        logger.warn(\"\\u{1F514} Peer Role is already set to\", data.role);\n        return;\n      }\n      if (!this.peerId) {\n        logger.error(\n          \"\\u274C Cannot Update Role, PeerId Not Found, (You have not joined the room yet)\"\n        );\n        return;\n      }\n      this.socket.publish(\"updatePeerRole\", {\n        peerId: this.peerId,\n        role: data.role\n      });\n    } catch (error) {\n      logger.error(\"\\u{1F514} Error Updating Role\", data);\n      logger.error(error);\n    }\n  };\n  __handler = {\n    error: (data) => {\n      logger.error(\"\\u274C Error Event\");\n      logger.error(data);\n    },\n    /**\n     * When Huddle01 Node has successfully accepted the connection request\n     * it sents back some usefull metadata for the client to use\n     * at this point the socket is assumed to the connected and the localPeer is ready to join the room\n     *\n     * @param data - Data from server { peerId }\n     */\n    hello: (data) => {\n      logger.info(\"\\u2705 Hello From Server, Connection Success\");\n      logger.info(data);\n      this.peerId = data.peerId;\n      this.__permissions.updatePermissions(data.acl);\n      if (data.role)\n        this.__permissions.role = data.role;\n      this.emit(\"permissions-updated\", {\n        permissions: data.acl,\n        role: data.role\n      });\n      if (data.metadata) {\n        this.__updateMetadata(data.metadata);\n      }\n    },\n    waitingRoom: (data) => {\n      logger.info(\"\\u{1F514} Waiting Room\");\n      this.room.emit(\"room-waiting\", data);\n    },\n    /**\n     * @description Uponn successful joining of the room, the server sends back some usefull metadata such as remotePeers in the room.\n     * @emits \"room-joined\" - When the client has successfully joined the room.\n     * @emits \"join-error\" - When the client has failed to join the room.\n     * @param data - Data from server { roomId, roomInfo, routerRTPCapabilities, turnServer }\n     */\n    connectRoomResponse: async (data) => {\n      logger.info(\"\\u2705 Join Success Event\");\n      logger.info({ roomInfo: data.roomInfo });\n      try {\n        const { roomInfo, routerRTPCapabilities, turnServers } = data;\n        this.room.config = roomInfo.config;\n        this.room.metadata = roomInfo.metadata;\n        const deviceType = (0,mediasoup_client__WEBPACK_IMPORTED_MODULE_9__.detectDevice)();\n        if (!deviceType) {\n          logger.error(\n            \"\\u274C Device is not supported, valid devices are : 'Chrome111' | 'Chrome74' | 'Chrome70' | 'Chrome67' | 'Chrome55' | 'Firefox60' | 'Safari12' | 'Safari11' | 'Edge11' | 'ReactNativeUnifiedPlan' | 'ReactNative'\"\n          );\n          throw new Error(\"\\u274C Device is not supported\");\n        }\n        this.__device = new mediasoup_client__WEBPACK_IMPORTED_MODULE_9__.Device({ handlerName: deviceType });\n        await this.__device.load({\n          routerRtpCapabilities: routerRTPCapabilities\n        });\n        if (!this.device.loaded) {\n          throw new Error(\"\\u274C Cannot Load Device\");\n        }\n        this.emit(\"device-created\", { device: this.__device });\n        this.__setRemotePeers(roomInfo);\n        this.__setLobbyPeers(roomInfo);\n        if (turnServers.length) {\n          logger.info(\"\\u{1F514} Setting Turn Server\", turnServers);\n          this.__turn = [...turnServers, ...this.__turn];\n        }\n        this.room.state = \"connected\";\n        this.joined = true;\n        this.room.emit(\"room-joined\");\n      } catch (error) {\n        logger.error(\"\\u274C Error Joining Room\");\n        logger.error(error);\n        this.room.emit(\"room-joined-failed\", {\n          message: \"\\u274C Error Joining Room\",\n          status: \"ROOM_ERRORED\"\n        });\n      }\n      this.__handleWaitingToProduce();\n    },\n    /**\n     * @description update the remote peers in the room , remove the remote peers which are not in the room anymore\n     * @param roomInfo\n     */\n    syncMeetingStateResponse: async (roomInfo) => {\n      try {\n        logger.info(\"\\u2705 Client recovered after reconnecting\");\n        const { peers: latestPeers } = roomInfo;\n        const latestPeersSet = new Set(latestPeers.map((p) => p.peerId));\n        for (const [peerId, peer] of this.__remotePeers.entries()) {\n          if (!latestPeersSet.has(peerId)) {\n            for (const label of peer.labels) {\n              this.__closeRemotePeerConsumer({\n                peerId,\n                label\n              });\n            }\n            peer.close();\n            this.__remotePeers.delete(peerId);\n            this.room.emit(\"peer-left\", peerId);\n            return;\n          }\n          const latestPeerInfo = latestPeers.find((p) => p.peerId === peerId);\n          if (!latestPeerInfo)\n            return;\n          const newProducerSet = new Set(\n            latestPeerInfo.producers.map((p) => p.label)\n          );\n          for (const label of peer.labels) {\n            if (!newProducerSet.has(label)) {\n              this.__closeRemotePeerConsumer({ peerId, label });\n            }\n          }\n          const currentProducerSet = new Set(peer.producerIds);\n          for (const producer of latestPeerInfo.producers) {\n            if (!currentProducerSet.has(producer.id)) {\n              if (!this.__recvTransport || this.__recvTransport.connectionState === \"connected\") {\n                peer._addLabelData({\n                  producerId: producer.id,\n                  label: producer.label\n                });\n              } else {\n                this.__waitingToConsume.push(() => {\n                  return peer._addLabelData({\n                    producerId: producer.id,\n                    label: producer.label\n                  });\n                });\n              }\n            }\n          }\n        }\n        const filteredPeers = latestPeers.filter(\n          (latestPeer) => !this.__remotePeers.has(latestPeer.peerId) && latestPeer.peerId !== this.peerId\n        ).values();\n        for (const latestPeer of filteredPeers) {\n          const remotePeer = new RemotePeer_default({\n            peerId: latestPeer.peerId,\n            role: latestPeer.role,\n            metadata: latestPeer.metadata\n          });\n          const remoteProducers = latestPeer.producers;\n          for (const p of remoteProducers) {\n            if (!this.__recvTransport || this.__recvTransport.connectionState === \"connected\") {\n              remotePeer._addLabelData({ producerId: p.id, label: p.label });\n            } else {\n              this.__waitingToConsume.push(() => {\n                return remotePeer._addLabelData({\n                  producerId: p.id,\n                  label: p.label\n                });\n              });\n            }\n          }\n          this.__remotePeers.set(latestPeer.peerId, remotePeer);\n          this.room.emit(\"new-peer-joined\", { peer: remotePeer });\n        }\n      } catch (error) {\n        logger.error(\"\\u274C Error Syncing Meeting State, Can't Recover\");\n        logger.error(error);\n      }\n    },\n    /**\n     * Upon creation of server side transport, the server sends back some usefull metadata for the client to use\n     * to create a client side transport, i.e. `send | recv` Transport.\n     * @param data - Data from server { transportSDPInfo, transportType }\n     */\n    createTransportOnClient: async (data) => {\n      try {\n        const device = this.device;\n        if (!this.peerId)\n          throw new Error(\n            \"\\u274C Cannot Create Transport, No PeerId Found for the user.\"\n          );\n        const transport = _chunk_OKUP6CWC_js__WEBPACK_IMPORTED_MODULE_0__.Transport_default.create({\n          device,\n          peerId: this.peerId,\n          socket: this.socket,\n          sdpInfo: data.transportSDPInfo,\n          iceServers: this.__turn,\n          transportType: data.transportType\n        });\n        if (transport.transportType === \"send\") {\n          this.__sendTransport = transport;\n          this.__sendTransport.mediasoupTransport.on(\n            \"connectionstatechange\",\n            (connectionState) => {\n              if (connectionState === \"connected\") {\n                this.__handleWaitingToProduce();\n              }\n            }\n          );\n          this.emit(\"new-send-transport\", {\n            transport\n          });\n        }\n        if (transport.transportType === \"recv\") {\n          this.__recvTransport = transport;\n          this.__recvTransport.mediasoupTransport.on(\n            \"connectionstatechange\",\n            (connectionState) => {\n              if (connectionState === \"connected\") {\n                this.__handleWaitingToConsume();\n              }\n            }\n          );\n          this.emit(\"new-recv-transport\", {\n            transport\n          });\n        }\n      } catch (error) {\n        logger.error(\n          \"\\u274C Error Creating MediasoupTransport On Client, transportType\",\n          data.transportType\n        );\n        logger.error(error);\n      }\n    },\n    /**\n     * !Important\n     * When the server has successfully connected the transport, it sends a ack back to the client\n     * which handles the callback() function which triggers the process of creation of producer and consumer\n     * for reference see: packages/nezuko/src/Transport.ts\n     * @param data\n     */\n    connectTransportResponse: async (data) => {\n      logger.info(\n        `\\u2705 Connect ${data.transportType} Transport On Server Response`\n      );\n      try {\n        const transportType = data.transportType;\n        const transport = transportType === \"send\" ? this.__sendTransport : this.__recvTransport;\n        if (!transport) {\n          throw new Error(`${transportType} Transport Not Initialized`);\n        }\n        transport.emit(\"connectTransportResponse\");\n      } catch (error) {\n        logger.error(\"\\u274C Error Connecting Transport On Server Response\");\n        logger.error(error);\n      }\n    },\n    produceResponse: async (data) => {\n      logger.info(\"\\u2705 Produce Response\");\n      logger.info(data);\n      try {\n        const { peerId, producerId, label } = data;\n        if (peerId === this.peerId) {\n          this.sendTransport.resolvePendingProducerTask({\n            id: producerId,\n            label,\n            peerId\n          });\n        } else {\n          const remotePeer = this.room.getRemotePeerById(peerId);\n          if (!this.__recvTransport || this.__recvTransport.connectionState === \"connected\") {\n            remotePeer._addLabelData({\n              producerId,\n              label\n            });\n          } else {\n            this.__waitingToConsume.push(() => {\n              return remotePeer._addLabelData({\n                producerId,\n                label\n              });\n            });\n          }\n        }\n      } catch (error) {\n        logger.error(\"\\u274C Error Produce Response\");\n        logger.error(error);\n      }\n    },\n    produceDataResponse: async (data) => {\n      logger.info(\"\\u2705 Produce Data Response consumerIdFromServer:%o\", data.id);\n      logger.info(data);\n      try {\n        const {\n          id,\n          peerId,\n          dataProducerId,\n          label,\n          appData,\n          protocol,\n          sctpStreamParameters\n        } = data;\n        if (peerId === this.peerId && label !== \"bot\") {\n          this.sendTransport.resolvePendingProducerTask({\n            id: dataProducerId,\n            label,\n            peerId\n          });\n        }\n        const botDataConsumer = this.recvTransport.dataConsumers.get(label);\n        if (botDataConsumer) {\n          logger.error(\"\\u274C Bot Data Consumer Already Exists, Can't Create\", {\n            label\n          });\n          return;\n        }\n        const dataConsumer = await this.recvTransport.consumeData({\n          appData,\n          dataProducerId,\n          id,\n          label,\n          peerId,\n          protocol,\n          sctpStreamParameters\n        });\n        dataConsumer.on(\"message\", (message) => {\n          const parsedJsonData = JSON.parse(message);\n          const result = _chunk_SSCVNXAL_js__WEBPACK_IMPORTED_MODULE_6__.VolatileDataMessageSchema.safeParse(parsedJsonData);\n          if (result.success) {\n            this.emit(\"receive-volatile-data\", result.data);\n          } else {\n            throw new Error(\n              \"\\u274C Data Consumer Message Schema Validation Failed\"\n            );\n          }\n        });\n        if (label === \"bot\") {\n          this.__pendingTasks.delete(\"bot\");\n        }\n      } catch (error) {\n        logger.error(\"\\u274C Error Produce Data Response\");\n        logger.error({ error });\n      }\n    },\n    consumeResponse: async (data) => {\n      logger.info(\"\\u2705 Consume Response\");\n      logger.info({\n        id: data.consumerId,\n        label: data.label,\n        consumerId: data.consumerId,\n        producerPeerId: data.producerPeerId\n      });\n      try {\n        const remotePeer = this.room.getRemotePeerById(data.producerPeerId);\n        if (!remotePeer.hasLabel(data.label)) {\n          logger.error(\"\\u274C Remote Peer is not producing this label\", {\n            label: data.label\n          });\n          throw new Error(\n            `\\u274C Remote Peer is not producing this label: ${data.label}`\n          );\n        }\n        const { consumer, mediaSoupConsumer } = await this.recvTransport.consume(data);\n        remotePeer.emit(\"stream-playable\", {\n          consumer,\n          label: consumer.label\n        });\n        this.room.emit(\"stream-added\", {\n          label: consumer.label,\n          peerId: data.producerPeerId\n        });\n        this.socket.publish(\"resumeConsumer\", {\n          consumerId: data.consumerId,\n          producerPeerId: data.producerPeerId\n        });\n        mediaSoupConsumer.resume();\n      } catch (error) {\n        logger.error(\"\\u274C Error Consume Response\");\n        logger.error(error);\n        this.__pendingConsumerTasks.delete(data.producerId);\n      }\n    },\n    closeProducerSuccess: async (data) => {\n      logger.info(\"\\u2705 Producer Closed\", data);\n      if (this.peerId === data.peerId)\n        return;\n      const { peerId, label } = data;\n      try {\n        this.__closeRemotePeerConsumer({\n          peerId,\n          label\n        });\n      } catch (err) {\n        logger.error(\"\\u274C Error Closing Producer\");\n        logger.error(err);\n      }\n    },\n    closeConsumerSuccess: async (data) => {\n      logger.info(\"\\u2705 Consumer Closed, \", data);\n    },\n    restartTransportIceResponse: async (data) => {\n      const { transportType, iceParameters } = data;\n      logger.info(\"\\u2705 Restart Transport Ice Response \", transportType);\n      const transport = transportType === \"send\" ? this.__sendTransport : this.__recvTransport;\n      if (!transport) {\n        logger.error(`\\u274C ${transportType} Transport Not Found`);\n        return;\n      }\n      try {\n        await transport.mediasoupTransport.restartIce({ iceParameters });\n        logger.info(\"\\u2705 Restarted Ice for type: \", transportType);\n      } catch (error) {\n        logger.error(\"\\u274C Error Restarting Ice for type: \", transportType);\n        logger.error(error);\n      }\n    },\n    newPeerJoined: (data) => {\n      if (this.peerId === data.peerId)\n        return;\n      logger.info(\"\\u2705 New Peer Joined\", { data });\n      try {\n        const { peerId } = data;\n        const remotePeer = new RemotePeer_default({\n          peerId,\n          role: data.role,\n          metadata: data.metadata\n        });\n        this.__remotePeers.set(peerId, remotePeer);\n        const lobbyPeers = this.room.lobbyPeersMap;\n        if (lobbyPeers.has(peerId)) {\n          lobbyPeers.delete(peerId);\n          this.room.lobbyPeersMap = lobbyPeers;\n        }\n        this.room.emit(\"new-peer-joined\", { peer: remotePeer });\n      } catch (error) {\n        logger.error(\"\\u274C Error New Peer Joined\");\n        logger.error(error);\n      }\n    },\n    newLobbyPeer: (data) => {\n      try {\n        logger.info(\"\\u2705 New Lobby Peer\", { data });\n        this.room.newlobbyPeers = [data];\n      } catch (error) {\n        logger.error(\"\\u274C Error New Lobb Peer\");\n        logger.error(error);\n      }\n    },\n    newPermissions: (data) => {\n      try {\n        this.__permissions.updatePermissions(data);\n        this.emit(\"permissions-updated\", {\n          permissions: this.permissions\n        });\n      } catch (error) {\n        logger.error(\"\\u274C Error Updating Permissions\");\n        logger.error(error);\n      }\n    },\n    newRoomControls: (data) => {\n      logger.info(\"\\u2705 Received New Room Controls\", { data });\n      this.room.config = {\n        ...this.room.config,\n        [data.type]: data.value\n      };\n      this.room.emit(\"room-controls-updated\", data);\n    },\n    newPeerRole: (data) => {\n      logger.info(\"\\u2705 Received New Peer's Role\", { data });\n      try {\n        const { peerId, role } = data;\n        if (peerId === this.peerId) {\n          logger.info(\"\\u2705 Updating Local Peer's Role\");\n          this.__permissions.role = role;\n          this.emit(\"role-updated\", {\n            role\n          });\n          return;\n        }\n        const remotePeer = this.room.getRemotePeerById(peerId);\n        const prevRole = remotePeer.role || \"\";\n        remotePeer.role = role;\n        this.room.emit(\"room-role-updated\", {\n          peerId,\n          newRole: role,\n          prevRole\n        });\n      } catch (error) {\n        logger.error(\"\\u274C Error Updating Peer's Role\");\n        logger.error(error);\n      }\n    },\n    roomClosedProducers: (data) => {\n      logger.info(\"\\u2705 Received Room's Closed Producers\", { data });\n      try {\n        const { producers, reason } = data;\n        for (const producer of producers) {\n          const { label, peerId } = producer;\n          if (peerId === this.peerId) {\n            this.stopProducing({ label });\n            continue;\n          }\n          try {\n            const remotePeer = this.room.getRemotePeerById(peerId);\n            const consumer = this.recvTransport.getConsumer({\n              label,\n              peerId\n            });\n            if (consumer) {\n              this.recvTransport.closeConsumer({ label, peerId });\n              remotePeer._removeLabelData(label);\n              this.room.emit(\"stream-closed\", {\n                label,\n                peerId\n              });\n            }\n          } catch (error) {\n            logger.error(\"\\u274C Error Closing Producer\");\n            logger.error(error);\n          }\n        }\n        this.room.emit(\"room-notification\", reason);\n      } catch (error) {\n        logger.error(\"\\u274C Error Updating Room's Closed Producers\");\n        logger.error(error);\n      }\n    },\n    receiveData: (data) => {\n      logger.info(\"\\u2705 Received Data\", { data });\n      try {\n        this.emit(\"receive-data\", data);\n      } catch (error) {\n        logger.error(\"\\u274C Error Receive Data\");\n        logger.error(error);\n      }\n    },\n    peerMetadataUpdated: (data) => {\n      try {\n        logger.info(\"\\u2705 Metadata Updated\", { data });\n        const { peerId, metadata } = data;\n        if (this.peerId === peerId) {\n          this.__updateMetadata(data.metadata);\n          return;\n        }\n        const remotePeer = this.room.getRemotePeerById(peerId);\n        remotePeer.metadata = JSON.parse(metadata);\n      } catch (error) {\n        logger.error(\"\\u274C Error Updating Metadata\");\n        logger.error(error);\n      }\n    },\n    roomMetadataUpdated: (data) => {\n      logger.info(\"\\u2705 Room Metadata Updated\", { data });\n      try {\n        const { metadata } = data;\n        this.room.metadata = metadata;\n      } catch (error) {\n        logger.error(\"\\u274C Error Updating Room Metadata\");\n        logger.error(error);\n      }\n    },\n    peerLeft: (data) => {\n      logger.info(\"\\u2705 Peer Left\", { peerId: data.peerId });\n      try {\n        const { peerId } = data;\n        const remotePeer = this.room.getRemotePeerById(peerId);\n        const labels = remotePeer.labels;\n        for (const label of labels) {\n          this.__closeRemotePeerConsumer({\n            peerId: remotePeer.peerId,\n            label\n          });\n        }\n        remotePeer.close();\n        this.__remotePeers.delete(peerId);\n        this.room.emit(\"peer-left\", data.peerId);\n      } catch (error) {\n        logger.error(\"\\u274C Error Peer Left\");\n        logger.error(error);\n      }\n    },\n    lobbyPeerLeft: (data) => {\n      logger.info(\"\\u2705 Lobby Peer Left\", { peerId: data.peerId });\n      try {\n        const { peerId } = data;\n        const lobbyPeers = this.room.lobbyPeersMap;\n        if (lobbyPeers.has(peerId)) {\n          lobbyPeers.delete(peerId);\n          this.room.lobbyPeersMap = lobbyPeers;\n        }\n      } catch (error) {\n        logger.error(\"\\u274C Error Lobby Peer's Left\");\n        logger.error(error);\n      }\n    }\n  };\n  /**\n   * @description Creates a Producer, if send transport is not initialized, it creates one and then creates a producer\n   * @param data - Data to create a producer { label, stream, stopTrackOnClose, appData }\n   * @returns - Producer\n   */\n  __createProducer = async (data) => {\n    if (!this.__sendTransport) {\n      throw new Error(\"\\u274C Send Transport Not Initialized, Internal Error\");\n    }\n    const producer = await this.__sendTransport.produce({\n      stream: data.stream,\n      stopTrackOnClose: data.stopTrackOnClose ?? true,\n      label: data.label,\n      appData: {\n        ...data.appData,\n        label: data.label\n      }\n    });\n    producer.on(\"transportclose\", () => {\n      this.stopProducing({ label: data.label });\n    });\n    this.emit(\"stream-playable\", {\n      label: data.label,\n      producer\n    });\n    return producer;\n  };\n  __createTransportOnServer = async (data) => {\n    const pendingPromise = this.__pendingTransportTasks.get(data.transportType);\n    if (pendingPromise) {\n      logger.info(\n        `\\u{1F514} Transport Task Already Pending for this transportType ${data.transportType}`\n      );\n      return pendingPromise;\n    }\n    const { transportType } = data;\n    const promise = new Promise((resolve, reject) => {\n      const handleNewTransport = (data2) => {\n        if (data2.transport.transportType === transportType) {\n          this.__pendingTransportTasks.delete(transportType);\n          resolve(data2.transport);\n        }\n      };\n      if (transportType === \"send\") {\n        this.once(\"new-send-transport\", handleNewTransport);\n      }\n      if (transportType === \"recv\") {\n        this.once(\"new-recv-transport\", handleNewTransport);\n      }\n      const device = this.device;\n      const transport = data.transportType === \"send\" ? this.__sendTransport : this.__recvTransport;\n      if (transport) {\n        reject(\n          new Error(`\\u274C Transport Already Initialized, type: ${transportType}`)\n        );\n      }\n      logger.info(`\\u{1F514} Creating ${data.transportType} Transport On Server`);\n      this.socket.publish(\"createTransport\", {\n        sctpCapabilities: device.sctpCapabilities,\n        transportType\n      });\n    });\n    this.__pendingTransportTasks.set(data.transportType, promise);\n    return promise;\n  };\n  /**\n   * Sets the Remote Peers in the Room\n   * @param roomInfo\n   */\n  __setRemotePeers = (roomInfo) => {\n    this.__remotePeers.clear();\n    const { peers } = roomInfo;\n    for (const peer of peers) {\n      if (peer.peerId === this.peerId)\n        continue;\n      const remotePeer = new RemotePeer_default({\n        peerId: peer.peerId,\n        metadata: peer.metadata,\n        role: peer.role\n      });\n      const producers = peer.producers;\n      this.__remotePeers.set(peer.peerId, remotePeer);\n      producers.map((p) => {\n        if (!this.__recvTransport || this.__recvTransport.connectionState === \"connected\") {\n          remotePeer._addLabelData({\n            producerId: p.id,\n            label: p.label\n          });\n        } else {\n          this.__waitingToConsume.push(() => {\n            return remotePeer._addLabelData({\n              producerId: p.id,\n              label: p.label\n            });\n          });\n        }\n      });\n    }\n  };\n  /**\n   * Sets the Lobby Peers in the Room\n   * @param roomInfo - RoomInfo\n   */\n  __setLobbyPeers = (roomInfo) => {\n    this.room.lobbyPeers.clear();\n    const { lobbyPeers } = roomInfo;\n    this.room.newlobbyPeers = lobbyPeers;\n  };\n  /**\n   * Helper Function to close the consumer of a remote peer\n   * @param data - Data to close the consumer { peerId, label }\n   */\n  __closeRemotePeerConsumer = (data) => {\n    try {\n      const { peerId, label } = data;\n      const remotePeer = this.room.getRemotePeerById(peerId);\n      const consumer = this.recvTransport.getConsumer({\n        label,\n        peerId\n      });\n      if (consumer) {\n        this.recvTransport.closeConsumer({ label, peerId });\n        remotePeer._removeLabelData(label);\n      }\n      this.room.emit(\"stream-closed\", {\n        label,\n        peerId: data.peerId\n      });\n    } catch (error) {\n      logger.error(\"\\u274C Error Closing Remote Peer's Consumer\");\n      logger.error(error);\n    }\n  };\n  /**\n   * !important\n   * Handler Function to handle the waiting to produce tasks when user is joining\n   * the room with active stream, check if the user has valid permissions and based on\n   * that allows the user to produce the stream\n   */\n  __handleWaitingToProduce = () => {\n    try {\n      const permissions = this.permissions;\n      const closeStream = (label) => {\n        const stream = this.__activeStreams.get(label);\n        if (stream) {\n          this.deviceHandler.stopStream(stream);\n          this.__activeStreams.delete(label);\n          this.emit(\"stream-closed\", {\n            label,\n            reason: {\n              code: 4444,\n              message: \"User's Permissions Denied\",\n              tag: \"CLOSED_BY_ADMIN\"\n            }\n          });\n        }\n        this.__waitingToProduce.delete(label);\n      };\n      if (!permissions.canProduce) {\n        for (const [label, _] of this.__waitingToProduce) {\n          closeStream(label);\n        }\n        this.__waitingToProduce.clear();\n        return;\n      }\n      for (const [label, pendingStreamTask] of this.__waitingToProduce) {\n        if (label === \"video\" && !permissions.canProduceSources.cam) {\n          closeStream(label);\n          continue;\n        }\n        if (label === \"audio\" && !permissions.canProduceSources.mic) {\n          closeStream(label);\n          continue;\n        }\n        pendingStreamTask().catch((error) => {\n          logger.error(\n            \"\\u274C Error Producing Stream which was waiting to be produced with label :\",\n            label\n          );\n          logger.error(error);\n          closeStream(label);\n        });\n      }\n      this.__waitingToProduce.clear();\n    } catch (error) {\n      logger.error(\"\\u274C Error Handling Waiting To Produce\");\n      logger.error(error);\n    }\n  };\n  __handleWaitingToConsume = () => {\n    for (const consumeTask of this.__waitingToConsume) {\n      consumeTask().catch(() => {\n        logger.error(\"Unable to Consume after ice restart\");\n      });\n    }\n    this.__waitingToConsume = [];\n  };\n  testEvent = (data) => {\n    try {\n      if (!this.peerId) {\n        throw new Error(\"\\u274C Cannot Test Event, PeerId Not Found\");\n      }\n      this.socket.publish(\"testEvent\", {\n        break: data.break,\n        peerId: this.peerId\n      });\n    } catch (error) {\n      logger.error(\"\\u274C Error Test Event\");\n    }\n  };\n};\nvar LocalPeer_default = LocalPeer;\n\n// src/RemotePeer.ts\nvar logger2 = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_7__.mainLogger.createSubLogger(\"RemotePeer\");\nvar RemotePeer = class extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_8__.EnhancedEventEmitter {\n  /**\n   * peerId of the remote peer, this is unique for each peer\n   */\n  peerId;\n  /**\n   * Stores the Metadata for the Remote Peer.\n   */\n  __metadata = \"{}\";\n  /**\n   * Stores the Role of the Remote Peer.\n   */\n  __role = null;\n  /**\n   * Labels are the unique identifier for the media stream that the remote peer is producing\n   */\n  __labelsToProducerId = /* @__PURE__ */ new Map();\n  /**\n   * Returns the list of labels that the remote peer is producing\n   */\n  get labels() {\n    return Array.from(this.__labelsToProducerId.keys());\n  }\n  get producerIds() {\n    return Array.from(this.__labelsToProducerId.values()).map(\n      (labelData) => labelData.producerId\n    );\n  }\n  /**\n   * Role of the Peer.\n   * @returns The Role of the Peer which if passed in the options when creating the token\n   */\n  get role() {\n    if (!this.__role)\n      return null;\n    return this.__role;\n  }\n  set role(role) {\n    this.__role = role;\n    this.emit(\"role-updated\", {\n      role\n    });\n  }\n  /**\n   * Checks if the remote peer is producing the label\n   * @param label - Label to check if the remote peer is producing\n   * @returns - Returns true if the remote peer is producing the label\n   */\n  hasLabel(label) {\n    return this.__labelsToProducerId.has(label);\n  }\n  /**\n   * Returns the data associated to the label, this is the producerId\n   *\n   * @returns\n   * producerId - Unique identifier for the producer\n   */\n  getLabelData(label) {\n    return this.__labelsToProducerId.get(label);\n  }\n  /**\n   * Get the associated consumer for the label\n   * @param label - Unique identifier for the consumer e.g. `video` | `audio` | `screen-share-video` | string\n   * @returns Consumer | null\n   */\n  getConsumer(label) {\n    try {\n      const localPeer = LocalPeer_default.getInstance();\n      const consumer = localPeer.recvTransport.getConsumer({\n        label,\n        peerId: this.peerId\n      });\n      return consumer;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\n   * Returns the metadata associated to the RemotePeer\n   */\n  getMetadata() {\n    return this.__metadata;\n  }\n  /**\n   * Setter function to update the Remote Peer Metadata\n   *\n   * `NOTE: This will NOT notify other Remote Peers of the update`\n   */\n  set metadata(data) {\n    this.__metadata = data;\n    this.emit(\"metadata-updated\", {\n      metadata: data\n    });\n  }\n  /**\n   * Update the Permissions of the Remote Peer in the Room. This will emit an event `updated` with the updated permissions.\n   */\n  updatePermissions = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    admin: true\n  }).validate(async (data) => {\n    try {\n      logger2.info(\"\\u{1F514} Updating Permissions\", data);\n      const localPeer = LocalPeer_default.getInstance();\n      const socket = localPeer.socket;\n      socket.publish(\"updatePeerPermission\", {\n        peerId: this.peerId,\n        permission: data\n      });\n    } catch (error) {\n      logger2.error(\"\\u{1F514} Error Updating Permissions\");\n      logger2.error(error);\n    }\n  });\n  /**\n   * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.\n   */\n  updateRole = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_4__.checkPermissions)({\n    admin: true\n  }).validate((data) => {\n    try {\n      logger2.info(\"\\u{1F514} Updating Peer Role\", data);\n      if (data.role === this.__role) {\n        logger2.warn(\"\\u{1F514} Role is already set to\", data.role);\n        return;\n      }\n      const localPeer = LocalPeer_default.getInstance();\n      const socket = localPeer.socket;\n      socket.publish(\"updatePeerRole\", {\n        peerId: this.peerId,\n        role: data.role\n      });\n    } catch (error) {\n      logger2.error(\"\\u{1F514} Error Updating Role\", data);\n      logger2.error(error);\n    }\n  });\n  /**\n   * Removes all the states of the remote peer and clears memory;\n   *\n   * `NOTE`: You need to close consumers using the `recvTransport.closeConsumer` of the local peer\n   */\n  close = () => {\n    logger2.info(\"Closing Remote Peer\");\n    this.removeAllListeners();\n  };\n  constructor(data) {\n    super();\n    this.peerId = data.peerId;\n    if (data.metadata) {\n      this.metadata = JSON.parse(data.metadata);\n    }\n    if (data.role) {\n      this.__role = data.role;\n    }\n  }\n  /**\n   * @protected\n   * Add a New Label to the Remote Peer and associate it with the ProducerId\n   *\n   * `NOTE: This is used internally by the Peer`\n   *\n   * @param data - Data to add the new label `label` and the `producerId` to associate it with\n   */\n  _addLabelData = async (data) => {\n    const { label, producerId } = data;\n    this.__labelsToProducerId.set(label, { producerId });\n    try {\n      const autoConsume = _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_3__.Room_default.getInstance().autoConsume;\n      const localPeer = LocalPeer_default.getInstance();\n      if (autoConsume) {\n        logger2.debug(\n          \"AUTO CONSUME IS ENABLED, CONSUMING THE PRODUCER'S STREAM\"\n        );\n        localPeer.consume({\n          appData: {},\n          label,\n          peerId: this.peerId\n        });\n      } else {\n        this.emit(\"stream-available\", {\n          label,\n          labelData: {\n            producerId\n          }\n        });\n      }\n    } catch (error) {\n      logger2.error(\"\\u274C Error While Consuming\", {\n        label,\n        peerId: this.peerId\n      });\n      logger2.error(error);\n      this.emit(\"stream-available\", {\n        label,\n        labelData: {\n          producerId\n        }\n      });\n    }\n  };\n  /**\n   * @protected\n   * Remove a Label from the Remote Peer and emit a `stream-closed` event\n   *\n   * `NOTE: This is used internally by the Peer`\n   *\n   * @param data - Data to remove the label from the Remote Peer\n   */\n  _removeLabelData = (label, reason) => {\n    this.__labelsToProducerId.delete(label);\n    this.emit(\"stream-closed\", {\n      label,\n      reason\n    });\n  };\n};\nvar RemotePeer_default = RemotePeer;\n\n\n//# sourceMappingURL=chunk-BDLAILV7.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUJETEFJTFY3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUU2QjtBQUlBO0FBR0E7QUFHQTtBQUlBO0FBR0E7QUFHQTtBQUdBO0FBR0E7O0FBRTdCO0FBQ3dEO0FBQ3hELGFBQWEsMERBQVU7QUFDdkI7QUFDQSx5Q0FBeUMsb0VBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGlCQUFpQiw0REFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQiw4REFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkRBQTJELElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZSxtQkFBbUIsT0FBTztBQUM5RTtBQUNBLFlBQVksb0VBQWdCO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFnQixvRUFBZ0I7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0VBQWdCLEdBQUcsa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBZ0I7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9CQUFvQixPQUFPLFlBQVksWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZSxvQkFBb0IsT0FBTztBQUNwRjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsWUFBWSxvRUFBZ0I7QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPLGtEQUFrRCxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQWdCO0FBQzdCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsVUFBVSxnRUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRUFBZ0I7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQSwyQkFBMkIsOERBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFNLEdBQUcseUJBQXlCO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0NBQWtDO0FBQzNFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHlFQUF5QjtBQUNsRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrREFBK0QsTUFBTTtBQUNyRTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RCxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sd0RBQXdELG1CQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGNBQWM7QUFDakY7QUFDQTtBQUNBLHNCQUFzQixPQUFPLFdBQVcsb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDBEQUFVO0FBQ3hCLCtCQUErQixvRUFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvRUFBZ0I7QUFDdEM7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0VBQWdCO0FBQy9CO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0EsMEJBQTBCLDREQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaHVkZGxlMDErd2ViLWNvcmVAMS4wLjAtZGV2LjY2L25vZGVfbW9kdWxlcy9AaHVkZGxlMDEvd2ViLWNvcmUvZGlzdC9jaHVuay1CRExBSUxWNy5qcz9lMGUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFRyYW5zcG9ydF9kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLU9LVVA2Q1dDLmpzXCI7XG5pbXBvcnQge1xuICBlc3RpbWF0ZVNpemUsXG4gIGdldE1lZGlhRGV2aWNlS2luZFxufSBmcm9tIFwiLi9jaHVuay1HN1NJUVhaNC5qc1wiO1xuaW1wb3J0IHtcbiAgRGV2aWNlSGFuZGxlcl9kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLUxVN1QzVjVVLmpzXCI7XG5pbXBvcnQge1xuICBSb29tX2RlZmF1bHRcbn0gZnJvbSBcIi4vY2h1bmstTkVXNEZFSEUuanNcIjtcbmltcG9ydCB7XG4gIFBlcm1pc3Npb25zX2RlZmF1bHQsXG4gIGNoZWNrUGVybWlzc2lvbnNcbn0gZnJvbSBcIi4vY2h1bmstVjRTM042NkQuanNcIjtcbmltcG9ydCB7XG4gIFNvY2tldF9kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLUhWQkJNV0hGLmpzXCI7XG5pbXBvcnQge1xuICBWb2xhdGlsZURhdGFNZXNzYWdlU2NoZW1hXG59IGZyb20gXCIuL2NodW5rLVNTQ1ZOWEFMLmpzXCI7XG5pbXBvcnQge1xuICBtYWluTG9nZ2VyXG59IGZyb20gXCIuL2NodW5rLUVWWFdNQ05ULmpzXCI7XG5pbXBvcnQge1xuICBFbmhhbmNlZEV2ZW50RW1pdHRlclxufSBmcm9tIFwiLi9jaHVuay03T1RRQUZYRS5qc1wiO1xuXG4vLyBzcmMvTG9jYWxQZWVyLnRzXG5pbXBvcnQgeyBEZXZpY2UsIGRldGVjdERldmljZSB9IGZyb20gXCJtZWRpYXNvdXAtY2xpZW50XCI7XG52YXIgbG9nZ2VyID0gbWFpbkxvZ2dlci5jcmVhdGVTdWJMb2dnZXIoXCJMb2NhbFBlZXJcIik7XG52YXIgTUFYX0RBVEFfTUVTU0FHRV9TSVpFID0gMSAqIDEwMjQ7XG52YXIgTG9jYWxQZWVyID0gY2xhc3MgX0xvY2FsUGVlciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIExvY2FsUGVlciBJbnN0YW5jZSwgU2luZ2xldG9uIGNsYXNzLCBvbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGNhbiBiZSBjcmVhdGVkXG4gICAqL1xuICBzdGF0aWMgX19pbnN0YW5jZSA9IG51bGw7XG4gIC8qKlxuICAgKiBQZWVySWQgb2YgdGhlIGN1cnJlbnQgY2xpZW50LCBzcGVjaWZpYyB0byB0aGUgTG9jYWwgUGVlciB3aG8gam9pbmVkIHRoZSBtZWV0aW5nXG4gICAqXG4gICAqIGBOT1RFOiBVbnRpbCB5b3UgZG9udCBqb2luIHRoZSByb29tLCB0aGlzIHdpbGwgYmUgKm51bGwqYFxuICAgKi9cbiAgcGVlcklkID0gbnVsbDtcbiAgLyoqXG4gICAqIEN1cnJlbnQgRGV2aWNlcyBvZiB0aGUgY3VycmVudCBjbGllbnRcbiAgICogZS5nLiBDaHJvbWUsIEZpcmVmb3gsIFNhZmFyaSwgUmVhY3ROYXRpdmVcbiAgICovXG4gIF9fZGV2aWNlID0gbnVsbDtcbiAgLyoqXG4gICAqIFNlbmRUcmFuc3BvcnQgaGFuZGxlcyB0aGUgc2VuZGluZyBvZiBtZWRpYSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlclxuICAgKi9cbiAgX19zZW5kVHJhbnNwb3J0ID0gbnVsbDtcbiAgLyoqXG4gICAqIFJlY3ZUcmFuc3BvcnQgaGFuZGxlcyB0aGUgcmVjZWl2aW5nIG9mIG1lZGlhIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50XG4gICAqL1xuICBfX3JlY3ZUcmFuc3BvcnQgPSBudWxsO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vbSBpbnN0YW5jZSwgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSByb29tIGlzIG5vdCBjcmVhdGVkXG4gICAqXG4gICAqIEB0aHJvd3MgeyBFcnJvciB9IElmIHRoZSByb29tIGlzIG5vdCBjcmVhdGVkLCBDYWxsIGNyZWF0ZVJvb20oKSBtZXRob2QgYmVmb3JlIHlvdSBjYW4gYWNjZXNzIHRoZSByb29tIGluIHRoZSBMb2NhbFBlZXJcbiAgICovXG4gIGdldCByb29tKCkge1xuICAgIGNvbnN0IHJvb20gPSBSb29tX2RlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIXJvb20pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIFJvb20gTm90IEluaXRpYWxpemVkXCIpO1xuICAgIHJldHVybiByb29tO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHNvY2tldCBjb25uZWN0aW9uXG4gICAqIEB0aHJvd3MgeyBFcnJvciB9IElmIHRoZSBzb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGdldCBzb2NrZXQoKSB7XG4gICAgY29uc3Qgc29ja2V0ID0gU29ja2V0X2RlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIXNvY2tldClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgU29ja2V0IE5vdCBJbml0aWFsaXplZFwiKTtcbiAgICByZXR1cm4gc29ja2V0O1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdGUgUGVlcnMgTWFwLCBTdG9yZXMgYWxsIHRoZSByZW1vdGUgcGVlcnNcbiAgICovXG4gIGdldCBfX3JlbW90ZVBlZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnJvb20ucmVtb3RlUGVlcnM7XG4gIH1cbiAgLyoqXG4gICAqIFR1cm4gU2VydmVyIHVzZWQgZm9yIHRoaXMgY2xpZW50XG4gICAqL1xuICBfX3R1cm4gPSBbXG4gICAge1xuICAgICAgdXNlcm5hbWU6IFwidGVzdC10dXJuXCIsXG4gICAgICB1cmxzOiBcInR1cm46dHVybi5odWRkbGUwMS5jb206NDQzP3RyYW5zcG9ydD11ZHBcIixcbiAgICAgIGNyZWRlbnRpYWw6IFwidGVzdC10dXJuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHVzZXJuYW1lOiBcInRlc3QtdHVyblwiLFxuICAgICAgdXJsczogXCJ0dXJuOnR1cm4uaHVkZGxlMDEuY29tOjQ0Mz90cmFuc3BvcnQ9dGNwXCIsXG4gICAgICBjcmVkZW50aWFsOiBcInRlc3QtdHVyblwiXG4gICAgfVxuICBdO1xuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGRldmljZSAoIGNocm9tZSwgZmlyZWZveCwgc2FmYXJpLCByZWFjdG5hdGl2ZSApIGZvciB0aGlzIGNsaWVudFxuICAgKlxuICAgKiBAdGhyb3dzIHsgRXJyb3IgfSBJZiB0aGUgZGV2aWNlIGlzIG5vdCBpbml0aWFsaXplZFxuICAgKi9cbiAgZ2V0IGRldmljZSgpIHtcbiAgICBpZiAoIXRoaXMuX19kZXZpY2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZXZpY2UgTm90IEluaXRpYWxpemVkXCIpO1xuICAgIGNvbnN0IGxvYWRlZCA9IHRoaXMuX19kZXZpY2UubG9hZGVkO1xuICAgIGlmICghbG9hZGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGV2aWNlIE5vdCBMb2FkZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuX19kZXZpY2U7XG4gIH1cbiAgLy8gIWltcG9ydGFudFxuICAvLyBDb25zdW1lciBjcmVhdGlvbiB0YXNrcyBhd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuXG4gIC8vIFN0b3JlcyB0aGUgbGFibGVzIG9mIHRoZSBwZW5kaW5nIGNvbnN1bWVycyB7IHByb2R1Y2VySWQ6IHN0cmluZyA9PT4gUHJvbWlzZTxDb25zdW1lcj4gfVxuICBfX3BlbmRpbmdDb25zdW1lclRhc2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gIWltcG9ydGFudFxuICAvLyBQcm9kdWNlciBjcmVhdGlvbiB0YXNrcyBhd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuXG4gIC8vIFN0b3JlcyB0aGUgbGFibGVzIG9mIHRoZSBwZW5kaW5nIHByb2R1Y2VycyB7IGxhYmVsOiBzdHJpbmcgfVxuICAvLyBVc2VkIHRvIGhhbmRsZSB0cmFuc3BvcnQgY2FsbGJhY2tzIG1vc3QgaW1wb3J0YW50O1xuICBfX3BlbmRpbmdQcm9kdWNlclRhc2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gIWltcG9ydGFudFxuICAvLyBNYXAgdG8gc3RvcmUgcGVuZGluZyB0YXNrcywgU3RvcmVzIHRoZSBsYWJlbCBhbmQgdGhlIHByb21pc2Ugb2YgdGhlIHRhc2tcbiAgX19wZW5kaW5nVGFza3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUGVuZGluZyBUcmFuc3BvcnQgVGFza3MsIFN0b3JlcyB0aGUgdHJhbnNwb3J0VHlwZSBhbmQgdGhlIHByb21pc2Ugb2YgdGhlIHRyYW5zcG9ydFxuICAgKlxuICAgKiBgTk9URTogVXNlZnVsIHRvIGNoZWNrIGlmIHRoZSB0cmFuc3BvcnQgaXMgYWxyZWFkeSBiZWluZyBjcmVhdGVkIGFuZCBwYXVzZSBhbGwgcHJvZHVjaW5nXG4gICAqIGFuZCBjb25zdW1pbmcgdW50aWwgdGhlIHRyYW5zcG9ydCBpcyBjcmVhdGVkYFxuICAgKi9cbiAgX19wZW5kaW5nVHJhbnNwb3J0VGFza3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogU3RvcmVzIGFsbCB0aGUgcGVuZGluZyBmZXRjaGluZyBzdHJlYW0gdGFza3Mgd2hpY2ggYXJlIGF3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgKiBJZiBmZXRjaGluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYXQgb25jZSwgaXQgd2lsbCBoYW5kbGUgdGhlIGNvbmN1cnJlbmN5IGlzc3Vlc1xuICAgKi9cbiAgX19wZW5kaW5nRmV0Y2hpbmdTdHJlYW0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogU3RvcmVzIGFsbCB0aGUgcGVuZGluZyBwcm9kdWNlIHRhc2tzIHdoaWNoIGFyZSBhd2FpdGluZyB0byBiZSBwcm9jZXNzZWRcbiAgICogTW9zdGx5IHVzZWQgd2hlbiB0aGUgcm9vbSBpcyBub3Qgam9pbmVkIGFuZCBwcm9kdWNlIGZ1bmN0aW9uYWxpdHkgbmVlZHMgdG8gYmUgaGFuZGxlZFxuICAgKlxuICAgKiBDYXNlcyBzdWNoIGFzIHNvY2tldCBleHBlcmllbmNpbmcgYSByZWNvbm5lY3QgYW5kIHByb2R1Y2UgaXMgY2FsbGVkLlxuICAgKiBPciBpbiB0aGUgY2FzZXMgd2hlcmUgcm9vbSBpcyBub3Qgam9pbmVkIGFuZCBlbmFibGVWaWRlbyBvciBlbmFibGVBdWRpbyBpcyBjYWxsZWRcbiAgICovXG4gIF9fd2FpdGluZ1RvUHJvZHVjZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBTdG9yZXMgYWxsIHRoZSBwZW5kaW5nIGNvbnN1bWUgdGFza3Mgd2hpY2ggYXJlIHdhaXRpbmcgZm9yIHJlY3YgdHJhbnNwb3J0IHRvIGJlIHJlLWNvbm5lY3RlZFxuICAgKi9cbiAgX193YWl0aW5nVG9Db25zdW1lID0gW107XG4gIC8qKlxuICAgKiBEZXZpY2VIYW5kbGVyIEluc3RhbmNlLCBIYW5kbGVzIHRoZSBtZWRpYSBkZXZpY2VzIGZvciB0aGlzIGNsaWVudFxuICAgKiBlLmcuIENhbWVyYSwgTWljcm9waG9uZVxuICAgKi9cbiAgZGV2aWNlSGFuZGxlciA9IG5ldyBEZXZpY2VIYW5kbGVyX2RlZmF1bHQoKTtcbiAgLyoqXG4gICAqIEFjdGl2ZVN0cmVhbSBNYXAgaG9sZHMgTWVkaWFTdHJlYW0gYXMgVmFsdWUgYW5kIEtleSBhcyBMYWJlbFxuICAgKi9cbiAgX19hY3RpdmVTdHJlYW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIEhhbmRsZSB0aGUgQ2xpZW50IFNpZGUgUGVybWlzc2lvbiBmb3IgdGhlIExvY2FsIFBlZXIuXG4gICAqL1xuICBfX3Blcm1pc3Npb25zID0gUGVybWlzc2lvbnNfZGVmYXVsdC5jcmVhdGVJbnN0YW5jZSgpO1xuICAvKipcbiAgICogU3RvcmVzIHRoZSBNZXRhZGF0YSBmb3IgdGhlIExvY2FsIFBlZXIuXG4gICAqL1xuICBfX21ldGFkYXRhID0gbnVsbDtcbiAgLyoqXG4gICAqIFZhcmlhYmxlIHRvIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBqb2luZWQgdGhlIHJvb21cbiAgICovXG4gIGpvaW5lZCA9IGZhbHNlO1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBsYWJlbHMgb2YgdGhlIE1lZGlhIFN0cmVhbSB0aGF0IHRoZSBMb2NhbCBQZWVyIGlzIHByb2R1Y2luZyB0byB0aGUgcm9vbVxuICAgKi9cbiAgZ2V0IGxhYmVscygpIHtcbiAgICBjb25zdCBzZW5kVHJhbnNwb3J0ID0gdGhpcy5fX3NlbmRUcmFuc3BvcnQ7XG4gICAgaWYgKHNlbmRUcmFuc3BvcnQpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IEFycmF5LmZyb20oc2VuZFRyYW5zcG9ydC5sYWJlbFRvUHJvZHVjZXJJZC5rZXlzKCkpO1xuICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIFBlcm1pc3Npb25zIG9mIHRoZSBMb2NhbCBQZWVyLiAoZS5nIGNhblByb2R1Y2UsIGNhbkNvbnN1bWUsIGNhblNlbmREYXRhLCBjYW5SZWN2RGF0YSBldGMpXG4gICAqL1xuICBnZXQgcGVybWlzc2lvbnMoKSB7XG4gICAgY29uc3QgYWNsID0gdGhpcy5fX3Blcm1pc3Npb25zLmFjbDtcbiAgICByZXR1cm4gYWNsO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIFJvbGUgb2YgdGhlIExvY2FsIFBlZXIuXG4gICAqL1xuICBnZXQgcm9sZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Blcm1pc3Npb25zLnJvbGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRva2VuIG9mIHRoZSBjdXJyZW50IHNvY2tldCBjb25uZWN0aW9uLCBzcGVjaWZpYyB0byB0aGUgTG9jYWwgUGVlciB3aG8gam9pbmVkIHRoZSBtZWV0aW5nXG4gICAqL1xuICBnZXQgdG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ja2V0LnRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb29tSWQgb2YgdGhlIGN1cnJlbnQgam9pbmVkIHJvb20uXG4gICAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLnJvb20ucm9vbUlkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBTZW5kVHJhbnNwb3J0XG4gICAqIEByZXR1cm5zIHsgVHJhbnNwb3J0IH0gU2VuZFRyYW5zcG9ydFxuICAgKiBAdGhyb3dzIHsgRXJyb3IgfSBJZiB0aGUgU2VuZFRyYW5zcG9ydCBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGdldCBzZW5kVHJhbnNwb3J0KCkge1xuICAgIGlmICghdGhpcy5fX3NlbmRUcmFuc3BvcnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIFRyYW5zcG9ydCBOb3QgSW5pdGlhbGl6ZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuX19zZW5kVHJhbnNwb3J0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWN2VHJhbnNwb3J0XG4gICAqIEByZXR1cm5zIHsgVHJhbnNwb3J0IH0gcmVjdlRyYW5zcG9ydFxuICAgKiBAdGhyb3dzIHsgRXJyb3IgfSBJZiB0aGUgcmVjdlRyYW5zcG9ydCBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGdldCByZWN2VHJhbnNwb3J0KCkge1xuICAgIGlmICghdGhpcy5fX3JlY3ZUcmFuc3BvcnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWN2IFRyYW5zcG9ydCBOb3QgSW5pdGlhbGl6ZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuX19yZWN2VHJhbnNwb3J0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSBMb2NhbFBlZXJcbiAgICovXG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHRoaXMuX19tZXRhZGF0YSB8fCBcInt9XCIpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBnZXRTdHJlYW0gcmV0dXJucyB0aGUgc3RyZWFtIHdpdGggdGhlIGdpdmVuIGxhYmVsXG4gICAqL1xuICBnZXRTdHJlYW0gPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX19hY3RpdmVTdHJlYW1zLmdldChkYXRhLmxhYmVsKTtcbiAgICBpZiAoc3RyZWFtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9O1xuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB0byB0aGUgTG9jYWxQZWVyLCBUcmlnZ2VycyB0aGUgYG1ldGFkYXRhLXVwZGF0ZWRgIGV2ZW50XG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgX191cGRhdGVNZXRhZGF0YSA9IChtZXRhZGF0YSkgPT4ge1xuICAgIHRoaXMuX19tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIGNvbnN0IHBhcnNlID0gSlNPTi5wYXJzZShtZXRhZGF0YSk7XG4gICAgdGhpcy5lbWl0KFwibWV0YWRhdGEtdXBkYXRlZFwiLCB7XG4gICAgICBtZXRhZGF0YTogcGFyc2VcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y2VyIHdpdGggdGhlIGdpdmVuIGxhYmVsXG4gICAqIEBwYXJhbSBsYWJlbCAtIElkZW50aWZpZXIgb2YgdGhlIHByb2R1Y2VyXG4gICAqIEByZXR1cm5zIHsgUHJvZHVjZXIgfSBQcm9kdWNlclxuICAgKiBAcmV0dXJucyB7IG51bGwgfSBJZiB0aGUgcHJvZHVjZXIgaXMgbm90IGZvdW5kXG4gICAqL1xuICBnZXRQcm9kdWNlcldpdGhMYWJlbCA9IChsYWJlbCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9kdWNlcklkID0gdGhpcy5fX3NlbmRUcmFuc3BvcnQ/LmxhYmVsVG9Qcm9kdWNlcklkLmdldChsYWJlbCk7XG4gICAgICBpZiAocHJvZHVjZXJJZCkge1xuICAgICAgICBjb25zdCBwcm9kdWNlciA9IHRoaXMuc2VuZFRyYW5zcG9ydC5nZXRQcm9kdWNlckJ5SWQocHJvZHVjZXJJZCk7XG4gICAgICAgIHJldHVybiBwcm9kdWNlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIENhbm5vdCBGaW5kIFByb2R1Y2VyIFdpdGggSWRlbnRpZmllcjogXCIsIGxhYmVsKTtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgdGhlIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHNvY2tldCAtIFNvY2tldCBJbnN0YW5jZVxuICAgKi9cbiAgX19yZWdpc3RlckhhbmRsZXJFdmVudHMgPSAoc29ja2V0KSA9PiB7XG4gICAgbGV0IGNudCA9IDA7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX19oYW5kbGVyKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmbiA9IHRoaXMuX19oYW5kbGVyW2tleV07XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICBzb2NrZXQuc3Vic2NyaWJlKGtleSwgZm4pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBcXHUyNzRDIEVycm9yIFJlZ2lzdGVyZWQgRm9yIEV2ZW50OiAke2tleX1gKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGNudCsrO1xuICAgIH1cbiAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgTG9jYWxQZWVyRXZlbnRIYW5kbGVyIFJlZ2lzdGVyZWRcIik7XG4gIH07XG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgaWYgKF9Mb2NhbFBlZXIuX19pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIF9Mb2NhbFBlZXIuX19pbnN0YW5jZTtcbiAgICB9XG4gICAgX0xvY2FsUGVlci5fX2luc3RhbmNlID0gbmV3IF9Mb2NhbFBlZXIoKTtcbiAgICByZXR1cm4gX0xvY2FsUGVlci5fX2luc3RhbmNlO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICBpZiAoIV9Mb2NhbFBlZXIuX19pbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWxQZWVyIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9Mb2NhbFBlZXIuX19pbnN0YW5jZTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3RlckhhbmRsZXJFdmVudHModGhpcy5zb2NrZXQpO1xuICAgIHRoaXMuc29ja2V0Lm9uKFwicmVjb25uZWN0ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fX3JlZ2lzdGVySGFuZGxlckV2ZW50cyh0aGlzLnNvY2tldCk7XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwic3luY01lZXRpbmdTdGF0ZVwiLCB2b2lkIDApO1xuICAgICAgaWYgKHRoaXMuX19zZW5kVHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJyZXN0YXJ0VHJhbnNwb3J0SWNlXCIsIHtcbiAgICAgICAgICB0cmFuc3BvcnRJZDogdGhpcy5fX3NlbmRUcmFuc3BvcnQubWVkaWFzb3VwVHJhbnNwb3J0LmlkLFxuICAgICAgICAgIHRyYW5zcG9ydFR5cGU6IFwic2VuZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19yZWN2VHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJyZXN0YXJ0VHJhbnNwb3J0SWNlXCIsIHtcbiAgICAgICAgICB0cmFuc3BvcnRJZDogdGhpcy5fX3JlY3ZUcmFuc3BvcnQubWVkaWFzb3VwVHJhbnNwb3J0LmlkLFxuICAgICAgICAgIHRyYW5zcG9ydFR5cGU6IFwicmVjdlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBjdXJyZW50IHBlZXIsIGNsb3NlcyBhbGwgdGhlIHRyYW5zcG9ydHMsIHByb2R1Y2VycyBhbmQgY29uc3VtZXJzXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIC0gQ2xvc2UgQ29kZVxuICAgKi9cbiAgY2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5fX2RldmljZSA9IG51bGw7XG4gICAgdGhpcy5fX3BlbmRpbmdDb25zdW1lclRhc2tzLmNsZWFyKCk7XG4gICAgdGhpcy5fX3BlbmRpbmdQcm9kdWNlclRhc2tzLmNsZWFyKCk7XG4gICAgdGhpcy5fX3BlbmRpbmdUcmFuc3BvcnRUYXNrcy5jbGVhcigpO1xuICAgIHRoaXMuX19wZW5kaW5nRmV0Y2hpbmdTdHJlYW0uY2xlYXIoKTtcbiAgICB0aGlzLl9fd2FpdGluZ1RvUHJvZHVjZS5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHRoaXMuX19hY3RpdmVTdHJlYW1zLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHN0cmVhbS5nZXRUcmFja3MoKSlcbiAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgIH1cbiAgICB0aGlzLmpvaW5lZCA9IGZhbHNlO1xuICAgIHRoaXMuZGV2aWNlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMuX19zZW5kVHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl9fc2VuZFRyYW5zcG9ydC5jbG9zZSh7IHJldHJpZXM6IDMgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fcmVjdlRyYW5zcG9ydCkge1xuICAgICAgdGhpcy5fX3JlY3ZUcmFuc3BvcnQuY2xvc2UoeyByZXRyaWVzOiAzIH0pO1xuICAgIH1cbiAgICB0aGlzLl9fc2VuZFRyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fX3JlY3ZUcmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX19wZXJtaXNzaW9ucy5yZXNldCgpO1xuICAgIHRoaXMuZW1pdChcInBlcm1pc3Npb25zLXVwZGF0ZWRcIiwge1xuICAgICAgcGVybWlzc2lvbnM6IHRoaXMucGVybWlzc2lvbnMsXG4gICAgICByb2xlOiB0aGlzLnJvbGUgPz8gXCJcIlxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogTG9jYWxQZWVyIEhhbmRsZXIgRnVuY3Rpb25zIEJlZ2lucyBIZXJlIPCfkYdcbiAgICovXG4gIC8qKlxuICAgKiBQcm9kdWNlIGEgc3RyZWFtIHdpdGggYSBnaXZlbiBsYWJlbCBhbmQgYXBwRGF0YSB0byBhbGwgdGhlIFJlbW90ZSBQZWVyc1xuICAgKlxuICAgKiBgY2FuUHJvZHVjZSBtdXN0IGJlIHRydWUgdG8gcHJvZHVjZSBhIHN0cmVhbWBcbiAgICpcbiAgICogYE5PVEU6IFRoaXMgd2lsbCBub3RpZnkgYWxsIHRoZSBSZW1vdGVQZWVycyB0aGF0IHRoaXMgcHJvZHVjZXIgaGFzIHN0YXJ0ZWQgcHJvZHVjaW5nIGFuZCB0aGV5IHNob3VsZCBzdGFydCBjb25zdW1pbmcgaXQgaWYgdGhleSB3YW50IHRvYFxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gcHJvZHVjZSBhIHN0cmVhbVxuICAgKiAgLSBgbGFiZWxgIC0gVW5pcXVlIElkZW50aWZpZXIgZm9yIHRoZSBzdHJlYW0gKCBzdHJpbmcgKVxuICAgKiAgLSBgc3RyZWFtYCAtIE1lZGlhU3RyZWFtIHRvIHByb2R1Y2UgKCBNZWRpYVN0cmVhbSApXG4gICAqICAtIGBzdG9wVHJhY2tPbkNsb3NlYCAtIElmIHRydWUsIGl0IHdpbGwgc3RvcCB0aGUgdHJhY2sgd2hlbiB0aGUgcHJvZHVjZXIgaXMgY2xvc2VkIHVzaW5nIHN0b3BQcm9kdWNpbmcgKCBib29sZWFuIClcbiAgICogIC0gYGFwcERhdGFgIC0gQXBwbGljYXRpb24gbGV2ZWwgY3VzdG9tIGRhdGEgd2hpY2ggY2FuIGJlIGFkZGVkIHRvIHRoZSBwcm9kdWNlciBmb3IgdGhlIExvY2FsUGVlciwgdGhpcyBkYXRhIHdpbGwgYmUgYXZhaWxhYmxlIGluIHRoZSBwcm9kdWNlciBvYmplY3QgYW5kIGNhbiBiZSB1c2VkIG9ubHkgYnkgdGhlIExvY2FsUGVlci4gKCBVbmtub3duIE9iamVjdCApXG4gICAqXG4gICAqIEBzdW1tYXJ5IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBwcm9kdWNlIGEgc3RyZWFtIHdpdGggYSBnaXZlbiBsYWJlbCBhbmQgYXBwRGF0YSB0byBhbGwgdGhlIFJlbW90ZSBQZWVycyBpZiB0aGUgc2VuZCB0cmFuc3BvcnQgaXMgbm90IGluaXRpYWxpc2VkXG4gICAqIGl0IHdpbGwgY3JlYXRlIGEgc2VuZCB0cmFuc3BvcnQgYW5kIHRoZW4gcHJvZHVjZSB0aGUgc3RyZWFtIHdpdGggdGhlIGdpdmVuIGxhYmVsIGFuZCBhcHBEYXRhIHRvIGFsbCB0aGUgUmVtb3RlIFBlZXJzXG4gICAqXG4gICAqIFNlbmQgVHJhbnNwb3J0IGlzIGEgc2VjdXJlIGNoYW5uZWwgd2hpY2ggaXMgdXNlZCB0byBzZW5kIG1lZGlhIGZyb20gTG9jYWxQZWVyIHRvIGFsbCB0aGUgUmVtb3RlUGVlcnMgaW4gdGhlIHJvb21cbiAgICpcbiAgICogYGxvY2FsUGVlci5vbignbmV3LXByb2R1Y2VyJywgKHtsYWJlbDogc3RyaW5nOyBwcm9kdWNlcjogUHJvZHVjZXJ9KSA9PiB7fSlgXG4gICAqL1xuICBwcm9kdWNlID0gY2hlY2tQZXJtaXNzaW9ucyh7XG4gICAgY2FuUHJvZHVjZTogdHJ1ZVxuICB9KS52YWxpZGF0ZShcbiAgICBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSBkYXRhLnN0cmVhbS5nZXRUcmFja3MoKVswXTtcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RvcFByb2R1Y2luZyh7IGxhYmVsOiBkYXRhLmxhYmVsIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5qb2luZWQgfHwgdGhpcy5fX3NlbmRUcmFuc3BvcnQgJiYgdGhpcy5fX3NlbmRUcmFuc3BvcnQ/LmNvbm5lY3Rpb25TdGF0ZSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjb25zdCBmbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y2VyMiA9IGF3YWl0IHRoaXMucHJvZHVjZShkYXRhKS50aGVuKChkYXRhMikgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGRhdGEyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEyO1xuICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nUHJvZHVjZXJUYXNrcy5kZWxldGUoZGF0YS5sYWJlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9kdWNlcjI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9fd2FpdGluZ1RvUHJvZHVjZS5zZXQoZGF0YS5sYWJlbCwgZm4pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc3RyZWFtIH0gPSBkYXRhO1xuICAgICAgY29uc3QgcHJvZHVjZXJQcm9taXNlID0gdGhpcy5fX3BlbmRpbmdQcm9kdWNlclRhc2tzLmdldChkYXRhLmxhYmVsKTtcbiAgICAgIGlmIChwcm9kdWNlclByb21pc2UpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgXCJcXHV7MUY1MTR9IFByb2R1Y2VyIFRhc2sgQWxyZWFkeSBQZW5kaW5nIGZvciB0aGlzIGxhYmVsIFwiLFxuICAgICAgICAgIGRhdGEubGFiZWxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHJvZHVjZXIyID0gYXdhaXQgcHJvZHVjZXJQcm9taXNlO1xuICAgICAgICByZXR1cm4gcHJvZHVjZXIyO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fc2VuZFRyYW5zcG9ydCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9fY3JlYXRlVHJhbnNwb3J0T25TZXJ2ZXIoe1xuICAgICAgICAgIHRyYW5zcG9ydFR5cGU6IFwic2VuZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25nb2luZ1Byb21pc2UgPSB0aGlzLl9fcGVuZGluZ1Byb2R1Y2VyVGFza3MuZ2V0KGRhdGEubGFiZWwpO1xuICAgICAgaWYgKG9uZ29pbmdQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y2VyMiA9IGF3YWl0IG9uZ29pbmdQcm9taXNlO1xuICAgICAgICByZXR1cm4gcHJvZHVjZXIyO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX19jcmVhdGVQcm9kdWNlcih7XG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbGFiZWw6IGRhdGEubGFiZWwsXG4gICAgICAgIGFwcERhdGE6IHsgLi4uZGF0YS5hcHBEYXRhLCBsYWJlbDogZGF0YS5sYWJlbCB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19wZW5kaW5nUHJvZHVjZXJUYXNrcy5zZXQoZGF0YS5sYWJlbCwgcHJvbWlzZSk7XG4gICAgICBjb25zdCBwcm9kdWNlciA9IGF3YWl0IHByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIENyZWF0ZSBQcm9kdWNlciBGYWlsZWRcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgRXJyb3IgQ3JlYXRlIFByb2R1Y2VyIEZhaWxlZFwiKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1Byb2R1Y2VyVGFza3MuZGVsZXRlKGRhdGEubGFiZWwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvZHVjZXI7XG4gICAgfVxuICApO1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgbG9jYWwgd2ViIGNhbSBhbmQgc3RhcnRzIHByb2R1Y2luZyB0aGUgc3RyZWFtIHdpdGggdGhlIGxhYmVsIGB2aWRlb2BcbiAgICpcbiAgICogQHN1bW1hcnkgVGhpcyBmdW5jdGlvbnMgaGFuZGxlIHRoZSBwcm9kdWNpbmcgb2YgbWVkaWEgc3RyZWFtcyB0byBhbGwgdGhlIHJlbW90ZSBwZWVycyBpbiB0aGUgcm9vbS5cbiAgICogaXQgZW5hYmxlcyB0aGUgbG9jYWwgd2ViIGNhbSBmZXRjaGVzIHRoZSBzdHJlYW0gb3BlbnMgeW91IHdlYiBjYW0gaW5kaWNhdG9yIGxpZ2h0IG9uIHRoZSBkZXZpY2VcbiAgICogdXBvbiBzdWNjZXNzZnVsbCBmZXRjaGluZyBvZiB0aGUgc3RyZWFtIGl0IHByb2R1Y2VzIHRoZSBzdHJlYW0gd2l0aCB0aGUgbGFiZWwgYHZpZGVvYCBhbmQgYHN0b3BUcmFja09uQ2xvc2U6IHRydWVgIHRvIGFsbCB0aGUgcmVtb3RlIHBlZXJzIGluIHRoZSByb29tLlxuICAgKiB3aGVuIGNsb3NpbmcgdXNpbmcgZGlzYWJsZVZpZGVvIGl0IHdpbGwgc3RvcCB0aGUgbG9jYWwgdHJhY2sgYW5kIGNsb3NlIHRoZSBwcm9kdWNlciB3aGljaCB3aWxsIG5vdGlmeSBhbGwgdGhlIFJlbW90ZVBlZXJzIHRoYXQgdGhpcyBwcm9kdWNlciBoYXMgc3RvcHBlZCBwcm9kdWNpbmdcbiAgICogYW5kIHRoZXkgc2hvdWxkIHN0b3AgY29uc3VtaW5nIGl0LlxuICAgKlxuICAgKiBgTk9URTogWW91IGNhbiBvbmx5IHByb2R1Y2UgdG8gYSByb29tIHdoZW4geW91IGhhdmUgam9pbmVkIHRoZSByb29tLCBpZiB5b3UgdHJ5IHRvIHByb2R1Y2UgYmVmb3JlIGpvaW5pbmcgdGhlIHJvb20gaXQgd2lsbCB0aHJvdyBhbiBlcnJvcmBcbiAgICpcbiAgICogQHRocm93cyB7IEVycm9yIH0gSWYgdGhlIHN0cmVhbSBpcyBub3QgZm91bmRcbiAgICovXG4gIGVuYWJsZVZpZGVvID0gY2hlY2tQZXJtaXNzaW9ucyh7XG4gICAgY2FuUHJvZHVjZTogdHJ1ZVxuICB9KS52YWxpZGF0ZShhc3luYyAoY3VzdG9tVmlkZW9TdHJlYW0pID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnBlcm1pc3Npb25zLmNhblByb2R1Y2VTb3VyY2VzLmNhbSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIENhbm5vdCBFbmFibGUgVmlkZW8sIFBlcm1pc3Npb24gRGVuaWVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIENhbm5vdCBFbmFibGUgVmlkZW8sIFBlcm1pc3Npb24gRGVuaWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhpc3RpbmdTdHJlYW0gPSB0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoXCJ2aWRlb1wiKTtcbiAgICAgIGlmIChleGlzdGluZ1N0cmVhbSkge1xuICAgICAgICBsb2dnZXIud2FybihcIlxcdXsxRjUxNH0gQ2FtIFN0cmVhbSBBbHJlYWR5IEVuYWJsZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdHJlYW07XG4gICAgICBpZiAoY3VzdG9tVmlkZW9TdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtID0gY3VzdG9tVmlkZW9TdHJlYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbmdvaW5nU3RyZWFtUHJvbWlzZSA9IHRoaXMuX19wZW5kaW5nRmV0Y2hpbmdTdHJlYW0uZ2V0KFwiY2FtXCIpO1xuICAgICAgICBpZiAob25nb2luZ1N0cmVhbVByb21pc2UpIHtcbiAgICAgICAgICBhd2FpdCBvbmdvaW5nU3RyZWFtUHJvbWlzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzdHJlYW1Qcm9taXNlID0gdGhpcy5kZXZpY2VIYW5kbGVyLmZldGNoU3RyZWFtKHtcbiAgICAgICAgICAgIG1lZGlhRGV2aWNlS2luZDogXCJjYW1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX19wZW5kaW5nRmV0Y2hpbmdTdHJlYW0uc2V0KFwiY2FtXCIsIHN0cmVhbVByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlID0gdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5nZXQoXCJjYW1cIik7XG4gICAgICAgIGlmICghcGVuZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gUGVuZGluZyBQcm9taXNlIE5vdCBGb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdHJlYW06IGZldGNoZWRTdHJlYW0sIGVycm9yIH0gPSBhd2FpdCBwZW5kaW5nUHJvbWlzZTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBGZXRjaGluZyBTdHJlYW0gRnJvbSBEZXZpY2VcIik7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIEVycm9yIEZldGNoaW5nIFN0cmVhbSBGcm9tIERldmljZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZldGNoZWRTdHJlYW0pIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIFN0cmVhbSBOb3QgRm91bmQsIGNhbm5vdCBkbyBlbmFibGVWaWRlb1wiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIFN0cmVhbSBOb3QgRm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtID0gZmV0Y2hlZFN0cmVhbTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLnNldChcInZpZGVvXCIsIHN0cmVhbSk7XG4gICAgICB0aGlzLmVtaXQoXCJzdHJlYW0tZmV0Y2hlZFwiLCB7XG4gICAgICAgIG1lZGlhS2luZDogXCJjYW1cIixcbiAgICAgICAgbGFiZWw6IFwidmlkZW9cIixcbiAgICAgICAgc3RyZWFtXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvZHVjZSh7XG4gICAgICAgIGxhYmVsOiBcInZpZGVvXCIsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYXBwRGF0YToge1xuICAgICAgICAgIHByb2R1Y2VyUGVlcklkOiB0aGlzLnBlZXJJZFxuICAgICAgICB9LFxuICAgICAgICBzdG9wVHJhY2tPbkNsb3NlOiB0cnVlXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdQcm9kdWNlclRhc2tzLmRlbGV0ZShcInZpZGVvXCIpO1xuICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgUHJvZHVjaW5nIFZpZGVvXCIpO1xuICAgICAgICB0aGlzLmRldmljZUhhbmRsZXIuc3RvcFN0cmVhbSh0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoXCJ2aWRlb1wiKSk7XG4gICAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLmRlbGV0ZShcInZpZGVvXCIpO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ0ZldGNoaW5nU3RyZWFtLmRlbGV0ZShcImNhbVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5kZWxldGUoXCJjYW1cIik7XG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIEVuYWJsaW5nIFZpZGVvXCIpO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuZGV2aWNlSGFuZGxlci5zdG9wU3RyZWFtKHRoaXMuX19hY3RpdmVTdHJlYW1zLmdldChcInZpZGVvXCIpKTtcbiAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLmRlbGV0ZShcInZpZGVvXCIpO1xuICAgICAgdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5kZWxldGUoXCJjYW1cIik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgbG9jYWwgc2NyZWVuIHNoYXJlICBhbmQgc3RhcnRzIHByb2R1Y2luZyB0aGUgc2NyZWVuIHNoYXJpbmcgc3RyZWFtXG4gICAqXG4gICAqYE5PVEU6IFlvdSBjYW4gb25seSBwcm9kdWNlIHRvIGEgcm9vbSB3aGVuIHlvdSBoYXZlIGpvaW5lZCB0aGUgcm9vbSwgaWYgeW91IHRyeSB0byBwcm9kdWNlIGJlZm9yZSBqb2luaW5nIHRoZSByb29tIGl0IHdpbGwgZmV0Y2ggdGhlIHN0cmVhbSBhbmQgc3RhcnQgcHJvZHVjaW5nIHdoZW4geW91IGpvaW4gdGhlIHJvb21gXG4gICAqXG4gICAqIEBzdW1tYXJ5IFRoaXMgZnVuY3Rpb25zIGhhbmRsZSB0aGUgcHJvZHVjaW5nIG9mIG1lZGlhIHN0cmVhbXMgdG8gYWxsIHRoZSByZW1vdGUgcGVlcnMgaW4gdGhlIHJvb20uXG4gICAqIGl0IGVuYWJsZXMgdGhlIGxvY2FsIG1pYyBmZXRjaGVzIHRoZSBzdHJlYW0gb3BlbnMgeW91IG1pYyBhY3RpdmUgaW5kaWNhdG9yIGxpZ2h0IG9uIHRoZSBkZXZpY2VcbiAgICogdXBvbiBzdWNjZXNzZnVsbCBmZXRjaGluZyBvZiB0aGUgc3RyZWFtIGl0IHByb2R1Y2VzIHRoZSBzdHJlYW0gd2l0aCB0aGUgbGFiZWwgYGF1ZGlvYCBhbmQgYHN0b3BUcmFja09uQ2xvc2U6IHRydWVgIHRvIGFsbCB0aGUgcmVtb3RlIHBlZXJzIGluIHRoZSByb29tLlxuICAgKiB3aGVuIGNsb3NpbmcgdXNpbmcgYGRpc2FibGVBdWRpb2AgaXQgd2lsbCBzdG9wIHRoZSBsb2NhbCBhdWRpbyB0cmFjayBhbmQgY2xvc2UgdGhlIHByb2R1Y2VyIHdoaWNoIHdpbGwgbm90aWZ5IGFsbCB0aGUgUmVtb3RlUGVlcnMgdGhhdCB0aGlzIHByb2R1Y2VyIGhhcyBzdG9wcGVkIHByb2R1Y2luZ1xuICAgKiBhbmQgdGhleSBzaG91bGQgc3RvcCBjb25zdW1pbmcgaXQuXG4gICAqXG4gICAqXG4gICAqL1xuICBzdGFydFNjcmVlblNoYXJlID0gY2hlY2tQZXJtaXNzaW9ucyh7IGNhblByb2R1Y2U6IHRydWUgfSkudmFsaWRhdGUoXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLnBlcm1pc3Npb25zLmNhblByb2R1Y2VTb3VyY2VzLnNjcmVlbikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgQ2Fubm90IEVuYWJsZSBTY3JlZW4gU2hhcmUsIFBlcm1pc3Npb24gRGVuaWVkXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgQ2Fubm90IEVuYWJsZSBTY3JlZW4gU2hhcmUsIFBlcm1pc3Npb24gRGVuaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU3RyZWFtID0gdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZ2V0KFwic2NyZWVuLXNoYXJlXCIpO1xuICAgICAgICBpZiAoZXhpc3RpbmdTdHJlYW0pIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcIlxcdXsxRjUxNH0gU2NyZWVuIFN0cmVhbSBBbHJlYWR5IEVuYWJsZWRcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uR29pbmdTdHJlYW1Qcm9taXNlID0gdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5nZXQoXCJzY3JlZW4tc2hhcmVcIik7XG4gICAgICAgIGlmIChvbkdvaW5nU3RyZWFtUHJvbWlzZSkge1xuICAgICAgICAgIGF3YWl0IG9uR29pbmdTdHJlYW1Qcm9taXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbVByb21pc2UgPSB0aGlzLmRldmljZUhhbmRsZXIuZmV0Y2hTY3JlZW4oKTtcbiAgICAgICAgICB0aGlzLl9fcGVuZGluZ0ZldGNoaW5nU3RyZWFtLnNldChcInNjcmVlbi1zaGFyZVwiLCBzdHJlYW1Qcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZW5kaW5nUHJvbWlzZSA9IHRoaXMuX19wZW5kaW5nRmV0Y2hpbmdTdHJlYW0uZ2V0KFwic2NyZWVuLXNoYXJlXCIpO1xuICAgICAgICBpZiAoIXBlbmRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oXCJcXHV7MUY1MTR9IFBlbmRpbmcgU2NyZWVuIFNoYXJlIFByb21pc2UgTm90IEZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0cmVhbSwgZXJyb3IgfSA9IGF3YWl0IHBlbmRpbmdQcm9taXNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIEZldGNoaW5nIFNjcmVlbiBTaGFyZSBTdHJlYW0gRnJvbSBEZXZpY2VcIik7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIEVycm9yIEZldGNoaW5nIFNjcmVlbiBTaGFyZVN0cmVhbSBGcm9tIERldmljZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgU3RyZWFtIE5vdCBGb3VuZCwgY2Fubm90IGRvIHN0YXJ0U2NyZWVuU2hhcmVcIik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1Mjc0QyBTdHJlYW0gTm90IEZvdW5kLCBjYW5ub3QgZG8gc3RhcnRTY3JlZW5TaGFyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fYWN0aXZlU3RyZWFtcy5zZXQoXCJzY3JlZW4tc2hhcmVcIiwgc3RyZWFtKTtcbiAgICAgICAgdGhpcy5lbWl0KFwic3RyZWFtLWZldGNoZWRcIiwge1xuICAgICAgICAgIG1lZGlhS2luZDogXCJzY3JlZW5cIixcbiAgICAgICAgICBsYWJlbDogXCJzY3JlZW4tc2hhcmVcIixcbiAgICAgICAgICBzdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKT8uWzBdO1xuICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk/LlswXTtcbiAgICAgICAgY29uc3QgdmlkZW9Qcm9kdWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2R1Y2Uoe1xuICAgICAgICAgICAgbGFiZWw6IFwic2NyZWVuLXNoYXJlLXZpZGVvXCIsXG4gICAgICAgICAgICBzdHJlYW06IG5ldyBNZWRpYVN0cmVhbShbdmlkZW9UcmFja10pLFxuICAgICAgICAgICAgYXBwRGF0YToge1xuICAgICAgICAgICAgICBwcm9kdWNlclBlZXJJZDogdGhpcy5wZWVySWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wVHJhY2tPbkNsb3NlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGF1ZGlvUHJvZHVjZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9kdWNlKHtcbiAgICAgICAgICAgIGxhYmVsOiBcInNjcmVlbi1zaGFyZS1hdWRpb1wiLFxuICAgICAgICAgICAgc3RyZWFtOiBuZXcgTWVkaWFTdHJlYW0oW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgICAgIGFwcERhdGE6IHtcbiAgICAgICAgICAgICAgcHJvZHVjZXJQZWVySWQ6IHRoaXMucGVlcklkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcFRyYWNrT25DbG9zZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgIHZpZGVvUHJvZHVjZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdQcm9kdWNlclRhc2tzLmRlbGV0ZShcInNjcmVlbi1zaGFyZS12aWRlb1wiKTtcbiAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFByb2R1Y2luZyBTY3JlZW4gU2hhcmUgVmlkZW9cIik7XG4gICAgICAgICAgICB0aGlzLmRldmljZUhhbmRsZXIuc3RvcFN0cmVhbShcbiAgICAgICAgICAgICAgdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZ2V0KFwic2NyZWVuLXNoYXJlXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZGVsZXRlKFwic2NyZWVuLXNoYXJlXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICBhdWRpb1Byb2R1Y2UoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nUHJvZHVjZXJUYXNrcy5kZWxldGUoXCJzY3JlZW4tc2hhcmUtYXVkaW9cIik7XG4gICAgICAgICAgfSkuY2F0Y2goKGVycm9yMikgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBQcm9kdWNpbmcgQXVkaW9cIik7XG4gICAgICAgICAgICB0aGlzLmRldmljZUhhbmRsZXIuc3RvcFN0cmVhbShcbiAgICAgICAgICAgICAgdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZ2V0KFwic2NyZWVuLXNoYXJlXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZGVsZXRlKFwic2NyZWVuLXNoYXJlXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5kZWxldGUoXCJzY3JlZW4tc2hhcmVcIik7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIEVuYWJsaW5nIFNjcmVlbiBTaGFyZVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5kZXZpY2VIYW5kbGVyLnN0b3BTdHJlYW0odGhpcy5fX2FjdGl2ZVN0cmVhbXMuZ2V0KFwic2NyZWVuLXNoYXJlXCIpKTtcbiAgICAgICAgdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZGVsZXRlKFwic2NyZWVuLXNoYXJlXCIpO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ0ZldGNoaW5nU3RyZWFtLmRlbGV0ZShcInNjcmVlbi1zaGFyZVwiKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICApO1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgbG9jYWwgbWljIGFuZCBzdGFydHMgcHJvZHVjaW5nIHRoZSBzdHJlYW0gd2l0aCB0aGUgbGFiZWwgYGF1ZGlvYFxuICAgKlxuICAgKmBOT1RFOiBZb3UgY2FuIG9ubHkgcHJvZHVjZSB0byBhIHJvb20gd2hlbiB5b3UgaGF2ZSBqb2luZWQgdGhlIHJvb20sIGlmIHlvdSB0cnkgdG8gcHJvZHVjZSBiZWZvcmUgam9pbmluZyB0aGUgcm9vbSBpdCB3aWxsIGZldGNoIHRoZSBzdHJlYW0gYW5kIHN0YXJ0IHByb2R1Y2luZyB3aGVuIHlvdSBqb2luIHRoZSByb29tYFxuICAgKlxuICAgKiBAc3VtbWFyeSBUaGlzIGZ1bmN0aW9ucyBoYW5kbGUgdGhlIHByb2R1Y2luZyBvZiBtZWRpYSBzdHJlYW1zIHRvIGFsbCB0aGUgcmVtb3RlIHBlZXJzIGluIHRoZSByb29tLlxuICAgKiBpdCBlbmFibGVzIHRoZSBsb2NhbCBtaWMgZmV0Y2hlcyB0aGUgc3RyZWFtIG9wZW5zIHlvdSBtaWMgYWN0aXZlIGluZGljYXRvciBsaWdodCBvbiB0aGUgZGV2aWNlXG4gICAqIHVwb24gc3VjY2Vzc2Z1bGwgZmV0Y2hpbmcgb2YgdGhlIHN0cmVhbSBpdCBwcm9kdWNlcyB0aGUgc3RyZWFtIHdpdGggdGhlIGxhYmVsIGBhdWRpb2AgYW5kIGBzdG9wVHJhY2tPbkNsb3NlOiB0cnVlYCB0byBhbGwgdGhlIHJlbW90ZSBwZWVycyBpbiB0aGUgcm9vbS5cbiAgICogd2hlbiBjbG9zaW5nIHVzaW5nIGBkaXNhYmxlQXVkaW9gIGl0IHdpbGwgc3RvcCB0aGUgbG9jYWwgYXVkaW8gdHJhY2sgYW5kIGNsb3NlIHRoZSBwcm9kdWNlciB3aGljaCB3aWxsIG5vdGlmeSBhbGwgdGhlIFJlbW90ZVBlZXJzIHRoYXQgdGhpcyBwcm9kdWNlciBoYXMgc3RvcHBlZCBwcm9kdWNpbmdcbiAgICogYW5kIHRoZXkgc2hvdWxkIHN0b3AgY29uc3VtaW5nIGl0LlxuICAgKi9cbiAgZW5hYmxlQXVkaW8gPSBjaGVja1Blcm1pc3Npb25zKHtcbiAgICBjYW5Qcm9kdWNlOiB0cnVlXG4gIH0pLnZhbGlkYXRlKGFzeW5jIChjdXN0b21BdWRpb1N0cmVhbSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMucGVybWlzc2lvbnMuY2FuUHJvZHVjZVNvdXJjZXMubWljKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgQ2Fubm90IEVuYWJsZSBBdWRpbywgUGVybWlzc2lvbiBEZW5pZWRcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgQ2Fubm90IEVuYWJsZSBBdWRpbywgUGVybWlzc2lvbiBEZW5pZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBleGlzdGluZ1N0cmVhbSA9IHRoaXMuX19hY3RpdmVTdHJlYW1zLmdldChcImF1ZGlvXCIpO1xuICAgICAgaWYgKGV4aXN0aW5nU3RyZWFtKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiXFx1ezFGNTE0fSBNaWMgU3RyZWFtIEFscmVhZHkgRW5hYmxlZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0cmVhbTtcbiAgICAgIGlmIChjdXN0b21BdWRpb1N0cmVhbSkge1xuICAgICAgICBzdHJlYW0gPSBjdXN0b21BdWRpb1N0cmVhbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9uZ29pbmdTdHJlYW1Qcm9taXNlID0gdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5nZXQoXCJtaWNcIik7XG4gICAgICAgIGlmIChvbmdvaW5nU3RyZWFtUHJvbWlzZSkge1xuICAgICAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbVByb21pc2UgPSB0aGlzLmRldmljZUhhbmRsZXIuZmV0Y2hTdHJlYW0oe1xuICAgICAgICAgICAgbWVkaWFEZXZpY2VLaW5kOiBcIm1pY1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fX3BlbmRpbmdGZXRjaGluZ1N0cmVhbS5zZXQoXCJtaWNcIiwgc3RyZWFtUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2UgPSB0aGlzLl9fcGVuZGluZ0ZldGNoaW5nU3RyZWFtLmdldChcIm1pY1wiKTtcbiAgICAgICAgaWYgKCFwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBQZW5kaW5nIE1pYyBQcm9taXNlIE5vdCBGb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdHJlYW06IGZldGNoZWRTdHJlYW0sIGVycm9yIH0gPSBhd2FpdCBwZW5kaW5nUHJvbWlzZTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBGZXRjaGluZyBTdHJlYW0gRnJvbSBEZXZpY2VcIik7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIEVycm9yIEZldGNoaW5nIFN0cmVhbSBGcm9tIERldmljZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZldGNoZWRTdHJlYW0pIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIFN0cmVhbSBOb3QgRm91bmQsIGNhbm5vdCBkbyBlbmFibGVBdWRpb1wiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIFN0cmVhbSBOb3QgRm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtID0gZmV0Y2hlZFN0cmVhbTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLnNldChcImF1ZGlvXCIsIHN0cmVhbSk7XG4gICAgICB0aGlzLmVtaXQoXCJzdHJlYW0tZmV0Y2hlZFwiLCB7XG4gICAgICAgIG1lZGlhS2luZDogXCJtaWNcIixcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBsYWJlbDogXCJhdWRpb1wiXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvZHVjZSh7XG4gICAgICAgIGxhYmVsOiBcImF1ZGlvXCIsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYXBwRGF0YToge1xuICAgICAgICAgIHByb2R1Y2VyUGVlcklkOiB0aGlzLnBlZXJJZFxuICAgICAgICB9LFxuICAgICAgICBzdG9wVHJhY2tPbkNsb3NlOiB0cnVlXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdQcm9kdWNlclRhc2tzLmRlbGV0ZShcImF1ZGlvXCIpO1xuICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgUHJvZHVjaW5nIEF1ZGlvXCIpO1xuICAgICAgICB0aGlzLmRldmljZUhhbmRsZXIuc3RvcFN0cmVhbSh0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoXCJhdWRpb1wiKSk7XG4gICAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLmRlbGV0ZShcImF1ZGlvXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9fcGVuZGluZ0ZldGNoaW5nU3RyZWFtLmRlbGV0ZShcIm1pY1wiKTtcbiAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgRW5hYmxpbmcgQXVkaW9cIik7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5kZXZpY2VIYW5kbGVyLnN0b3BTdHJlYW0odGhpcy5fX2FjdGl2ZVN0cmVhbXMuZ2V0KFwiYXVkaW9cIikpO1xuICAgICAgdGhpcy5fX2FjdGl2ZVN0cmVhbXMuZGVsZXRlKFwiYXVkaW9cIik7XG4gICAgICB0aGlzLl9fcGVuZGluZ0ZldGNoaW5nU3RyZWFtLmRlbGV0ZShcIm1pY1wiKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdW5kZXJseWluZyBwcm9kdWNpbmcgb2YgYSBzdHJlYW0gZm9yIGEgcGFydGljdWxhciBsYWJlbFxuICAgKlxuICAgKiBgTk9URTogVGhpcyB3aWxsIG5vdGlmeSBhbGwgdGhlIFJlbW90ZVBlZXJzIHRoYXQgdGhpcyBwcm9kdWNlciBoYXMgc3RvcHBlZCBwcm9kdWNpbmcgYW5kIHRoZXkgc2hvdWxkIHN0b3AgY29uc3VtaW5nIGl0LmBcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBzdG9wIHByb2R1Y2luZyB7IGxhYmVsOiBzdHJpbmcgfVxuICAgKi9cbiAgc3RvcFByb2R1Y2luZyA9IChkYXRhKSA9PiB7XG4gICAgdGhpcy5fX3dhaXRpbmdUb1Byb2R1Y2UuZGVsZXRlKGRhdGEubGFiZWwpO1xuICAgIHRoaXMuX19wZW5kaW5nUHJvZHVjZXJUYXNrcy5kZWxldGUoZGF0YS5sYWJlbCk7XG4gICAgbGV0IGNsb3NlZFN0cmVhbSA9IGZhbHNlO1xuICAgIGNvbnN0IHByb2R1Y2VyID0gdGhpcy5nZXRQcm9kdWNlcldpdGhMYWJlbChkYXRhLmxhYmVsKTtcbiAgICBpZiAocHJvZHVjZXIpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBDbG9zaW5nIFByb2R1Y2VyXCIsIHtcbiAgICAgICAgbGFiZWw6IGRhdGEubGFiZWwsXG4gICAgICAgIHByb2R1Y2VySWQ6IHByb2R1Y2VyLmlkXG4gICAgICB9KTtcbiAgICAgIHByb2R1Y2VyLmNsb3NlKCk7XG4gICAgICBwcm9kdWNlci5vbihcInRyYWNrZW5kZWRcIiwgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFwiXFx1ezFGNTE0fSBUcmFjayBFbmRlZCBGb3IgdGhlIFByb2R1Y2VyXCIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9fc2VuZFRyYW5zcG9ydD8ucmVtb3ZlUHJvZHVjZXJCeUlkKHByb2R1Y2VyLmlkKTtcbiAgICAgIGNsb3NlZFN0cmVhbSA9IHRydWU7XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwiY2xvc2VQcm9kdWNlclwiLCB7XG4gICAgICAgIHByb2R1Y2VySWQ6IHByb2R1Y2VyLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2xvc2VkU3RyZWFtTGFiZWwgPSBkYXRhLmxhYmVsLnN0YXJ0c1dpdGgoXCJzY3JlZW4tc2hhcmVcIikgPyBcInNjcmVlbi1zaGFyZVwiIDogZGF0YS5sYWJlbDtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoY2xvc2VkU3RyZWFtTGFiZWwpO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHRoaXMuZGV2aWNlSGFuZGxlci5zdG9wU3RyZWFtKHN0cmVhbSk7XG4gICAgICB0aGlzLl9fYWN0aXZlU3RyZWFtcy5kZWxldGUoY2xvc2VkU3RyZWFtTGFiZWwpO1xuICAgICAgY2xvc2VkU3RyZWFtID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNsb3NlZFN0cmVhbSkge1xuICAgICAgdGhpcy5lbWl0KFwic3RyZWFtLWNsb3NlZFwiLCB7XG4gICAgICAgIGxhYmVsOiBkYXRhLmxhYmVsLFxuICAgICAgICByZWFzb246IHtcbiAgICAgICAgICBjb2RlOiAxMjAwLFxuICAgICAgICAgIHRhZzogXCJTVFJFQU1fQ0xPU0VEXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJTdG9wcGVkIFN0cmVhbWluZ1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB1bmRlcmx5aW5nIHByb2R1Y2luZyBvZiBhIGNhbWVyYSBzdHJlYW0sIHN0b3BzIHRoZSBsb2NhbCB0cmFjayBhbmQgY2xvc2VzIHRoZSBwcm9kdWNlclxuICAgKlxuICAgKiBgTk9URTogVGhpcyB3aWxsIG5vdGlmeSBhbGwgdGhlIFJlbW90ZVBlZXJzIHRoYXQgdGhpcyBwcm9kdWNlciBoYXMgc3RvcHBlZCBwcm9kdWNpbmcgYW5kIHRoZXkgc2hvdWxkIHN0b3AgY29uc3VtaW5nIGl0LiBpZiB5b3UgaGF2ZSBqb2luZWQgdGhlIHJvb20sIGVsc2UgaXQgd2lsbCBqdXN0IGNsb3NlIHRoZSBzdHJlYW1gXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gc3RvcCBwcm9kdWNpbmcgeyBsYWJlbDogc3RyaW5nIH1cbiAgICovXG4gIGRpc2FibGVWaWRlbyA9IGFzeW5jICgpID0+IHtcbiAgICB0aGlzLnN0b3BQcm9kdWNpbmcoe1xuICAgICAgbGFiZWw6IFwidmlkZW9cIlxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgdmlkZW8gc3RyZWFtIHdpdGggdGhlIG5ldyBzdHJlYW1cbiAgICpcbiAgICogaWYgeW91IGhhdmUgcHJvZHVjZWQgYSBzdHJlYW0gd2l0aCBsYWJlbCBgdmlkZW9gIG9yIHVzZWQgdGhlIGRlZmF1bHQgZnVuY3Rpb24gYGVuYWJsZVZpZGVvYCBhbmQgeW91IHdhbnQgdG8gcmVwbGFjZSBpdCB3aXRoIGEgbmV3IHN0cmVhbVxuICAgKiBAcGFyYW0gc3RyZWFtIC0gTmV3IFZpZGVvIFN0cmVhbVxuICAgKi9cbiAgcmVwbGFjZVZpZGVvU3RyZWFtID0gYXN5bmMgKHN0cmVhbSkgPT4ge1xuICAgIGF3YWl0IHRoaXMucmVwbGFjZVN0cmVhbSh7XG4gICAgICBsYWJlbDogXCJ2aWRlb1wiLFxuICAgICAgbmV3U3RyZWFtOiBzdHJlYW1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIFZpZGVvIHNvdXJjZSB0byB0aGUgZ2l2ZW4gZGV2aWNlSWQsIHNldHMgdGhlIHByZWZlcnJlZCBjYW0gZGV2aWNlIGFzIHRoZSBnaXZlbiBkZXZpY2VJZFxuICAgKiBAcGFyYW0gZGV2aWNlSWRcbiAgICovXG4gIGNoYW5nZVZpZGVvU291cmNlID0gYXN5bmMgKGRldmljZUlkKSA9PiB7XG4gICAgdGhpcy5kZXZpY2VIYW5kbGVyLnNldFByZWZlcnJlZERldmljZSh7XG4gICAgICBkZXZpY2VJZCxcbiAgICAgIGRldmljZUtpbmQ6IFwiY2FtXCJcbiAgICB9KTtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoXCJ2aWRlb1wiKTtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHN0cmVhbTogbmV3U3RyZWFtIH0gPSBhd2FpdCB0aGlzLmRldmljZUhhbmRsZXIuZmV0Y2hTdHJlYW0oe1xuICAgICAgbWVkaWFEZXZpY2VLaW5kOiBcImNhbVwiXG4gICAgfSk7XG4gICAgaWYgKCFuZXdTdHJlYW0pXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgdGhpcy5yZXBsYWNlVmlkZW9TdHJlYW0obmV3U3RyZWFtKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGF1ZGlvIHN0cmVhbSB3aXRoIHRoZSBuZXcgc3RyZWFtXG4gICAqIGlmIHlvdSBoYXZlIHByb2R1Y2VkIGEgc3RyZWFtIHdpdGggbGFiZWwgYGF1ZGlvYCBvciB1c2VkIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIGBlbmFibGVBdWRpb2AgYW5kIHlvdSB3YW50IHRvIHJlcGxhY2UgaXQgd2l0aCBhIG5ldyBzdHJlYW1cbiAgICogQHBhcmFtIHN0cmVhbSAtIE5ldyBBdWRpbyBTdHJlYW1cbiAgICpcbiAgICovXG4gIHJlcGxhY2VBdWRpb1N0cmVhbSA9IGFzeW5jIChzdHJlYW0pID0+IHtcbiAgICBhd2FpdCB0aGlzLnJlcGxhY2VTdHJlYW0oe1xuICAgICAgbGFiZWw6IFwiYXVkaW9cIixcbiAgICAgIG5ld1N0cmVhbTogc3RyZWFtXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBjdXJyZW50IHN0cmVhbSB3aXRoIHRoZSBuZXcgc3RyZWFtIGJhc2VkIG9uIHRoZSBsYWJlbCB1c2VkIHRvIHByb2R1Y2UgdGhlIHN0cmVhbVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBGb3IgVmlkZW9cbiAgICogYXdhaXQgbG9jYWxQZWVyLnJlcGxhY2VTdHJlYW0oe1xuICAgKiAgbGFiZWw6ICd2aWRlbycsXG4gICAqICBuZXdTdHJlYW06IG5ld1N0cmVhbVxuICAgKiB9KVxuICAgKlxuICAgKiBGb3IgU2NyZWVuLVNoYXJlXG4gICAqIGF3YWl0IGxvY2FsUGVlci5yZXBsYWNlU3RyZWFtKHtcbiAgICogIGxhYmVsOiAnc2NyZWVuLXNoYXJlLXZpZGVvJyxcbiAgICogIG5ld1N0cmVhbTogbmV3U3RyZWFtXG4gICAqIH0pXG4gICAqXG4gICAqIElmIGFueSBjdXN0b20gbGFiZWwgdXNlZFxuICAgKiBhd2FpdCBsb2NhbFBlZXIucmVwbGFjZVN0cmVhbSh7XG4gICAqICBsYWJlbDogJ2N1c3RvbScsXG4gICAqICBuZXdTdHJlYW06IG5ld1N0cmVhbVxuICAgKiB9KVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIHsgbGFiZWw6IHN0cmluZywgbmV3U3RyZWFtOiBNZWRpYVN0cmVhbSB9XG4gICAqL1xuICByZXBsYWNlU3RyZWFtID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhgXFx1ezFGNTE0fSBSZXBsYWNpbmcgJHtkYXRhLmxhYmVsfSBTdHJlYW0gYCk7XG4gICAgY29uc3QgcHJvZHVjZXIgPSB0aGlzLmdldFByb2R1Y2VyV2l0aExhYmVsKGRhdGEubGFiZWwpO1xuICAgIGNvbnN0IHRyYWNrID0gZGF0YS5uZXdTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnN0b3BQcm9kdWNpbmcoeyBsYWJlbDogZGF0YS5sYWJlbCB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJvZHVjZXIpIHtcbiAgICAgIGF3YWl0IHByb2R1Y2VyLnJlcGxhY2VUcmFjayh7IHRyYWNrIH0pO1xuICAgIH1cbiAgICBjb25zdCBjbG9zZWRTdHJlYW1MYWJlbCA9IGRhdGEubGFiZWwuc3RhcnRzV2l0aChcInNjcmVlbi1zaGFyZVwiKSA/IFwic2NyZWVuLXNoYXJlXCIgOiBkYXRhLmxhYmVsO1xuICAgIGNvbnN0IHByZXZTdHJlYW0gPSB0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoY2xvc2VkU3RyZWFtTGFiZWwpO1xuICAgIGlmIChwcmV2U3RyZWFtICYmICF0aGlzLl9fd2FpdGluZ1RvUHJvZHVjZS5oYXMoY2xvc2VkU3RyZWFtTGFiZWwpKSB7XG4gICAgICB0aGlzLmRldmljZUhhbmRsZXIuc3RvcFN0cmVhbShwcmV2U3RyZWFtKTtcbiAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLmRlbGV0ZShjbG9zZWRTdHJlYW1MYWJlbCk7XG4gICAgICB0aGlzLl9fYWN0aXZlU3RyZWFtcy5zZXQoY2xvc2VkU3RyZWFtTGFiZWwsIGRhdGEubmV3U3RyZWFtKTtcbiAgICB9IGVsc2UgaWYgKHByZXZTdHJlYW0gJiYgdGhpcy5fX3dhaXRpbmdUb1Byb2R1Y2UuaGFzKGNsb3NlZFN0cmVhbUxhYmVsKSkge1xuICAgICAgZm9yIChjb25zdCB0cmFjazIgb2YgcHJldlN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICBwcmV2U3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrMik7XG4gICAgICAgIHRyYWNrMi5zdG9wKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHRyYWNrMiBvZiBkYXRhLm5ld1N0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICBwcmV2U3RyZWFtLmFkZFRyYWNrKHRyYWNrMik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRGV2aWNlS2luZCA9IGdldE1lZGlhRGV2aWNlS2luZCh0cmFjayk7XG4gICAgdGhpcy5lbWl0KFwic3RyZWFtLWZldGNoZWRcIiwge1xuICAgICAgbGFiZWw6IGRhdGEubGFiZWwsXG4gICAgICBzdHJlYW06IGRhdGEubmV3U3RyZWFtLFxuICAgICAgbWVkaWFLaW5kOiBtZWRpYURldmljZUtpbmRcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIEF1ZGlvIHNvdXJjZSB0byB0aGUgZ2l2ZW4gZGV2aWNlSWQsIHNldHMgdGhlIHByZWZlcnJlZCBtaWMgZGV2aWNlIGFzIHRoZSBnaXZlbiBkZXZpY2VJZFxuICAgKiBAcGFyYW0gZGV2aWNlSWRcbiAgICovXG4gIGNoYW5nZUF1ZGlvU291cmNlID0gYXN5bmMgKGRldmljZUlkKSA9PiB7XG4gICAgdGhpcy5kZXZpY2VIYW5kbGVyLnNldFByZWZlcnJlZERldmljZSh7XG4gICAgICBkZXZpY2VJZCxcbiAgICAgIGRldmljZUtpbmQ6IFwibWljXCJcbiAgICB9KTtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9fYWN0aXZlU3RyZWFtcy5nZXQoXCJhdWRpb1wiKTtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHN0cmVhbTogbmV3U3RyZWFtIH0gPSBhd2FpdCB0aGlzLmRldmljZUhhbmRsZXIuZmV0Y2hTdHJlYW0oe1xuICAgICAgbWVkaWFEZXZpY2VLaW5kOiBcIm1pY1wiXG4gICAgfSk7XG4gICAgaWYgKCFuZXdTdHJlYW0pXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgdGhpcy5yZXBsYWNlQXVkaW9TdHJlYW0obmV3U3RyZWFtKTtcbiAgfTtcbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB1bmRlcmx5aW5nIHByb2R1Y2luZyBvZiBhIG1pY3JvcGhvbmUgc3RyZWFtLCBzdG9wcyB0aGUgbG9jYWwgdHJhY2sgYW5kIGNsb3NlcyB0aGUgcHJvZHVjZXJcbiAgICpcbiAgICogYE5PVEU6IFRoaXMgd2lsbCBub3RpZnkgYWxsIHRoZSBSZW1vdGVQZWVycyB0aGF0IHRoaXMgcHJvZHVjZXIgaGFzIHN0b3BwZWQgcHJvZHVjaW5nIGFuZCB0aGV5IHNob3VsZCBzdG9wIGNvbnN1bWluZyBpdC5gXG4gICAqL1xuICBkaXNhYmxlQXVkaW8gPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5zdG9wUHJvZHVjaW5nKHtcbiAgICAgIGxhYmVsOiBcImF1ZGlvXCJcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB1bmRlcmx5aW5nIHByb2R1Y2luZyBvZiBhIHNjcmVlbi1zaGFyZSBzdHJlYW0sIHN0b3BzIHRoZSBsb2NhbCB0cmFjayBhbmQgY2xvc2VzIHRoZSBwcm9kdWNlclxuICAgKlxuICAgKiBgTk9URTogVGhpcyB3aWxsIG5vdGlmeSBhbGwgdGhlIFJlbW90ZVBlZXJzIHRoYXQgdGhpcyBwcm9kdWNlciBoYXMgc3RvcHBlZCBwcm9kdWNpbmcgYW5kIHRoZXkgc2hvdWxkIHN0b3AgY29uc3VtaW5nIGl0LiBpZiB5b3UgaGF2ZSBqb2luZWQgdGhlIHJvb20sIGVsc2UgaXQgd2lsbCBqdXN0IGNsb3NlIHRoZSBzdHJlYW1gXG4gICAqL1xuICBzdG9wU2NyZWVuU2hhcmUgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcFByb2R1Y2luZyh7XG4gICAgICAgIGxhYmVsOiBcInNjcmVlbi1zaGFyZS12aWRlb1wiXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RvcFByb2R1Y2luZyh7XG4gICAgICAgIGxhYmVsOiBcInNjcmVlbi1zaGFyZS1hdWRpb1wiXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIERpc2FibGluZyBTY3JlZW4gU2hhcmVcIik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ29uc3VtZXMgYSBzdHJlYW0gd2l0aCB0aGUgcHJvZHVjZXJJZCBhbmQgcGVlcklkIG9mIHRoZSBSZW1vdGVQZWVyLCBhcHBEYXRhIGlzIGFwcGxpY2F0aW9uIGxldmVsIGN1c3RvbSBkYXRhIHdoaWNoXG4gICAqIGNhbiBiZSBhZGRlZCB0byB0aGUgY29uc3VtZXIgZm9yIHRoZSBMb2NhbFBlZXIsIHRoaXMgZGF0YSB3aWxsIGJlIGF2YWlsYWJsZSBpbiB0aGUgY29uc3VtZXIgb2JqZWN0IGFuZCBjYW4gYmUgdXNlZCBvbmx5IGJ5IHRoZSBMb2NhbFBlZXIuXG4gICAqXG4gICAqIGBOT1RFOiBUaGlzIHdpbGwgbm90IG5vdGlmeSB0aGUgUmVtb3RlUGVlcnMgdGhhdCB5b3UgYXJlIGNvbnN1bWluZyBhIHN0cmVhbSwgeW91IGhhdmUgdG8gbm90aWZ5IHRoZW0gbWFudWFsbHlgXG4gICAqIEBzdW1tYXJ5IEV2ZXJ5IHRpbWUgYSBSZW1vdGVQZWVyIGlzIHByb2R1Y2luZyBhIE1lZGlhIGluIHRoZSBSb29tLCBMb2NhbFBlZXIgd2lsbCBiZSBub3RpZmllZCBhYm91dCBpdCBhbmQgaXQgd2lsbCBiZSBhYmxlIHRvIGNvbnN1bWUgaXQuXG4gICAqIENvbnN1bWluZyBpcyBhIHByb2Nlc3Mgd2hlcmUgdGhlIG1lZGlhIGlzIHJlY2VpdmVkIGZyb20gdGhlIFJlbW90ZVBlZXIgYW5kIHRoZSBzdHJlYW0gY2FuIGJlIHBsYXllZCBvbiB0aGUgTG9jYWxQZWVycyBkZXZpY2UuXG4gICAqXG4gICAqIFRvIGdldCB0aGUgY29uc3VtZXIgYmFjayB5b3UgY2FuIHVzZVxuICAgKlxuICAgKiBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5yb29tLmdldFJlbW90ZVBlZXJCeUlkKGRhdGEucGVlcklkKTtcbiAgICpcbiAgICogYHJlbW90ZVBlZXIub24oJ3N0cmVhbS1wbGF5YWJsZScsICh7IGxhYmVsOiBzdHJpbmc7IGNvbnN1bWVyOiBDb25zdW1lciB9KSA9PiB7fSlgXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0ge3BlZXJJZDogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCBhcHBEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAgICpcbiAgICovXG4gIGNvbnN1bWUgPSBjaGVja1Blcm1pc3Npb25zKHtcbiAgICBjYW5Db25zdW1lOiB0cnVlXG4gIH0pLnZhbGlkYXRlKFxuICAgIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5fX3JlbW90ZVBlZXJzLmdldChkYXRhLnBlZXJJZCk7XG4gICAgICBpZiAoIXJlbW90ZVBlZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZW1vdGUgUGVlciBOb3QgRm91bmQgd2l0aCBQZWVySWQgJHtkYXRhLnBlZXJJZH1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IHJlbW90ZVBlZXIuZ2V0TGFiZWxEYXRhKGRhdGEubGFiZWwpO1xuICAgICAgaWYgKCFsYWJlbERhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSZW1vdGUgUGVlciBpcyBub3QgcHJvZHVjaW5nIHdpdGggTGFiZWwgJHtkYXRhLmxhYmVsfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnN1bWVyRXhpc3RzID0gcmVtb3RlUGVlci5nZXRDb25zdW1lcihkYXRhLmxhYmVsKTtcbiAgICAgIGlmIChjb25zdW1lckV4aXN0cz8uY29uc3VtaW5nKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiXFx1ezFGNTE0fSBDb25zdW1lciBBbHJlYWR5IEV4aXN0cyB3aXRoIGxhYmVsIFwiLCBkYXRhLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWVyRXhpc3RzO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2UgPSB0aGlzLl9fcGVuZGluZ0NvbnN1bWVyVGFza3MuZ2V0KFxuICAgICAgICBsYWJlbERhdGE/LnByb2R1Y2VySWRcbiAgICAgICk7XG4gICAgICBpZiAocGVuZGluZ1Byb21pc2UpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFxcdXsxRjUxNH0gQ29uc3VtZXIgVGFzayBQZW5kaW5nIHRvIGJlIENvbnN1bWVkIHdpdGggbGFiZWwgJHtkYXRhLmxhYmVsfSwgUmV0dXJuaW5nYFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb25zdW1lcjIgPSBhd2FpdCBwZW5kaW5nUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWVyMjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBDb25zdW1pbmcgU3RyZWFtIHdpdGggbGFiZWwgXCIsIGRhdGEubGFiZWwpO1xuICAgICAgaWYgKCF0aGlzLl9fcmVjdlRyYW5zcG9ydCkge1xuICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICBcIlxcdXsxRjUxNH0gUmVjdiBUcmFuc3BvcnQgTm90IEluaXRpYWxpemVkLCBDcmVhaXRuZyBSZWN2VHJhbnNwb3J0XCJcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fX2NyZWF0ZVRyYW5zcG9ydE9uU2VydmVyKHtcbiAgICAgICAgICB0cmFuc3BvcnRUeXBlOiBcInJlY3ZcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnN1bWVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVN0cmVhbVBsYXlhYmxlID0gKHN0cmVhbURhdGEpID0+IHtcbiAgICAgICAgICBpZiAoc3RyZWFtRGF0YS5sYWJlbCA9PT0gZGF0YS5sYWJlbCkge1xuICAgICAgICAgICAgcmVtb3RlUGVlci5vZmYoXCJzdHJlYW0tcGxheWFibGVcIiwgaGFuZGxlU3RyZWFtUGxheWFibGUpO1xuICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW1EYXRhLmNvbnN1bWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlbW90ZVBlZXIub25jZShcInN0cmVhbS1wbGF5YWJsZVwiLCBoYW5kbGVTdHJlYW1QbGF5YWJsZSk7XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJjb25zdW1lXCIsIHtcbiAgICAgICAgICBjcmVhdGVDb25zdW1lckRhdGE6IHtcbiAgICAgICAgICAgIGFwcERhdGE6IGRhdGEuYXBwRGF0YSxcbiAgICAgICAgICAgIHByb2R1Y2VySWQ6IGxhYmVsRGF0YS5wcm9kdWNlcklkLFxuICAgICAgICAgICAgcHJvZHVjZXJQZWVySWQ6IGRhdGEucGVlcklkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX3BlbmRpbmdDb25zdW1lclRhc2tzLnNldChsYWJlbERhdGEucHJvZHVjZXJJZCwgY29uc3VtZXJQcm9taXNlKTtcbiAgICAgIGNvbnN0IGNvbnN1bWVyID0gYXdhaXQgY29uc3VtZXJQcm9taXNlLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIENvbnN1bWluZyBTdHJlYW1cIik7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nQ29uc3VtZXJUYXNrcy5kZWxldGUobGFiZWxEYXRhLnByb2R1Y2VySWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29uc3VtZXI7XG4gICAgfVxuICApO1xuICAvKipcbiAgICogU3RvcHMgdGhlIHVuZGVybHlpbmcgY29uc3VtaW5nIG9mIGEgc3RyZWFtIGZvciBhIHBhcnRpY3VsYXIgbGFiZWxcbiAgICpcbiAgICogYE5PVEU6IFRoaXMgZG9lcyBub3Qgbm90aWZ5IHRoZSByZW1vdGUgcGVlcnMgdGhhdCB5b3UgYXJlIG5vdCBjb25zdW1pbmcgYSBzdHJlYW1gXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqL1xuICBzdG9wQ29uc3VtaW5nID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5yb29tLmdldFJlbW90ZVBlZXJCeUlkKGRhdGEucGVlcklkKTtcbiAgICBpZiAoIXJlbW90ZVBlZXIuaGFzTGFiZWwoZGF0YS5sYWJlbCkpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgYFxcdTI3NEMgUmVtb3RlIFBlZXIgaXMgbm90IHByb2R1Y2luZyBhbnl0aGluZyB3aXRoIGxhYmVsOiAke2RhdGEubGFiZWx9YFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29uc3VtZXIgPSB0aGlzLnJlY3ZUcmFuc3BvcnQuZ2V0Q29uc3VtZXIoZGF0YSk7XG4gICAgaWYgKCFjb25zdW1lcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBDb25zdW1lciBOb3QgRm91bmRcIiwgZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY29uc3VtZXIuY29uc3VtaW5nKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIFlvdSBhcmUgbm90IENvbnN1bWluZyBhbnkgU3RyZWFtLCBDb25zdW1lciBOb3QgRm91bmRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnN1bWVySWQgPSBjb25zdW1lci5pZDtcbiAgICBpZiAoIWNvbnN1bWVySWQpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgQ29uc3VtZXJJZCBOb3QgRm91bmRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJjbG9zZUNvbnN1bWVyXCIsIHtcbiAgICAgIGNvbnN1bWVySWQ6IGNvbnN1bWVyLmlkXG4gICAgfSk7XG4gICAgcmVtb3RlUGVlci5lbWl0KFwic3RyZWFtLWNsb3NlZFwiLCB7XG4gICAgICBsYWJlbDogZGF0YS5sYWJlbFxuICAgIH0pO1xuICAgIHRoaXMucmVjdlRyYW5zcG9ydC5jbG9zZUNvbnN1bWVyKGRhdGEpO1xuICB9O1xuICAvKipcbiAgICogRnVuY3Rpb24gdG8gYWN0aXZhdGUgdGhlIHZvbGF0aWxlIGRhdGEgbWVzc2FnaW5nXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhY3RpdmF0aW9uIG9mIG5vdGlmaWNhdGlvbiBmYWlscy5cbiAgICovXG4gIGFjdGl2YXRlU3BlYWtlck5vdGlmaWNhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gQWN0aXZhdGluZyBTcGVha2VyIE5vdGlmaWNhdGlvbiwgc2l6ZTogJzknXCIpO1xuICAgIGNvbnN0IGJvdERhdGFQcm9kdWNlciA9IHRoaXMuX19zZW5kVHJhbnNwb3J0Py5kYXRhUHJvZHVjZXJzLmdldChcImJvdFwiKTtcbiAgICBpZiAoYm90RGF0YVByb2R1Y2VyKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gQm90IERhdGEgUHJvZHVjZXIgQWxyZWFkeSBFeGlzdHNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uZ29pbmdBY3RpdmVTcGVha2VyUHJvbWlzZSA9IHRoaXMuX19wZW5kaW5nVGFza3MuZ2V0KFwiYm90XCIpO1xuICAgIGlmIChvbmdvaW5nQWN0aXZlU3BlYWtlclByb21pc2UpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBCb3QgRGF0YSBQcm9kdWNlciBUYXNrIEFscmVhZHkgUGVuZGluZ1wiKTtcbiAgICAgIGF3YWl0IG9uZ29pbmdBY3RpdmVTcGVha2VyUHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWN0aXZhdGVOb3RpZmljYXRpb25Qcm9taXNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX19yZWN2VHJhbnNwb3J0KSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICBcIlxcdXsxRjUxNH0gUmVjdiBUcmFuc3BvcnQgTm90IEluaXRpYWxpemVkLCBDcmVhdGluZyBSZWN2VHJhbnNwb3J0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGF3YWl0IHRoaXMuX19jcmVhdGVUcmFuc3BvcnRPblNlcnZlcih7XG4gICAgICAgICAgICB0cmFuc3BvcnRUeXBlOiBcInJlY3ZcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJhY3RpdmF0ZVNwZWFrZXJOb3RpZmljYXRpb25cIiwge1xuICAgICAgICAgIHNpemU6IHRoaXMucm9vbS5hY3RpdmVTcGVha2Vycy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBhY3RpdmF0ZU5vdGlmaWNhdGlvblByb21pc2UoKTtcbiAgICAgIHRoaXMuX19wZW5kaW5nVGFza3Muc2V0KFwiYm90XCIsIHByb21pc2UpO1xuICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gIH07XG4gIHNlbmREYXRhID0gY2hlY2tQZXJtaXNzaW9ucyh7XG4gICAgY2FuU2VuZERhdGE6IHRydWVcbiAgfSkudmFsaWRhdGUoXG4gICAgKGRhdGEpID0+IHtcbiAgICAgIGlmIChlc3RpbWF0ZVNpemUoZGF0YS5wYXlsb2FkKSA+IE1BWF9EQVRBX01FU1NBR0VfU0laRSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIERhdGEgbWVzc2FnZSBleGNlZWRzIDFrYiBpbiBzaXplXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwic2VuZERhdGFcIiwgZGF0YSk7XG4gICAgfVxuICApO1xuICBwcm9kdWNlRGF0YSA9ICgpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gUHJvZHVjaW5nIERhdGEsXCIpO1xuICB9O1xuICAvKipcbiAgICogU2VuZCBNZXNzYWdlIHRvIHVwZGF0ZSB0aGUgbWV0YWRhdGEgb2YgdGhlIExvY2FsIFBlZXJcbiAgICpcbiAgICogYE5PVEU6IFRoaXMgd2lsbCBub3RpZnkgZXZlcnkgdXNlciBpbiB0aGUgcm9vbSBhYm91dCB0aGUgbWV0YWRhdGEgdXBkYXRlYFxuICAgKi9cbiAgdXBkYXRlTWV0YWRhdGEgPSBjaGVja1Blcm1pc3Npb25zKHtcbiAgICBjYW5VcGRhdGVNZXRhZGF0YTogdHJ1ZVxuICB9KS52YWxpZGF0ZSgoZGF0YSkgPT4ge1xuICAgIGlmICghdGhpcy5qb2luZWQpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgXCJcXHUyNzRDIENhbm5vdCBVcGRhdGUgTWV0YWRhdGEsIFlvdSBoYXZlIG5vdCBqb2luZWQgdGhlIHJvb20geWV0XCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlZXJJZCA9IHRoaXMucGVlcklkO1xuICAgIGlmICghcGVlcklkKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIENhbm5vdCBVcGRhdGUgTWV0YWRhdGEsIFBlZXJJZCBOb3QgRm91bmRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld01ldGFkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgdGhpcy5zb2NrZXQucHVibGlzaChcInVwZGF0ZVBlZXJNZXRhZGF0YVwiLCB7XG4gICAgICBwZWVySWQsXG4gICAgICBtZXRhZGF0YTogbmV3TWV0YWRhdGFcbiAgICB9KTtcbiAgfSk7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHJvbGUgb2YgdGhlIFJlbW90ZSBQZWVyIGluIHRoZSBSb29tLCB0aGlzIHdpbGwgZW1pdCBhbiBldmVudCBgdXBkYXRlZGAgd2l0aCB0aGUgdXBkYXRlZCByb2xlLlxuICAgKi9cbiAgdXBkYXRlUm9sZSA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5qb2luZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiXFx1Mjc0QyBDYW5ub3QgVXBkYXRlIFJvbGUsIFlvdSBoYXZlIG5vdCBqb2luZWQgdGhlIHJvb20geWV0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJvbGUgPT09IHRoaXMucm9sZSkge1xuICAgICAgICBsb2dnZXIud2FybihcIlxcdXsxRjUxNH0gUGVlciBSb2xlIGlzIGFscmVhZHkgc2V0IHRvXCIsIGRhdGEucm9sZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wZWVySWQpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgIFwiXFx1Mjc0QyBDYW5ub3QgVXBkYXRlIFJvbGUsIFBlZXJJZCBOb3QgRm91bmQsIChZb3UgaGF2ZSBub3Qgam9pbmVkIHRoZSByb29tIHlldClcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwidXBkYXRlUGVlclJvbGVcIiwge1xuICAgICAgICBwZWVySWQ6IHRoaXMucGVlcklkLFxuICAgICAgICByb2xlOiBkYXRhLnJvbGVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHV7MUY1MTR9IEVycm9yIFVwZGF0aW5nIFJvbGVcIiwgZGF0YSk7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgX19oYW5kbGVyID0ge1xuICAgIGVycm9yOiAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBFdmVudFwiKTtcbiAgICAgIGxvZ2dlci5lcnJvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZW4gSHVkZGxlMDEgTm9kZSBoYXMgc3VjY2Vzc2Z1bGx5IGFjY2VwdGVkIHRoZSBjb25uZWN0aW9uIHJlcXVlc3RcbiAgICAgKiBpdCBzZW50cyBiYWNrIHNvbWUgdXNlZnVsbCBtZXRhZGF0YSBmb3IgdGhlIGNsaWVudCB0byB1c2VcbiAgICAgKiBhdCB0aGlzIHBvaW50IHRoZSBzb2NrZXQgaXMgYXNzdW1lZCB0byB0aGUgY29ubmVjdGVkIGFuZCB0aGUgbG9jYWxQZWVyIGlzIHJlYWR5IHRvIGpvaW4gdGhlIHJvb21cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gRGF0YSBmcm9tIHNlcnZlciB7IHBlZXJJZCB9XG4gICAgICovXG4gICAgaGVsbG86IChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgSGVsbG8gRnJvbSBTZXJ2ZXIsIENvbm5lY3Rpb24gU3VjY2Vzc1wiKTtcbiAgICAgIGxvZ2dlci5pbmZvKGRhdGEpO1xuICAgICAgdGhpcy5wZWVySWQgPSBkYXRhLnBlZXJJZDtcbiAgICAgIHRoaXMuX19wZXJtaXNzaW9ucy51cGRhdGVQZXJtaXNzaW9ucyhkYXRhLmFjbCk7XG4gICAgICBpZiAoZGF0YS5yb2xlKVxuICAgICAgICB0aGlzLl9fcGVybWlzc2lvbnMucm9sZSA9IGRhdGEucm9sZTtcbiAgICAgIHRoaXMuZW1pdChcInBlcm1pc3Npb25zLXVwZGF0ZWRcIiwge1xuICAgICAgICBwZXJtaXNzaW9uczogZGF0YS5hY2wsXG4gICAgICAgIHJvbGU6IGRhdGEucm9sZVxuICAgICAgfSk7XG4gICAgICBpZiAoZGF0YS5tZXRhZGF0YSkge1xuICAgICAgICB0aGlzLl9fdXBkYXRlTWV0YWRhdGEoZGF0YS5tZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YWl0aW5nUm9vbTogKGRhdGEpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBXYWl0aW5nIFJvb21cIik7XG4gICAgICB0aGlzLnJvb20uZW1pdChcInJvb20td2FpdGluZ1wiLCBkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBVcG9ubiBzdWNjZXNzZnVsIGpvaW5pbmcgb2YgdGhlIHJvb20sIHRoZSBzZXJ2ZXIgc2VuZHMgYmFjayBzb21lIHVzZWZ1bGwgbWV0YWRhdGEgc3VjaCBhcyByZW1vdGVQZWVycyBpbiB0aGUgcm9vbS5cbiAgICAgKiBAZW1pdHMgXCJyb29tLWpvaW5lZFwiIC0gV2hlbiB0aGUgY2xpZW50IGhhcyBzdWNjZXNzZnVsbHkgam9pbmVkIHRoZSByb29tLlxuICAgICAqIEBlbWl0cyBcImpvaW4tZXJyb3JcIiAtIFdoZW4gdGhlIGNsaWVudCBoYXMgZmFpbGVkIHRvIGpvaW4gdGhlIHJvb20uXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIGZyb20gc2VydmVyIHsgcm9vbUlkLCByb29tSW5mbywgcm91dGVyUlRQQ2FwYWJpbGl0aWVzLCB0dXJuU2VydmVyIH1cbiAgICAgKi9cbiAgICBjb25uZWN0Um9vbVJlc3BvbnNlOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IEpvaW4gU3VjY2VzcyBFdmVudFwiKTtcbiAgICAgIGxvZ2dlci5pbmZvKHsgcm9vbUluZm86IGRhdGEucm9vbUluZm8gfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHJvb21JbmZvLCByb3V0ZXJSVFBDYXBhYmlsaXRpZXMsIHR1cm5TZXJ2ZXJzIH0gPSBkYXRhO1xuICAgICAgICB0aGlzLnJvb20uY29uZmlnID0gcm9vbUluZm8uY29uZmlnO1xuICAgICAgICB0aGlzLnJvb20ubWV0YWRhdGEgPSByb29tSW5mby5tZXRhZGF0YTtcbiAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9IGRldGVjdERldmljZSgpO1xuICAgICAgICBpZiAoIWRldmljZVR5cGUpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBcIlxcdTI3NEMgRGV2aWNlIGlzIG5vdCBzdXBwb3J0ZWQsIHZhbGlkIGRldmljZXMgYXJlIDogJ0Nocm9tZTExMScgfCAnQ2hyb21lNzQnIHwgJ0Nocm9tZTcwJyB8ICdDaHJvbWU2NycgfCAnQ2hyb21lNTUnIHwgJ0ZpcmVmb3g2MCcgfCAnU2FmYXJpMTInIHwgJ1NhZmFyaTExJyB8ICdFZGdlMTEnIHwgJ1JlYWN0TmF0aXZlVW5pZmllZFBsYW4nIHwgJ1JlYWN0TmF0aXZlJ1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIERldmljZSBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kZXZpY2UgPSBuZXcgRGV2aWNlKHsgaGFuZGxlck5hbWU6IGRldmljZVR5cGUgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX19kZXZpY2UubG9hZCh7XG4gICAgICAgICAgcm91dGVyUnRwQ2FwYWJpbGl0aWVzOiByb3V0ZXJSVFBDYXBhYmlsaXRpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5kZXZpY2UubG9hZGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1Mjc0QyBDYW5ub3QgTG9hZCBEZXZpY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGV2aWNlLWNyZWF0ZWRcIiwgeyBkZXZpY2U6IHRoaXMuX19kZXZpY2UgfSk7XG4gICAgICAgIHRoaXMuX19zZXRSZW1vdGVQZWVycyhyb29tSW5mbyk7XG4gICAgICAgIHRoaXMuX19zZXRMb2JieVBlZXJzKHJvb21JbmZvKTtcbiAgICAgICAgaWYgKHR1cm5TZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBTZXR0aW5nIFR1cm4gU2VydmVyXCIsIHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgICB0aGlzLl9fdHVybiA9IFsuLi50dXJuU2VydmVycywgLi4udGhpcy5fX3R1cm5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vbS5zdGF0ZSA9IFwiY29ubmVjdGVkXCI7XG4gICAgICAgIHRoaXMuam9pbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb29tLmVtaXQoXCJyb29tLWpvaW5lZFwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgSm9pbmluZyBSb29tXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLnJvb20uZW1pdChcInJvb20tam9pbmVkLWZhaWxlZFwiLCB7XG4gICAgICAgICAgbWVzc2FnZTogXCJcXHUyNzRDIEVycm9yIEpvaW5pbmcgUm9vbVwiLFxuICAgICAgICAgIHN0YXR1czogXCJST09NX0VSUk9SRURcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19oYW5kbGVXYWl0aW5nVG9Qcm9kdWNlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gdXBkYXRlIHRoZSByZW1vdGUgcGVlcnMgaW4gdGhlIHJvb20gLCByZW1vdmUgdGhlIHJlbW90ZSBwZWVycyB3aGljaCBhcmUgbm90IGluIHRoZSByb29tIGFueW1vcmVcbiAgICAgKiBAcGFyYW0gcm9vbUluZm9cbiAgICAgKi9cbiAgICBzeW5jTWVldGluZ1N0YXRlUmVzcG9uc2U6IGFzeW5jIChyb29tSW5mbykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IENsaWVudCByZWNvdmVyZWQgYWZ0ZXIgcmVjb25uZWN0aW5nXCIpO1xuICAgICAgICBjb25zdCB7IHBlZXJzOiBsYXRlc3RQZWVycyB9ID0gcm9vbUluZm87XG4gICAgICAgIGNvbnN0IGxhdGVzdFBlZXJzU2V0ID0gbmV3IFNldChsYXRlc3RQZWVycy5tYXAoKHApID0+IHAucGVlcklkKSk7XG4gICAgICAgIGZvciAoY29uc3QgW3BlZXJJZCwgcGVlcl0gb2YgdGhpcy5fX3JlbW90ZVBlZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghbGF0ZXN0UGVlcnNTZXQuaGFzKHBlZXJJZCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFiZWwgb2YgcGVlci5sYWJlbHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fX2Nsb3NlUmVtb3RlUGVlckNvbnN1bWVyKHtcbiAgICAgICAgICAgICAgICBwZWVySWQsXG4gICAgICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZWVyLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9fcmVtb3RlUGVlcnMuZGVsZXRlKHBlZXJJZCk7XG4gICAgICAgICAgICB0aGlzLnJvb20uZW1pdChcInBlZXItbGVmdFwiLCBwZWVySWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXRlc3RQZWVySW5mbyA9IGxhdGVzdFBlZXJzLmZpbmQoKHApID0+IHAucGVlcklkID09PSBwZWVySWQpO1xuICAgICAgICAgIGlmICghbGF0ZXN0UGVlckluZm8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgbmV3UHJvZHVjZXJTZXQgPSBuZXcgU2V0KFxuICAgICAgICAgICAgbGF0ZXN0UGVlckluZm8ucHJvZHVjZXJzLm1hcCgocCkgPT4gcC5sYWJlbClcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgbGFiZWwgb2YgcGVlci5sYWJlbHMpIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvZHVjZXJTZXQuaGFzKGxhYmVsKSkge1xuICAgICAgICAgICAgICB0aGlzLl9fY2xvc2VSZW1vdGVQZWVyQ29uc3VtZXIoeyBwZWVySWQsIGxhYmVsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXJyZW50UHJvZHVjZXJTZXQgPSBuZXcgU2V0KHBlZXIucHJvZHVjZXJJZHMpO1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvZHVjZXIgb2YgbGF0ZXN0UGVlckluZm8ucHJvZHVjZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9kdWNlclNldC5oYXMocHJvZHVjZXIuaWQpKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fX3JlY3ZUcmFuc3BvcnQgfHwgdGhpcy5fX3JlY3ZUcmFuc3BvcnQuY29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcGVlci5fYWRkTGFiZWxEYXRhKHtcbiAgICAgICAgICAgICAgICAgIHByb2R1Y2VySWQ6IHByb2R1Y2VyLmlkLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IHByb2R1Y2VyLmxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3dhaXRpbmdUb0NvbnN1bWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGVlci5fYWRkTGFiZWxEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjZXJJZDogcHJvZHVjZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwcm9kdWNlci5sYWJlbFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWRQZWVycyA9IGxhdGVzdFBlZXJzLmZpbHRlcihcbiAgICAgICAgICAobGF0ZXN0UGVlcikgPT4gIXRoaXMuX19yZW1vdGVQZWVycy5oYXMobGF0ZXN0UGVlci5wZWVySWQpICYmIGxhdGVzdFBlZXIucGVlcklkICE9PSB0aGlzLnBlZXJJZFxuICAgICAgICApLnZhbHVlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IGxhdGVzdFBlZXIgb2YgZmlsdGVyZWRQZWVycykge1xuICAgICAgICAgIGNvbnN0IHJlbW90ZVBlZXIgPSBuZXcgUmVtb3RlUGVlcl9kZWZhdWx0KHtcbiAgICAgICAgICAgIHBlZXJJZDogbGF0ZXN0UGVlci5wZWVySWQsXG4gICAgICAgICAgICByb2xlOiBsYXRlc3RQZWVyLnJvbGUsXG4gICAgICAgICAgICBtZXRhZGF0YTogbGF0ZXN0UGVlci5tZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlbW90ZVByb2R1Y2VycyA9IGxhdGVzdFBlZXIucHJvZHVjZXJzO1xuICAgICAgICAgIGZvciAoY29uc3QgcCBvZiByZW1vdGVQcm9kdWNlcnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fX3JlY3ZUcmFuc3BvcnQgfHwgdGhpcy5fX3JlY3ZUcmFuc3BvcnQuY29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgICAgIHJlbW90ZVBlZXIuX2FkZExhYmVsRGF0YSh7IHByb2R1Y2VySWQ6IHAuaWQsIGxhYmVsOiBwLmxhYmVsIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fX3dhaXRpbmdUb0NvbnN1bWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVBlZXIuX2FkZExhYmVsRGF0YSh7XG4gICAgICAgICAgICAgICAgICBwcm9kdWNlcklkOiBwLmlkLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IHAubGFiZWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19yZW1vdGVQZWVycy5zZXQobGF0ZXN0UGVlci5wZWVySWQsIHJlbW90ZVBlZXIpO1xuICAgICAgICAgIHRoaXMucm9vbS5lbWl0KFwibmV3LXBlZXItam9pbmVkXCIsIHsgcGVlcjogcmVtb3RlUGVlciB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBTeW5jaW5nIE1lZXRpbmcgU3RhdGUsIENhbid0IFJlY292ZXJcIik7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVcG9uIGNyZWF0aW9uIG9mIHNlcnZlciBzaWRlIHRyYW5zcG9ydCwgdGhlIHNlcnZlciBzZW5kcyBiYWNrIHNvbWUgdXNlZnVsbCBtZXRhZGF0YSBmb3IgdGhlIGNsaWVudCB0byB1c2VcbiAgICAgKiB0byBjcmVhdGUgYSBjbGllbnQgc2lkZSB0cmFuc3BvcnQsIGkuZS4gYHNlbmQgfCByZWN2YCBUcmFuc3BvcnQuXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIGZyb20gc2VydmVyIHsgdHJhbnNwb3J0U0RQSW5mbywgdHJhbnNwb3J0VHlwZSB9XG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNwb3J0T25DbGllbnQ6IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgaWYgKCF0aGlzLnBlZXJJZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlxcdTI3NEMgQ2Fubm90IENyZWF0ZSBUcmFuc3BvcnQsIE5vIFBlZXJJZCBGb3VuZCBmb3IgdGhlIHVzZXIuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBUcmFuc3BvcnRfZGVmYXVsdC5jcmVhdGUoe1xuICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICBwZWVySWQ6IHRoaXMucGVlcklkLFxuICAgICAgICAgIHNvY2tldDogdGhpcy5zb2NrZXQsXG4gICAgICAgICAgc2RwSW5mbzogZGF0YS50cmFuc3BvcnRTRFBJbmZvLFxuICAgICAgICAgIGljZVNlcnZlcnM6IHRoaXMuX190dXJuLFxuICAgICAgICAgIHRyYW5zcG9ydFR5cGU6IGRhdGEudHJhbnNwb3J0VHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyYW5zcG9ydC50cmFuc3BvcnRUeXBlID09PSBcInNlbmRcIikge1xuICAgICAgICAgIHRoaXMuX19zZW5kVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICAgIHRoaXMuX19zZW5kVHJhbnNwb3J0Lm1lZGlhc291cFRyYW5zcG9ydC5vbihcbiAgICAgICAgICAgIFwiY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsXG4gICAgICAgICAgICAoY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlV2FpdGluZ1RvUHJvZHVjZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJuZXctc2VuZC10cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zcG9ydC50cmFuc3BvcnRUeXBlID09PSBcInJlY3ZcIikge1xuICAgICAgICAgIHRoaXMuX19yZWN2VHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICAgIHRoaXMuX19yZWN2VHJhbnNwb3J0Lm1lZGlhc291cFRyYW5zcG9ydC5vbihcbiAgICAgICAgICAgIFwiY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsXG4gICAgICAgICAgICAoY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlV2FpdGluZ1RvQ29uc3VtZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJuZXctcmVjdi10cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICBcIlxcdTI3NEMgRXJyb3IgQ3JlYXRpbmcgTWVkaWFzb3VwVHJhbnNwb3J0IE9uIENsaWVudCwgdHJhbnNwb3J0VHlwZVwiLFxuICAgICAgICAgIGRhdGEudHJhbnNwb3J0VHlwZVxuICAgICAgICApO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogIUltcG9ydGFudFxuICAgICAqIFdoZW4gdGhlIHNlcnZlciBoYXMgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0aGUgdHJhbnNwb3J0LCBpdCBzZW5kcyBhIGFjayBiYWNrIHRvIHRoZSBjbGllbnRcbiAgICAgKiB3aGljaCBoYW5kbGVzIHRoZSBjYWxsYmFjaygpIGZ1bmN0aW9uIHdoaWNoIHRyaWdnZXJzIHRoZSBwcm9jZXNzIG9mIGNyZWF0aW9uIG9mIHByb2R1Y2VyIGFuZCBjb25zdW1lclxuICAgICAqIGZvciByZWZlcmVuY2Ugc2VlOiBwYWNrYWdlcy9uZXp1a28vc3JjL1RyYW5zcG9ydC50c1xuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgY29ubmVjdFRyYW5zcG9ydFJlc3BvbnNlOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgIGBcXHUyNzA1IENvbm5lY3QgJHtkYXRhLnRyYW5zcG9ydFR5cGV9IFRyYW5zcG9ydCBPbiBTZXJ2ZXIgUmVzcG9uc2VgXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0VHlwZSA9IGRhdGEudHJhbnNwb3J0VHlwZTtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gdHJhbnNwb3J0VHlwZSA9PT0gXCJzZW5kXCIgPyB0aGlzLl9fc2VuZFRyYW5zcG9ydCA6IHRoaXMuX19yZWN2VHJhbnNwb3J0O1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgTm90IEluaXRpYWxpemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNwb3J0LmVtaXQoXCJjb25uZWN0VHJhbnNwb3J0UmVzcG9uc2VcIik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIENvbm5lY3RpbmcgVHJhbnNwb3J0IE9uIFNlcnZlciBSZXNwb25zZVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2R1Y2VSZXNwb25zZTogYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1MjcwNSBQcm9kdWNlIFJlc3BvbnNlXCIpO1xuICAgICAgbG9nZ2VyLmluZm8oZGF0YSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHBlZXJJZCwgcHJvZHVjZXJJZCwgbGFiZWwgfSA9IGRhdGE7XG4gICAgICAgIGlmIChwZWVySWQgPT09IHRoaXMucGVlcklkKSB7XG4gICAgICAgICAgdGhpcy5zZW5kVHJhbnNwb3J0LnJlc29sdmVQZW5kaW5nUHJvZHVjZXJUYXNrKHtcbiAgICAgICAgICAgIGlkOiBwcm9kdWNlcklkLFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBwZWVySWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5yb29tLmdldFJlbW90ZVBlZXJCeUlkKHBlZXJJZCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9fcmVjdlRyYW5zcG9ydCB8fCB0aGlzLl9fcmVjdlRyYW5zcG9ydC5jb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIHJlbW90ZVBlZXIuX2FkZExhYmVsRGF0YSh7XG4gICAgICAgICAgICAgIHByb2R1Y2VySWQsXG4gICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3dhaXRpbmdUb0NvbnN1bWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByZW1vdGVQZWVyLl9hZGRMYWJlbERhdGEoe1xuICAgICAgICAgICAgICAgIHByb2R1Y2VySWQsXG4gICAgICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgUHJvZHVjZSBSZXNwb25zZVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2R1Y2VEYXRhUmVzcG9uc2U6IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgUHJvZHVjZSBEYXRhIFJlc3BvbnNlIGNvbnN1bWVySWRGcm9tU2VydmVyOiVvXCIsIGRhdGEuaWQpO1xuICAgICAgbG9nZ2VyLmluZm8oZGF0YSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGVlcklkLFxuICAgICAgICAgIGRhdGFQcm9kdWNlcklkLFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIGFwcERhdGEsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgc2N0cFN0cmVhbVBhcmFtZXRlcnNcbiAgICAgICAgfSA9IGRhdGE7XG4gICAgICAgIGlmIChwZWVySWQgPT09IHRoaXMucGVlcklkICYmIGxhYmVsICE9PSBcImJvdFwiKSB7XG4gICAgICAgICAgdGhpcy5zZW5kVHJhbnNwb3J0LnJlc29sdmVQZW5kaW5nUHJvZHVjZXJUYXNrKHtcbiAgICAgICAgICAgIGlkOiBkYXRhUHJvZHVjZXJJZCxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgcGVlcklkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm90RGF0YUNvbnN1bWVyID0gdGhpcy5yZWN2VHJhbnNwb3J0LmRhdGFDb25zdW1lcnMuZ2V0KGxhYmVsKTtcbiAgICAgICAgaWYgKGJvdERhdGFDb25zdW1lcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgQm90IERhdGEgQ29uc3VtZXIgQWxyZWFkeSBFeGlzdHMsIENhbid0IENyZWF0ZVwiLCB7XG4gICAgICAgICAgICBsYWJlbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhQ29uc3VtZXIgPSBhd2FpdCB0aGlzLnJlY3ZUcmFuc3BvcnQuY29uc3VtZURhdGEoe1xuICAgICAgICAgIGFwcERhdGEsXG4gICAgICAgICAgZGF0YVByb2R1Y2VySWQsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgcGVlcklkLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHNjdHBTdHJlYW1QYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhQ29uc3VtZXIub24oXCJtZXNzYWdlXCIsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkSnNvbkRhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFZvbGF0aWxlRGF0YU1lc3NhZ2VTY2hlbWEuc2FmZVBhcnNlKHBhcnNlZEpzb25EYXRhKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlY2VpdmUtdm9sYXRpbGUtZGF0YVwiLCByZXN1bHQuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJcXHUyNzRDIERhdGEgQ29uc3VtZXIgTWVzc2FnZSBTY2hlbWEgVmFsaWRhdGlvbiBGYWlsZWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFiZWwgPT09IFwiYm90XCIpIHtcbiAgICAgICAgICB0aGlzLl9fcGVuZGluZ1Rhc2tzLmRlbGV0ZShcImJvdFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBQcm9kdWNlIERhdGEgUmVzcG9uc2VcIik7XG4gICAgICAgIGxvZ2dlci5lcnJvcih7IGVycm9yIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29uc3VtZVJlc3BvbnNlOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IENvbnN1bWUgUmVzcG9uc2VcIik7XG4gICAgICBsb2dnZXIuaW5mbyh7XG4gICAgICAgIGlkOiBkYXRhLmNvbnN1bWVySWQsXG4gICAgICAgIGxhYmVsOiBkYXRhLmxhYmVsLFxuICAgICAgICBjb25zdW1lcklkOiBkYXRhLmNvbnN1bWVySWQsXG4gICAgICAgIHByb2R1Y2VyUGVlcklkOiBkYXRhLnByb2R1Y2VyUGVlcklkXG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZVBlZXIgPSB0aGlzLnJvb20uZ2V0UmVtb3RlUGVlckJ5SWQoZGF0YS5wcm9kdWNlclBlZXJJZCk7XG4gICAgICAgIGlmICghcmVtb3RlUGVlci5oYXNMYWJlbChkYXRhLmxhYmVsKSkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgUmVtb3RlIFBlZXIgaXMgbm90IHByb2R1Y2luZyB0aGlzIGxhYmVsXCIsIHtcbiAgICAgICAgICAgIGxhYmVsOiBkYXRhLmxhYmVsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFxcdTI3NEMgUmVtb3RlIFBlZXIgaXMgbm90IHByb2R1Y2luZyB0aGlzIGxhYmVsOiAke2RhdGEubGFiZWx9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb25zdW1lciwgbWVkaWFTb3VwQ29uc3VtZXIgfSA9IGF3YWl0IHRoaXMucmVjdlRyYW5zcG9ydC5jb25zdW1lKGRhdGEpO1xuICAgICAgICByZW1vdGVQZWVyLmVtaXQoXCJzdHJlYW0tcGxheWFibGVcIiwge1xuICAgICAgICAgIGNvbnN1bWVyLFxuICAgICAgICAgIGxhYmVsOiBjb25zdW1lci5sYWJlbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb29tLmVtaXQoXCJzdHJlYW0tYWRkZWRcIiwge1xuICAgICAgICAgIGxhYmVsOiBjb25zdW1lci5sYWJlbCxcbiAgICAgICAgICBwZWVySWQ6IGRhdGEucHJvZHVjZXJQZWVySWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJyZXN1bWVDb25zdW1lclwiLCB7XG4gICAgICAgICAgY29uc3VtZXJJZDogZGF0YS5jb25zdW1lcklkLFxuICAgICAgICAgIHByb2R1Y2VyUGVlcklkOiBkYXRhLnByb2R1Y2VyUGVlcklkXG4gICAgICAgIH0pO1xuICAgICAgICBtZWRpYVNvdXBDb25zdW1lci5yZXN1bWUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgQ29uc3VtZSBSZXNwb25zZVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdDb25zdW1lclRhc2tzLmRlbGV0ZShkYXRhLnByb2R1Y2VySWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VQcm9kdWNlclN1Y2Nlc3M6IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgUHJvZHVjZXIgQ2xvc2VkXCIsIGRhdGEpO1xuICAgICAgaWYgKHRoaXMucGVlcklkID09PSBkYXRhLnBlZXJJZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBwZWVySWQsIGxhYmVsIH0gPSBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fX2Nsb3NlUmVtb3RlUGVlckNvbnN1bWVyKHtcbiAgICAgICAgICBwZWVySWQsXG4gICAgICAgICAgbGFiZWxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBDbG9zaW5nIFByb2R1Y2VyXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlQ29uc3VtZXJTdWNjZXNzOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IENvbnN1bWVyIENsb3NlZCwgXCIsIGRhdGEpO1xuICAgIH0sXG4gICAgcmVzdGFydFRyYW5zcG9ydEljZVJlc3BvbnNlOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgeyB0cmFuc3BvcnRUeXBlLCBpY2VQYXJhbWV0ZXJzIH0gPSBkYXRhO1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IFJlc3RhcnQgVHJhbnNwb3J0IEljZSBSZXNwb25zZSBcIiwgdHJhbnNwb3J0VHlwZSk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSB0cmFuc3BvcnRUeXBlID09PSBcInNlbmRcIiA/IHRoaXMuX19zZW5kVHJhbnNwb3J0IDogdGhpcy5fX3JlY3ZUcmFuc3BvcnQ7XG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYFxcdTI3NEMgJHt0cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgTm90IEZvdW5kYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRyYW5zcG9ydC5tZWRpYXNvdXBUcmFuc3BvcnQucmVzdGFydEljZSh7IGljZVBhcmFtZXRlcnMgfSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiXFx1MjcwNSBSZXN0YXJ0ZWQgSWNlIGZvciB0eXBlOiBcIiwgdHJhbnNwb3J0VHlwZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFJlc3RhcnRpbmcgSWNlIGZvciB0eXBlOiBcIiwgdHJhbnNwb3J0VHlwZSk7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuZXdQZWVySm9pbmVkOiAoZGF0YSkgPT4ge1xuICAgICAgaWYgKHRoaXMucGVlcklkID09PSBkYXRhLnBlZXJJZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IE5ldyBQZWVyIEpvaW5lZFwiLCB7IGRhdGEgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHBlZXJJZCB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgcmVtb3RlUGVlciA9IG5ldyBSZW1vdGVQZWVyX2RlZmF1bHQoe1xuICAgICAgICAgIHBlZXJJZCxcbiAgICAgICAgICByb2xlOiBkYXRhLnJvbGUsXG4gICAgICAgICAgbWV0YWRhdGE6IGRhdGEubWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX19yZW1vdGVQZWVycy5zZXQocGVlcklkLCByZW1vdGVQZWVyKTtcbiAgICAgICAgY29uc3QgbG9iYnlQZWVycyA9IHRoaXMucm9vbS5sb2JieVBlZXJzTWFwO1xuICAgICAgICBpZiAobG9iYnlQZWVycy5oYXMocGVlcklkKSkge1xuICAgICAgICAgIGxvYmJ5UGVlcnMuZGVsZXRlKHBlZXJJZCk7XG4gICAgICAgICAgdGhpcy5yb29tLmxvYmJ5UGVlcnNNYXAgPSBsb2JieVBlZXJzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vbS5lbWl0KFwibmV3LXBlZXItam9pbmVkXCIsIHsgcGVlcjogcmVtb3RlUGVlciB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgTmV3IFBlZXIgSm9pbmVkXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmV3TG9iYnlQZWVyOiAoZGF0YSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IE5ldyBMb2JieSBQZWVyXCIsIHsgZGF0YSB9KTtcbiAgICAgICAgdGhpcy5yb29tLm5ld2xvYmJ5UGVlcnMgPSBbZGF0YV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIE5ldyBMb2JiIFBlZXJcIik7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuZXdQZXJtaXNzaW9uczogKGRhdGEpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX19wZXJtaXNzaW9ucy51cGRhdGVQZXJtaXNzaW9ucyhkYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KFwicGVybWlzc2lvbnMtdXBkYXRlZFwiLCB7XG4gICAgICAgICAgcGVybWlzc2lvbnM6IHRoaXMucGVybWlzc2lvbnNcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFVwZGF0aW5nIFBlcm1pc3Npb25zXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmV3Um9vbUNvbnRyb2xzOiAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IFJlY2VpdmVkIE5ldyBSb29tIENvbnRyb2xzXCIsIHsgZGF0YSB9KTtcbiAgICAgIHRoaXMucm9vbS5jb25maWcgPSB7XG4gICAgICAgIC4uLnRoaXMucm9vbS5jb25maWcsXG4gICAgICAgIFtkYXRhLnR5cGVdOiBkYXRhLnZhbHVlXG4gICAgICB9O1xuICAgICAgdGhpcy5yb29tLmVtaXQoXCJyb29tLWNvbnRyb2xzLXVwZGF0ZWRcIiwgZGF0YSk7XG4gICAgfSxcbiAgICBuZXdQZWVyUm9sZTogKGRhdGEpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1MjcwNSBSZWNlaXZlZCBOZXcgUGVlcidzIFJvbGVcIiwgeyBkYXRhIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBwZWVySWQsIHJvbGUgfSA9IGRhdGE7XG4gICAgICAgIGlmIChwZWVySWQgPT09IHRoaXMucGVlcklkKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IFVwZGF0aW5nIExvY2FsIFBlZXIncyBSb2xlXCIpO1xuICAgICAgICAgIHRoaXMuX19wZXJtaXNzaW9ucy5yb2xlID0gcm9sZTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyb2xlLXVwZGF0ZWRcIiwge1xuICAgICAgICAgICAgcm9sZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5yb29tLmdldFJlbW90ZVBlZXJCeUlkKHBlZXJJZCk7XG4gICAgICAgIGNvbnN0IHByZXZSb2xlID0gcmVtb3RlUGVlci5yb2xlIHx8IFwiXCI7XG4gICAgICAgIHJlbW90ZVBlZXIucm9sZSA9IHJvbGU7XG4gICAgICAgIHRoaXMucm9vbS5lbWl0KFwicm9vbS1yb2xlLXVwZGF0ZWRcIiwge1xuICAgICAgICAgIHBlZXJJZCxcbiAgICAgICAgICBuZXdSb2xlOiByb2xlLFxuICAgICAgICAgIHByZXZSb2xlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBVcGRhdGluZyBQZWVyJ3MgUm9sZVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJvb21DbG9zZWRQcm9kdWNlcnM6IChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgUmVjZWl2ZWQgUm9vbSdzIENsb3NlZCBQcm9kdWNlcnNcIiwgeyBkYXRhIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBwcm9kdWNlcnMsIHJlYXNvbiB9ID0gZGF0YTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9kdWNlciBvZiBwcm9kdWNlcnMpIHtcbiAgICAgICAgICBjb25zdCB7IGxhYmVsLCBwZWVySWQgfSA9IHByb2R1Y2VyO1xuICAgICAgICAgIGlmIChwZWVySWQgPT09IHRoaXMucGVlcklkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQcm9kdWNpbmcoeyBsYWJlbCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlUGVlciA9IHRoaXMucm9vbS5nZXRSZW1vdGVQZWVyQnlJZChwZWVySWQpO1xuICAgICAgICAgICAgY29uc3QgY29uc3VtZXIgPSB0aGlzLnJlY3ZUcmFuc3BvcnQuZ2V0Q29uc3VtZXIoe1xuICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgcGVlcklkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lcikge1xuICAgICAgICAgICAgICB0aGlzLnJlY3ZUcmFuc3BvcnQuY2xvc2VDb25zdW1lcih7IGxhYmVsLCBwZWVySWQgfSk7XG4gICAgICAgICAgICAgIHJlbW90ZVBlZXIuX3JlbW92ZUxhYmVsRGF0YShsYWJlbCk7XG4gICAgICAgICAgICAgIHRoaXMucm9vbS5lbWl0KFwic3RyZWFtLWNsb3NlZFwiLCB7XG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgcGVlcklkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIENsb3NpbmcgUHJvZHVjZXJcIik7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb20uZW1pdChcInJvb20tbm90aWZpY2F0aW9uXCIsIHJlYXNvbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFVwZGF0aW5nIFJvb20ncyBDbG9zZWQgUHJvZHVjZXJzXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZURhdGE6IChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgUmVjZWl2ZWQgRGF0YVwiLCB7IGRhdGEgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWNlaXZlLWRhdGFcIiwgZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFJlY2VpdmUgRGF0YVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBlZXJNZXRhZGF0YVVwZGF0ZWQ6IChkYXRhKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgTWV0YWRhdGEgVXBkYXRlZFwiLCB7IGRhdGEgfSk7XG4gICAgICAgIGNvbnN0IHsgcGVlcklkLCBtZXRhZGF0YSB9ID0gZGF0YTtcbiAgICAgICAgaWYgKHRoaXMucGVlcklkID09PSBwZWVySWQpIHtcbiAgICAgICAgICB0aGlzLl9fdXBkYXRlTWV0YWRhdGEoZGF0YS5tZXRhZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZVBlZXIgPSB0aGlzLnJvb20uZ2V0UmVtb3RlUGVlckJ5SWQocGVlcklkKTtcbiAgICAgICAgcmVtb3RlUGVlci5tZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YWRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBVcGRhdGluZyBNZXRhZGF0YVwiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJvb21NZXRhZGF0YVVwZGF0ZWQ6IChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgUm9vbSBNZXRhZGF0YSBVcGRhdGVkXCIsIHsgZGF0YSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGEgfSA9IGRhdGE7XG4gICAgICAgIHRoaXMucm9vbS5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBVcGRhdGluZyBSb29tIE1ldGFkYXRhXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGVlckxlZnQ6IChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgUGVlciBMZWZ0XCIsIHsgcGVlcklkOiBkYXRhLnBlZXJJZCB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcGVlcklkIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5yb29tLmdldFJlbW90ZVBlZXJCeUlkKHBlZXJJZCk7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHJlbW90ZVBlZXIubGFiZWxzO1xuICAgICAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVscykge1xuICAgICAgICAgIHRoaXMuX19jbG9zZVJlbW90ZVBlZXJDb25zdW1lcih7XG4gICAgICAgICAgICBwZWVySWQ6IHJlbW90ZVBlZXIucGVlcklkLFxuICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdGVQZWVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX19yZW1vdGVQZWVycy5kZWxldGUocGVlcklkKTtcbiAgICAgICAgdGhpcy5yb29tLmVtaXQoXCJwZWVyLWxlZnRcIiwgZGF0YS5wZWVySWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBQZWVyIExlZnRcIik7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2JieVBlZXJMZWZ0OiAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHUyNzA1IExvYmJ5IFBlZXIgTGVmdFwiLCB7IHBlZXJJZDogZGF0YS5wZWVySWQgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHBlZXJJZCB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgbG9iYnlQZWVycyA9IHRoaXMucm9vbS5sb2JieVBlZXJzTWFwO1xuICAgICAgICBpZiAobG9iYnlQZWVycy5oYXMocGVlcklkKSkge1xuICAgICAgICAgIGxvYmJ5UGVlcnMuZGVsZXRlKHBlZXJJZCk7XG4gICAgICAgICAgdGhpcy5yb29tLmxvYmJ5UGVlcnNNYXAgPSBsb2JieVBlZXJzO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIExvYmJ5IFBlZXIncyBMZWZ0XCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgUHJvZHVjZXIsIGlmIHNlbmQgdHJhbnNwb3J0IGlzIG5vdCBpbml0aWFsaXplZCwgaXQgY3JlYXRlcyBvbmUgYW5kIHRoZW4gY3JlYXRlcyBhIHByb2R1Y2VyXG4gICAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBjcmVhdGUgYSBwcm9kdWNlciB7IGxhYmVsLCBzdHJlYW0sIHN0b3BUcmFja09uQ2xvc2UsIGFwcERhdGEgfVxuICAgKiBAcmV0dXJucyAtIFByb2R1Y2VyXG4gICAqL1xuICBfX2NyZWF0ZVByb2R1Y2VyID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICBpZiAoIXRoaXMuX19zZW5kVHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyNzRDIFNlbmQgVHJhbnNwb3J0IE5vdCBJbml0aWFsaXplZCwgSW50ZXJuYWwgRXJyb3JcIik7XG4gICAgfVxuICAgIGNvbnN0IHByb2R1Y2VyID0gYXdhaXQgdGhpcy5fX3NlbmRUcmFuc3BvcnQucHJvZHVjZSh7XG4gICAgICBzdHJlYW06IGRhdGEuc3RyZWFtLFxuICAgICAgc3RvcFRyYWNrT25DbG9zZTogZGF0YS5zdG9wVHJhY2tPbkNsb3NlID8/IHRydWUsXG4gICAgICBsYWJlbDogZGF0YS5sYWJlbCxcbiAgICAgIGFwcERhdGE6IHtcbiAgICAgICAgLi4uZGF0YS5hcHBEYXRhLFxuICAgICAgICBsYWJlbDogZGF0YS5sYWJlbFxuICAgICAgfVxuICAgIH0pO1xuICAgIHByb2R1Y2VyLm9uKFwidHJhbnNwb3J0Y2xvc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9wUHJvZHVjaW5nKHsgbGFiZWw6IGRhdGEubGFiZWwgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwic3RyZWFtLXBsYXlhYmxlXCIsIHtcbiAgICAgIGxhYmVsOiBkYXRhLmxhYmVsLFxuICAgICAgcHJvZHVjZXJcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvZHVjZXI7XG4gIH07XG4gIF9fY3JlYXRlVHJhbnNwb3J0T25TZXJ2ZXIgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlID0gdGhpcy5fX3BlbmRpbmdUcmFuc3BvcnRUYXNrcy5nZXQoZGF0YS50cmFuc3BvcnRUeXBlKTtcbiAgICBpZiAocGVuZGluZ1Byb21pc2UpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgXFx1ezFGNTE0fSBUcmFuc3BvcnQgVGFzayBBbHJlYWR5IFBlbmRpbmcgZm9yIHRoaXMgdHJhbnNwb3J0VHlwZSAke2RhdGEudHJhbnNwb3J0VHlwZX1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCB7IHRyYW5zcG9ydFR5cGUgfSA9IGRhdGE7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZU5ld1RyYW5zcG9ydCA9IChkYXRhMikgPT4ge1xuICAgICAgICBpZiAoZGF0YTIudHJhbnNwb3J0LnRyYW5zcG9ydFR5cGUgPT09IHRyYW5zcG9ydFR5cGUpIHtcbiAgICAgICAgICB0aGlzLl9fcGVuZGluZ1RyYW5zcG9ydFRhc2tzLmRlbGV0ZSh0cmFuc3BvcnRUeXBlKTtcbiAgICAgICAgICByZXNvbHZlKGRhdGEyLnRyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodHJhbnNwb3J0VHlwZSA9PT0gXCJzZW5kXCIpIHtcbiAgICAgICAgdGhpcy5vbmNlKFwibmV3LXNlbmQtdHJhbnNwb3J0XCIsIGhhbmRsZU5ld1RyYW5zcG9ydCk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNwb3J0VHlwZSA9PT0gXCJyZWN2XCIpIHtcbiAgICAgICAgdGhpcy5vbmNlKFwibmV3LXJlY3YtdHJhbnNwb3J0XCIsIGhhbmRsZU5ld1RyYW5zcG9ydCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IGRhdGEudHJhbnNwb3J0VHlwZSA9PT0gXCJzZW5kXCIgPyB0aGlzLl9fc2VuZFRyYW5zcG9ydCA6IHRoaXMuX19yZWN2VHJhbnNwb3J0O1xuICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICByZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKGBcXHUyNzRDIFRyYW5zcG9ydCBBbHJlYWR5IEluaXRpYWxpemVkLCB0eXBlOiAke3RyYW5zcG9ydFR5cGV9YClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5pbmZvKGBcXHV7MUY1MTR9IENyZWF0aW5nICR7ZGF0YS50cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgT24gU2VydmVyYCk7XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwiY3JlYXRlVHJhbnNwb3J0XCIsIHtcbiAgICAgICAgc2N0cENhcGFiaWxpdGllczogZGV2aWNlLnNjdHBDYXBhYmlsaXRpZXMsXG4gICAgICAgIHRyYW5zcG9ydFR5cGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX19wZW5kaW5nVHJhbnNwb3J0VGFza3Muc2V0KGRhdGEudHJhbnNwb3J0VHlwZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBSZW1vdGUgUGVlcnMgaW4gdGhlIFJvb21cbiAgICogQHBhcmFtIHJvb21JbmZvXG4gICAqL1xuICBfX3NldFJlbW90ZVBlZXJzID0gKHJvb21JbmZvKSA9PiB7XG4gICAgdGhpcy5fX3JlbW90ZVBlZXJzLmNsZWFyKCk7XG4gICAgY29uc3QgeyBwZWVycyB9ID0gcm9vbUluZm87XG4gICAgZm9yIChjb25zdCBwZWVyIG9mIHBlZXJzKSB7XG4gICAgICBpZiAocGVlci5wZWVySWQgPT09IHRoaXMucGVlcklkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlbW90ZVBlZXIgPSBuZXcgUmVtb3RlUGVlcl9kZWZhdWx0KHtcbiAgICAgICAgcGVlcklkOiBwZWVyLnBlZXJJZCxcbiAgICAgICAgbWV0YWRhdGE6IHBlZXIubWV0YWRhdGEsXG4gICAgICAgIHJvbGU6IHBlZXIucm9sZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9kdWNlcnMgPSBwZWVyLnByb2R1Y2VycztcbiAgICAgIHRoaXMuX19yZW1vdGVQZWVycy5zZXQocGVlci5wZWVySWQsIHJlbW90ZVBlZXIpO1xuICAgICAgcHJvZHVjZXJzLm1hcCgocCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX19yZWN2VHJhbnNwb3J0IHx8IHRoaXMuX19yZWN2VHJhbnNwb3J0LmNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICAgIHJlbW90ZVBlZXIuX2FkZExhYmVsRGF0YSh7XG4gICAgICAgICAgICBwcm9kdWNlcklkOiBwLmlkLFxuICAgICAgICAgICAgbGFiZWw6IHAubGFiZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fd2FpdGluZ1RvQ29uc3VtZS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGVQZWVyLl9hZGRMYWJlbERhdGEoe1xuICAgICAgICAgICAgICBwcm9kdWNlcklkOiBwLmlkLFxuICAgICAgICAgICAgICBsYWJlbDogcC5sYWJlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIExvYmJ5IFBlZXJzIGluIHRoZSBSb29tXG4gICAqIEBwYXJhbSByb29tSW5mbyAtIFJvb21JbmZvXG4gICAqL1xuICBfX3NldExvYmJ5UGVlcnMgPSAocm9vbUluZm8pID0+IHtcbiAgICB0aGlzLnJvb20ubG9iYnlQZWVycy5jbGVhcigpO1xuICAgIGNvbnN0IHsgbG9iYnlQZWVycyB9ID0gcm9vbUluZm87XG4gICAgdGhpcy5yb29tLm5ld2xvYmJ5UGVlcnMgPSBsb2JieVBlZXJzO1xuICB9O1xuICAvKipcbiAgICogSGVscGVyIEZ1bmN0aW9uIHRvIGNsb3NlIHRoZSBjb25zdW1lciBvZiBhIHJlbW90ZSBwZWVyXG4gICAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBjbG9zZSB0aGUgY29uc3VtZXIgeyBwZWVySWQsIGxhYmVsIH1cbiAgICovXG4gIF9fY2xvc2VSZW1vdGVQZWVyQ29uc3VtZXIgPSAoZGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHBlZXJJZCwgbGFiZWwgfSA9IGRhdGE7XG4gICAgICBjb25zdCByZW1vdGVQZWVyID0gdGhpcy5yb29tLmdldFJlbW90ZVBlZXJCeUlkKHBlZXJJZCk7XG4gICAgICBjb25zdCBjb25zdW1lciA9IHRoaXMucmVjdlRyYW5zcG9ydC5nZXRDb25zdW1lcih7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBwZWVySWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGNvbnN1bWVyKSB7XG4gICAgICAgIHRoaXMucmVjdlRyYW5zcG9ydC5jbG9zZUNvbnN1bWVyKHsgbGFiZWwsIHBlZXJJZCB9KTtcbiAgICAgICAgcmVtb3RlUGVlci5fcmVtb3ZlTGFiZWxEYXRhKGxhYmVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vbS5lbWl0KFwic3RyZWFtLWNsb3NlZFwiLCB7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBwZWVySWQ6IGRhdGEucGVlcklkXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBDbG9zaW5nIFJlbW90ZSBQZWVyJ3MgQ29uc3VtZXJcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICFpbXBvcnRhbnRcbiAgICogSGFuZGxlciBGdW5jdGlvbiB0byBoYW5kbGUgdGhlIHdhaXRpbmcgdG8gcHJvZHVjZSB0YXNrcyB3aGVuIHVzZXIgaXMgam9pbmluZ1xuICAgKiB0aGUgcm9vbSB3aXRoIGFjdGl2ZSBzdHJlYW0sIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyB2YWxpZCBwZXJtaXNzaW9ucyBhbmQgYmFzZWQgb25cbiAgICogdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gcHJvZHVjZSB0aGUgc3RyZWFtXG4gICAqL1xuICBfX2hhbmRsZVdhaXRpbmdUb1Byb2R1Y2UgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICAgIGNvbnN0IGNsb3NlU3RyZWFtID0gKGxhYmVsKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX19hY3RpdmVTdHJlYW1zLmdldChsYWJlbCk7XG4gICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLmRldmljZUhhbmRsZXIuc3RvcFN0cmVhbShzdHJlYW0pO1xuICAgICAgICAgIHRoaXMuX19hY3RpdmVTdHJlYW1zLmRlbGV0ZShsYWJlbCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFwic3RyZWFtLWNsb3NlZFwiLCB7XG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHJlYXNvbjoge1xuICAgICAgICAgICAgICBjb2RlOiA0NDQ0LFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVzZXIncyBQZXJtaXNzaW9ucyBEZW5pZWRcIixcbiAgICAgICAgICAgICAgdGFnOiBcIkNMT1NFRF9CWV9BRE1JTlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3dhaXRpbmdUb1Byb2R1Y2UuZGVsZXRlKGxhYmVsKTtcbiAgICAgIH07XG4gICAgICBpZiAoIXBlcm1pc3Npb25zLmNhblByb2R1Y2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBbbGFiZWwsIF9dIG9mIHRoaXMuX193YWl0aW5nVG9Qcm9kdWNlKSB7XG4gICAgICAgICAgY2xvc2VTdHJlYW0obGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX193YWl0aW5nVG9Qcm9kdWNlLmNsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2xhYmVsLCBwZW5kaW5nU3RyZWFtVGFza10gb2YgdGhpcy5fX3dhaXRpbmdUb1Byb2R1Y2UpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSBcInZpZGVvXCIgJiYgIXBlcm1pc3Npb25zLmNhblByb2R1Y2VTb3VyY2VzLmNhbSkge1xuICAgICAgICAgIGNsb3NlU3RyZWFtKGxhYmVsKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwgPT09IFwiYXVkaW9cIiAmJiAhcGVybWlzc2lvbnMuY2FuUHJvZHVjZVNvdXJjZXMubWljKSB7XG4gICAgICAgICAgY2xvc2VTdHJlYW0obGFiZWwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdTdHJlYW1UYXNrKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgXCJcXHUyNzRDIEVycm9yIFByb2R1Y2luZyBTdHJlYW0gd2hpY2ggd2FzIHdhaXRpbmcgdG8gYmUgcHJvZHVjZWQgd2l0aCBsYWJlbCA6XCIsXG4gICAgICAgICAgICBsYWJlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICBjbG9zZVN0cmVhbShsYWJlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3dhaXRpbmdUb1Byb2R1Y2UuY2xlYXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBIYW5kbGluZyBXYWl0aW5nIFRvIFByb2R1Y2VcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgX19oYW5kbGVXYWl0aW5nVG9Db25zdW1lID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgY29uc3VtZVRhc2sgb2YgdGhpcy5fX3dhaXRpbmdUb0NvbnN1bWUpIHtcbiAgICAgIGNvbnN1bWVUYXNrKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJVbmFibGUgdG8gQ29uc3VtZSBhZnRlciBpY2UgcmVzdGFydFwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9fd2FpdGluZ1RvQ29uc3VtZSA9IFtdO1xuICB9O1xuICB0ZXN0RXZlbnQgPSAoZGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMucGVlcklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgQ2Fubm90IFRlc3QgRXZlbnQsIFBlZXJJZCBOb3QgRm91bmRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwidGVzdEV2ZW50XCIsIHtcbiAgICAgICAgYnJlYWs6IGRhdGEuYnJlYWssXG4gICAgICAgIHBlZXJJZDogdGhpcy5wZWVySWRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFRlc3QgRXZlbnRcIik7XG4gICAgfVxuICB9O1xufTtcbnZhciBMb2NhbFBlZXJfZGVmYXVsdCA9IExvY2FsUGVlcjtcblxuLy8gc3JjL1JlbW90ZVBlZXIudHNcbnZhciBsb2dnZXIyID0gbWFpbkxvZ2dlci5jcmVhdGVTdWJMb2dnZXIoXCJSZW1vdGVQZWVyXCIpO1xudmFyIFJlbW90ZVBlZXIgPSBjbGFzcyBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIHBlZXJJZCBvZiB0aGUgcmVtb3RlIHBlZXIsIHRoaXMgaXMgdW5pcXVlIGZvciBlYWNoIHBlZXJcbiAgICovXG4gIHBlZXJJZDtcbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgTWV0YWRhdGEgZm9yIHRoZSBSZW1vdGUgUGVlci5cbiAgICovXG4gIF9fbWV0YWRhdGEgPSBcInt9XCI7XG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIFJvbGUgb2YgdGhlIFJlbW90ZSBQZWVyLlxuICAgKi9cbiAgX19yb2xlID0gbnVsbDtcbiAgLyoqXG4gICAqIExhYmVscyBhcmUgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgbWVkaWEgc3RyZWFtIHRoYXQgdGhlIHJlbW90ZSBwZWVyIGlzIHByb2R1Y2luZ1xuICAgKi9cbiAgX19sYWJlbHNUb1Byb2R1Y2VySWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBsYWJlbHMgdGhhdCB0aGUgcmVtb3RlIHBlZXIgaXMgcHJvZHVjaW5nXG4gICAqL1xuICBnZXQgbGFiZWxzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX19sYWJlbHNUb1Byb2R1Y2VySWQua2V5cygpKTtcbiAgfVxuICBnZXQgcHJvZHVjZXJJZHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fX2xhYmVsc1RvUHJvZHVjZXJJZC52YWx1ZXMoKSkubWFwKFxuICAgICAgKGxhYmVsRGF0YSkgPT4gbGFiZWxEYXRhLnByb2R1Y2VySWRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSb2xlIG9mIHRoZSBQZWVyLlxuICAgKiBAcmV0dXJucyBUaGUgUm9sZSBvZiB0aGUgUGVlciB3aGljaCBpZiBwYXNzZWQgaW4gdGhlIG9wdGlvbnMgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW5cbiAgICovXG4gIGdldCByb2xlKCkge1xuICAgIGlmICghdGhpcy5fX3JvbGUpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fX3JvbGU7XG4gIH1cbiAgc2V0IHJvbGUocm9sZSkge1xuICAgIHRoaXMuX19yb2xlID0gcm9sZTtcbiAgICB0aGlzLmVtaXQoXCJyb2xlLXVwZGF0ZWRcIiwge1xuICAgICAgcm9sZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHJlbW90ZSBwZWVyIGlzIHByb2R1Y2luZyB0aGUgbGFiZWxcbiAgICogQHBhcmFtIGxhYmVsIC0gTGFiZWwgdG8gY2hlY2sgaWYgdGhlIHJlbW90ZSBwZWVyIGlzIHByb2R1Y2luZ1xuICAgKiBAcmV0dXJucyAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVtb3RlIHBlZXIgaXMgcHJvZHVjaW5nIHRoZSBsYWJlbFxuICAgKi9cbiAgaGFzTGFiZWwobGFiZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xhYmVsc1RvUHJvZHVjZXJJZC5oYXMobGFiZWwpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIGxhYmVsLCB0aGlzIGlzIHRoZSBwcm9kdWNlcklkXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqIHByb2R1Y2VySWQgLSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHByb2R1Y2VyXG4gICAqL1xuICBnZXRMYWJlbERhdGEobGFiZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xhYmVsc1RvUHJvZHVjZXJJZC5nZXQobGFiZWwpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFzc29jaWF0ZWQgY29uc3VtZXIgZm9yIHRoZSBsYWJlbFxuICAgKiBAcGFyYW0gbGFiZWwgLSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbnN1bWVyIGUuZy4gYHZpZGVvYCB8IGBhdWRpb2AgfCBgc2NyZWVuLXNoYXJlLXZpZGVvYCB8IHN0cmluZ1xuICAgKiBAcmV0dXJucyBDb25zdW1lciB8IG51bGxcbiAgICovXG4gIGdldENvbnN1bWVyKGxhYmVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxvY2FsUGVlciA9IExvY2FsUGVlcl9kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBjb25zdW1lciA9IGxvY2FsUGVlci5yZWN2VHJhbnNwb3J0LmdldENvbnN1bWVyKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHBlZXJJZDogdGhpcy5wZWVySWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnN1bWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1ldGFkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIFJlbW90ZVBlZXJcbiAgICovXG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9fbWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIFJlbW90ZSBQZWVyIE1ldGFkYXRhXG4gICAqXG4gICAqIGBOT1RFOiBUaGlzIHdpbGwgTk9UIG5vdGlmeSBvdGhlciBSZW1vdGUgUGVlcnMgb2YgdGhlIHVwZGF0ZWBcbiAgICovXG4gIHNldCBtZXRhZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fX21ldGFkYXRhID0gZGF0YTtcbiAgICB0aGlzLmVtaXQoXCJtZXRhZGF0YS11cGRhdGVkXCIsIHtcbiAgICAgIG1ldGFkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgUGVybWlzc2lvbnMgb2YgdGhlIFJlbW90ZSBQZWVyIGluIHRoZSBSb29tLiBUaGlzIHdpbGwgZW1pdCBhbiBldmVudCBgdXBkYXRlZGAgd2l0aCB0aGUgdXBkYXRlZCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIHVwZGF0ZVBlcm1pc3Npb25zID0gY2hlY2tQZXJtaXNzaW9ucyh7XG4gICAgYWRtaW46IHRydWVcbiAgfSkudmFsaWRhdGUoYXN5bmMgKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwiXFx1ezFGNTE0fSBVcGRhdGluZyBQZXJtaXNzaW9uc1wiLCBkYXRhKTtcbiAgICAgIGNvbnN0IGxvY2FsUGVlciA9IExvY2FsUGVlcl9kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBzb2NrZXQgPSBsb2NhbFBlZXIuc29ja2V0O1xuICAgICAgc29ja2V0LnB1Ymxpc2goXCJ1cGRhdGVQZWVyUGVybWlzc2lvblwiLCB7XG4gICAgICAgIHBlZXJJZDogdGhpcy5wZWVySWQsXG4gICAgICAgIHBlcm1pc3Npb246IGRhdGFcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiXFx1ezFGNTE0fSBFcnJvciBVcGRhdGluZyBQZXJtaXNzaW9uc1wiKTtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHJvbGUgb2YgdGhlIFJlbW90ZSBQZWVyIGluIHRoZSBSb29tLCB0aGlzIHdpbGwgZW1pdCBhbiBldmVudCBgdXBkYXRlZGAgd2l0aCB0aGUgdXBkYXRlZCByb2xlLlxuICAgKi9cbiAgdXBkYXRlUm9sZSA9IGNoZWNrUGVybWlzc2lvbnMoe1xuICAgIGFkbWluOiB0cnVlXG4gIH0pLnZhbGlkYXRlKChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIlxcdXsxRjUxNH0gVXBkYXRpbmcgUGVlciBSb2xlXCIsIGRhdGEpO1xuICAgICAgaWYgKGRhdGEucm9sZSA9PT0gdGhpcy5fX3JvbGUpIHtcbiAgICAgICAgbG9nZ2VyMi53YXJuKFwiXFx1ezFGNTE0fSBSb2xlIGlzIGFscmVhZHkgc2V0IHRvXCIsIGRhdGEucm9sZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvY2FsUGVlciA9IExvY2FsUGVlcl9kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBzb2NrZXQgPSBsb2NhbFBlZXIuc29ja2V0O1xuICAgICAgc29ja2V0LnB1Ymxpc2goXCJ1cGRhdGVQZWVyUm9sZVwiLCB7XG4gICAgICAgIHBlZXJJZDogdGhpcy5wZWVySWQsXG4gICAgICAgIHJvbGU6IGRhdGEucm9sZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJcXHV7MUY1MTR9IEVycm9yIFVwZGF0aW5nIFJvbGVcIiwgZGF0YSk7XG4gICAgICBsb2dnZXIyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdGhlIHN0YXRlcyBvZiB0aGUgcmVtb3RlIHBlZXIgYW5kIGNsZWFycyBtZW1vcnk7XG4gICAqXG4gICAqIGBOT1RFYDogWW91IG5lZWQgdG8gY2xvc2UgY29uc3VtZXJzIHVzaW5nIHRoZSBgcmVjdlRyYW5zcG9ydC5jbG9zZUNvbnN1bWVyYCBvZiB0aGUgbG9jYWwgcGVlclxuICAgKi9cbiAgY2xvc2UgPSAoKSA9PiB7XG4gICAgbG9nZ2VyMi5pbmZvKFwiQ2xvc2luZyBSZW1vdGUgUGVlclwiKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9O1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBlZXJJZCA9IGRhdGEucGVlcklkO1xuICAgIGlmIChkYXRhLm1ldGFkYXRhKSB7XG4gICAgICB0aGlzLm1ldGFkYXRhID0gSlNPTi5wYXJzZShkYXRhLm1ldGFkYXRhKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucm9sZSkge1xuICAgICAgdGhpcy5fX3JvbGUgPSBkYXRhLnJvbGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEFkZCBhIE5ldyBMYWJlbCB0byB0aGUgUmVtb3RlIFBlZXIgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIHRoZSBQcm9kdWNlcklkXG4gICAqXG4gICAqIGBOT1RFOiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgUGVlcmBcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGFkZCB0aGUgbmV3IGxhYmVsIGBsYWJlbGAgYW5kIHRoZSBgcHJvZHVjZXJJZGAgdG8gYXNzb2NpYXRlIGl0IHdpdGhcbiAgICovXG4gIF9hZGRMYWJlbERhdGEgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgbGFiZWwsIHByb2R1Y2VySWQgfSA9IGRhdGE7XG4gICAgdGhpcy5fX2xhYmVsc1RvUHJvZHVjZXJJZC5zZXQobGFiZWwsIHsgcHJvZHVjZXJJZCB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXV0b0NvbnN1bWUgPSBSb29tX2RlZmF1bHQuZ2V0SW5zdGFuY2UoKS5hdXRvQ29uc3VtZTtcbiAgICAgIGNvbnN0IGxvY2FsUGVlciA9IExvY2FsUGVlcl9kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICBpZiAoYXV0b0NvbnN1bWUpIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcbiAgICAgICAgICBcIkFVVE8gQ09OU1VNRSBJUyBFTkFCTEVELCBDT05TVU1JTkcgVEhFIFBST0RVQ0VSJ1MgU1RSRUFNXCJcbiAgICAgICAgKTtcbiAgICAgICAgbG9jYWxQZWVyLmNvbnN1bWUoe1xuICAgICAgICAgIGFwcERhdGE6IHt9LFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIHBlZXJJZDogdGhpcy5wZWVySWRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJzdHJlYW0tYXZhaWxhYmxlXCIsIHtcbiAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICBsYWJlbERhdGE6IHtcbiAgICAgICAgICAgIHByb2R1Y2VySWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBXaGlsZSBDb25zdW1pbmdcIiwge1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgcGVlcklkOiB0aGlzLnBlZXJJZFxuICAgICAgfSk7XG4gICAgICBsb2dnZXIyLmVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuZW1pdChcInN0cmVhbS1hdmFpbGFibGVcIiwge1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGFiZWxEYXRhOiB7XG4gICAgICAgICAgcHJvZHVjZXJJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIFJlbW92ZSBhIExhYmVsIGZyb20gdGhlIFJlbW90ZSBQZWVyIGFuZCBlbWl0IGEgYHN0cmVhbS1jbG9zZWRgIGV2ZW50XG4gICAqXG4gICAqIGBOT1RFOiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgUGVlcmBcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSB0aGUgUmVtb3RlIFBlZXJcbiAgICovXG4gIF9yZW1vdmVMYWJlbERhdGEgPSAobGFiZWwsIHJlYXNvbikgPT4ge1xuICAgIHRoaXMuX19sYWJlbHNUb1Byb2R1Y2VySWQuZGVsZXRlKGxhYmVsKTtcbiAgICB0aGlzLmVtaXQoXCJzdHJlYW0tY2xvc2VkXCIsIHtcbiAgICAgIGxhYmVsLFxuICAgICAgcmVhc29uXG4gICAgfSk7XG4gIH07XG59O1xudmFyIFJlbW90ZVBlZXJfZGVmYXVsdCA9IFJlbW90ZVBlZXI7XG5cbmV4cG9ydCB7XG4gIFJlbW90ZVBlZXJfZGVmYXVsdCxcbiAgTG9jYWxQZWVyX2RlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1CRExBSUxWNy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-BDLAILV7.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-CQH3TPW3.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-CQH3TPW3.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PC_PROPRIETARY_CONSTRAINTS: function() { return /* binding */ PC_PROPRIETARY_CONSTRAINTS; },\n/* harmony export */   SCREEN_SHARING_SVC_ENCODINGS: function() { return /* binding */ SCREEN_SHARING_SVC_ENCODINGS; },\n/* harmony export */   VIDEO_CONSTRAINTS: function() { return /* binding */ VIDEO_CONSTRAINTS; },\n/* harmony export */   WEBCAM_KSVC_ENCODINGS: function() { return /* binding */ WEBCAM_KSVC_ENCODINGS; },\n/* harmony export */   WEBCAM_SIMULCAST_ENCODINGS: function() { return /* binding */ WEBCAM_SIMULCAST_ENCODINGS; },\n/* harmony export */   codecOptionsViaKind: function() { return /* binding */ codecOptionsViaKind; },\n/* harmony export */   encodingViaMediaType: function() { return /* binding */ encodingViaMediaType; }\n/* harmony export */ });\n// src/constants/rtpConstants.ts\nvar VIDEO_CONSTRAINTS = {\n  qvga: { width: { ideal: 320 }, height: { ideal: 240 } },\n  vga: { width: { ideal: 640 }, height: { ideal: 480 } },\n  hd: { width: { ideal: 1280 }, height: { ideal: 720 } },\n  fHd: { width: { ideal: 1920 }, height: { ideal: 1080 } },\n  qHd: { width: { ideal: 4096 }, height: { ideal: 2160 } }\n};\nvar PC_PROPRIETARY_CONSTRAINTS = {\n  optional: [{ googDscp: true }]\n};\nvar WEBCAM_SIMULCAST_ENCODINGS = [\n  {\n    scaleResolutionDownBy: 4,\n    maxBitrate: 3e5,\n    // 300kbps\n    rid: \"r0\",\n    scalabilityMode: \"S1T3\",\n    maxFramerate: 15\n  },\n  {\n    scaleResolutionDownBy: 2,\n    maxBitrate: 6e5,\n    // 600kbps\n    rid: \"r1\",\n    scalabilityMode: \"S1T3\",\n    maxFramerate: 30\n  },\n  {\n    scaleResolutionDownBy: 1,\n    maxBitrate: 9e6,\n    // 900kbps\n    rid: \"r2\",\n    scalabilityMode: \"S1T3\",\n    maxFramerate: 30\n  }\n];\nvar SCREEN_SHARING_SVC_ENCODINGS = [\n  { scalabilityMode: \"S3T3\", dtx: true }\n];\nvar encodingViaMediaType = {\n  video: WEBCAM_SIMULCAST_ENCODINGS,\n  \"screen-share-video\": void 0,\n  audio: [{ maxBitrate: 128e3 }]\n};\nvar codecOptionsViaKind = {\n  audio: { opusStereo: true, opusFec: true, opusDtx: true },\n  video: { videoGoogleStartBitrate: 1e3 }\n};\nvar WEBCAM_KSVC_ENCODINGS = [{ scalabilityMode: \"S3T3_KEY\" }];\n\n\n//# sourceMappingURL=chunk-CQH3TPW3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUNRSDNUUFczLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLFlBQVksWUFBWSxjQUFjO0FBQ3pELFNBQVMsU0FBUyxZQUFZLFlBQVksY0FBYztBQUN4RCxRQUFRLFNBQVMsYUFBYSxZQUFZLGNBQWM7QUFDeEQsU0FBUyxTQUFTLGFBQWEsWUFBWSxlQUFlO0FBQzFELFNBQVMsU0FBUyxhQUFhLFlBQVk7QUFDM0M7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRCxXQUFXO0FBQ1g7QUFDQSwrQkFBK0IsNkJBQTZCOztBQVUxRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaHVkZGxlMDErd2ViLWNvcmVAMS4wLjAtZGV2LjY2L25vZGVfbW9kdWxlcy9AaHVkZGxlMDEvd2ViLWNvcmUvZGlzdC9jaHVuay1DUUgzVFBXMy5qcz84N2YyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb25zdGFudHMvcnRwQ29uc3RhbnRzLnRzXG52YXIgVklERU9fQ09OU1RSQUlOVFMgPSB7XG4gIHF2Z2E6IHsgd2lkdGg6IHsgaWRlYWw6IDMyMCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDI0MCB9IH0sXG4gIHZnYTogeyB3aWR0aDogeyBpZGVhbDogNjQwIH0sIGhlaWdodDogeyBpZGVhbDogNDgwIH0gfSxcbiAgaGQ6IHsgd2lkdGg6IHsgaWRlYWw6IDEyODAgfSwgaGVpZ2h0OiB7IGlkZWFsOiA3MjAgfSB9LFxuICBmSGQ6IHsgd2lkdGg6IHsgaWRlYWw6IDE5MjAgfSwgaGVpZ2h0OiB7IGlkZWFsOiAxMDgwIH0gfSxcbiAgcUhkOiB7IHdpZHRoOiB7IGlkZWFsOiA0MDk2IH0sIGhlaWdodDogeyBpZGVhbDogMjE2MCB9IH1cbn07XG52YXIgUENfUFJPUFJJRVRBUllfQ09OU1RSQUlOVFMgPSB7XG4gIG9wdGlvbmFsOiBbeyBnb29nRHNjcDogdHJ1ZSB9XVxufTtcbnZhciBXRUJDQU1fU0lNVUxDQVNUX0VOQ09ESU5HUyA9IFtcbiAge1xuICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogNCxcbiAgICBtYXhCaXRyYXRlOiAzZTUsXG4gICAgLy8gMzAwa2Jwc1xuICAgIHJpZDogXCJyMFwiLFxuICAgIHNjYWxhYmlsaXR5TW9kZTogXCJTMVQzXCIsXG4gICAgbWF4RnJhbWVyYXRlOiAxNVxuICB9LFxuICB7XG4gICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiAyLFxuICAgIG1heEJpdHJhdGU6IDZlNSxcbiAgICAvLyA2MDBrYnBzXG4gICAgcmlkOiBcInIxXCIsXG4gICAgc2NhbGFiaWxpdHlNb2RlOiBcIlMxVDNcIixcbiAgICBtYXhGcmFtZXJhdGU6IDMwXG4gIH0sXG4gIHtcbiAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDEsXG4gICAgbWF4Qml0cmF0ZTogOWU2LFxuICAgIC8vIDkwMGticHNcbiAgICByaWQ6IFwicjJcIixcbiAgICBzY2FsYWJpbGl0eU1vZGU6IFwiUzFUM1wiLFxuICAgIG1heEZyYW1lcmF0ZTogMzBcbiAgfVxuXTtcbnZhciBTQ1JFRU5fU0hBUklOR19TVkNfRU5DT0RJTkdTID0gW1xuICB7IHNjYWxhYmlsaXR5TW9kZTogXCJTM1QzXCIsIGR0eDogdHJ1ZSB9XG5dO1xudmFyIGVuY29kaW5nVmlhTWVkaWFUeXBlID0ge1xuICB2aWRlbzogV0VCQ0FNX1NJTVVMQ0FTVF9FTkNPRElOR1MsXG4gIFwic2NyZWVuLXNoYXJlLXZpZGVvXCI6IHZvaWQgMCxcbiAgYXVkaW86IFt7IG1heEJpdHJhdGU6IDEyOGUzIH1dXG59O1xudmFyIGNvZGVjT3B0aW9uc1ZpYUtpbmQgPSB7XG4gIGF1ZGlvOiB7IG9wdXNTdGVyZW86IHRydWUsIG9wdXNGZWM6IHRydWUsIG9wdXNEdHg6IHRydWUgfSxcbiAgdmlkZW86IHsgdmlkZW9Hb29nbGVTdGFydEJpdHJhdGU6IDFlMyB9XG59O1xudmFyIFdFQkNBTV9LU1ZDX0VOQ09ESU5HUyA9IFt7IHNjYWxhYmlsaXR5TW9kZTogXCJTM1QzX0tFWVwiIH1dO1xuXG5leHBvcnQge1xuICBWSURFT19DT05TVFJBSU5UUyxcbiAgUENfUFJPUFJJRVRBUllfQ09OU1RSQUlOVFMsXG4gIFdFQkNBTV9TSU1VTENBU1RfRU5DT0RJTkdTLFxuICBTQ1JFRU5fU0hBUklOR19TVkNfRU5DT0RJTkdTLFxuICBlbmNvZGluZ1ZpYU1lZGlhVHlwZSxcbiAgY29kZWNPcHRpb25zVmlhS2luZCxcbiAgV0VCQ0FNX0tTVkNfRU5DT0RJTkdTXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstQ1FIM1RQVzMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-CQH3TPW3.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLogger: function() { return /* binding */ createLogger; },\n/* harmony export */   mainLogger: function() { return /* binding */ mainLogger; },\n/* harmony export */   setLogLevel: function() { return /* binding */ setLogLevel; },\n/* harmony export */   setLoggerFactory: function() { return /* binding */ setLoggerFactory; }\n/* harmony export */ });\n// src/logger.ts\nvar COLORS = {\n  black: \"\\x1B[30m\",\n  red: \"\\x1B[31m\",\n  green: \"\\x1B[32m\",\n  yellow: \"\\x1B[33m\",\n  blue: \"\\x1B[34m\",\n  magenta: \"\\x1B[35m\",\n  cyan: \"\\x1B[36m\",\n  white: \"\\x1B[37m\",\n  default: \"\\x1B[39m\"\n};\nvar defaultLevel = \"debug\";\nvar created = Date.now();\nfunction createDefaultLoggerFactory() {\n  return () => {\n    const trace = (...args) => {\n      console.trace(...args);\n    };\n    const debug = (...args) => {\n      console.debug(...args);\n    };\n    const info = (...args) => {\n      console.info(...args);\n    };\n    const warn = (...args) => {\n      console.warn(...args);\n    };\n    const error = (...args) => {\n      console.error(...args);\n    };\n    return {\n      trace,\n      debug,\n      info,\n      warn,\n      error\n    };\n  };\n}\nvar wrapLogger = (logger, moduleName, logLevel) => {\n  let isTrace = false;\n  let isDebug = false;\n  let isInfo = false;\n  let isWarning = false;\n  let isError = false;\n  let _level = logLevel;\n  let _logger = logger;\n  const tracePrefix = `${COLORS.magenta}[TRACE]${COLORS.default} ${moduleName}`;\n  const debugPrefix = `${COLORS.cyan}[DEBUG]${COLORS.default} ${moduleName}`;\n  const infoPrefix = `${COLORS.green}[INFO]${COLORS.default} ${moduleName}`;\n  const warnPrefix = `${COLORS.yellow}[WARN]${COLORS.default} ${moduleName}`;\n  const errorPrefix = `${COLORS.red}[ERROR]${COLORS.default} ${moduleName}`;\n  const result = new class {\n    init() {\n      isTrace = [\"trace\"].includes(_level ?? defaultLevel);\n      isDebug = [\"trace\", \"debug\"].includes(_level ?? defaultLevel);\n      isInfo = [\"trace\", \"debug\", \"info\"].includes(_level ?? defaultLevel);\n      isWarning = [\"trace\", \"debug\", \"info\", \"warn\"].includes(\n        _level ?? defaultLevel\n      );\n      isError = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"].includes(\n        _level ?? defaultLevel\n      );\n    }\n    get logger() {\n      return _logger;\n    }\n    set logger(value) {\n      _logger = value;\n    }\n    get level() {\n      return _level;\n    }\n    set level(value) {\n      _level = value;\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: need any\n    trace(...args) {\n      if (isTrace) {\n        const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;\n        logger.trace(tracePrefix, ...args, elapsedInMs);\n      }\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: need any\n    debug(...args) {\n      if (isDebug) {\n        const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;\n        logger.debug(debugPrefix, ...args, elapsedInMs);\n      }\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: need any\n    info(...args) {\n      if (isInfo) {\n        const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;\n        logger.info(infoPrefix, ...args, elapsedInMs);\n      }\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: need any\n    warn(...args) {\n      if (isWarning) {\n        const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;\n        logger.warn(warnPrefix, ...args, elapsedInMs);\n      }\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: need any\n    error(...args) {\n      if (isError) {\n        const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;\n        logger.error(errorPrefix, ...args, elapsedInMs);\n      }\n    }\n  }();\n  return result;\n};\nvar actualLoggerFactory = createDefaultLoggerFactory();\nvar loggers = /* @__PURE__ */ new Map();\nvar createLogger = (moduleName, logLevel) => {\n  let wrappedLogger = loggers.get(moduleName);\n  if (!wrappedLogger) {\n    const logger = actualLoggerFactory();\n    wrappedLogger = wrapLogger(logger, moduleName, logLevel ?? defaultLevel);\n    loggers.set(moduleName, wrappedLogger);\n  } else {\n    wrappedLogger.level = logLevel ?? defaultLevel;\n  }\n  wrappedLogger.init();\n  return wrappedLogger;\n};\nvar setLogLevel = (level) => {\n  defaultLevel = level;\n  for (const [moduleName] of Array.from(loggers.entries())) {\n    loggers.set(moduleName, createLogger(moduleName, level));\n  }\n};\nvar setLoggerFactory = (loggerFactory) => {\n  actualLoggerFactory = loggerFactory;\n  for (const [moduleName, logger] of Array.from(loggers.entries())) {\n    loggers.set(moduleName, createLogger(moduleName, logger.level));\n  }\n};\nvar mainLogger = {\n  createSubLogger: (moduleName) => createLogger(`nezuko:${moduleName}`)\n};\n\n\n//# sourceMappingURL=chunk-EVXWMCNT.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUVWWFdNQ05ULmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZSxTQUFTLGdCQUFnQixFQUFFLFdBQVc7QUFDOUUseUJBQXlCLFlBQVksU0FBUyxnQkFBZ0IsRUFBRSxXQUFXO0FBQzNFLHdCQUF3QixhQUFhLFFBQVEsZ0JBQWdCLEVBQUUsV0FBVztBQUMxRSx3QkFBd0IsY0FBYyxRQUFRLGdCQUFnQixFQUFFLFdBQVc7QUFDM0UseUJBQXlCLFdBQVcsU0FBUyxnQkFBZ0IsRUFBRSxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlLEdBQUcscUJBQXFCLElBQUksZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZSxHQUFHLHFCQUFxQixJQUFJLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWUsR0FBRyxxQkFBcUIsSUFBSSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlLEdBQUcscUJBQXFCLElBQUksZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZSxHQUFHLHFCQUFxQixJQUFJLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFOztBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUVWWFdNQ05ULmpzPzY5MWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xvZ2dlci50c1xudmFyIENPTE9SUyA9IHtcbiAgYmxhY2s6IFwiXFx4MUJbMzBtXCIsXG4gIHJlZDogXCJcXHgxQlszMW1cIixcbiAgZ3JlZW46IFwiXFx4MUJbMzJtXCIsXG4gIHllbGxvdzogXCJcXHgxQlszM21cIixcbiAgYmx1ZTogXCJcXHgxQlszNG1cIixcbiAgbWFnZW50YTogXCJcXHgxQlszNW1cIixcbiAgY3lhbjogXCJcXHgxQlszNm1cIixcbiAgd2hpdGU6IFwiXFx4MUJbMzdtXCIsXG4gIGRlZmF1bHQ6IFwiXFx4MUJbMzltXCJcbn07XG52YXIgZGVmYXVsdExldmVsID0gXCJkZWJ1Z1wiO1xudmFyIGNyZWF0ZWQgPSBEYXRlLm5vdygpO1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdExvZ2dlckZhY3RvcnkoKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgdHJhY2UgPSAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc29sZS50cmFjZSguLi5hcmdzKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlYnVnID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnNvbGUuZGVidWcoLi4uYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBpbmZvID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICB9O1xuICAgIGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgZXJyb3IgPSAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0cmFjZSxcbiAgICAgIGRlYnVnLFxuICAgICAgaW5mbyxcbiAgICAgIHdhcm4sXG4gICAgICBlcnJvclxuICAgIH07XG4gIH07XG59XG52YXIgd3JhcExvZ2dlciA9IChsb2dnZXIsIG1vZHVsZU5hbWUsIGxvZ0xldmVsKSA9PiB7XG4gIGxldCBpc1RyYWNlID0gZmFsc2U7XG4gIGxldCBpc0RlYnVnID0gZmFsc2U7XG4gIGxldCBpc0luZm8gPSBmYWxzZTtcbiAgbGV0IGlzV2FybmluZyA9IGZhbHNlO1xuICBsZXQgaXNFcnJvciA9IGZhbHNlO1xuICBsZXQgX2xldmVsID0gbG9nTGV2ZWw7XG4gIGxldCBfbG9nZ2VyID0gbG9nZ2VyO1xuICBjb25zdCB0cmFjZVByZWZpeCA9IGAke0NPTE9SUy5tYWdlbnRhfVtUUkFDRV0ke0NPTE9SUy5kZWZhdWx0fSAke21vZHVsZU5hbWV9YDtcbiAgY29uc3QgZGVidWdQcmVmaXggPSBgJHtDT0xPUlMuY3lhbn1bREVCVUddJHtDT0xPUlMuZGVmYXVsdH0gJHttb2R1bGVOYW1lfWA7XG4gIGNvbnN0IGluZm9QcmVmaXggPSBgJHtDT0xPUlMuZ3JlZW59W0lORk9dJHtDT0xPUlMuZGVmYXVsdH0gJHttb2R1bGVOYW1lfWA7XG4gIGNvbnN0IHdhcm5QcmVmaXggPSBgJHtDT0xPUlMueWVsbG93fVtXQVJOXSR7Q09MT1JTLmRlZmF1bHR9ICR7bW9kdWxlTmFtZX1gO1xuICBjb25zdCBlcnJvclByZWZpeCA9IGAke0NPTE9SUy5yZWR9W0VSUk9SXSR7Q09MT1JTLmRlZmF1bHR9ICR7bW9kdWxlTmFtZX1gO1xuICBjb25zdCByZXN1bHQgPSBuZXcgY2xhc3Mge1xuICAgIGluaXQoKSB7XG4gICAgICBpc1RyYWNlID0gW1widHJhY2VcIl0uaW5jbHVkZXMoX2xldmVsID8/IGRlZmF1bHRMZXZlbCk7XG4gICAgICBpc0RlYnVnID0gW1widHJhY2VcIiwgXCJkZWJ1Z1wiXS5pbmNsdWRlcyhfbGV2ZWwgPz8gZGVmYXVsdExldmVsKTtcbiAgICAgIGlzSW5mbyA9IFtcInRyYWNlXCIsIFwiZGVidWdcIiwgXCJpbmZvXCJdLmluY2x1ZGVzKF9sZXZlbCA/PyBkZWZhdWx0TGV2ZWwpO1xuICAgICAgaXNXYXJuaW5nID0gW1widHJhY2VcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCJdLmluY2x1ZGVzKFxuICAgICAgICBfbGV2ZWwgPz8gZGVmYXVsdExldmVsXG4gICAgICApO1xuICAgICAgaXNFcnJvciA9IFtcInRyYWNlXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdLmluY2x1ZGVzKFxuICAgICAgICBfbGV2ZWwgPz8gZGVmYXVsdExldmVsXG4gICAgICApO1xuICAgIH1cbiAgICBnZXQgbG9nZ2VyKCkge1xuICAgICAgcmV0dXJuIF9sb2dnZXI7XG4gICAgfVxuICAgIHNldCBsb2dnZXIodmFsdWUpIHtcbiAgICAgIF9sb2dnZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgcmV0dXJuIF9sZXZlbDtcbiAgICB9XG4gICAgc2V0IGxldmVsKHZhbHVlKSB7XG4gICAgICBfbGV2ZWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiBuZWVkIGFueVxuICAgIHRyYWNlKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChpc1RyYWNlKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRJbk1zID0gYCR7Q09MT1JTLm1hZ2VudGF9KyR7RGF0ZS5ub3coKSAtIGNyZWF0ZWR9bXMke0NPTE9SUy5kZWZhdWx0fWA7XG4gICAgICAgIGxvZ2dlci50cmFjZSh0cmFjZVByZWZpeCwgLi4uYXJncywgZWxhcHNlZEluTXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IG5lZWQgYW55XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZEluTXMgPSBgJHtDT0xPUlMubWFnZW50YX0rJHtEYXRlLm5vdygpIC0gY3JlYXRlZH1tcyR7Q09MT1JTLmRlZmF1bHR9YDtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGRlYnVnUHJlZml4LCAuLi5hcmdzLCBlbGFwc2VkSW5Ncyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogbmVlZCBhbnlcbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChpc0luZm8pIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZEluTXMgPSBgJHtDT0xPUlMubWFnZW50YX0rJHtEYXRlLm5vdygpIC0gY3JlYXRlZH1tcyR7Q09MT1JTLmRlZmF1bHR9YDtcbiAgICAgICAgbG9nZ2VyLmluZm8oaW5mb1ByZWZpeCwgLi4uYXJncywgZWxhcHNlZEluTXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IG5lZWQgYW55XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICBpZiAoaXNXYXJuaW5nKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRJbk1zID0gYCR7Q09MT1JTLm1hZ2VudGF9KyR7RGF0ZS5ub3coKSAtIGNyZWF0ZWR9bXMke0NPTE9SUy5kZWZhdWx0fWA7XG4gICAgICAgIGxvZ2dlci53YXJuKHdhcm5QcmVmaXgsIC4uLmFyZ3MsIGVsYXBzZWRJbk1zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiBuZWVkIGFueVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRJbk1zID0gYCR7Q09MT1JTLm1hZ2VudGF9KyR7RGF0ZS5ub3coKSAtIGNyZWF0ZWR9bXMke0NPTE9SUy5kZWZhdWx0fWA7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvclByZWZpeCwgLi4uYXJncywgZWxhcHNlZEluTXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBhY3R1YWxMb2dnZXJGYWN0b3J5ID0gY3JlYXRlRGVmYXVsdExvZ2dlckZhY3RvcnkoKTtcbnZhciBsb2dnZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBjcmVhdGVMb2dnZXIgPSAobW9kdWxlTmFtZSwgbG9nTGV2ZWwpID0+IHtcbiAgbGV0IHdyYXBwZWRMb2dnZXIgPSBsb2dnZXJzLmdldChtb2R1bGVOYW1lKTtcbiAgaWYgKCF3cmFwcGVkTG9nZ2VyKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gYWN0dWFsTG9nZ2VyRmFjdG9yeSgpO1xuICAgIHdyYXBwZWRMb2dnZXIgPSB3cmFwTG9nZ2VyKGxvZ2dlciwgbW9kdWxlTmFtZSwgbG9nTGV2ZWwgPz8gZGVmYXVsdExldmVsKTtcbiAgICBsb2dnZXJzLnNldChtb2R1bGVOYW1lLCB3cmFwcGVkTG9nZ2VyKTtcbiAgfSBlbHNlIHtcbiAgICB3cmFwcGVkTG9nZ2VyLmxldmVsID0gbG9nTGV2ZWwgPz8gZGVmYXVsdExldmVsO1xuICB9XG4gIHdyYXBwZWRMb2dnZXIuaW5pdCgpO1xuICByZXR1cm4gd3JhcHBlZExvZ2dlcjtcbn07XG52YXIgc2V0TG9nTGV2ZWwgPSAobGV2ZWwpID0+IHtcbiAgZGVmYXVsdExldmVsID0gbGV2ZWw7XG4gIGZvciAoY29uc3QgW21vZHVsZU5hbWVdIG9mIEFycmF5LmZyb20obG9nZ2Vycy5lbnRyaWVzKCkpKSB7XG4gICAgbG9nZ2Vycy5zZXQobW9kdWxlTmFtZSwgY3JlYXRlTG9nZ2VyKG1vZHVsZU5hbWUsIGxldmVsKSk7XG4gIH1cbn07XG52YXIgc2V0TG9nZ2VyRmFjdG9yeSA9IChsb2dnZXJGYWN0b3J5KSA9PiB7XG4gIGFjdHVhbExvZ2dlckZhY3RvcnkgPSBsb2dnZXJGYWN0b3J5O1xuICBmb3IgKGNvbnN0IFttb2R1bGVOYW1lLCBsb2dnZXJdIG9mIEFycmF5LmZyb20obG9nZ2Vycy5lbnRyaWVzKCkpKSB7XG4gICAgbG9nZ2Vycy5zZXQobW9kdWxlTmFtZSwgY3JlYXRlTG9nZ2VyKG1vZHVsZU5hbWUsIGxvZ2dlci5sZXZlbCkpO1xuICB9XG59O1xudmFyIG1haW5Mb2dnZXIgPSB7XG4gIGNyZWF0ZVN1YkxvZ2dlcjogKG1vZHVsZU5hbWUpID0+IGNyZWF0ZUxvZ2dlcihgbmV6dWtvOiR7bW9kdWxlTmFtZX1gKVxufTtcblxuZXhwb3J0IHtcbiAgY3JlYXRlTG9nZ2VyLFxuICBzZXRMb2dMZXZlbCxcbiAgc2V0TG9nZ2VyRmFjdG9yeSxcbiAgbWFpbkxvZ2dlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUVWWFdNQ05ULmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-FE7RZJBI.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-FE7RZJBI.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Consumer_default: function() { return /* binding */ Consumer_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n\n\n\n// src/Consumer.ts\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_0__.mainLogger.createSubLogger(\"Consumer\");\nvar Consumer = class _Consumer extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_1__.EnhancedEventEmitter {\n  /**\n   * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.\n   */\n  producerId;\n  /**\n   * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.\n   */\n  producerPeerId;\n  /**\n   * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.\n   */\n  label;\n  /**\n   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.\n   *\n   * @default false\n   */\n  __consuming = false;\n  /**\n   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.\n   *\n   * @default false\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get consuming() {\n    return this.__consuming;\n  }\n  /**\n   * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.\n   * @remarks This is a private property and should not be accessed directly.\n   *\n   * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.\n   */\n  #mediasoupConsumer = null;\n  /**\n   * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.\n   */\n  get id() {\n    return this.#mediasoupConsumer?.id;\n  }\n  /**\n   *\n   * @param consumer Sets the mediasoupConsumer for the Consumer\n   */\n  setMediaSoupConsumer(consumer) {\n    if (this.consuming) {\n      throw new Error(\"Consumer is already consuming\");\n    }\n    if (this.#mediasoupConsumer) {\n      throw new Error(\"Consumer already has a mediasoupConsumer\");\n    }\n    this.#mediasoupConsumer = consumer;\n    this.__consuming = true;\n  }\n  /**\n   * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get consumerId() {\n    return this.#mediasoupConsumer?.id;\n  }\n  /**\n   * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get track() {\n    return this.#mediasoupConsumer?.track;\n  }\n  /**\n   * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get kind() {\n    return this.#mediasoupConsumer?.kind;\n  }\n  /**\n   * If the Consumer is paused, it is only available when the Consumer is consuming a media.\n   *\n   * if paused the user is not consuming any media for the given producerId.\n   */\n  get paused() {\n    return this.#mediasoupConsumer?.paused;\n  }\n  /**\n   * AppData of the Consumer, it is only available when the Consumer is consuming a media.\n   */\n  get appData() {\n    return this.#mediasoupConsumer?.appData;\n  }\n  /**\n   * State of a Consumer is defined by the following:\n   * - `playable` - The Consumer is ready to play the media.\n   * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.\n   * - `paused` - The Consumer is paused and is not playing the media.\n   * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: \"video\", appData: {} });` after which the state will change to `playable`.\n   */\n  get state() {\n    if (this?.consuming)\n      return \"playable\";\n    if (this?.paused)\n      return \"paused\";\n    return \"available\";\n  }\n  /**\n   * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.\n   * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.\n   * @returns - RTCStatsReport | null\n   */\n  getStats = async () => {\n    const stats = await this.#mediasoupConsumer?.getStats();\n    return stats;\n  };\n  /**\n   * Resume the consumer, if the state of the consumer is `paused`.\n   */\n  resume = () => {\n    this.#mediasoupConsumer?.resume();\n  };\n  /**\n   * Removes all the eventListeners attached to the Consumer.\n   */\n  removeListeners = () => {\n    this.removeAllListeners();\n  };\n  /**\n   * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.\n   */\n  static create = (data) => {\n    try {\n      const consumer = new _Consumer(data);\n      return consumer;\n    } catch (error) {\n      logger.error(error);\n      throw new Error(\"\\u274C Error creating Consumer\");\n    }\n  };\n  close = () => {\n    try {\n      this.#mediasoupConsumer?.close();\n      this.__consuming = false;\n      this.emit(\"closed\");\n      this.removeAllListeners();\n    } catch (error) {\n      logger.error(\"\\u274C Error Closing Consumer\");\n      logger.error({\n        consumerId: this.consumerId,\n        producerId: this.producerId\n      });\n    }\n  };\n  constructor(data) {\n    super();\n    this.producerPeerId = data.producerPeerId;\n    this.producerId = data.producerId;\n    this.label = data.label;\n  }\n};\nvar Consumer_default = Consumer;\n\n\n//# sourceMappingURL=chunk-FE7RZJBI.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUZFN1JaSkJJLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUU2QjtBQUdBOztBQUU3QjtBQUNBLGFBQWEsMERBQVU7QUFDdkIsdUNBQXVDLG9FQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHFDQUFxQyxFQUFFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHFDQUFxQyxFQUFFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHFDQUFxQyxFQUFFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHFDQUFxQyxFQUFFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkgscUNBQXFDLEVBQUU7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLG1DQUFtQztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUZFN1JaSkJJLmpzPzlmMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgbWFpbkxvZ2dlclxufSBmcm9tIFwiLi9jaHVuay1FVlhXTUNOVC5qc1wiO1xuaW1wb3J0IHtcbiAgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbn0gZnJvbSBcIi4vY2h1bmstN09UUUFGWEUuanNcIjtcblxuLy8gc3JjL0NvbnN1bWVyLnRzXG52YXIgbG9nZ2VyID0gbWFpbkxvZ2dlci5jcmVhdGVTdWJMb2dnZXIoXCJDb25zdW1lclwiKTtcbnZhciBDb25zdW1lciA9IGNsYXNzIF9Db25zdW1lciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFByb2R1Y2VySWQgb2YgdGhlIENvbnN1bWVyLCB0aGlzIGlzIHRoZSBpZCBvZiB0aGUgTWVkaWEgRW50aXR5IHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBwcm9kdWNpbmcgdGhlIG1lZGlhIGluIHRoZSByb29tLlxuICAgKi9cbiAgcHJvZHVjZXJJZDtcbiAgLyoqXG4gICAqIFBlZXJJZCBvZiB0aGUgUHJvZHVjZXIsIHRoaXMgaXMgdGhlIHBlZXJJZCBvZiB0aGUgUGVlciB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgcHJvZHVjaW5nIHRoZSBtZWRpYSBpbiB0aGUgcm9vbS5cbiAgICovXG4gIHByb2R1Y2VyUGVlcklkO1xuICAvKipcbiAgICogTGFiZWwgb2YgdGhlIENvbnN1bWVyLCB0aGlzIGlzIHRoZSBsYWJlbCBvZiB0aGUgTWVkaWEgRW50aXR5IHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBwcm9kdWNpbmcgdGhlIG1lZGlhIGluIHRoZSByb29tLlxuICAgKi9cbiAgbGFiZWw7XG4gIC8qKlxuICAgKiBGbGFnIHRvIGNoZWNrIGlmIHRoZSBDb25zdW1lciBpcyBjb25zdW1pbmcgYSBtZWRpYSwgaWYgYHRydWVgIHRoZW4gdGhlIENvbnN1bWVyIGlzIGNvbnN1bWluZyBhIG1lZGlhLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgX19jb25zdW1pbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEZsYWcgdG8gY2hlY2sgaWYgdGhlIENvbnN1bWVyIGlzIGNvbnN1bWluZyBhIG1lZGlhLCBpZiBgdHJ1ZWAgdGhlbiB0aGUgQ29uc3VtZXIgaXMgY29uc3VtaW5nIGEgbWVkaWEuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZXJlIGFyZSB0d28gd2F5cyBhIFBlZXIgY2FuIENvbnN1bWUgYW55IG1lZGlhIHByb2R1Y2VkIGluIHRoZSByb29tLlxuICAgKiAtIEF1dG9tYXRpY2FsbHkgY29uc3VtZSB0aGUgbWVkaWEgc3RyZWFtcyBvZiB0aGUgcmVtb3RlIHBlZXJzIGJ5IHNldHRpbmcgdGhlIGBhdXRvQ29uc3VtZWAgZmxhZyB0byBgdHJ1ZWAgaW4gdGhlIGBSb29tYC5cbiAgICogLSBVc2luZyB0aGUgYGNvbnN1bWVgIGZ1bmN0aW9uIGluc2lkZSB0aGUgYExvY2FsUGVlcmAgaW5zdGFuY2UuIGBsb2NhbFBlZXIuY29uc3VtZSh7IHBlZXJJZCwgbGFiZWw6IFwidmlkZW9cIiwgYXBwRGF0YToge30gfSk7YFxuICAgKi9cbiAgZ2V0IGNvbnN1bWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2NvbnN1bWluZztcbiAgfVxuICAvKipcbiAgICogbWVkaWFzb3VwQ29uc3VtZXIgaW5zdGFuY2UsIHRoaXMgaXMgdGhlIGluc3RhbmNlIG9mIHRoZSBtZWRpYXNvdXBDb25zdW1lciB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgY29uc3VtaW5nIHRoZSBtZWRpYSBpbiB0aGUgcm9vbS5cbiAgICogQHJlbWFya3MgVGhpcyBpcyBhIHByaXZhdGUgcHJvcGVydHkgYW5kIHNob3VsZCBub3QgYmUgYWNjZXNzZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqIEV2ZXJ5IENvbnN1bWVyIGlzIGNyZWF0ZWQgd2l0aG91dCBhIG1lZGlhc291cENvbnN1bWVyLCB3aGVuIHRoZSBwZWVyIHN0YXJ0cyB0byBjb25zdW1lIHRoZSBtZWRpYSwgdGhlIG1lZGlhc291cENvbnN1bWVyIGlzIHNldC5cbiAgICovXG4gICNtZWRpYXNvdXBDb25zdW1lciA9IG51bGw7XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBpZCBmb3IgdGhlIG1lZGlhU291cENvbnN1bWVyLCB3aGljaCBpcyBhbHNvIHRoZSBpZCBvZiB0aGUgQ29uc3VtZXIgZm9yIHRoZSBSZW1vdGVQZWVyLlxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLiNtZWRpYXNvdXBDb25zdW1lcj8uaWQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBjb25zdW1lciBTZXRzIHRoZSBtZWRpYXNvdXBDb25zdW1lciBmb3IgdGhlIENvbnN1bWVyXG4gICAqL1xuICBzZXRNZWRpYVNvdXBDb25zdW1lcihjb25zdW1lcikge1xuICAgIGlmICh0aGlzLmNvbnN1bWluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc3VtZXIgaXMgYWxyZWFkeSBjb25zdW1pbmdcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtZWRpYXNvdXBDb25zdW1lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc3VtZXIgYWxyZWFkeSBoYXMgYSBtZWRpYXNvdXBDb25zdW1lclwiKTtcbiAgICB9XG4gICAgdGhpcy4jbWVkaWFzb3VwQ29uc3VtZXIgPSBjb25zdW1lcjtcbiAgICB0aGlzLl9fY29uc3VtaW5nID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgbWVkaWFzb3VwQ29uc3VtZXIgaWQsIHdoaWNoIGlzIGFsc28gdGhlIGlkIG9mIHRoZSBDb25zdW1lciBmb3IgdGhlIFJlbW90ZVBlZXIuIGl0IGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIENvbnN1bWVyIGlzIGNvbnN1bWluZyBhIG1lZGlhLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGVyZSBhcmUgdHdvIHdheXMgYSBQZWVyIGNhbiBDb25zdW1lIGFueSBtZWRpYSBwcm9kdWNlZCBpbiB0aGUgcm9vbS5cbiAgICogLSBBdXRvbWF0aWNhbGx5IGNvbnN1bWUgdGhlIG1lZGlhIHN0cmVhbXMgb2YgdGhlIHJlbW90ZSBwZWVycyBieSBzZXR0aW5nIHRoZSBgYXV0b0NvbnN1bWVgIGZsYWcgdG8gYHRydWVgIGluIHRoZSBgUm9vbWAuXG4gICAqIC0gVXNpbmcgdGhlIGBjb25zdW1lYCBmdW5jdGlvbiBpbnNpZGUgdGhlIGBMb2NhbFBlZXJgIGluc3RhbmNlLiBgbG9jYWxQZWVyLmNvbnN1bWUoeyBwZWVySWQsIGxhYmVsOiBcInZpZGVvXCIsIGFwcERhdGE6IHt9IH0pO2BcbiAgICovXG4gIGdldCBjb25zdW1lcklkKCkge1xuICAgIHJldHVybiB0aGlzLiNtZWRpYXNvdXBDb25zdW1lcj8uaWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgVHJhY2sgb2YgdGhlIENvbnN1bWVyLCBpdCBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBDb25zdW1lciBpcyBjb25zdW1pbmcgYSBtZWRpYS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlcmUgYXJlIHR3byB3YXlzIGEgUGVlciBjYW4gQ29uc3VtZSBhbnkgbWVkaWEgcHJvZHVjZWQgaW4gdGhlIHJvb20uXG4gICAqIC0gQXV0b21hdGljYWxseSBjb25zdW1lIHRoZSBtZWRpYSBzdHJlYW1zIG9mIHRoZSByZW1vdGUgcGVlcnMgYnkgc2V0dGluZyB0aGUgYGF1dG9Db25zdW1lYCBmbGFnIHRvIGB0cnVlYCBpbiB0aGUgYFJvb21gLlxuICAgKiAtIFVzaW5nIHRoZSBgY29uc3VtZWAgZnVuY3Rpb24gaW5zaWRlIHRoZSBgTG9jYWxQZWVyYCBpbnN0YW5jZS4gYGxvY2FsUGVlci5jb25zdW1lKHsgcGVlcklkLCBsYWJlbDogXCJ2aWRlb1wiLCBhcHBEYXRhOiB7fSB9KTtgXG4gICAqL1xuICBnZXQgdHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI21lZGlhc291cENvbnN1bWVyPy50cmFjaztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBraW5kIG9mIHRoZSBDb25zdW1lciwgaXQgaXMgb25seSBhdmFpbGFibGUgd2hlbiB0aGUgQ29uc3VtZXIgaXMgY29uc3VtaW5nIGEgbWVkaWEuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZXJlIGFyZSB0d28gd2F5cyBhIFBlZXIgY2FuIENvbnN1bWUgYW55IG1lZGlhIHByb2R1Y2VkIGluIHRoZSByb29tLlxuICAgKiAtIEF1dG9tYXRpY2FsbHkgY29uc3VtZSB0aGUgbWVkaWEgc3RyZWFtcyBvZiB0aGUgcmVtb3RlIHBlZXJzIGJ5IHNldHRpbmcgdGhlIGBhdXRvQ29uc3VtZWAgZmxhZyB0byBgdHJ1ZWAgaW4gdGhlIGBSb29tYC5cbiAgICogLSBVc2luZyB0aGUgYGNvbnN1bWVgIGZ1bmN0aW9uIGluc2lkZSB0aGUgYExvY2FsUGVlcmAgaW5zdGFuY2UuIGBsb2NhbFBlZXIuY29uc3VtZSh7IHBlZXJJZCwgbGFiZWw6IFwidmlkZW9cIiwgYXBwRGF0YToge30gfSk7YFxuICAgKi9cbiAgZ2V0IGtpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21lZGlhc291cENvbnN1bWVyPy5raW5kO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgQ29uc3VtZXIgaXMgcGF1c2VkLCBpdCBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBDb25zdW1lciBpcyBjb25zdW1pbmcgYSBtZWRpYS5cbiAgICpcbiAgICogaWYgcGF1c2VkIHRoZSB1c2VyIGlzIG5vdCBjb25zdW1pbmcgYW55IG1lZGlhIGZvciB0aGUgZ2l2ZW4gcHJvZHVjZXJJZC5cbiAgICovXG4gIGdldCBwYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21lZGlhc291cENvbnN1bWVyPy5wYXVzZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEFwcERhdGEgb2YgdGhlIENvbnN1bWVyLCBpdCBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBDb25zdW1lciBpcyBjb25zdW1pbmcgYSBtZWRpYS5cbiAgICovXG4gIGdldCBhcHBEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNtZWRpYXNvdXBDb25zdW1lcj8uYXBwRGF0YTtcbiAgfVxuICAvKipcbiAgICogU3RhdGUgb2YgYSBDb25zdW1lciBpcyBkZWZpbmVkIGJ5IHRoZSBmb2xsb3dpbmc6XG4gICAqIC0gYHBsYXlhYmxlYCAtIFRoZSBDb25zdW1lciBpcyByZWFkeSB0byBwbGF5IHRoZSBtZWRpYS5cbiAgICogLSBgdW5hdmFpbGFibGVgIC0gVGhlIENvbnN1bWVyIGlzIG5vdCBhdmFpbGFibGUgdG8gcGxheSB0aGUgbWVkaWEuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBDb25zdW1lciBpcyBjbG9zZWQgb3IgcGF1c2VkLlxuICAgKiAtIGBwYXVzZWRgIC0gVGhlIENvbnN1bWVyIGlzIHBhdXNlZCBhbmQgaXMgbm90IHBsYXlpbmcgdGhlIG1lZGlhLlxuICAgKiAtIGBhdmFpbGFibGVgIC0gVGhlIENvbnN1bWVyIGlzIGF2YWlsYWJsZSB0byBwbGF5IHRoZSBtZWRpYS4gUGVlciBjYW4gY29uc3VtZSB0aGUgbWVkaWEgYnkgdXNpbmcgYGxvY2FsUGVlci5jb25zdW1lKHsgcGVlcklkLCBsYWJlbDogXCJ2aWRlb1wiLCBhcHBEYXRhOiB7fSB9KTtgIGFmdGVyIHdoaWNoIHRoZSBzdGF0ZSB3aWxsIGNoYW5nZSB0byBgcGxheWFibGVgLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIGlmICh0aGlzPy5jb25zdW1pbmcpXG4gICAgICByZXR1cm4gXCJwbGF5YWJsZVwiO1xuICAgIGlmICh0aGlzPy5wYXVzZWQpXG4gICAgICByZXR1cm4gXCJwYXVzZWRcIjtcbiAgICByZXR1cm4gXCJhdmFpbGFibGVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0cyBvZiB0aGUgQ29uc3VtZXIsIGl0IGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIENvbnN1bWVyIGlzIGNvbnN1bWluZyBhIG1lZGlhLlxuICAgKiBJdCBnZW5lcmF0ZXMgdGhlIHN0YXRzIGZvciB0aGUgQ29uc3VtZXIgdXNpbmcgdGhlIGBnZXRTdGF0c2AgbWV0aG9kIG9mIHRoZSBtZWRpYXNvdXBDb25zdW1lci5cbiAgICogQHJldHVybnMgLSBSVENTdGF0c1JlcG9ydCB8IG51bGxcbiAgICovXG4gIGdldFN0YXRzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy4jbWVkaWFzb3VwQ29uc3VtZXI/LmdldFN0YXRzKCk7XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9O1xuICAvKipcbiAgICogUmVzdW1lIHRoZSBjb25zdW1lciwgaWYgdGhlIHN0YXRlIG9mIHRoZSBjb25zdW1lciBpcyBgcGF1c2VkYC5cbiAgICovXG4gIHJlc3VtZSA9ICgpID0+IHtcbiAgICB0aGlzLiNtZWRpYXNvdXBDb25zdW1lcj8ucmVzdW1lKCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0aGUgZXZlbnRMaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIENvbnN1bWVyLlxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ29uc3VtZXIgaW5zdGFuY2UuIFRoaXMgaXMgYSBzdGF0aWMgbWV0aG9kIGFuZCBzaG91bGQgYmUgY2FsbGVkIHVzaW5nIGBDb25zdW1lci5jcmVhdGUoeyBwcm9kdWNlclBlZXJJZCwgcHJvZHVjZXJJZCwgbGFiZWwgfSlgLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnN1bWVyID0gbmV3IF9Db25zdW1lcihkYXRhKTtcbiAgICAgIHJldHVybiBjb25zdW1lcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgRXJyb3IgY3JlYXRpbmcgQ29uc3VtZXJcIik7XG4gICAgfVxuICB9O1xuICBjbG9zZSA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy4jbWVkaWFzb3VwQ29uc3VtZXI/LmNsb3NlKCk7XG4gICAgICB0aGlzLl9fY29uc3VtaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoXCJjbG9zZWRcIik7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIENsb3NpbmcgQ29uc3VtZXJcIik7XG4gICAgICBsb2dnZXIuZXJyb3Ioe1xuICAgICAgICBjb25zdW1lcklkOiB0aGlzLmNvbnN1bWVySWQsXG4gICAgICAgIHByb2R1Y2VySWQ6IHRoaXMucHJvZHVjZXJJZFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByb2R1Y2VyUGVlcklkID0gZGF0YS5wcm9kdWNlclBlZXJJZDtcbiAgICB0aGlzLnByb2R1Y2VySWQgPSBkYXRhLnByb2R1Y2VySWQ7XG4gICAgdGhpcy5sYWJlbCA9IGRhdGEubGFiZWw7XG4gIH1cbn07XG52YXIgQ29uc3VtZXJfZGVmYXVsdCA9IENvbnN1bWVyO1xuXG5leHBvcnQge1xuICBDb25zdW1lcl9kZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstRkU3UlpKQkkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-FE7RZJBI.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-G7SIQXZ4.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-G7SIQXZ4.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateSize: function() { return /* binding */ estimateSize; },\n/* harmony export */   getMediaDeviceKind: function() { return /* binding */ getMediaDeviceKind; },\n/* harmony export */   getMediaStreamKind: function() { return /* binding */ getMediaStreamKind; },\n/* harmony export */   getMediaTrack: function() { return /* binding */ getMediaTrack; }\n/* harmony export */ });\n// src/helpers/index.ts\nvar getMediaStreamKind = (stream) => {\n  let kind = null;\n  const tracks = stream.getTracks();\n  for (const track of tracks) {\n    if (track.kind === \"audio\") {\n      kind = \"audio\";\n      break;\n    } else if (track.kind === \"video\") {\n      kind = \"video\";\n      break;\n    }\n  }\n  if (!kind) {\n    throw new Error(\"Stream Kind Not Found\");\n  }\n  return kind;\n};\nvar getMediaDeviceKind = (track) => {\n  if (track.kind === \"audio\") {\n    return \"mic\";\n  } else if (track.kind === \"video\") {\n    const settings = track.getSettings();\n    if (settings.displaySurface) {\n      return \"screen\";\n    } else {\n      return \"cam\";\n    }\n  }\n  return \"cam\";\n};\nvar getMediaTrack = (data) => {\n  const { stream, kind } = data;\n  const tracks = stream.getTracks();\n  for (const track of tracks) {\n    if (track.kind === kind) {\n      return track;\n    }\n  }\n  throw new Error(\"Track Not Found\");\n};\nvar estimateSize = (obj) => {\n  const str = JSON.stringify(obj);\n  return new TextEncoder().encode(str).length;\n};\n\n\n//# sourceMappingURL=chunk-G7SIQXZ4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUc3U0lRWFo0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaHVkZGxlMDErd2ViLWNvcmVAMS4wLjAtZGV2LjY2L25vZGVfbW9kdWxlcy9AaHVkZGxlMDEvd2ViLWNvcmUvZGlzdC9jaHVuay1HN1NJUVhaNC5qcz81MjM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9oZWxwZXJzL2luZGV4LnRzXG52YXIgZ2V0TWVkaWFTdHJlYW1LaW5kID0gKHN0cmVhbSkgPT4ge1xuICBsZXQga2luZCA9IG51bGw7XG4gIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgZm9yIChjb25zdCB0cmFjayBvZiB0cmFja3MpIHtcbiAgICBpZiAodHJhY2sua2luZCA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICBraW5kID0gXCJhdWRpb1wiO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBcInZpZGVvXCIpIHtcbiAgICAgIGtpbmQgPSBcInZpZGVvXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFraW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIEtpbmQgTm90IEZvdW5kXCIpO1xuICB9XG4gIHJldHVybiBraW5kO1xufTtcbnZhciBnZXRNZWRpYURldmljZUtpbmQgPSAodHJhY2spID0+IHtcbiAgaWYgKHRyYWNrLmtpbmQgPT09IFwiYXVkaW9cIikge1xuICAgIHJldHVybiBcIm1pY1wiO1xuICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFwidmlkZW9cIikge1xuICAgIGNvbnN0IHNldHRpbmdzID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBpZiAoc2V0dGluZ3MuZGlzcGxheVN1cmZhY2UpIHtcbiAgICAgIHJldHVybiBcInNjcmVlblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJjYW1cIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiY2FtXCI7XG59O1xudmFyIGdldE1lZGlhVHJhY2sgPSAoZGF0YSkgPT4ge1xuICBjb25zdCB7IHN0cmVhbSwga2luZCB9ID0gZGF0YTtcbiAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRyYWNrcykge1xuICAgIGlmICh0cmFjay5raW5kID09PSBraW5kKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlRyYWNrIE5vdCBGb3VuZFwiKTtcbn07XG52YXIgZXN0aW1hdGVTaXplID0gKG9iaikgPT4ge1xuICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikubGVuZ3RoO1xufTtcblxuZXhwb3J0IHtcbiAgZ2V0TWVkaWFTdHJlYW1LaW5kLFxuICBnZXRNZWRpYURldmljZUtpbmQsXG4gIGdldE1lZGlhVHJhY2ssXG4gIGVzdGltYXRlU2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUc3U0lRWFo0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-G7SIQXZ4.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Socket_default: function() { return /* binding */ Socket_default; },\n/* harmony export */   require_socket_types: function() { return /* binding */ require_socket_types; }\n/* harmony export */ });\n/* harmony import */ var _chunk_SSCVNXAL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-SSCVNXAL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SSCVNXAL.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n/* harmony import */ var _chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-UXIASGQL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js\");\n\n\n\n\n\n// ../types/dist/socket.types.js\nvar require_socket_types = (0,_chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_3__.__commonJS)({\n  \"../types/dist/socket.types.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SocketCloseReason = exports.ESocketCloseCode = void 0;\n    var ESocketCloseCode2;\n    (function(ESocketCloseCode3) {\n      ESocketCloseCode3[ESocketCloseCode3[\"ABNORMAL_CLOSURE\"] = 1006] = \"ABNORMAL_CLOSURE\";\n      ESocketCloseCode3[ESocketCloseCode3[\"NORMAL_CLOSURE\"] = 1e3] = \"NORMAL_CLOSURE\";\n      ESocketCloseCode3[ESocketCloseCode3[\"BROWSER_TAB_CLOSE\"] = 1001] = \"BROWSER_TAB_CLOSE\";\n      ESocketCloseCode3[ESocketCloseCode3[\"GOING_AWAY\"] = 4001] = \"GOING_AWAY\";\n      ESocketCloseCode3[ESocketCloseCode3[\"CONNECTION_EXPIRED\"] = 4002] = \"CONNECTION_EXPIRED\";\n      ESocketCloseCode3[ESocketCloseCode3[\"CONNECTION_ERROR\"] = 4006] = \"CONNECTION_ERROR\";\n      ESocketCloseCode3[ESocketCloseCode3[\"ROOM_CLOSED\"] = 4007] = \"ROOM_CLOSED\";\n      ESocketCloseCode3[ESocketCloseCode3[\"ROOM_ENTRY_DENIED\"] = 4008] = \"ROOM_ENTRY_DENIED\";\n      ESocketCloseCode3[ESocketCloseCode3[\"KICKED\"] = 4009] = \"KICKED\";\n    })(ESocketCloseCode2 || (exports.ESocketCloseCode = ESocketCloseCode2 = {}));\n    exports.SocketCloseReason = {\n      [ESocketCloseCode2.ROOM_CLOSED]: \"ROOM_CLOSED\",\n      [ESocketCloseCode2.ABNORMAL_CLOSURE]: \"ABNORMAL_CLOSURE\",\n      [ESocketCloseCode2.NORMAL_CLOSURE]: \"NORMAL_CLOSURE\",\n      [ESocketCloseCode2.BROWSER_TAB_CLOSE]: \"BROWSER_TAB_CLOSE\",\n      [ESocketCloseCode2.GOING_AWAY]: \"GOING_AWAY\",\n      [ESocketCloseCode2.CONNECTION_ERROR]: \"CONNECTION_ERROR\",\n      [ESocketCloseCode2.CONNECTION_EXPIRED]: \"CONNECTION_EXPIRED\",\n      [ESocketCloseCode2.ROOM_ENTRY_DENIED]: \"ROOM_ENTRY_DENIED\",\n      [ESocketCloseCode2.KICKED]: \"KICKED\"\n    };\n  }\n});\n\n// src/Socket.ts\nvar import_socket = (0,_chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_3__.__toESM)(require_socket_types(), 1);\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_1__.mainLogger.createSubLogger(\"Socket.ts\");\nvar Socket = class _Socket extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_2__.EnhancedEventEmitter {\n  /**\n   * Socket Instance, Singleton class\n   */\n  static __instance = null;\n  /**\n   * Retry count for the socket connection, if the connection is closed abnormally, we try to reconnect 5 times\n   */\n  __retryCount = 0;\n  /**\n   * Current connection state of the socket connection\n   */\n  __connectionState = \"uninitialized\";\n  /**\n   * Underlying WebSocket connection, until we dont call Socket.connect(); this will be null\n   */\n  __ws = null;\n  /**\n   * Map of all the subscribed events/topics for the socket connection\n   */\n  __subscribedMap = /* @__PURE__ */ new Map();\n  /**\n   * Region of the current socket connection, specific to the Local Peer who joined the meeting\n   */\n  __region = null;\n  /**\n   * Endpoint of the socket server, this is fetched from the API server\n   */\n  __ENDPOINT = null;\n  /**\n   * Flag to enable local development\n   */\n  isLocalDev = false;\n  /**\n   * Token of the current socket connection, specific to the Local Peer who joined the meeting\n   */\n  token = null;\n  /**\n   * Returns the underlying WebSocket connection, throws an error if the connection is not initialized\n   * @throws `Error` if the connection is not initialized\n   */\n  get ws() {\n    if (!this.__ws) {\n      throw new Error(\"\\u{1F534} Socket Not Initialised\");\n    }\n    return this.__ws;\n  }\n  /**\n   * Getter for the region of the current socket connection\n   */\n  get region() {\n    return this.__region;\n  }\n  /**\n   * Returns the current connection state of the socket connection\n   */\n  get connectionState() {\n    return this.__connectionState;\n  }\n  /**\n   * Returns true if the socket connection is connected\n   */\n  get connected() {\n    return this.ws.OPEN === 1 && this.connectionState === \"connected\";\n  }\n  /**\n   * Returns true if the socket connection is connecting\n   */\n  get connecting() {\n    return this.ws.CONNECTING === 0 && this.connectionState === \"connecting\";\n  }\n  /**\n   * Returns true if the socket connection is closed\n   */\n  get closed() {\n    return this.ws.CLOSED === 3 || this.ws.CLOSING === 2;\n  }\n  /**\n   * Sets the current connection state of the socket connection\n   */\n  set connectionState(state) {\n    logger.info(`Connection state changed to ${state}`);\n    this.__connectionState = state;\n  }\n  /**\n   * Update the token for this socket\n   * @throws `Error` if the token is already set\n   */\n  setToken(token) {\n    if (this.token) {\n      throw new Error(\"\\u{1F534} Token Already Set\");\n    }\n    this.token = token;\n    this.emit(\"token-updated\", token);\n  }\n  /**\n   * Set a new region for the socket connection\n   */\n  setRegion(region) {\n    this.__region = region;\n    this.emit(\"region-updated\", region);\n  }\n  /**\n   * Creates the socket and returns the instance of the socket if already initialized\n   * you need to call connect method to connect to the server\n   * @param data\n   * @returns\n   */\n  static create() {\n    if (!this.__instance) {\n      this.__instance = new _Socket();\n    }\n    return this.__instance;\n  }\n  /**\n   * Returns the instance of the socket connection, throws an error if the connection is not initialized\n   * @throws `Error` if the connection is not initialized\n   */\n  static getInstance() {\n    if (!_Socket.__instance) {\n      throw new Error(\n        \"\\u{1F534} Socket Instance Not Initialised, You are trying to do something which is not possible\"\n      );\n    }\n    return _Socket.__instance;\n  }\n  constructor() {\n    super();\n  }\n  /**\n   *\n   */\n  __getRegion = async () => {\n    const resp = await fetch(\n      \"https://shinigami.huddle01.com/api/get-geolocation\"\n    );\n    const data = await resp?.json();\n    const geolocationdata = _chunk_SSCVNXAL_js__WEBPACK_IMPORTED_MODULE_0__.GeolocationSchema.safeParse(data);\n    if (!geolocationdata.success) {\n      throw new Error(\"\\u{1F534} Error While Finding the Region to connect to\");\n    }\n    const region = geolocationdata.data.globalRegion;\n    return region;\n  };\n  enableLocalDev = () => {\n    this.isLocalDev = true;\n  };\n  /**\n   * Connect to the socket server using the token\n   * @param data - `{ token: string }`\n   */\n  connect = async (data) => {\n    if (!_Socket.__instance) {\n      throw new Error(\"\\u{1F534} Socket Instance Not Initialised\");\n    }\n    if (!this.token) {\n      this.setToken(data.token);\n    }\n    if (this.connectionState === \"connected\") {\n      logger.error(\"\\u{1F534} Socket Already Connected\");\n      return _Socket.__instance;\n    }\n    if (this.connectionState === \"connecting\") {\n      logger.error(\"\\u{1F534} Socket Connecting\");\n      return _Socket.__instance;\n    }\n    if (this.__ws) {\n      logger.error(\"\\u{1F534} Socket Already Initialized\");\n      return _Socket.__instance;\n    }\n    logger.info(\"\\u{1F50C} Connecting to the socket server\");\n    if (this.connectionState === \"awaiting-reconnection\") {\n      logger.info(\n        \"\\u{1F50C} Socket connection was awaiting reconnection , creating a new socket connection\"\n      );\n      this.emit(\"reconnecting\");\n    }\n    if (!this.__region) {\n      const region = await this.__getRegion();\n      this.__region = region;\n    }\n    const url = await this.__getConfigUrl(data.token, this.__region);\n    this.__ws = new WebSocket(url);\n    this.__ws.onerror = (ev) => {\n      logger.error(ev);\n    };\n    this.connectionState = \"connecting\";\n    this.emit(\"connecting\");\n    this.__ws.addEventListener(\"message\", this.__handleIncomingMessage);\n    this.__registerSocketEvents(this.ws);\n    this.__ws.onclose = async (ev) => {\n      logger.info(\"\\u{1F514} Socket connection closed\", ev);\n      if (ev.code === import_socket.ESocketCloseCode.ABNORMAL_CLOSURE) {\n        logger.info(\n          \"\\u{1F514} Socket connection closed abnormally, Trying to Reconnect\"\n        );\n        if (this.__retryCount < 7) {\n          const delay = 2 ** this.__retryCount * 1e3;\n          setTimeout(async () => {\n            if (this.token) {\n              try {\n                await this.connect({ token: this.token });\n                this.emit(\"reconnected\");\n                this.__retryCount = 0;\n              } catch (err) {\n                logger.error(\n                  `Reconnection Attempt ${this.__retryCount} failed`\n                );\n              }\n            }\n          }, Math.min(delay, 2e4));\n          this.__retryCount++;\n        } else {\n          logger.error(\n            \"\\u{1F534} Socket connection closed abnormally, reconnecting failed\"\n          );\n          this.close(import_socket.ESocketCloseCode.CONNECTION_EXPIRED);\n        }\n      }\n    };\n    const socketConnectionPromise = new Promise((resolve, reject) => {\n      const handleSuccess = () => {\n        logger.info(\"\\u2705 Socket Connection Established\");\n        handleRemoveListeners();\n        resolve();\n      };\n      const handleError = () => {\n        logger.error(\"\\u{1F534} Error While Connecting to the Socket\");\n        handleRemoveListeners();\n        reject(new Error(\"\\u274C Socket Connection Failed\"));\n      };\n      const handleRemoveListeners = () => {\n        this.off(\"connected\", handleSuccess);\n        this.off(\"failed\", handleError);\n      };\n      this.once(\"connected\", handleSuccess);\n      this.once(\"failed\", handleError);\n    });\n    await socketConnectionPromise;\n    return _Socket.__instance;\n  };\n  /**\n   * Closes the underlying socket connection, and clears all the event listeners and subscriptions to events as well as\n   * any other information related to the connection.\n   * @param code `{ ESocketCloseCode }`\n   */\n  close = (code) => {\n    this.ws.removeEventListener(\"message\", this.__handleIncomingMessage);\n    const reason = import_socket.SocketCloseReason[code];\n    logger.info(`\\u{1F50C} Closing the connection, ${code} ${reason}`);\n    if (code >= 3e3 && code <= 4999 || code === 1e3) {\n      this.ws.close(code, reason);\n      this.token = null;\n      this.__ENDPOINT = null;\n      this.emit(\"token-updated\", null);\n    } else {\n      this.ws.close();\n    }\n    this.__unregisterSocketEvents(this.ws);\n    this.__ws = null;\n    if (code === 1006) {\n      this.connectionState = \"awaiting-reconnection\";\n      logger.info(\"\\u{1F50C} Socket Connection closed abnormally, reconnecting\");\n      return;\n    }\n    this.connectionState = \"closed\";\n    this.emit(\"closed\", code);\n    logger.info(\"\\u{1F50C} Socket Connection closed\");\n  };\n  /**\n   * Publish a message to the server using the socket connection based on some events/topics\n   */\n  publish = (event, data) => {\n    const payload = JSON.stringify({\n      event,\n      data: data || {}\n    });\n    this.ws.send(payload);\n  };\n  /**\n   * Subscribe to a specific event/topic from the server\n   */\n  subscribe = (event, fn) => {\n    if (this.__subscribedMap.has(event)) {\n      logger.warn(\"\\u26A0\\uFE0F Overriding existing event handler\");\n    }\n    this.__subscribedMap.set(event, fn);\n  };\n  /**\n   * Get the config url for the socket connection based on the token and region\n   * @param token Local Peer specific meeting token\n   * @param region Local Peer specific region\n   * @returns\n   */\n  async __getConfigUrl(token, region) {\n    if (this.__ENDPOINT) {\n      return this.__ENDPOINT;\n    }\n    const apiServerUrl = this.isLocalDev ? \"http://localhost:8000/api/v1\" : \"https://apira.huddle01.com/api/v1\";\n    const res = await fetch(`${apiServerUrl}/getSushiUrl`, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        authorization: `Bearer ${token}`\n      }\n    });\n    if (!res.ok) {\n      throw new Error(\"\\u{1F534} Error While Fetching the Url\");\n    }\n    const { url } = await res.json();\n    this.__ENDPOINT = url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n    const wssAddress = `${this.__ENDPOINT}/ws`;\n    const wsAddress = `${wssAddress}?${[\n      `token=${token}`,\n      `version=${2}`,\n      `region=${region}`\n    ].join(\"&\")}`;\n    this.__ENDPOINT = wsAddress;\n    return wsAddress;\n  }\n  /**\n   * !Important\n   * Handle the incoming message from the server based on the events received from the server and call the subscribed event handler\n   */\n  __handleIncomingMessage = (event) => {\n    const { event: eventName, data } = JSON.parse(event.data);\n    logger.info(\"\\u{1F4E8} Incoming message event name: \", eventName);\n    const fn = this.__subscribedMap.get(eventName);\n    if (fn) {\n      fn(data);\n    }\n  };\n  __handleSocketError = (ev) => {\n    logger.error(\"Socket connection error\", ev);\n    this.connectionState = \"failed\";\n    this.emit(\"failed\");\n  };\n  /**\n   * @description Handle the socket close event which is sent by the server\n   * @param ev CloseEvent\n   */\n  __handleSocketClose = (ev) => {\n    logger.info(\"Socket connection closed\", ev);\n    const code = ev.code;\n    const reason = import_socket.SocketCloseReason[code];\n    logger.info(`\\u{1F534} { Server }: Closing the connection, ${code} ${reason}`);\n    this.close(code);\n  };\n  /**\n   * @description Handle the socket open event which is sent after the connection is established with the server\n   * @param ev Event\n   */\n  __handleSocketOpen = (ev) => {\n    logger.info(\"Socket Connection Open\", ev);\n    this.connectionState = \"connected\";\n    this.emit(\"connected\");\n  };\n  /**\n   * @description Register the socket events\n   * @param ws WebSocket\n   */\n  __registerSocketEvents = (ws) => {\n    ws.addEventListener(\"error\", this.__handleSocketError);\n    ws.addEventListener(\"close\", this.__handleSocketClose);\n    ws.addEventListener(\"open\", this.__handleSocketOpen);\n  };\n  /**\n   * @description Unregister the socket events\n   * @param ws WebSocket\n   */\n  __unregisterSocketEvents = (ws) => {\n    ws.removeEventListener(\"error\", this.__handleSocketError);\n    ws.removeEventListener(\"close\", this.__handleSocketClose);\n    ws.removeEventListener(\"open\", this.__handleSocketOpen);\n  };\n};\nvar Socket_default = Socket;\n\n\n//# sourceMappingURL=chunk-HVBBMWHF.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUhWQkJNV0hGLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUU2QjtBQUdBO0FBR0E7QUFJQTs7QUFFN0I7QUFDQSwyQkFBMkIsOERBQVU7QUFDckM7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUVBQXlFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQkFBb0IsMkRBQU87QUFDM0IsYUFBYSwwREFBVTtBQUN2QixtQ0FBbUMsb0VBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpRUFBaUI7QUFDN0M7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPLDBCQUEwQixNQUFNLEVBQUUsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDLHlCQUF5QixXQUFXLEdBQUc7QUFDdkMsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixFQUFFO0FBQ25CLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVMsUUFBUSw0QkFBNEIsTUFBTSxFQUFFLE9BQU87QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGh1ZGRsZTAxK3dlYi1jb3JlQDEuMC4wLWRldi42Ni9ub2RlX21vZHVsZXMvQGh1ZGRsZTAxL3dlYi1jb3JlL2Rpc3QvY2h1bmstSFZCQk1XSEYuanM/NjA5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBHZW9sb2NhdGlvblNjaGVtYVxufSBmcm9tIFwiLi9jaHVuay1TU0NWTlhBTC5qc1wiO1xuaW1wb3J0IHtcbiAgbWFpbkxvZ2dlclxufSBmcm9tIFwiLi9jaHVuay1FVlhXTUNOVC5qc1wiO1xuaW1wb3J0IHtcbiAgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbn0gZnJvbSBcIi4vY2h1bmstN09UUUFGWEUuanNcIjtcbmltcG9ydCB7XG4gIF9fY29tbW9uSlMsXG4gIF9fdG9FU01cbn0gZnJvbSBcIi4vY2h1bmstVVhJQVNHUUwuanNcIjtcblxuLy8gLi4vdHlwZXMvZGlzdC9zb2NrZXQudHlwZXMuanNcbnZhciByZXF1aXJlX3NvY2tldF90eXBlcyA9IF9fY29tbW9uSlMoe1xuICBcIi4uL3R5cGVzL2Rpc3Qvc29ja2V0LnR5cGVzLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLlNvY2tldENsb3NlUmVhc29uID0gZXhwb3J0cy5FU29ja2V0Q2xvc2VDb2RlID0gdm9pZCAwO1xuICAgIHZhciBFU29ja2V0Q2xvc2VDb2RlMjtcbiAgICAoZnVuY3Rpb24oRVNvY2tldENsb3NlQ29kZTMpIHtcbiAgICAgIEVTb2NrZXRDbG9zZUNvZGUzW0VTb2NrZXRDbG9zZUNvZGUzW1wiQUJOT1JNQUxfQ0xPU1VSRVwiXSA9IDEwMDZdID0gXCJBQk5PUk1BTF9DTE9TVVJFXCI7XG4gICAgICBFU29ja2V0Q2xvc2VDb2RlM1tFU29ja2V0Q2xvc2VDb2RlM1tcIk5PUk1BTF9DTE9TVVJFXCJdID0gMWUzXSA9IFwiTk9STUFMX0NMT1NVUkVcIjtcbiAgICAgIEVTb2NrZXRDbG9zZUNvZGUzW0VTb2NrZXRDbG9zZUNvZGUzW1wiQlJPV1NFUl9UQUJfQ0xPU0VcIl0gPSAxMDAxXSA9IFwiQlJPV1NFUl9UQUJfQ0xPU0VcIjtcbiAgICAgIEVTb2NrZXRDbG9zZUNvZGUzW0VTb2NrZXRDbG9zZUNvZGUzW1wiR09JTkdfQVdBWVwiXSA9IDQwMDFdID0gXCJHT0lOR19BV0FZXCI7XG4gICAgICBFU29ja2V0Q2xvc2VDb2RlM1tFU29ja2V0Q2xvc2VDb2RlM1tcIkNPTk5FQ1RJT05fRVhQSVJFRFwiXSA9IDQwMDJdID0gXCJDT05ORUNUSU9OX0VYUElSRURcIjtcbiAgICAgIEVTb2NrZXRDbG9zZUNvZGUzW0VTb2NrZXRDbG9zZUNvZGUzW1wiQ09OTkVDVElPTl9FUlJPUlwiXSA9IDQwMDZdID0gXCJDT05ORUNUSU9OX0VSUk9SXCI7XG4gICAgICBFU29ja2V0Q2xvc2VDb2RlM1tFU29ja2V0Q2xvc2VDb2RlM1tcIlJPT01fQ0xPU0VEXCJdID0gNDAwN10gPSBcIlJPT01fQ0xPU0VEXCI7XG4gICAgICBFU29ja2V0Q2xvc2VDb2RlM1tFU29ja2V0Q2xvc2VDb2RlM1tcIlJPT01fRU5UUllfREVOSUVEXCJdID0gNDAwOF0gPSBcIlJPT01fRU5UUllfREVOSUVEXCI7XG4gICAgICBFU29ja2V0Q2xvc2VDb2RlM1tFU29ja2V0Q2xvc2VDb2RlM1tcIktJQ0tFRFwiXSA9IDQwMDldID0gXCJLSUNLRURcIjtcbiAgICB9KShFU29ja2V0Q2xvc2VDb2RlMiB8fCAoZXhwb3J0cy5FU29ja2V0Q2xvc2VDb2RlID0gRVNvY2tldENsb3NlQ29kZTIgPSB7fSkpO1xuICAgIGV4cG9ydHMuU29ja2V0Q2xvc2VSZWFzb24gPSB7XG4gICAgICBbRVNvY2tldENsb3NlQ29kZTIuUk9PTV9DTE9TRURdOiBcIlJPT01fQ0xPU0VEXCIsXG4gICAgICBbRVNvY2tldENsb3NlQ29kZTIuQUJOT1JNQUxfQ0xPU1VSRV06IFwiQUJOT1JNQUxfQ0xPU1VSRVwiLFxuICAgICAgW0VTb2NrZXRDbG9zZUNvZGUyLk5PUk1BTF9DTE9TVVJFXTogXCJOT1JNQUxfQ0xPU1VSRVwiLFxuICAgICAgW0VTb2NrZXRDbG9zZUNvZGUyLkJST1dTRVJfVEFCX0NMT1NFXTogXCJCUk9XU0VSX1RBQl9DTE9TRVwiLFxuICAgICAgW0VTb2NrZXRDbG9zZUNvZGUyLkdPSU5HX0FXQVldOiBcIkdPSU5HX0FXQVlcIixcbiAgICAgIFtFU29ja2V0Q2xvc2VDb2RlMi5DT05ORUNUSU9OX0VSUk9SXTogXCJDT05ORUNUSU9OX0VSUk9SXCIsXG4gICAgICBbRVNvY2tldENsb3NlQ29kZTIuQ09OTkVDVElPTl9FWFBJUkVEXTogXCJDT05ORUNUSU9OX0VYUElSRURcIixcbiAgICAgIFtFU29ja2V0Q2xvc2VDb2RlMi5ST09NX0VOVFJZX0RFTklFRF06IFwiUk9PTV9FTlRSWV9ERU5JRURcIixcbiAgICAgIFtFU29ja2V0Q2xvc2VDb2RlMi5LSUNLRURdOiBcIktJQ0tFRFwiXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9Tb2NrZXQudHNcbnZhciBpbXBvcnRfc29ja2V0ID0gX190b0VTTShyZXF1aXJlX3NvY2tldF90eXBlcygpLCAxKTtcbnZhciBsb2dnZXIgPSBtYWluTG9nZ2VyLmNyZWF0ZVN1YkxvZ2dlcihcIlNvY2tldC50c1wiKTtcbnZhciBTb2NrZXQgPSBjbGFzcyBfU29ja2V0IGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogU29ja2V0IEluc3RhbmNlLCBTaW5nbGV0b24gY2xhc3NcbiAgICovXG4gIHN0YXRpYyBfX2luc3RhbmNlID0gbnVsbDtcbiAgLyoqXG4gICAqIFJldHJ5IGNvdW50IGZvciB0aGUgc29ja2V0IGNvbm5lY3Rpb24sIGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBhYm5vcm1hbGx5LCB3ZSB0cnkgdG8gcmVjb25uZWN0IDUgdGltZXNcbiAgICovXG4gIF9fcmV0cnlDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgb2YgdGhlIHNvY2tldCBjb25uZWN0aW9uXG4gICAqL1xuICBfX2Nvbm5lY3Rpb25TdGF0ZSA9IFwidW5pbml0aWFsaXplZFwiO1xuICAvKipcbiAgICogVW5kZXJseWluZyBXZWJTb2NrZXQgY29ubmVjdGlvbiwgdW50aWwgd2UgZG9udCBjYWxsIFNvY2tldC5jb25uZWN0KCk7IHRoaXMgd2lsbCBiZSBudWxsXG4gICAqL1xuICBfX3dzID0gbnVsbDtcbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgdGhlIHN1YnNjcmliZWQgZXZlbnRzL3RvcGljcyBmb3IgdGhlIHNvY2tldCBjb25uZWN0aW9uXG4gICAqL1xuICBfX3N1YnNjcmliZWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUmVnaW9uIG9mIHRoZSBjdXJyZW50IHNvY2tldCBjb25uZWN0aW9uLCBzcGVjaWZpYyB0byB0aGUgTG9jYWwgUGVlciB3aG8gam9pbmVkIHRoZSBtZWV0aW5nXG4gICAqL1xuICBfX3JlZ2lvbiA9IG51bGw7XG4gIC8qKlxuICAgKiBFbmRwb2ludCBvZiB0aGUgc29ja2V0IHNlcnZlciwgdGhpcyBpcyBmZXRjaGVkIGZyb20gdGhlIEFQSSBzZXJ2ZXJcbiAgICovXG4gIF9fRU5EUE9JTlQgPSBudWxsO1xuICAvKipcbiAgICogRmxhZyB0byBlbmFibGUgbG9jYWwgZGV2ZWxvcG1lbnRcbiAgICovXG4gIGlzTG9jYWxEZXYgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRva2VuIG9mIHRoZSBjdXJyZW50IHNvY2tldCBjb25uZWN0aW9uLCBzcGVjaWZpYyB0byB0aGUgTG9jYWwgUGVlciB3aG8gam9pbmVkIHRoZSBtZWV0aW5nXG4gICAqL1xuICB0b2tlbiA9IG51bGw7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBjb25uZWN0aW9uLCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluaXRpYWxpemVkXG4gICAqIEB0aHJvd3MgYEVycm9yYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGdldCB3cygpIHtcbiAgICBpZiAoIXRoaXMuX193cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1ezFGNTM0fSBTb2NrZXQgTm90IEluaXRpYWxpc2VkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX3dzO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSByZWdpb24gb2YgdGhlIGN1cnJlbnQgc29ja2V0IGNvbm5lY3Rpb25cbiAgICovXG4gIGdldCByZWdpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19yZWdpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICovXG4gIGdldCBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jb25uZWN0aW9uU3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc29ja2V0IGNvbm5lY3Rpb24gaXMgY29ubmVjdGVkXG4gICAqL1xuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLndzLk9QRU4gPT09IDEgJiYgdGhpcy5jb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc29ja2V0IGNvbm5lY3Rpb24gaXMgY29ubmVjdGluZ1xuICAgKi9cbiAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMud3MuQ09OTkVDVElORyA9PT0gMCAmJiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjb25uZWN0aW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc29ja2V0IGNvbm5lY3Rpb24gaXMgY2xvc2VkXG4gICAqL1xuICBnZXQgY2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLndzLkNMT1NFRCA9PT0gMyB8fCB0aGlzLndzLkNMT1NJTkcgPT09IDI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICovXG4gIHNldCBjb25uZWN0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICBsb2dnZXIuaW5mbyhgQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvICR7c3RhdGV9YCk7XG4gICAgdGhpcy5fX2Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHRva2VuIGZvciB0aGlzIHNvY2tldFxuICAgKiBAdGhyb3dzIGBFcnJvcmAgaWYgdGhlIHRva2VuIGlzIGFscmVhZHkgc2V0XG4gICAqL1xuICBzZXRUb2tlbih0b2tlbikge1xuICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHV7MUY1MzR9IFRva2VuIEFscmVhZHkgU2V0XCIpO1xuICAgIH1cbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5lbWl0KFwidG9rZW4tdXBkYXRlZFwiLCB0b2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIG5ldyByZWdpb24gZm9yIHRoZSBzb2NrZXQgY29ubmVjdGlvblxuICAgKi9cbiAgc2V0UmVnaW9uKHJlZ2lvbikge1xuICAgIHRoaXMuX19yZWdpb24gPSByZWdpb247XG4gICAgdGhpcy5lbWl0KFwicmVnaW9uLXVwZGF0ZWRcIiwgcmVnaW9uKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgc29ja2V0IGFuZCByZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgc29ja2V0IGlmIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICogeW91IG5lZWQgdG8gY2FsbCBjb25uZWN0IG1ldGhvZCB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG5ldyBfU29ja2V0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9faW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBzb2NrZXQgY29ubmVjdGlvbiwgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb25uZWN0aW9uIGlzIG5vdCBpbml0aWFsaXplZFxuICAgKiBAdGhyb3dzIGBFcnJvcmAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluaXRpYWxpemVkXG4gICAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCFfU29ja2V0Ll9faW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJcXHV7MUY1MzR9IFNvY2tldCBJbnN0YW5jZSBOb3QgSW5pdGlhbGlzZWQsIFlvdSBhcmUgdHJ5aW5nIHRvIGRvIHNvbWV0aGluZyB3aGljaCBpcyBub3QgcG9zc2libGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9Tb2NrZXQuX19pbnN0YW5jZTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgX19nZXRSZWdpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKFxuICAgICAgXCJodHRwczovL3NoaW5pZ2FtaS5odWRkbGUwMS5jb20vYXBpL2dldC1nZW9sb2NhdGlvblwiXG4gICAgKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcD8uanNvbigpO1xuICAgIGNvbnN0IGdlb2xvY2F0aW9uZGF0YSA9IEdlb2xvY2F0aW9uU2NoZW1hLnNhZmVQYXJzZShkYXRhKTtcbiAgICBpZiAoIWdlb2xvY2F0aW9uZGF0YS5zdWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHV7MUY1MzR9IEVycm9yIFdoaWxlIEZpbmRpbmcgdGhlIFJlZ2lvbiB0byBjb25uZWN0IHRvXCIpO1xuICAgIH1cbiAgICBjb25zdCByZWdpb24gPSBnZW9sb2NhdGlvbmRhdGEuZGF0YS5nbG9iYWxSZWdpb247XG4gICAgcmV0dXJuIHJlZ2lvbjtcbiAgfTtcbiAgZW5hYmxlTG9jYWxEZXYgPSAoKSA9PiB7XG4gICAgdGhpcy5pc0xvY2FsRGV2ID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gdGhlIHNvY2tldCBzZXJ2ZXIgdXNpbmcgdGhlIHRva2VuXG4gICAqIEBwYXJhbSBkYXRhIC0gYHsgdG9rZW46IHN0cmluZyB9YFxuICAgKi9cbiAgY29ubmVjdCA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgaWYgKCFfU29ja2V0Ll9faW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdXsxRjUzNH0gU29ja2V0IEluc3RhbmNlIE5vdCBJbml0aWFsaXNlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRva2VuKSB7XG4gICAgICB0aGlzLnNldFRva2VuKGRhdGEudG9rZW4pO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdXsxRjUzNH0gU29ja2V0IEFscmVhZHkgQ29ubmVjdGVkXCIpO1xuICAgICAgcmV0dXJuIF9Tb2NrZXQuX19pbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RpbmdcIikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1ezFGNTM0fSBTb2NrZXQgQ29ubmVjdGluZ1wiKTtcbiAgICAgIHJldHVybiBfU29ja2V0Ll9faW5zdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fd3MpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdXsxRjUzNH0gU29ja2V0IEFscmVhZHkgSW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm4gX1NvY2tldC5fX2luc3RhbmNlO1xuICAgIH1cbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUwQ30gQ29ubmVjdGluZyB0byB0aGUgc29ja2V0IHNlcnZlclwiKTtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uU3RhdGUgPT09IFwiYXdhaXRpbmctcmVjb25uZWN0aW9uXCIpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBcIlxcdXsxRjUwQ30gU29ja2V0IGNvbm5lY3Rpb24gd2FzIGF3YWl0aW5nIHJlY29ubmVjdGlvbiAsIGNyZWF0aW5nIGEgbmV3IHNvY2tldCBjb25uZWN0aW9uXCJcbiAgICAgICk7XG4gICAgICB0aGlzLmVtaXQoXCJyZWNvbm5lY3RpbmdcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5fX3JlZ2lvbikge1xuICAgICAgY29uc3QgcmVnaW9uID0gYXdhaXQgdGhpcy5fX2dldFJlZ2lvbigpO1xuICAgICAgdGhpcy5fX3JlZ2lvbiA9IHJlZ2lvbjtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fX2dldENvbmZpZ1VybChkYXRhLnRva2VuLCB0aGlzLl9fcmVnaW9uKTtcbiAgICB0aGlzLl9fd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgdGhpcy5fX3dzLm9uZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgIGxvZ2dlci5lcnJvcihldik7XG4gICAgfTtcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIHRoaXMuZW1pdChcImNvbm5lY3RpbmdcIik7XG4gICAgdGhpcy5fX3dzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX19oYW5kbGVJbmNvbWluZ01lc3NhZ2UpO1xuICAgIHRoaXMuX19yZWdpc3RlclNvY2tldEV2ZW50cyh0aGlzLndzKTtcbiAgICB0aGlzLl9fd3Mub25jbG9zZSA9IGFzeW5jIChldikgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHV7MUY1MTR9IFNvY2tldCBjb25uZWN0aW9uIGNsb3NlZFwiLCBldik7XG4gICAgICBpZiAoZXYuY29kZSA9PT0gaW1wb3J0X3NvY2tldC5FU29ja2V0Q2xvc2VDb2RlLkFCTk9STUFMX0NMT1NVUkUpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgXCJcXHV7MUY1MTR9IFNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCBhYm5vcm1hbGx5LCBUcnlpbmcgdG8gUmVjb25uZWN0XCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMuX19yZXRyeUNvdW50IDwgNykge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gMiAqKiB0aGlzLl9fcmV0cnlDb3VudCAqIDFlMztcbiAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KHsgdG9rZW46IHRoaXMudG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3JldHJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBgUmVjb25uZWN0aW9uIEF0dGVtcHQgJHt0aGlzLl9fcmV0cnlDb3VudH0gZmFpbGVkYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBNYXRoLm1pbihkZWxheSwgMmU0KSk7XG4gICAgICAgICAgdGhpcy5fX3JldHJ5Q291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBcIlxcdXsxRjUzNH0gU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkIGFibm9ybWFsbHksIHJlY29ubmVjdGluZyBmYWlsZWRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5jbG9zZShpbXBvcnRfc29ja2V0LkVTb2NrZXRDbG9zZUNvZGUuQ09OTkVDVElPTl9FWFBJUkVEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc29ja2V0Q29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVTdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIlxcdTI3MDUgU29ja2V0IENvbm5lY3Rpb24gRXN0YWJsaXNoZWRcIik7XG4gICAgICAgIGhhbmRsZVJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdXsxRjUzNH0gRXJyb3IgV2hpbGUgQ29ubmVjdGluZyB0byB0aGUgU29ja2V0XCIpO1xuICAgICAgICBoYW5kbGVSZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlxcdTI3NEMgU29ja2V0IENvbm5lY3Rpb24gRmFpbGVkXCIpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBoYW5kbGVSZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFwiY29ubmVjdGVkXCIsIGhhbmRsZVN1Y2Nlc3MpO1xuICAgICAgICB0aGlzLm9mZihcImZhaWxlZFwiLCBoYW5kbGVFcnJvcik7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFwiY29ubmVjdGVkXCIsIGhhbmRsZVN1Y2Nlc3MpO1xuICAgICAgdGhpcy5vbmNlKFwiZmFpbGVkXCIsIGhhbmRsZUVycm9yKTtcbiAgICB9KTtcbiAgICBhd2FpdCBzb2NrZXRDb25uZWN0aW9uUHJvbWlzZTtcbiAgICByZXR1cm4gX1NvY2tldC5fX2luc3RhbmNlO1xuICB9O1xuICAvKipcbiAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIHNvY2tldCBjb25uZWN0aW9uLCBhbmQgY2xlYXJzIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIGFuZCBzdWJzY3JpcHRpb25zIHRvIGV2ZW50cyBhcyB3ZWxsIGFzXG4gICAqIGFueSBvdGhlciBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0gY29kZSBgeyBFU29ja2V0Q2xvc2VDb2RlIH1gXG4gICAqL1xuICBjbG9zZSA9IChjb2RlKSA9PiB7XG4gICAgdGhpcy53cy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9faGFuZGxlSW5jb21pbmdNZXNzYWdlKTtcbiAgICBjb25zdCByZWFzb24gPSBpbXBvcnRfc29ja2V0LlNvY2tldENsb3NlUmVhc29uW2NvZGVdO1xuICAgIGxvZ2dlci5pbmZvKGBcXHV7MUY1MEN9IENsb3NpbmcgdGhlIGNvbm5lY3Rpb24sICR7Y29kZX0gJHtyZWFzb259YCk7XG4gICAgaWYgKGNvZGUgPj0gM2UzICYmIGNvZGUgPD0gNDk5OSB8fCBjb2RlID09PSAxZTMpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgIHRoaXMudG9rZW4gPSBudWxsO1xuICAgICAgdGhpcy5fX0VORFBPSU5UID0gbnVsbDtcbiAgICAgIHRoaXMuZW1pdChcInRva2VuLXVwZGF0ZWRcIiwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5fX3VucmVnaXN0ZXJTb2NrZXRFdmVudHModGhpcy53cyk7XG4gICAgdGhpcy5fX3dzID0gbnVsbDtcbiAgICBpZiAoY29kZSA9PT0gMTAwNikge1xuICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGUgPSBcImF3YWl0aW5nLXJlY29ubmVjdGlvblwiO1xuICAgICAgbG9nZ2VyLmluZm8oXCJcXHV7MUY1MEN9IFNvY2tldCBDb25uZWN0aW9uIGNsb3NlZCBhYm5vcm1hbGx5LCByZWNvbm5lY3RpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICB0aGlzLmVtaXQoXCJjbG9zZWRcIiwgY29kZSk7XG4gICAgbG9nZ2VyLmluZm8oXCJcXHV7MUY1MEN9IFNvY2tldCBDb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgfTtcbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIHNvY2tldCBjb25uZWN0aW9uIGJhc2VkIG9uIHNvbWUgZXZlbnRzL3RvcGljc1xuICAgKi9cbiAgcHVibGlzaCA9IChldmVudCwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBldmVudCxcbiAgICAgIGRhdGE6IGRhdGEgfHwge31cbiAgICB9KTtcbiAgICB0aGlzLndzLnNlbmQocGF5bG9hZCk7XG4gIH07XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gYSBzcGVjaWZpYyBldmVudC90b3BpYyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIHN1YnNjcmliZSA9IChldmVudCwgZm4pID0+IHtcbiAgICBpZiAodGhpcy5fX3N1YnNjcmliZWRNYXAuaGFzKGV2ZW50KSkge1xuICAgICAgbG9nZ2VyLndhcm4oXCJcXHUyNkEwXFx1RkUwRiBPdmVycmlkaW5nIGV4aXN0aW5nIGV2ZW50IGhhbmRsZXJcIik7XG4gICAgfVxuICAgIHRoaXMuX19zdWJzY3JpYmVkTWFwLnNldChldmVudCwgZm4pO1xuICB9O1xuICAvKipcbiAgICogR2V0IHRoZSBjb25maWcgdXJsIGZvciB0aGUgc29ja2V0IGNvbm5lY3Rpb24gYmFzZWQgb24gdGhlIHRva2VuIGFuZCByZWdpb25cbiAgICogQHBhcmFtIHRva2VuIExvY2FsIFBlZXIgc3BlY2lmaWMgbWVldGluZyB0b2tlblxuICAgKiBAcGFyYW0gcmVnaW9uIExvY2FsIFBlZXIgc3BlY2lmaWMgcmVnaW9uXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBfX2dldENvbmZpZ1VybCh0b2tlbiwgcmVnaW9uKSB7XG4gICAgaWYgKHRoaXMuX19FTkRQT0lOVCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19FTkRQT0lOVDtcbiAgICB9XG4gICAgY29uc3QgYXBpU2VydmVyVXJsID0gdGhpcy5pc0xvY2FsRGV2ID8gXCJodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpL3YxXCIgOiBcImh0dHBzOi8vYXBpcmEuaHVkZGxlMDEuY29tL2FwaS92MVwiO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke2FwaVNlcnZlclVybH0vZ2V0U3VzaGlVcmxgLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXHV7MUY1MzR9IEVycm9yIFdoaWxlIEZldGNoaW5nIHRoZSBVcmxcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgdXJsIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHRoaXMuX19FTkRQT0lOVCA9IHVybC5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJ3c3M6Ly9cIikucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJ3czovL1wiKTtcbiAgICBjb25zdCB3c3NBZGRyZXNzID0gYCR7dGhpcy5fX0VORFBPSU5UfS93c2A7XG4gICAgY29uc3Qgd3NBZGRyZXNzID0gYCR7d3NzQWRkcmVzc30/JHtbXG4gICAgICBgdG9rZW49JHt0b2tlbn1gLFxuICAgICAgYHZlcnNpb249JHsyfWAsXG4gICAgICBgcmVnaW9uPSR7cmVnaW9ufWBcbiAgICBdLmpvaW4oXCImXCIpfWA7XG4gICAgdGhpcy5fX0VORFBPSU5UID0gd3NBZGRyZXNzO1xuICAgIHJldHVybiB3c0FkZHJlc3M7XG4gIH1cbiAgLyoqXG4gICAqICFJbXBvcnRhbnRcbiAgICogSGFuZGxlIHRoZSBpbmNvbWluZyBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBiYXNlZCBvbiB0aGUgZXZlbnRzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBhbmQgY2FsbCB0aGUgc3Vic2NyaWJlZCBldmVudCBoYW5kbGVyXG4gICAqL1xuICBfX2hhbmRsZUluY29taW5nTWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHsgZXZlbnQ6IGV2ZW50TmFtZSwgZGF0YSB9ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjRFOH0gSW5jb21pbmcgbWVzc2FnZSBldmVudCBuYW1lOiBcIiwgZXZlbnROYW1lKTtcbiAgICBjb25zdCBmbiA9IHRoaXMuX19zdWJzY3JpYmVkTWFwLmdldChldmVudE5hbWUpO1xuICAgIGlmIChmbikge1xuICAgICAgZm4oZGF0YSk7XG4gICAgfVxuICB9O1xuICBfX2hhbmRsZVNvY2tldEVycm9yID0gKGV2KSA9PiB7XG4gICAgbG9nZ2VyLmVycm9yKFwiU29ja2V0IGNvbm5lY3Rpb24gZXJyb3JcIiwgZXYpO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gXCJmYWlsZWRcIjtcbiAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIik7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlIHRoZSBzb2NrZXQgY2xvc2UgZXZlbnQgd2hpY2ggaXMgc2VudCBieSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSBldiBDbG9zZUV2ZW50XG4gICAqL1xuICBfX2hhbmRsZVNvY2tldENsb3NlID0gKGV2KSA9PiB7XG4gICAgbG9nZ2VyLmluZm8oXCJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIiwgZXYpO1xuICAgIGNvbnN0IGNvZGUgPSBldi5jb2RlO1xuICAgIGNvbnN0IHJlYXNvbiA9IGltcG9ydF9zb2NrZXQuU29ja2V0Q2xvc2VSZWFzb25bY29kZV07XG4gICAgbG9nZ2VyLmluZm8oYFxcdXsxRjUzNH0geyBTZXJ2ZXIgfTogQ2xvc2luZyB0aGUgY29ubmVjdGlvbiwgJHtjb2RlfSAke3JlYXNvbn1gKTtcbiAgICB0aGlzLmNsb3NlKGNvZGUpO1xuICB9O1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEhhbmRsZSB0aGUgc29ja2V0IG9wZW4gZXZlbnQgd2hpY2ggaXMgc2VudCBhZnRlciB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCB3aXRoIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIGV2IEV2ZW50XG4gICAqL1xuICBfX2hhbmRsZVNvY2tldE9wZW4gPSAoZXYpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIlNvY2tldCBDb25uZWN0aW9uIE9wZW5cIiwgZXYpO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gXCJjb25uZWN0ZWRcIjtcbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIik7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgdGhlIHNvY2tldCBldmVudHNcbiAgICogQHBhcmFtIHdzIFdlYlNvY2tldFxuICAgKi9cbiAgX19yZWdpc3RlclNvY2tldEV2ZW50cyA9ICh3cykgPT4ge1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9faGFuZGxlU29ja2V0RXJyb3IpO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCB0aGlzLl9faGFuZGxlU29ja2V0Q2xvc2UpO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIHRoaXMuX19oYW5kbGVTb2NrZXRPcGVuKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBVbnJlZ2lzdGVyIHRoZSBzb2NrZXQgZXZlbnRzXG4gICAqIEBwYXJhbSB3cyBXZWJTb2NrZXRcbiAgICovXG4gIF9fdW5yZWdpc3RlclNvY2tldEV2ZW50cyA9ICh3cykgPT4ge1xuICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9faGFuZGxlU29ja2V0RXJyb3IpO1xuICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCB0aGlzLl9faGFuZGxlU29ja2V0Q2xvc2UpO1xuICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIHRoaXMuX19oYW5kbGVTb2NrZXRPcGVuKTtcbiAgfTtcbn07XG52YXIgU29ja2V0X2RlZmF1bHQgPSBTb2NrZXQ7XG5cbmV4cG9ydCB7XG4gIHJlcXVpcmVfc29ja2V0X3R5cGVzLFxuICBTb2NrZXRfZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUhWQkJNV0hGLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-LU7T3V5U.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-LU7T3V5U.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeviceHandler_default: function() { return /* binding */ DeviceHandler_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-WHLOPA5E.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-WHLOPA5E.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n\n\n\n\n// src/DeviceHandler.ts\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_1__.mainLogger.createSubLogger(\"DeviceHandler\");\nvar CustomMediaKindToSystemKind = {\n  cam: \"videoinput\",\n  mic: \"audioinput\",\n  speaker: \"videoinput\"\n};\nvar DeviceHandler = class extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_2__.EnhancedEventEmitter {\n  SCREEN_DEFAULT_DEVICE = \"monitor\";\n  /**\n   * User Selected Devices, If no device is selected, it will use the default device of the system\n   *\n   * is preffered device is null, it will use the default device of the system\n   *\n   * `NOTE: User has the ability to select a preferred device for each media kind`\n   */\n  __preferredDevices = /* @__PURE__ */ new Map([\n    [\"cam\", null],\n    [\"mic\", null],\n    [\"speaker\", null]\n  ]);\n  /**\n   * Map the media devices currently present in the system\n   */\n  __mediaDevicesInfo = /* @__PURE__ */ new Map([\n    [\"cam\", []],\n    [\"mic\", []],\n    [\"speaker\", []]\n  ]);\n  /**\n   * Get all the devices which are currently available in the system\n   */\n  get devices() {\n    return this.__mediaDevicesInfo;\n  }\n  get preferredDevices() {\n    return this.__preferredDevices;\n  }\n  /**\n   * Get all the devices which are currently available in the system, also updates the `__mediaDevicesInfo` record\n   *\n   * Can also query for a specific device kind `audioinput` | `videoinput` | `audiooutput`\n   *\n   * @param deviceKind `cam` | `mic` | `speaker` | `undefined`\n   * @returns - MediaDeviceInfo[] | null\n   *\n   * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`\n   */\n  getMediaDevices = async (filterByDeviceKind) => {\n    logger.info(\"\\u{1F4F9} Fetching Media Devices\");\n    let constraints;\n    if (filterByDeviceKind === \"speaker\") {\n      constraints = _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default.mic;\n    } else if (filterByDeviceKind) {\n      constraints = _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default[filterByDeviceKind];\n    } else {\n      constraints = {\n        ..._chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default.mic,\n        ..._chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default.cam\n      };\n    }\n    const stream = await navigator.mediaDevices.getUserMedia(constraints).catch((err) => {\n      logger.error(\"fetching stream failed\", err);\n    });\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    if (!filterByDeviceKind) {\n      this.__setMediaDeviceInfo({ devices, update: \"all\" });\n    }\n    if (filterByDeviceKind === \"cam\" || filterByDeviceKind === \"mic\") {\n      this.__setMediaDeviceInfo({ devices, update: filterByDeviceKind });\n    }\n    if (stream) {\n      const tracks = stream.getTracks();\n      for (const track of tracks) {\n        track.stop();\n      }\n    }\n    const mediaDevices = devices.filter((device) => {\n      if (device.deviceId === \"\" || device.label === \"\") {\n        return false;\n      }\n      if (filterByDeviceKind) {\n        const systemDeviceKind = CustomMediaKindToSystemKind[filterByDeviceKind];\n        return device.kind === systemDeviceKind;\n      }\n      return true;\n    });\n    return mediaDevices;\n  };\n  /**\n   * Get the device from the given facing type of device\n   *\n   * This function is used for only RN\n   *\n   * @param facing - facing of the device { 'environment' | 'front' | 'undefined' }\n   * @param mediaDeviceKind - mediaDeviceKind for the device { 'audioinput' | 'videoinput' }\n   * @returns - deviceId: string | null\n   *\n   * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`\n   */\n  getDeviceFromFacingMode = (facing, mediaDeviceKind) => {\n    const allDevices = this.__mediaDevicesInfo.get(mediaDeviceKind);\n    if (allDevices) {\n      const d = allDevices.find((device) => device.facing === facing);\n      if (d) {\n        if (mediaDeviceKind === \"cam\") {\n          return facing || d.deviceId;\n        }\n        return d.deviceId;\n      }\n    }\n    return null;\n  };\n  setPreferredDevice = (data) => {\n    const { deviceId, deviceKind } = data;\n    this.__preferredDevices.set(deviceKind, deviceId);\n    this.emit(\"preferred-device-change\", {\n      deviceId,\n      deviceKind\n    });\n  };\n  /**\n   * Fetches a stream of the screen of the device i.e the screen sharing stream\n   * based on the selected choice from the pop up returns the audio and video stream\n   * in one stream.\n   *\n   * `NOTE: This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK`\n   * @returns\n   */\n  fetchScreen = async () => {\n    const constraints = _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default.screen;\n    try {\n      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);\n      return { stream };\n    } catch (err) {\n      logger.error(err);\n      let error = {\n        message: \"Unknown Error\",\n        errorStack: err\n      };\n      if (err instanceof DOMException) {\n        error = {\n          blocked: {\n            byDeviceMissing: err.name === \"NotFoundError\",\n            byDeviceInUse: err.name === \"OverconstrainedError\",\n            byPermissions: err.name === \"NotAllowedError\"\n          },\n          message: err.message\n        };\n      }\n      return {\n        stream: null,\n        error\n      };\n    }\n  };\n  /**\n   * Fetch the stream from the device for the given media kind, if no preferred device is found it will throw an error.\n   * by default the preferred device is the system default device\n   *\n   * `NOTE: If Preffered device is not found, it will use the system default device, if no default device is found it will throw an error`\n   * `Set the preferred device using setPreferredDevice()`\n   *\n   */\n  fetchStream = async (data) => {\n    const preferredDeviceId = this.__preferredDevices.get(data.mediaDeviceKind);\n    logger.info(\"\\u{1F4F9} Fetching Stream\", {\n      mediaDeviceKind: data.mediaDeviceKind,\n      preferredDeviceId\n    });\n    navigator.mediaDevices.ondevicechange = async () => {\n      const newMediaDevices = await this.getMediaDevices();\n      for (const [deviceKind, deviceId] of this.__preferredDevices) {\n        const device = newMediaDevices.find((d) => d.deviceId === deviceId);\n        if (!device) {\n          this.setPreferredDevice({ deviceId: null, deviceKind });\n        }\n      }\n      this.emit(\"device-change\");\n    };\n    try {\n      let fetchStreamFunc;\n      if (typeof navigator === \"object\" && navigator.product === \"ReactNative\") {\n        fetchStreamFunc = this.__fetchStreamFromDeviceForRN;\n      } else {\n        fetchStreamFunc = this.__fetchStreamFromDeviceForWeb;\n      }\n      const { stream, deviceId } = await fetchStreamFunc({\n        deviceId: preferredDeviceId ?? void 0,\n        mediaKind: data.mediaDeviceKind === \"mic\" ? \"mic\" : \"cam\"\n      });\n      const track = data.mediaDeviceKind === \"mic\" ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0];\n      if (!this.__preferredDevices.get(data.mediaDeviceKind)) {\n        this.setPreferredDevice({ deviceId, deviceKind: data.mediaDeviceKind });\n      }\n      return {\n        stream,\n        track,\n        deviceId\n      };\n    } catch (err) {\n      logger.error(err);\n      let error = {\n        message: \"Unknown Error\",\n        errorStack: err\n      };\n      if (err instanceof DOMException) {\n        error = {\n          blocked: {\n            byDeviceMissing: err.name === \"NotFoundError\",\n            byDeviceInUse: err.name === \"OverconstrainedError\",\n            byPermissions: err.name === \"NotAllowedError\"\n          },\n          message: err.message\n        };\n      }\n      return {\n        stream: null,\n        track: null,\n        deviceId: null,\n        error\n      };\n    }\n  };\n  fetchStreamByGroupId = async (data) => {\n    let constraints;\n    if (data.mediaDeviceKind === \"mic\") {\n      constraints = { audio: { groupId: data.groupId } };\n    } else {\n      constraints = { video: { groupId: data.groupId } };\n    }\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    return stream;\n  };\n  /**\n   * Fetch the stream from the device for the React Native Based Application\n   *\n   * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK\n   * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`\n   *\n   * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped\n   *\n   * @param data - { deviceId: \"front\" | \"back\" | \"audio\" | string; kind: \"audioinput\" | \"videoinput\" }\n   * @returns - { stream: MediaStream, deviceId: string }\n   */\n  __fetchStreamFromDeviceForRN = async (data) => {\n    const constraints = _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default[data.mediaKind];\n    let facingMode;\n    if (data.mediaKind === \"cam\") {\n      facingMode = data.deviceId === \"environment\" ? \"environment\" : \"front\";\n      constraints.video = Object.assign({}, constraints.video, {\n        facingMode\n      });\n    }\n    if (data.mediaKind === \"mic\") {\n      constraints.audio = Object.assign({}, constraints.audio, {\n        deviceId: data.deviceId\n      });\n    }\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    const streamDeviceId = this.getDeviceFromFacingMode(\n      facingMode,\n      data.mediaKind === \"mic\" ? \"mic\" : \"cam\"\n    );\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    if (data.mediaKind === \"cam\" || data.mediaKind === \"mic\") {\n      this.emit(\"permission-granted\", { deviceKind: data.mediaKind });\n      this.__setMediaDeviceInfo({ devices, update: data.mediaKind });\n    }\n    if (!streamDeviceId) {\n      const tracks = stream.getTracks();\n      for (const track of tracks) {\n        track.stop();\n      }\n      throw new Error(\n        \"\\u274C No DeviceId found for this stream, this is a bug in the SDK, please report it to the developers\"\n      );\n    }\n    return {\n      stream,\n      deviceId: streamDeviceId\n    };\n  };\n  /**\n   * Fetch the stream from the device for the web\n   *\n   * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK\n   * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`\n   *\n   * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped\n   *\n   * @param data - { deviceId: string; kind: 'audio' | 'video' }\n   * @returns - { stream: MediaStream, deviceId: string }\n   */\n  __fetchStreamFromDeviceForWeb = async (data) => {\n    const constraints = Object.assign(\n      {},\n      _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_0__.deviceConstraints_default[data.mediaKind]\n    );\n    if (data.mediaKind === \"cam\" && data.deviceId) {\n      constraints.video = Object.assign({}, constraints.video, {\n        deviceId: data.deviceId\n      });\n    }\n    if (data.mediaKind === \"mic\" && data.deviceId) {\n      constraints.audio = Object.assign({}, constraints.audio, {\n        deviceId: {\n          exact: data.deviceId\n        }\n      });\n    }\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    const streamDeviceId = stream.getTracks()[0].getSettings().deviceId;\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    if (data.mediaKind === \"cam\" || data.mediaKind === \"mic\") {\n      this.emit(\"permission-granted\", { deviceKind: data.mediaKind });\n      this.__setMediaDeviceInfo({ devices, update: data.mediaKind });\n    }\n    if (!streamDeviceId) {\n      const tracks = stream.getTracks();\n      for (const track of tracks) {\n        track.stop();\n      }\n      throw new Error(\n        \"\\u274C No DeviceId found for this stream, this is a bug in the browser, please report it to the developers\"\n      );\n    }\n    return {\n      stream,\n      deviceId: streamDeviceId\n    };\n  };\n  /**\n   * @description Get the media permission for the given type\n   * @param data  { type: 'video' | 'audio' }\n   * @throws error { StreamPermissionsError }\n   * @example await getMediaPermission({ type: 'video' })\n   */\n  getMediaPermission = async (data) => {\n    const { mediaDeviceKind } = data;\n    try {\n      await this.getMediaDevices(mediaDeviceKind);\n      this.emit(\"permission-granted\", { deviceKind: mediaDeviceKind });\n      return {\n        permission: \"granted\"\n      };\n    } catch (err) {\n      let error = {\n        message: \"Unknown Error\",\n        errorStack: err\n      };\n      if (err instanceof DOMException) {\n        error = {\n          blocked: {\n            byDeviceMissing: err.name === \"NotFoundError\",\n            byDeviceInUse: err.name === \"OverconstrainedError\",\n            byPermissions: err.name === \"NotAllowedError\"\n          },\n          message: err.message\n        };\n      }\n      this.emit(\"permission-denied\", { deviceKind: mediaDeviceKind, error });\n      return {\n        permission: \"denied\",\n        error\n      };\n    }\n  };\n  stopStream = (stream) => {\n    if (!stream)\n      return;\n    for (const track of stream.getTracks()) {\n      track.stop();\n    }\n  };\n  destroy = () => {\n    this.__preferredDevices.clear();\n    this.__mediaDevicesInfo.clear();\n    logger.info(\"\\u2705 Destroyed StreamHandler\");\n  };\n  /**\n   * Set the Media devices info based on the latest devices available in the system\n   */\n  __setMediaDeviceInfo = (data) => {\n    const { devices, update } = data;\n    const camDevices = [];\n    const micDevices = [];\n    const speakerDevices = [];\n    for (const device of devices) {\n      if (device.label === \"\" || device.deviceId === \"\")\n        return;\n      if (device.kind === \"videoinput\")\n        camDevices.push(device);\n      if (device.kind === \"audioinput\")\n        micDevices.push(device);\n      if (device.kind === \"audiooutput\")\n        speakerDevices.push(device);\n    }\n    if (update === \"all\") {\n      this.__mediaDevicesInfo.set(\"cam\", camDevices);\n      this.__mediaDevicesInfo.set(\"mic\", micDevices);\n      this.__mediaDevicesInfo.set(\"speaker\", speakerDevices);\n    }\n    if (update === \"cam\")\n      this.__mediaDevicesInfo.set(\"cam\", camDevices);\n    if (update === \"mic\") {\n      this.__mediaDevicesInfo.set(\"mic\", micDevices);\n      this.__mediaDevicesInfo.set(\"speaker\", speakerDevices);\n    }\n  };\n};\nvar DeviceHandler_default = DeviceHandler;\n\n\n//# sourceMappingURL=chunk-LU7T3V5U.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUxVN1QzVjVVLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFNkI7QUFHQTtBQUdBOztBQUU3QjtBQUNBLGFBQWEsMERBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvRUFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IseUVBQXlCO0FBQzdDLE1BQU07QUFDTixvQkFBb0IseUVBQXlCO0FBQzdDLE1BQU07QUFDTjtBQUNBLFdBQVcseUVBQXlCO0FBQ3BDLFdBQVcseUVBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQSxrQ0FBa0MscUNBQXFDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5RUFBeUI7QUFDakQ7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsTUFBTTtBQUNOLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0RBQWtEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQ0FBK0M7QUFDcEUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx3QkFBd0IseUVBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0RBQWtEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNLHlFQUF5QjtBQUMvQjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLUxVN1QzVjVVLmpzPzA5MmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZGV2aWNlQ29uc3RyYWludHNfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1XSExPUEE1RS5qc1wiO1xuaW1wb3J0IHtcbiAgbWFpbkxvZ2dlclxufSBmcm9tIFwiLi9jaHVuay1FVlhXTUNOVC5qc1wiO1xuaW1wb3J0IHtcbiAgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbn0gZnJvbSBcIi4vY2h1bmstN09UUUFGWEUuanNcIjtcblxuLy8gc3JjL0RldmljZUhhbmRsZXIudHNcbnZhciBsb2dnZXIgPSBtYWluTG9nZ2VyLmNyZWF0ZVN1YkxvZ2dlcihcIkRldmljZUhhbmRsZXJcIik7XG52YXIgQ3VzdG9tTWVkaWFLaW5kVG9TeXN0ZW1LaW5kID0ge1xuICBjYW06IFwidmlkZW9pbnB1dFwiLFxuICBtaWM6IFwiYXVkaW9pbnB1dFwiLFxuICBzcGVha2VyOiBcInZpZGVvaW5wdXRcIlxufTtcbnZhciBEZXZpY2VIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gIFNDUkVFTl9ERUZBVUxUX0RFVklDRSA9IFwibW9uaXRvclwiO1xuICAvKipcbiAgICogVXNlciBTZWxlY3RlZCBEZXZpY2VzLCBJZiBubyBkZXZpY2UgaXMgc2VsZWN0ZWQsIGl0IHdpbGwgdXNlIHRoZSBkZWZhdWx0IGRldmljZSBvZiB0aGUgc3lzdGVtXG4gICAqXG4gICAqIGlzIHByZWZmZXJlZCBkZXZpY2UgaXMgbnVsbCwgaXQgd2lsbCB1c2UgdGhlIGRlZmF1bHQgZGV2aWNlIG9mIHRoZSBzeXN0ZW1cbiAgICpcbiAgICogYE5PVEU6IFVzZXIgaGFzIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCBhIHByZWZlcnJlZCBkZXZpY2UgZm9yIGVhY2ggbWVkaWEga2luZGBcbiAgICovXG4gIF9fcHJlZmVycmVkRGV2aWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbXCJjYW1cIiwgbnVsbF0sXG4gICAgW1wibWljXCIsIG51bGxdLFxuICAgIFtcInNwZWFrZXJcIiwgbnVsbF1cbiAgXSk7XG4gIC8qKlxuICAgKiBNYXAgdGhlIG1lZGlhIGRldmljZXMgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIHN5c3RlbVxuICAgKi9cbiAgX19tZWRpYURldmljZXNJbmZvID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtcImNhbVwiLCBbXV0sXG4gICAgW1wibWljXCIsIFtdXSxcbiAgICBbXCJzcGVha2VyXCIsIFtdXVxuICBdKTtcbiAgLyoqXG4gICAqIEdldCBhbGwgdGhlIGRldmljZXMgd2hpY2ggYXJlIGN1cnJlbnRseSBhdmFpbGFibGUgaW4gdGhlIHN5c3RlbVxuICAgKi9cbiAgZ2V0IGRldmljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19tZWRpYURldmljZXNJbmZvO1xuICB9XG4gIGdldCBwcmVmZXJyZWREZXZpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9fcHJlZmVycmVkRGV2aWNlcztcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgZGV2aWNlcyB3aGljaCBhcmUgY3VycmVudGx5IGF2YWlsYWJsZSBpbiB0aGUgc3lzdGVtLCBhbHNvIHVwZGF0ZXMgdGhlIGBfX21lZGlhRGV2aWNlc0luZm9gIHJlY29yZFxuICAgKlxuICAgKiBDYW4gYWxzbyBxdWVyeSBmb3IgYSBzcGVjaWZpYyBkZXZpY2Uga2luZCBgYXVkaW9pbnB1dGAgfCBgdmlkZW9pbnB1dGAgfCBgYXVkaW9vdXRwdXRgXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VLaW5kIGBjYW1gIHwgYG1pY2AgfCBgc3BlYWtlcmAgfCBgdW5kZWZpbmVkYFxuICAgKiBAcmV0dXJucyAtIE1lZGlhRGV2aWNlSW5mb1tdIHwgbnVsbFxuICAgKlxuICAgKiBgTk9URWA6IEFzayBmb3IgTWVkaWFEZXZpY2UgUGVybWlzc2lvbiB0byBnZXQgdGhlIHJpZ2h0IHJlc3VsdCBmb3IgdGhhdCBkZXZpY2UgZWxzZSBpdCB3aWxsIHJldHVybiBgbnVsbGBcbiAgICovXG4gIGdldE1lZGlhRGV2aWNlcyA9IGFzeW5jIChmaWx0ZXJCeURldmljZUtpbmQpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjRGOX0gRmV0Y2hpbmcgTWVkaWEgRGV2aWNlc1wiKTtcbiAgICBsZXQgY29uc3RyYWludHM7XG4gICAgaWYgKGZpbHRlckJ5RGV2aWNlS2luZCA9PT0gXCJzcGVha2VyXCIpIHtcbiAgICAgIGNvbnN0cmFpbnRzID0gZGV2aWNlQ29uc3RyYWludHNfZGVmYXVsdC5taWM7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJCeURldmljZUtpbmQpIHtcbiAgICAgIGNvbnN0cmFpbnRzID0gZGV2aWNlQ29uc3RyYWludHNfZGVmYXVsdFtmaWx0ZXJCeURldmljZUtpbmRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgLi4uZGV2aWNlQ29uc3RyYWludHNfZGVmYXVsdC5taWMsXG4gICAgICAgIC4uLmRldmljZUNvbnN0cmFpbnRzX2RlZmF1bHQuY2FtXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiZmV0Y2hpbmcgc3RyZWFtIGZhaWxlZFwiLCBlcnIpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICBpZiAoIWZpbHRlckJ5RGV2aWNlS2luZCkge1xuICAgICAgdGhpcy5fX3NldE1lZGlhRGV2aWNlSW5mbyh7IGRldmljZXMsIHVwZGF0ZTogXCJhbGxcIiB9KTtcbiAgICB9XG4gICAgaWYgKGZpbHRlckJ5RGV2aWNlS2luZCA9PT0gXCJjYW1cIiB8fCBmaWx0ZXJCeURldmljZUtpbmQgPT09IFwibWljXCIpIHtcbiAgICAgIHRoaXMuX19zZXRNZWRpYURldmljZUluZm8oeyBkZXZpY2VzLCB1cGRhdGU6IGZpbHRlckJ5RGV2aWNlS2luZCB9KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0cmFja3MpIHtcbiAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZWRpYURldmljZXMgPSBkZXZpY2VzLmZpbHRlcigoZGV2aWNlKSA9PiB7XG4gICAgICBpZiAoZGV2aWNlLmRldmljZUlkID09PSBcIlwiIHx8IGRldmljZS5sYWJlbCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyQnlEZXZpY2VLaW5kKSB7XG4gICAgICAgIGNvbnN0IHN5c3RlbURldmljZUtpbmQgPSBDdXN0b21NZWRpYUtpbmRUb1N5c3RlbUtpbmRbZmlsdGVyQnlEZXZpY2VLaW5kXTtcbiAgICAgICAgcmV0dXJuIGRldmljZS5raW5kID09PSBzeXN0ZW1EZXZpY2VLaW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lZGlhRGV2aWNlcztcbiAgfTtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGV2aWNlIGZyb20gdGhlIGdpdmVuIGZhY2luZyB0eXBlIG9mIGRldmljZVxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIG9ubHkgUk5cbiAgICpcbiAgICogQHBhcmFtIGZhY2luZyAtIGZhY2luZyBvZiB0aGUgZGV2aWNlIHsgJ2Vudmlyb25tZW50JyB8ICdmcm9udCcgfCAndW5kZWZpbmVkJyB9XG4gICAqIEBwYXJhbSBtZWRpYURldmljZUtpbmQgLSBtZWRpYURldmljZUtpbmQgZm9yIHRoZSBkZXZpY2UgeyAnYXVkaW9pbnB1dCcgfCAndmlkZW9pbnB1dCcgfVxuICAgKiBAcmV0dXJucyAtIGRldmljZUlkOiBzdHJpbmcgfCBudWxsXG4gICAqXG4gICAqIGBOT1RFYDogQXNrIGZvciBNZWRpYURldmljZSBQZXJtaXNzaW9uIHRvIGdldCB0aGUgcmlnaHQgcmVzdWx0IGZvciB0aGF0IGRldmljZSBlbHNlIGl0IHdpbGwgcmV0dXJuIGBudWxsYFxuICAgKi9cbiAgZ2V0RGV2aWNlRnJvbUZhY2luZ01vZGUgPSAoZmFjaW5nLCBtZWRpYURldmljZUtpbmQpID0+IHtcbiAgICBjb25zdCBhbGxEZXZpY2VzID0gdGhpcy5fX21lZGlhRGV2aWNlc0luZm8uZ2V0KG1lZGlhRGV2aWNlS2luZCk7XG4gICAgaWYgKGFsbERldmljZXMpIHtcbiAgICAgIGNvbnN0IGQgPSBhbGxEZXZpY2VzLmZpbmQoKGRldmljZSkgPT4gZGV2aWNlLmZhY2luZyA9PT0gZmFjaW5nKTtcbiAgICAgIGlmIChkKSB7XG4gICAgICAgIGlmIChtZWRpYURldmljZUtpbmQgPT09IFwiY2FtXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFjaW5nIHx8IGQuZGV2aWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQuZGV2aWNlSWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBzZXRQcmVmZXJyZWREZXZpY2UgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgZGV2aWNlSWQsIGRldmljZUtpbmQgfSA9IGRhdGE7XG4gICAgdGhpcy5fX3ByZWZlcnJlZERldmljZXMuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICB0aGlzLmVtaXQoXCJwcmVmZXJyZWQtZGV2aWNlLWNoYW5nZVwiLCB7XG4gICAgICBkZXZpY2VJZCxcbiAgICAgIGRldmljZUtpbmRcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEZldGNoZXMgYSBzdHJlYW0gb2YgdGhlIHNjcmVlbiBvZiB0aGUgZGV2aWNlIGkuZSB0aGUgc2NyZWVuIHNoYXJpbmcgc3RyZWFtXG4gICAqIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBjaG9pY2UgZnJvbSB0aGUgcG9wIHVwIHJldHVybnMgdGhlIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1cbiAgICogaW4gb25lIHN0cmVhbS5cbiAgICpcbiAgICogYE5PVEU6IFRoaXMgc3RyZWFtIGlzIG5vdCBtYW5hZ2VkIGJ5IHRoZSBIdWRkbGUwMSBTREssIGkuZS4gaXQgd2lsbCBub3QgYmUgY2xvc2VkIGJ5IHRoZSBTREtgXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBmZXRjaFNjcmVlbiA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGRldmljZUNvbnN0cmFpbnRzX2RlZmF1bHQuc2NyZWVuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICByZXR1cm4geyBzdHJlYW0gfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgbGV0IGVycm9yID0ge1xuICAgICAgICBtZXNzYWdlOiBcIlVua25vd24gRXJyb3JcIixcbiAgICAgICAgZXJyb3JTdGFjazogZXJyXG4gICAgICB9O1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikge1xuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBibG9ja2VkOiB7XG4gICAgICAgICAgICBieURldmljZU1pc3Npbmc6IGVyci5uYW1lID09PSBcIk5vdEZvdW5kRXJyb3JcIixcbiAgICAgICAgICAgIGJ5RGV2aWNlSW5Vc2U6IGVyci5uYW1lID09PSBcIk92ZXJjb25zdHJhaW5lZEVycm9yXCIsXG4gICAgICAgICAgICBieVBlcm1pc3Npb25zOiBlcnIubmFtZSA9PT0gXCJOb3RBbGxvd2VkRXJyb3JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogbnVsbCxcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRmV0Y2ggdGhlIHN0cmVhbSBmcm9tIHRoZSBkZXZpY2UgZm9yIHRoZSBnaXZlbiBtZWRpYSBraW5kLCBpZiBubyBwcmVmZXJyZWQgZGV2aWNlIGlzIGZvdW5kIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqIGJ5IGRlZmF1bHQgdGhlIHByZWZlcnJlZCBkZXZpY2UgaXMgdGhlIHN5c3RlbSBkZWZhdWx0IGRldmljZVxuICAgKlxuICAgKiBgTk9URTogSWYgUHJlZmZlcmVkIGRldmljZSBpcyBub3QgZm91bmQsIGl0IHdpbGwgdXNlIHRoZSBzeXN0ZW0gZGVmYXVsdCBkZXZpY2UsIGlmIG5vIGRlZmF1bHQgZGV2aWNlIGlzIGZvdW5kIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JgXG4gICAqIGBTZXQgdGhlIHByZWZlcnJlZCBkZXZpY2UgdXNpbmcgc2V0UHJlZmVycmVkRGV2aWNlKClgXG4gICAqXG4gICAqL1xuICBmZXRjaFN0cmVhbSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgY29uc3QgcHJlZmVycmVkRGV2aWNlSWQgPSB0aGlzLl9fcHJlZmVycmVkRGV2aWNlcy5nZXQoZGF0YS5tZWRpYURldmljZUtpbmQpO1xuICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNEY5fSBGZXRjaGluZyBTdHJlYW1cIiwge1xuICAgICAgbWVkaWFEZXZpY2VLaW5kOiBkYXRhLm1lZGlhRGV2aWNlS2luZCxcbiAgICAgIHByZWZlcnJlZERldmljZUlkXG4gICAgfSk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5vbmRldmljZWNoYW5nZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld01lZGlhRGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0TWVkaWFEZXZpY2VzKCk7XG4gICAgICBmb3IgKGNvbnN0IFtkZXZpY2VLaW5kLCBkZXZpY2VJZF0gb2YgdGhpcy5fX3ByZWZlcnJlZERldmljZXMpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlID0gbmV3TWVkaWFEZXZpY2VzLmZpbmQoKGQpID0+IGQuZGV2aWNlSWQgPT09IGRldmljZUlkKTtcbiAgICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgICB0aGlzLnNldFByZWZlcnJlZERldmljZSh7IGRldmljZUlkOiBudWxsLCBkZXZpY2VLaW5kIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJkZXZpY2UtY2hhbmdlXCIpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGxldCBmZXRjaFN0cmVhbUZ1bmM7XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiKSB7XG4gICAgICAgIGZldGNoU3RyZWFtRnVuYyA9IHRoaXMuX19mZXRjaFN0cmVhbUZyb21EZXZpY2VGb3JSTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoU3RyZWFtRnVuYyA9IHRoaXMuX19mZXRjaFN0cmVhbUZyb21EZXZpY2VGb3JXZWI7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHN0cmVhbSwgZGV2aWNlSWQgfSA9IGF3YWl0IGZldGNoU3RyZWFtRnVuYyh7XG4gICAgICAgIGRldmljZUlkOiBwcmVmZXJyZWREZXZpY2VJZCA/PyB2b2lkIDAsXG4gICAgICAgIG1lZGlhS2luZDogZGF0YS5tZWRpYURldmljZUtpbmQgPT09IFwibWljXCIgPyBcIm1pY1wiIDogXCJjYW1cIlxuICAgICAgfSk7XG4gICAgICBjb25zdCB0cmFjayA9IGRhdGEubWVkaWFEZXZpY2VLaW5kID09PSBcIm1pY1wiID8gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0gOiBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgIGlmICghdGhpcy5fX3ByZWZlcnJlZERldmljZXMuZ2V0KGRhdGEubWVkaWFEZXZpY2VLaW5kKSkge1xuICAgICAgICB0aGlzLnNldFByZWZlcnJlZERldmljZSh7IGRldmljZUlkLCBkZXZpY2VLaW5kOiBkYXRhLm1lZGlhRGV2aWNlS2luZCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIGRldmljZUlkXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICBsZXQgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6IFwiVW5rbm93biBFcnJvclwiLFxuICAgICAgICBlcnJvclN0YWNrOiBlcnJcbiAgICAgIH07XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIGJsb2NrZWQ6IHtcbiAgICAgICAgICAgIGJ5RGV2aWNlTWlzc2luZzogZXJyLm5hbWUgPT09IFwiTm90Rm91bmRFcnJvclwiLFxuICAgICAgICAgICAgYnlEZXZpY2VJblVzZTogZXJyLm5hbWUgPT09IFwiT3ZlcmNvbnN0cmFpbmVkRXJyb3JcIixcbiAgICAgICAgICAgIGJ5UGVybWlzc2lvbnM6IGVyci5uYW1lID09PSBcIk5vdEFsbG93ZWRFcnJvclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBudWxsLFxuICAgICAgICB0cmFjazogbnVsbCxcbiAgICAgICAgZGV2aWNlSWQ6IG51bGwsXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgZmV0Y2hTdHJlYW1CeUdyb3VwSWQgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgIGxldCBjb25zdHJhaW50cztcbiAgICBpZiAoZGF0YS5tZWRpYURldmljZUtpbmQgPT09IFwibWljXCIpIHtcbiAgICAgIGNvbnN0cmFpbnRzID0geyBhdWRpbzogeyBncm91cElkOiBkYXRhLmdyb3VwSWQgfSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cyA9IHsgdmlkZW86IHsgZ3JvdXBJZDogZGF0YS5ncm91cElkIH0gfTtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH07XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgc3RyZWFtIGZyb20gdGhlIGRldmljZSBmb3IgdGhlIFJlYWN0IE5hdGl2ZSBCYXNlZCBBcHBsaWNhdGlvblxuICAgKlxuICAgKiBgVGhpcyBzdHJlYW0gaXMgbm90IG1hbmFnZWQgYnkgdGhlIEh1ZGRsZTAxIFNESywgaS5lLiBpdCB3aWxsIG5vdCBiZSBjbG9zZWQgYnkgdGhlIFNES1xuICAgKiB0aGUgdXNlciBoYXMgdG8gY2xvc2UgaXQgbWFudWFsbHkgYnkgY2FsbGluZyB7c3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKX1gXG4gICAqXG4gICAqIE5PVEU6IGB1c2luZyBzdG9wVHJhY2tPbkNsb3NlID0gdHJ1ZWAgd2hpbGUgcHJvZHVjaW5nIHdpbGwgc3RvcCB0aGUgdHJhY2sgd2hlbiBwcm9kdWNpbmcgaXMgc3RvcHBlZFxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIHsgZGV2aWNlSWQ6IFwiZnJvbnRcIiB8IFwiYmFja1wiIHwgXCJhdWRpb1wiIHwgc3RyaW5nOyBraW5kOiBcImF1ZGlvaW5wdXRcIiB8IFwidmlkZW9pbnB1dFwiIH1cbiAgICogQHJldHVybnMgLSB7IHN0cmVhbTogTWVkaWFTdHJlYW0sIGRldmljZUlkOiBzdHJpbmcgfVxuICAgKi9cbiAgX19mZXRjaFN0cmVhbUZyb21EZXZpY2VGb3JSTiA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBkZXZpY2VDb25zdHJhaW50c19kZWZhdWx0W2RhdGEubWVkaWFLaW5kXTtcbiAgICBsZXQgZmFjaW5nTW9kZTtcbiAgICBpZiAoZGF0YS5tZWRpYUtpbmQgPT09IFwiY2FtXCIpIHtcbiAgICAgIGZhY2luZ01vZGUgPSBkYXRhLmRldmljZUlkID09PSBcImVudmlyb25tZW50XCIgPyBcImVudmlyb25tZW50XCIgOiBcImZyb250XCI7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzLnZpZGVvLCB7XG4gICAgICAgIGZhY2luZ01vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YS5tZWRpYUtpbmQgPT09IFwibWljXCIpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMuYXVkaW8sIHtcbiAgICAgICAgZGV2aWNlSWQ6IGRhdGEuZGV2aWNlSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgY29uc3Qgc3RyZWFtRGV2aWNlSWQgPSB0aGlzLmdldERldmljZUZyb21GYWNpbmdNb2RlKFxuICAgICAgZmFjaW5nTW9kZSxcbiAgICAgIGRhdGEubWVkaWFLaW5kID09PSBcIm1pY1wiID8gXCJtaWNcIiA6IFwiY2FtXCJcbiAgICApO1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICBpZiAoZGF0YS5tZWRpYUtpbmQgPT09IFwiY2FtXCIgfHwgZGF0YS5tZWRpYUtpbmQgPT09IFwibWljXCIpIHtcbiAgICAgIHRoaXMuZW1pdChcInBlcm1pc3Npb24tZ3JhbnRlZFwiLCB7IGRldmljZUtpbmQ6IGRhdGEubWVkaWFLaW5kIH0pO1xuICAgICAgdGhpcy5fX3NldE1lZGlhRGV2aWNlSW5mbyh7IGRldmljZXMsIHVwZGF0ZTogZGF0YS5tZWRpYUtpbmQgfSk7XG4gICAgfVxuICAgIGlmICghc3RyZWFtRGV2aWNlSWQpIHtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgdHJhY2tzKSB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJcXHUyNzRDIE5vIERldmljZUlkIGZvdW5kIGZvciB0aGlzIHN0cmVhbSwgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgU0RLLCBwbGVhc2UgcmVwb3J0IGl0IHRvIHRoZSBkZXZlbG9wZXJzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdHJlYW0sXG4gICAgICBkZXZpY2VJZDogc3RyZWFtRGV2aWNlSWRcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogRmV0Y2ggdGhlIHN0cmVhbSBmcm9tIHRoZSBkZXZpY2UgZm9yIHRoZSB3ZWJcbiAgICpcbiAgICogYFRoaXMgc3RyZWFtIGlzIG5vdCBtYW5hZ2VkIGJ5IHRoZSBIdWRkbGUwMSBTREssIGkuZS4gaXQgd2lsbCBub3QgYmUgY2xvc2VkIGJ5IHRoZSBTREtcbiAgICogdGhlIHVzZXIgaGFzIHRvIGNsb3NlIGl0IG1hbnVhbGx5IGJ5IGNhbGxpbmcge3N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSl9YFxuICAgKlxuICAgKiBOT1RFOiBgdXNpbmcgc3RvcFRyYWNrT25DbG9zZSA9IHRydWVgIHdoaWxlIHByb2R1Y2luZyB3aWxsIHN0b3AgdGhlIHRyYWNrIHdoZW4gcHJvZHVjaW5nIGlzIHN0b3BwZWRcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSB7IGRldmljZUlkOiBzdHJpbmc7IGtpbmQ6ICdhdWRpbycgfCAndmlkZW8nIH1cbiAgICogQHJldHVybnMgLSB7IHN0cmVhbTogTWVkaWFTdHJlYW0sIGRldmljZUlkOiBzdHJpbmcgfVxuICAgKi9cbiAgX19mZXRjaFN0cmVhbUZyb21EZXZpY2VGb3JXZWIgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgZGV2aWNlQ29uc3RyYWludHNfZGVmYXVsdFtkYXRhLm1lZGlhS2luZF1cbiAgICApO1xuICAgIGlmIChkYXRhLm1lZGlhS2luZCA9PT0gXCJjYW1cIiAmJiBkYXRhLmRldmljZUlkKSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzLnZpZGVvLCB7XG4gICAgICAgIGRldmljZUlkOiBkYXRhLmRldmljZUlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRhdGEubWVkaWFLaW5kID09PSBcIm1pY1wiICYmIGRhdGEuZGV2aWNlSWQpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMuYXVkaW8sIHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBleGFjdDogZGF0YS5kZXZpY2VJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIGNvbnN0IHN0cmVhbURldmljZUlkID0gc3RyZWFtLmdldFRyYWNrcygpWzBdLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIGlmIChkYXRhLm1lZGlhS2luZCA9PT0gXCJjYW1cIiB8fCBkYXRhLm1lZGlhS2luZCA9PT0gXCJtaWNcIikge1xuICAgICAgdGhpcy5lbWl0KFwicGVybWlzc2lvbi1ncmFudGVkXCIsIHsgZGV2aWNlS2luZDogZGF0YS5tZWRpYUtpbmQgfSk7XG4gICAgICB0aGlzLl9fc2V0TWVkaWFEZXZpY2VJbmZvKHsgZGV2aWNlcywgdXBkYXRlOiBkYXRhLm1lZGlhS2luZCB9KTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW1EZXZpY2VJZCkge1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0cmFja3MpIHtcbiAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlxcdTI3NEMgTm8gRGV2aWNlSWQgZm91bmQgZm9yIHRoaXMgc3RyZWFtLCB0aGlzIGlzIGEgYnVnIGluIHRoZSBicm93c2VyLCBwbGVhc2UgcmVwb3J0IGl0IHRvIHRoZSBkZXZlbG9wZXJzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdHJlYW0sXG4gICAgICBkZXZpY2VJZDogc3RyZWFtRGV2aWNlSWRcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgbWVkaWEgcGVybWlzc2lvbiBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICogQHBhcmFtIGRhdGEgIHsgdHlwZTogJ3ZpZGVvJyB8ICdhdWRpbycgfVxuICAgKiBAdGhyb3dzIGVycm9yIHsgU3RyZWFtUGVybWlzc2lvbnNFcnJvciB9XG4gICAqIEBleGFtcGxlIGF3YWl0IGdldE1lZGlhUGVybWlzc2lvbih7IHR5cGU6ICd2aWRlbycgfSlcbiAgICovXG4gIGdldE1lZGlhUGVybWlzc2lvbiA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgY29uc3QgeyBtZWRpYURldmljZUtpbmQgfSA9IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0TWVkaWFEZXZpY2VzKG1lZGlhRGV2aWNlS2luZCk7XG4gICAgICB0aGlzLmVtaXQoXCJwZXJtaXNzaW9uLWdyYW50ZWRcIiwgeyBkZXZpY2VLaW5kOiBtZWRpYURldmljZUtpbmQgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZXJtaXNzaW9uOiBcImdyYW50ZWRcIlxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxldCBlcnJvciA9IHtcbiAgICAgICAgbWVzc2FnZTogXCJVbmtub3duIEVycm9yXCIsXG4gICAgICAgIGVycm9yU3RhY2s6IGVyclxuICAgICAgfTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcbiAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgYmxvY2tlZDoge1xuICAgICAgICAgICAgYnlEZXZpY2VNaXNzaW5nOiBlcnIubmFtZSA9PT0gXCJOb3RGb3VuZEVycm9yXCIsXG4gICAgICAgICAgICBieURldmljZUluVXNlOiBlcnIubmFtZSA9PT0gXCJPdmVyY29uc3RyYWluZWRFcnJvclwiLFxuICAgICAgICAgICAgYnlQZXJtaXNzaW9uczogZXJyLm5hbWUgPT09IFwiTm90QWxsb3dlZEVycm9yXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJwZXJtaXNzaW9uLWRlbmllZFwiLCB7IGRldmljZUtpbmQ6IG1lZGlhRGV2aWNlS2luZCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZXJtaXNzaW9uOiBcImRlbmllZFwiLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHN0b3BTdHJlYW0gPSAoc3RyZWFtKSA9PiB7XG4gICAgaWYgKCFzdHJlYW0pXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCB0cmFjayBvZiBzdHJlYW0uZ2V0VHJhY2tzKCkpIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9XG4gIH07XG4gIGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgdGhpcy5fX3ByZWZlcnJlZERldmljZXMuY2xlYXIoKTtcbiAgICB0aGlzLl9fbWVkaWFEZXZpY2VzSW5mby5jbGVhcigpO1xuICAgIGxvZ2dlci5pbmZvKFwiXFx1MjcwNSBEZXN0cm95ZWQgU3RyZWFtSGFuZGxlclwiKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCB0aGUgTWVkaWEgZGV2aWNlcyBpbmZvIGJhc2VkIG9uIHRoZSBsYXRlc3QgZGV2aWNlcyBhdmFpbGFibGUgaW4gdGhlIHN5c3RlbVxuICAgKi9cbiAgX19zZXRNZWRpYURldmljZUluZm8gPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgZGV2aWNlcywgdXBkYXRlIH0gPSBkYXRhO1xuICAgIGNvbnN0IGNhbURldmljZXMgPSBbXTtcbiAgICBjb25zdCBtaWNEZXZpY2VzID0gW107XG4gICAgY29uc3Qgc3BlYWtlckRldmljZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBpZiAoZGV2aWNlLmxhYmVsID09PSBcIlwiIHx8IGRldmljZS5kZXZpY2VJZCA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGRldmljZS5raW5kID09PSBcInZpZGVvaW5wdXRcIilcbiAgICAgICAgY2FtRGV2aWNlcy5wdXNoKGRldmljZSk7XG4gICAgICBpZiAoZGV2aWNlLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiKVxuICAgICAgICBtaWNEZXZpY2VzLnB1c2goZGV2aWNlKTtcbiAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gXCJhdWRpb291dHB1dFwiKVxuICAgICAgICBzcGVha2VyRGV2aWNlcy5wdXNoKGRldmljZSk7XG4gICAgfVxuICAgIGlmICh1cGRhdGUgPT09IFwiYWxsXCIpIHtcbiAgICAgIHRoaXMuX19tZWRpYURldmljZXNJbmZvLnNldChcImNhbVwiLCBjYW1EZXZpY2VzKTtcbiAgICAgIHRoaXMuX19tZWRpYURldmljZXNJbmZvLnNldChcIm1pY1wiLCBtaWNEZXZpY2VzKTtcbiAgICAgIHRoaXMuX19tZWRpYURldmljZXNJbmZvLnNldChcInNwZWFrZXJcIiwgc3BlYWtlckRldmljZXMpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlID09PSBcImNhbVwiKVxuICAgICAgdGhpcy5fX21lZGlhRGV2aWNlc0luZm8uc2V0KFwiY2FtXCIsIGNhbURldmljZXMpO1xuICAgIGlmICh1cGRhdGUgPT09IFwibWljXCIpIHtcbiAgICAgIHRoaXMuX19tZWRpYURldmljZXNJbmZvLnNldChcIm1pY1wiLCBtaWNEZXZpY2VzKTtcbiAgICAgIHRoaXMuX19tZWRpYURldmljZXNJbmZvLnNldChcInNwZWFrZXJcIiwgc3BlYWtlckRldmljZXMpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgRGV2aWNlSGFuZGxlcl9kZWZhdWx0ID0gRGV2aWNlSGFuZGxlcjtcblxuZXhwb3J0IHtcbiAgRGV2aWNlSGFuZGxlcl9kZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstTFU3VDNWNVUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-LU7T3V5U.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-NEW4FEHE.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-NEW4FEHE.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Room_default: function() { return /* binding */ Room_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-V4S3N66D.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-V4S3N66D.js\");\n/* harmony import */ var _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-HVBBMWHF.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n\n\n\n\n\n// src/Room.ts\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_2__.mainLogger.createSubLogger(\"Room.ts\");\nvar Room = class _Room extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_3__.EnhancedEventEmitter {\n  /**\n   * Room Instance, Singleton class\n   */\n  static __instance = null;\n  /**\n   * Socket Instance, Singleton class\n   */\n  __socket = _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_1__.Socket_default.getInstance();\n  /**\n   * Returns the instance of the socket connection\n   */\n  get socket() {\n    return this.__socket;\n  }\n  /**\n   * Room Id of the current room\n   */\n  __roomId = null;\n  /**\n   * Lobby PeerIds\n   */\n  __lobbyPeers = /* @__PURE__ */ new Map();\n  /**\n   * Removed Lobby PeerId from the lobby\n   * @param peerId - PeerId of the peer who joined the room\n   */\n  removeLobbyPeer = (peerId) => {\n    this.__lobbyPeers.delete(peerId);\n    this.emit(\"lobby-peers-updated\", this.lobbyPeerIds);\n  };\n  /**\n   * Room Config Object\n   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams\n   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams\n   * - `allowSendData`: Allow non-admin Peers in the Room to send data message\n   * - `roomLocked`: If the room is locked\n   */\n  __config = {\n    roomLocked: false,\n    allowProduce: true,\n    allowProduceSources: {\n      cam: true,\n      mic: true,\n      screen: true\n    },\n    allowConsume: true,\n    allowSendData: true\n  };\n  /**\n   * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers\n   *\n   * @default true\n   *\n   * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,\n   * - if set to false, the user will have to manually consume the media streams of the remote peers\n   * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  autoConsume = true;\n  /**\n   * If using activeSpeakerNotification, Returns back the size of peers which are returned for the activeSpeakers in the Room;\n   * `Default` value is 8\n   */\n  activeSpeakers = {\n    size: 8\n  };\n  /**\n   * State of the Room\n   */\n  __state = \"idle\";\n  /**\n   * Set the state of the room\n   */\n  set state(newState) {\n    if (this.state !== newState) {\n      this.__state = newState;\n    }\n  }\n  /**\n   * State of the room\n   */\n  get state() {\n    return this.__state;\n  }\n  /**\n   * Get the lobby peers in the form of map\n   * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}\n   * @example\n   * ```ts\n   * const lobbyPeers = room.lobbyPeersMap;\n   *\n   * for (const [peerId, metadata] of lobbyPeers) {}\n   *\n   * ```\n   */\n  get lobbyPeersMap() {\n    return this.__lobbyPeers;\n  }\n  /**\n   * Get lobby peers in the form of array\n   */\n  get lobbyPeerIds() {\n    return Array.from(this.__lobbyPeers.keys());\n  }\n  /**\n   * Get lobby peers in the form of array\n   * @returns - Array of Lobby PeerIds\n   */\n  get lobbyPeers() {\n    return this.__lobbyPeers;\n  }\n  /**\n   * Set lobby peers in the form of map\n   * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`\n   */\n  set lobbyPeersMap(peers) {\n    this.__lobbyPeers = peers;\n    this.emit(\"lobby-peers-updated\", this.lobbyPeerIds);\n  }\n  /**\n   * Get\n   * @returns\n   */\n  getLobbyPeerMetadata = (peerId) => {\n    const lobbyPeer = this.lobbyPeers.get(peerId);\n    let metadata = {};\n    if (lobbyPeer?.metadata) {\n      metadata = JSON.parse(lobbyPeer.metadata);\n    }\n    return {\n      peerId,\n      metadata\n    };\n  };\n  /**\n   * Set lobby peers in the form of array\n   */\n  set newlobbyPeers(peers) {\n    for (const peer of peers) {\n      this.__lobbyPeers.set(peer.peerId, peer);\n    }\n    this.emit(\"lobby-peers-updated\", this.lobbyPeerIds);\n  }\n  /**\n   * Room Config Object\n   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams\n   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams\n   * - `allowSendData`: Allow non-admin Peers in the Room to send data message\n   * - `roomLocked`: If the room is locked\n   */\n  get config() {\n    return this.__config;\n  }\n  set config(config) {\n    this.__config = config;\n  }\n  /**\n   * Remote Peers Map, Stores all the remote peers\n   */\n  remotePeers = /* @__PURE__ */ new Map();\n  /**\n   * Metadata of the room.\n   */\n  __metadata = \"{}\";\n  /**\n   * Setter function for the metadata of the room\n   * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`\n   * `To notify everyone in the room about the metadata change, use the updateMetadata function`\n   */\n  set metadata(metadata) {\n    this.__metadata = metadata;\n    const parse = JSON.parse(metadata);\n    this.emit(\"metadata-updated\", parse);\n  }\n  /**\n   * Get the metadata of the room\n   */\n  getMetadata = () => {\n    const data = JSON.parse(this.__metadata || \"{}\");\n    return data;\n  };\n  /**\n   * Update Metadata of the room\n   */\n  updateMetadata = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({}).validate(\n    (data) => {\n      try {\n        if (this.state === \"closed\" || this.state === \"failed\" || this.state === \"left\") {\n          logger.error(\n            \"\\u274C Cannot Update Metadata, You have not joined the room yet\"\n          );\n          return;\n        }\n        const metadata = JSON.stringify(data);\n        this.metadata = metadata;\n        this.socket.publish(\"updateRoomMetadata\", {\n          metadata\n        });\n      } catch (error) {\n        logger.error(\"\\u274C Error Updating Metadata\");\n        logger.error(error);\n      }\n    }\n  );\n  /**\n   * Create a new Room Instance if not created, else return the existing Room Instance\n   *\n   * @returns - Room Instance\n   */\n  static create(data) {\n    if (_Room.__instance) {\n      return _Room.__instance;\n    }\n    logger.debug({ data });\n    _Room.__instance = new _Room(data);\n    return _Room.__instance;\n  }\n  /**\n   * Get the Room Instance if its not initialized it will throw an error\n   * @returns - Room Instance\n   * @throws { Error } If the Room Instance is not initialized\n   */\n  static getInstance = () => {\n    if (!_Room.__instance) {\n      throw new Error(\"\\u274C Room Instance Not Initialized\");\n    }\n    return _Room.__instance;\n  };\n  /**\n   * RoomId of the currently joined room.\n   */\n  get roomId() {\n    if (!this.__roomId)\n      return null;\n    return this.__roomId;\n  }\n  set roomId(roomId) {\n    if (this.__roomId) {\n      logger.warn(\n        \"RoomId is already set, Ignoring the new roomId, end this room and create a new room\"\n      );\n      return;\n    }\n    this.__roomId = roomId;\n  }\n  /**\n   * Returns the PeerIds of the remote peers\n   */\n  get peerIds() {\n    return Array.from(this.remotePeers.keys());\n  }\n  /**\n   * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData\n   * @param data: TNewRoomControls\n   */\n  updateRoomControls = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({\n    admin: true\n  }).validate((data) => {\n    logger.info(\"\\u{1F514} Updating Room Controls\", data);\n    this.config[data.type] = data.value;\n    this.emit(\"room-controls-updated\", { ...data });\n    this.socket.publish(\"updateRoomControls\", data);\n  });\n  /**\n   * Close a particular stream of remote peers\n   *  @param data: { label: string; peerIds?: string[] }\n   *  @param label: Label of the stream\n   *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers\n   */\n  closeStreamOfLabel = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({}).validate(\n    (data) => {\n      logger.info(\"\\u{1F514} Closing Stream of Label\", data);\n      this.socket.publish(\"closeStreamOfLabel\", data);\n    }\n  );\n  /**\n   * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions\n   *\n   * `NOTE: This will target all the audio stream in the room with the label \"audio\"`\n   */\n  muteEveryone = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({ admin: true }).validate(() => {\n    logger.info(\"\\u{1F514} Muting Everyone\");\n    this.socket.publish(\"closeStreamOfLabel\", {\n      label: \"audio\"\n    });\n  });\n  /**\n   * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.\n   *\n   * @param peerId - PeerId of the remote peer\n   * @returns - RemotePeer Instance\n   * @return - null if the peer is not present in the room\n   */\n  remotePeerExists = (peerId) => {\n    const peer = this.remotePeers.get(peerId);\n    if (!peer) {\n      return null;\n    }\n    return peer;\n  };\n  /**\n   * Returns the Remote Peer if present in room.\n   * @param peerId - PeerId of the remote peer\n   * @returns - RemotePeer Instance\n   * @throws { Error } If the Remote Peer is not found\n   */\n  getRemotePeerById(peerId) {\n    const peer = this.remotePeers.get(peerId);\n    if (!peer) {\n      throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);\n    }\n    return peer;\n  }\n  constructor(data) {\n    super();\n    logger.debug({ data });\n    if (data?.activeSpeakers?.size) {\n      this.activeSpeakers.size = data?.activeSpeakers?.size;\n    }\n    if (data?.autoConsume !== void 0) {\n      this.autoConsume = data.autoConsume;\n    }\n  }\n  /**\n   * Connects to the room and returns the instance of the room\n   * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting\n   */\n  connect = () => {\n    if (_Room.__instance === null) {\n      throw new Error(\"Room Instance Not Initialized\");\n    }\n    if (!this.socket.connected) {\n      throw new Error(\"Socket is Not Connected\");\n    }\n    if (this.socket.connecting) {\n      throw new Error(\"Socket is Connecting, Wait for it to be connected\");\n    }\n    if (!this.roomId) {\n      throw new Error(\"Room Id is required to connect to the room\");\n    }\n    this.socket.publish(\"connectRoom\", { roomId: this.roomId });\n    this.__state = \"connecting\";\n    this.emit(\"room-connecting\");\n    return _Room.__instance;\n  };\n  /**\n   * Admit a Peer to the room who is in the lobby\n   */\n  admitPeer = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({ admin: true }).validate(\n    (peerId) => {\n      try {\n        this.removeLobbyPeer(peerId);\n        this.socket.publish(\"acceptLobbyPeer\", { peerId });\n      } catch (error) {\n        logger.error(\"\\u{1F534} Error admitting peer\", error);\n      }\n    }\n  );\n  /**\n   * Denies the peer from joining the room, who is in the lobby\n   */\n  denyPeer = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({ admin: true }).validate(\n    (peerId) => {\n      try {\n        this.removeLobbyPeer(peerId);\n        this.socket.publish(\"denyLobbyPeer\", { peerId });\n      } catch (error) {\n        logger.error(\"\\u{1F534} Error denying peer\", error);\n      }\n    }\n  );\n  /**\n   * kick peer from room with respective peerId\n   */\n  kickPeer = (0,_chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_0__.checkPermissions)({ admin: true }).validate(\n    (peerId) => {\n      try {\n        this.socket.publish(\"kickPeer\", { peerId });\n      } catch (error) {\n        logger.error(\"\\u{1F534} Error denying peer\", error);\n      }\n    }\n  );\n  /**\n   * closing the room for the current user, room will keep on running for the remote users\n   * @deprecated - Use `leaveRoom` from `huddleClient` instead\n   */\n  close = (reason) => {\n    try {\n      logger.info(\"\\u{1F534} Leaving the room\");\n      this.__roomId = null;\n      this.remotePeers.clear();\n      this.lobbyPeers.clear();\n      this.metadata = \"{}\";\n      this.state = \"left\";\n      this.emit(\"room-closed\", { reason: reason || \"LEFT\" });\n    } catch (error) {\n      logger.error(\"Error: Leaving the Room\");\n    }\n  };\n};\nvar Room_default = Room;\n\n\n//# sourceMappingURL=chunk-NEW4FEHE.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLU5FVzRGRUhFLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRTZCO0FBR0E7QUFHQTtBQUdBOztBQUU3QjtBQUNBLGFBQWEsMERBQVU7QUFDdkIsK0JBQStCLG9FQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOERBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHFDQUFxQyxFQUFFO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0VBQWdCLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFnQjtBQUN2QztBQUNBLEdBQUc7QUFDSCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQWdCLEdBQUc7QUFDMUM7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9FQUFnQixHQUFHLGFBQWE7QUFDakQsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0VBQWdCLEdBQUcsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxRQUFRO0FBQ1IseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBZ0IsR0FBRyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZELFFBQVE7QUFDUix5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFnQixHQUFHLGFBQWE7QUFDN0M7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELFFBQVE7QUFDUix5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLU5FVzRGRUhFLmpzPzNjMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY2hlY2tQZXJtaXNzaW9uc1xufSBmcm9tIFwiLi9jaHVuay1WNFMzTjY2RC5qc1wiO1xuaW1wb3J0IHtcbiAgU29ja2V0X2RlZmF1bHRcbn0gZnJvbSBcIi4vY2h1bmstSFZCQk1XSEYuanNcIjtcbmltcG9ydCB7XG4gIG1haW5Mb2dnZXJcbn0gZnJvbSBcIi4vY2h1bmstRVZYV01DTlQuanNcIjtcbmltcG9ydCB7XG4gIEVuaGFuY2VkRXZlbnRFbWl0dGVyXG59IGZyb20gXCIuL2NodW5rLTdPVFFBRlhFLmpzXCI7XG5cbi8vIHNyYy9Sb29tLnRzXG52YXIgbG9nZ2VyID0gbWFpbkxvZ2dlci5jcmVhdGVTdWJMb2dnZXIoXCJSb29tLnRzXCIpO1xudmFyIFJvb20gPSBjbGFzcyBfUm9vbSBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFJvb20gSW5zdGFuY2UsIFNpbmdsZXRvbiBjbGFzc1xuICAgKi9cbiAgc3RhdGljIF9faW5zdGFuY2UgPSBudWxsO1xuICAvKipcbiAgICogU29ja2V0IEluc3RhbmNlLCBTaW5nbGV0b24gY2xhc3NcbiAgICovXG4gIF9fc29ja2V0ID0gU29ja2V0X2RlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBzb2NrZXQgY29ubmVjdGlvblxuICAgKi9cbiAgZ2V0IHNvY2tldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3NvY2tldDtcbiAgfVxuICAvKipcbiAgICogUm9vbSBJZCBvZiB0aGUgY3VycmVudCByb29tXG4gICAqL1xuICBfX3Jvb21JZCA9IG51bGw7XG4gIC8qKlxuICAgKiBMb2JieSBQZWVySWRzXG4gICAqL1xuICBfX2xvYmJ5UGVlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUmVtb3ZlZCBMb2JieSBQZWVySWQgZnJvbSB0aGUgbG9iYnlcbiAgICogQHBhcmFtIHBlZXJJZCAtIFBlZXJJZCBvZiB0aGUgcGVlciB3aG8gam9pbmVkIHRoZSByb29tXG4gICAqL1xuICByZW1vdmVMb2JieVBlZXIgPSAocGVlcklkKSA9PiB7XG4gICAgdGhpcy5fX2xvYmJ5UGVlcnMuZGVsZXRlKHBlZXJJZCk7XG4gICAgdGhpcy5lbWl0KFwibG9iYnktcGVlcnMtdXBkYXRlZFwiLCB0aGlzLmxvYmJ5UGVlcklkcyk7XG4gIH07XG4gIC8qKlxuICAgKiBSb29tIENvbmZpZyBPYmplY3RcbiAgICogLSBgYWxsb3dQcm9kdWNlYDogQWxsb3cgbm9uLWFkbWluIFBlZXJzIGluIHRoZSBSb29tIHRvIHByb2R1Y2UgTWVkaWEgU3RyZWFtc1xuICAgKiAtIGBhbGxvd0NvbnN1bWVgOiBBbGxvdyBub24tYWRtaW4gUGVlcnMgaW4gdGhlIFJvb20gdG8gY29uc3VtZSBNZWRpYSBTdHJlYW1zXG4gICAqIC0gYGFsbG93U2VuZERhdGFgOiBBbGxvdyBub24tYWRtaW4gUGVlcnMgaW4gdGhlIFJvb20gdG8gc2VuZCBkYXRhIG1lc3NhZ2VcbiAgICogLSBgcm9vbUxvY2tlZGA6IElmIHRoZSByb29tIGlzIGxvY2tlZFxuICAgKi9cbiAgX19jb25maWcgPSB7XG4gICAgcm9vbUxvY2tlZDogZmFsc2UsXG4gICAgYWxsb3dQcm9kdWNlOiB0cnVlLFxuICAgIGFsbG93UHJvZHVjZVNvdXJjZXM6IHtcbiAgICAgIGNhbTogdHJ1ZSxcbiAgICAgIG1pYzogdHJ1ZSxcbiAgICAgIHNjcmVlbjogdHJ1ZVxuICAgIH0sXG4gICAgYWxsb3dDb25zdW1lOiB0cnVlLFxuICAgIGFsbG93U2VuZERhdGE6IHRydWVcbiAgfTtcbiAgLyoqXG4gICAqIEF1dG8gY29uc3VtZSBmbGFnLCBpZiBzZXQgdG8gdHJ1ZSwgUGVlcnMgSm9pbmluZyB0aGUgUm9vbSB3aWxsIGF1dG9tYXRpY2FsbHkgY29uc3VtZSB0aGUgbWVkaWEgc3RyZWFtcyBvZiB0aGUgcmVtb3RlIHBlZXJzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICpcbiAgICogQHJlbWFya3MgLSBUaGlzIGZsYWcgaXMgdXNlZCBieSB0aGUgYHVzZVJvb21gIGhvb2sgdG8gYXV0b21hdGljYWxseSBjb25zdW1lIHRoZSBtZWRpYSBzdHJlYW1zIG9mIHRoZSByZW1vdGUgcGVlcnMsXG4gICAqIC0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgdXNlciB3aWxsIGhhdmUgdG8gbWFudWFsbHkgY29uc3VtZSB0aGUgbWVkaWEgc3RyZWFtcyBvZiB0aGUgcmVtb3RlIHBlZXJzXG4gICAqIHVzaW5nIHRoZSBgY29uc3VtZWAgbWV0aG9kIG9mIHRoZSBgTG9jYWxQZWVyYCBpbnN0YW5jZSBgbG9jYWxQZWVyLmNvbnN1bWUoeyBwZWVySWQsIGxhYmVsOiBcInZpZGVvXCIsIGFwcERhdGE6IHt9IH0pO2BcbiAgICovXG4gIGF1dG9Db25zdW1lID0gdHJ1ZTtcbiAgLyoqXG4gICAqIElmIHVzaW5nIGFjdGl2ZVNwZWFrZXJOb3RpZmljYXRpb24sIFJldHVybnMgYmFjayB0aGUgc2l6ZSBvZiBwZWVycyB3aGljaCBhcmUgcmV0dXJuZWQgZm9yIHRoZSBhY3RpdmVTcGVha2VycyBpbiB0aGUgUm9vbTtcbiAgICogYERlZmF1bHRgIHZhbHVlIGlzIDhcbiAgICovXG4gIGFjdGl2ZVNwZWFrZXJzID0ge1xuICAgIHNpemU6IDhcbiAgfTtcbiAgLyoqXG4gICAqIFN0YXRlIG9mIHRoZSBSb29tXG4gICAqL1xuICBfX3N0YXRlID0gXCJpZGxlXCI7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSByb29tXG4gICAqL1xuICBzZXQgc3RhdGUobmV3U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV3U3RhdGUpIHtcbiAgICAgIHRoaXMuX19zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RhdGUgb2YgdGhlIHJvb21cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3N0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvYmJ5IHBlZXJzIGluIHRoZSBmb3JtIG9mIG1hcFxuICAgKiBAcmV0dXJucyAtIE1hcCBvZiBMb2JieSBQZWVySWRzLCB3aXRoIHRoZSBtZXRhZGF0YSwge3BlZXJJZCA9PT4ge3BlZXJJZCwgbWV0YWRhdGF9fVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBsb2JieVBlZXJzID0gcm9vbS5sb2JieVBlZXJzTWFwO1xuICAgKlxuICAgKiBmb3IgKGNvbnN0IFtwZWVySWQsIG1ldGFkYXRhXSBvZiBsb2JieVBlZXJzKSB7fVxuICAgKlxuICAgKiBgYGBcbiAgICovXG4gIGdldCBsb2JieVBlZXJzTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9fbG9iYnlQZWVycztcbiAgfVxuICAvKipcbiAgICogR2V0IGxvYmJ5IHBlZXJzIGluIHRoZSBmb3JtIG9mIGFycmF5XG4gICAqL1xuICBnZXQgbG9iYnlQZWVySWRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX19sb2JieVBlZXJzLmtleXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBsb2JieSBwZWVycyBpbiB0aGUgZm9ybSBvZiBhcnJheVxuICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIExvYmJ5IFBlZXJJZHNcbiAgICovXG4gIGdldCBsb2JieVBlZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9fbG9iYnlQZWVycztcbiAgfVxuICAvKipcbiAgICogU2V0IGxvYmJ5IHBlZXJzIGluIHRoZSBmb3JtIG9mIG1hcFxuICAgKiBgTk9URTogVGhpcyBmdW5jdGlvbiBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiBvZiB0aGUgU0RLLCBVc2VkIHRvIGVtaXQgZXZudHMgYmFzZWQgb24gY2hhbmdlc2BcbiAgICovXG4gIHNldCBsb2JieVBlZXJzTWFwKHBlZXJzKSB7XG4gICAgdGhpcy5fX2xvYmJ5UGVlcnMgPSBwZWVycztcbiAgICB0aGlzLmVtaXQoXCJsb2JieS1wZWVycy11cGRhdGVkXCIsIHRoaXMubG9iYnlQZWVySWRzKTtcbiAgfVxuICAvKipcbiAgICogR2V0XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRMb2JieVBlZXJNZXRhZGF0YSA9IChwZWVySWQpID0+IHtcbiAgICBjb25zdCBsb2JieVBlZXIgPSB0aGlzLmxvYmJ5UGVlcnMuZ2V0KHBlZXJJZCk7XG4gICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgaWYgKGxvYmJ5UGVlcj8ubWV0YWRhdGEpIHtcbiAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZShsb2JieVBlZXIubWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGVlcklkLFxuICAgICAgbWV0YWRhdGFcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogU2V0IGxvYmJ5IHBlZXJzIGluIHRoZSBmb3JtIG9mIGFycmF5XG4gICAqL1xuICBzZXQgbmV3bG9iYnlQZWVycyhwZWVycykge1xuICAgIGZvciAoY29uc3QgcGVlciBvZiBwZWVycykge1xuICAgICAgdGhpcy5fX2xvYmJ5UGVlcnMuc2V0KHBlZXIucGVlcklkLCBwZWVyKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibG9iYnktcGVlcnMtdXBkYXRlZFwiLCB0aGlzLmxvYmJ5UGVlcklkcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJvb20gQ29uZmlnIE9iamVjdFxuICAgKiAtIGBhbGxvd1Byb2R1Y2VgOiBBbGxvdyBub24tYWRtaW4gUGVlcnMgaW4gdGhlIFJvb20gdG8gcHJvZHVjZSBNZWRpYSBTdHJlYW1zXG4gICAqIC0gYGFsbG93Q29uc3VtZWA6IEFsbG93IG5vbi1hZG1pbiBQZWVycyBpbiB0aGUgUm9vbSB0byBjb25zdW1lIE1lZGlhIFN0cmVhbXNcbiAgICogLSBgYWxsb3dTZW5kRGF0YWA6IEFsbG93IG5vbi1hZG1pbiBQZWVycyBpbiB0aGUgUm9vbSB0byBzZW5kIGRhdGEgbWVzc2FnZVxuICAgKiAtIGByb29tTG9ja2VkYDogSWYgdGhlIHJvb20gaXMgbG9ja2VkXG4gICAqL1xuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl9fY29uZmlnO1xuICB9XG4gIHNldCBjb25maWcoY29uZmlnKSB7XG4gICAgdGhpcy5fX2NvbmZpZyA9IGNvbmZpZztcbiAgfVxuICAvKipcbiAgICogUmVtb3RlIFBlZXJzIE1hcCwgU3RvcmVzIGFsbCB0aGUgcmVtb3RlIHBlZXJzXG4gICAqL1xuICByZW1vdGVQZWVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSBvZiB0aGUgcm9vbS5cbiAgICovXG4gIF9fbWV0YWRhdGEgPSBcInt9XCI7XG4gIC8qKlxuICAgKiBTZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBtZXRhZGF0YSBvZiB0aGUgcm9vbVxuICAgKiBgTm90ZTogVGhpcyB3aWxsIG5vdCB1cGRhdGUgdGhlIG1ldGFkYXRhIG9mIHRoZSByb29tLCB0aGlzIGlzIGp1c3QgYSBzZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBtZXRhZGF0YWBcbiAgICogYFRvIG5vdGlmeSBldmVyeW9uZSBpbiB0aGUgcm9vbSBhYm91dCB0aGUgbWV0YWRhdGEgY2hhbmdlLCB1c2UgdGhlIHVwZGF0ZU1ldGFkYXRhIGZ1bmN0aW9uYFxuICAgKi9cbiAgc2V0IG1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdGhpcy5fX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgY29uc3QgcGFyc2UgPSBKU09OLnBhcnNlKG1ldGFkYXRhKTtcbiAgICB0aGlzLmVtaXQoXCJtZXRhZGF0YS11cGRhdGVkXCIsIHBhcnNlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtZXRhZGF0YSBvZiB0aGUgcm9vbVxuICAgKi9cbiAgZ2V0TWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5fX21ldGFkYXRhIHx8IFwie31cIik7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGUgTWV0YWRhdGEgb2YgdGhlIHJvb21cbiAgICovXG4gIHVwZGF0ZU1ldGFkYXRhID0gY2hlY2tQZXJtaXNzaW9ucyh7fSkudmFsaWRhdGUoXG4gICAgKGRhdGEpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImNsb3NlZFwiIHx8IHRoaXMuc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBcIlxcdTI3NEMgQ2Fubm90IFVwZGF0ZSBNZXRhZGF0YSwgWW91IGhhdmUgbm90IGpvaW5lZCB0aGUgcm9vbSB5ZXRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zb2NrZXQucHVibGlzaChcInVwZGF0ZVJvb21NZXRhZGF0YVwiLCB7XG4gICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFVwZGF0aW5nIE1ldGFkYXRhXCIpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSb29tIEluc3RhbmNlIGlmIG5vdCBjcmVhdGVkLCBlbHNlIHJldHVybiB0aGUgZXhpc3RpbmcgUm9vbSBJbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyAtIFJvb20gSW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZGF0YSkge1xuICAgIGlmIChfUm9vbS5fX2luc3RhbmNlKSB7XG4gICAgICByZXR1cm4gX1Jvb20uX19pbnN0YW5jZTtcbiAgICB9XG4gICAgbG9nZ2VyLmRlYnVnKHsgZGF0YSB9KTtcbiAgICBfUm9vbS5fX2luc3RhbmNlID0gbmV3IF9Sb29tKGRhdGEpO1xuICAgIHJldHVybiBfUm9vbS5fX2luc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIFJvb20gSW5zdGFuY2UgaWYgaXRzIG5vdCBpbml0aWFsaXplZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAqIEByZXR1cm5zIC0gUm9vbSBJbnN0YW5jZVxuICAgKiBAdGhyb3dzIHsgRXJyb3IgfSBJZiB0aGUgUm9vbSBJbnN0YW5jZSBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSA9ICgpID0+IHtcbiAgICBpZiAoIV9Sb29tLl9faW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcdTI3NEMgUm9vbSBJbnN0YW5jZSBOb3QgSW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBfUm9vbS5fX2luc3RhbmNlO1xuICB9O1xuICAvKipcbiAgICogUm9vbUlkIG9mIHRoZSBjdXJyZW50bHkgam9pbmVkIHJvb20uXG4gICAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIGlmICghdGhpcy5fX3Jvb21JZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9fcm9vbUlkO1xuICB9XG4gIHNldCByb29tSWQocm9vbUlkKSB7XG4gICAgaWYgKHRoaXMuX19yb29tSWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBcIlJvb21JZCBpcyBhbHJlYWR5IHNldCwgSWdub3JpbmcgdGhlIG5ldyByb29tSWQsIGVuZCB0aGlzIHJvb20gYW5kIGNyZWF0ZSBhIG5ldyByb29tXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19yb29tSWQgPSByb29tSWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFBlZXJJZHMgb2YgdGhlIHJlbW90ZSBwZWVyc1xuICAgKi9cbiAgZ2V0IHBlZXJJZHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZW1vdGVQZWVycy5rZXlzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVXBkYXRlIHJvb20gY29udHJvbCBib29sZWFucyAtIHJvb21Mb2NrZWQsIGFsbG93UHJvZHVjZSwgYWxsb3dDb25zdW1lLCBhbGxvd1NlbmREYXRhXG4gICAqIEBwYXJhbSBkYXRhOiBUTmV3Um9vbUNvbnRyb2xzXG4gICAqL1xuICB1cGRhdGVSb29tQ29udHJvbHMgPSBjaGVja1Blcm1pc3Npb25zKHtcbiAgICBhZG1pbjogdHJ1ZVxuICB9KS52YWxpZGF0ZSgoZGF0YSkgPT4ge1xuICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBVcGRhdGluZyBSb29tIENvbnRyb2xzXCIsIGRhdGEpO1xuICAgIHRoaXMuY29uZmlnW2RhdGEudHlwZV0gPSBkYXRhLnZhbHVlO1xuICAgIHRoaXMuZW1pdChcInJvb20tY29udHJvbHMtdXBkYXRlZFwiLCB7IC4uLmRhdGEgfSk7XG4gICAgdGhpcy5zb2NrZXQucHVibGlzaChcInVwZGF0ZVJvb21Db250cm9sc1wiLCBkYXRhKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBDbG9zZSBhIHBhcnRpY3VsYXIgc3RyZWFtIG9mIHJlbW90ZSBwZWVyc1xuICAgKiAgQHBhcmFtIGRhdGE6IHsgbGFiZWw6IHN0cmluZzsgcGVlcklkcz86IHN0cmluZ1tdIH1cbiAgICogIEBwYXJhbSBsYWJlbDogTGFiZWwgb2YgdGhlIHN0cmVhbVxuICAgKiAgQHBhcmFtIHBlZXJJZHM6IFBlZXJJZHMgb2YgdGhlIHJlbW90ZSBwZWVycywgaWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGNsb3NlIHRoZSBzdHJlYW0gb2YgYWxsIHRoZSByZW1vdGUgcGVlcnNcbiAgICovXG4gIGNsb3NlU3RyZWFtT2ZMYWJlbCA9IGNoZWNrUGVybWlzc2lvbnMoe30pLnZhbGlkYXRlKFxuICAgIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gQ2xvc2luZyBTdHJlYW0gb2YgTGFiZWxcIiwgZGF0YSk7XG4gICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwiY2xvc2VTdHJlYW1PZkxhYmVsXCIsIGRhdGEpO1xuICAgIH1cbiAgKTtcbiAgLyoqXG4gICAqIE11dGUgZXZlcnlvbmUgaW4gdGhlIHJvb20uIFRoaXMgd2lsbCBjbG9zZSB0aGUgYXVkaW8gc3RyZWFtIG9mIGFsbCB0aGUgcmVtb3RlIHBlZXJzIHdobyBkb250IGhhdmUgYWRtaW4gcGVybWlzc2lvbnNcbiAgICpcbiAgICogYE5PVEU6IFRoaXMgd2lsbCB0YXJnZXQgYWxsIHRoZSBhdWRpbyBzdHJlYW0gaW4gdGhlIHJvb20gd2l0aCB0aGUgbGFiZWwgXCJhdWRpb1wiYFxuICAgKi9cbiAgbXV0ZUV2ZXJ5b25lID0gY2hlY2tQZXJtaXNzaW9ucyh7IGFkbWluOiB0cnVlIH0pLnZhbGlkYXRlKCgpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gTXV0aW5nIEV2ZXJ5b25lXCIpO1xuICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJjbG9zZVN0cmVhbU9mTGFiZWxcIiwge1xuICAgICAgbGFiZWw6IFwiYXVkaW9cIlxuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFJlbW90ZSBQZWVyIHdpdGggdGhlIGdpdmVuIHBlZXJJZCBpcyBwcmVzZW50IGluIHRoZSByb29tLiBSZXR1cm5zIG51bGwgaWYgdGhlIHBlZXIgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJvb20uXG4gICAqXG4gICAqIEBwYXJhbSBwZWVySWQgLSBQZWVySWQgb2YgdGhlIHJlbW90ZSBwZWVyXG4gICAqIEByZXR1cm5zIC0gUmVtb3RlUGVlciBJbnN0YW5jZVxuICAgKiBAcmV0dXJuIC0gbnVsbCBpZiB0aGUgcGVlciBpcyBub3QgcHJlc2VudCBpbiB0aGUgcm9vbVxuICAgKi9cbiAgcmVtb3RlUGVlckV4aXN0cyA9IChwZWVySWQpID0+IHtcbiAgICBjb25zdCBwZWVyID0gdGhpcy5yZW1vdGVQZWVycy5nZXQocGVlcklkKTtcbiAgICBpZiAoIXBlZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGVlcjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFJlbW90ZSBQZWVyIGlmIHByZXNlbnQgaW4gcm9vbS5cbiAgICogQHBhcmFtIHBlZXJJZCAtIFBlZXJJZCBvZiB0aGUgcmVtb3RlIHBlZXJcbiAgICogQHJldHVybnMgLSBSZW1vdGVQZWVyIEluc3RhbmNlXG4gICAqIEB0aHJvd3MgeyBFcnJvciB9IElmIHRoZSBSZW1vdGUgUGVlciBpcyBub3QgZm91bmRcbiAgICovXG4gIGdldFJlbW90ZVBlZXJCeUlkKHBlZXJJZCkge1xuICAgIGNvbnN0IHBlZXIgPSB0aGlzLnJlbW90ZVBlZXJzLmdldChwZWVySWQpO1xuICAgIGlmICghcGVlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZW1vdGUgUGVlciBOb3QgRm91bmQsIHBlZXJJZDogJHtwZWVySWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBwZWVyO1xuICB9XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIGxvZ2dlci5kZWJ1Zyh7IGRhdGEgfSk7XG4gICAgaWYgKGRhdGE/LmFjdGl2ZVNwZWFrZXJzPy5zaXplKSB7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzLnNpemUgPSBkYXRhPy5hY3RpdmVTcGVha2Vycz8uc2l6ZTtcbiAgICB9XG4gICAgaWYgKGRhdGE/LmF1dG9Db25zdW1lICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuYXV0b0NvbnN1bWUgPSBkYXRhLmF1dG9Db25zdW1lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIHJvb20gYW5kIHJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSByb29tXG4gICAqIEB0aHJvd3MgeyBFcnJvciB9IElmIHRoZSBzb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkLCBvciBpZiB0aGUgc29ja2V0IGNvbm5lY3Rpb24gaXMgY29ubmVjdGluZ1xuICAgKi9cbiAgY29ubmVjdCA9ICgpID0+IHtcbiAgICBpZiAoX1Jvb20uX19pbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbSBJbnN0YW5jZSBOb3QgSW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5zb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb2NrZXQgaXMgTm90IENvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc29ja2V0LmNvbm5lY3RpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvY2tldCBpcyBDb25uZWN0aW5nLCBXYWl0IGZvciBpdCB0byBiZSBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5yb29tSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb20gSWQgaXMgcmVxdWlyZWQgdG8gY29ubmVjdCB0byB0aGUgcm9vbVwiKTtcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQucHVibGlzaChcImNvbm5lY3RSb29tXCIsIHsgcm9vbUlkOiB0aGlzLnJvb21JZCB9KTtcbiAgICB0aGlzLl9fc3RhdGUgPSBcImNvbm5lY3RpbmdcIjtcbiAgICB0aGlzLmVtaXQoXCJyb29tLWNvbm5lY3RpbmdcIik7XG4gICAgcmV0dXJuIF9Sb29tLl9faW5zdGFuY2U7XG4gIH07XG4gIC8qKlxuICAgKiBBZG1pdCBhIFBlZXIgdG8gdGhlIHJvb20gd2hvIGlzIGluIHRoZSBsb2JieVxuICAgKi9cbiAgYWRtaXRQZWVyID0gY2hlY2tQZXJtaXNzaW9ucyh7IGFkbWluOiB0cnVlIH0pLnZhbGlkYXRlKFxuICAgIChwZWVySWQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTG9iYnlQZWVyKHBlZXJJZCk7XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJhY2NlcHRMb2JieVBlZXJcIiwgeyBwZWVySWQgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHV7MUY1MzR9IEVycm9yIGFkbWl0dGluZyBwZWVyXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIC8qKlxuICAgKiBEZW5pZXMgdGhlIHBlZXIgZnJvbSBqb2luaW5nIHRoZSByb29tLCB3aG8gaXMgaW4gdGhlIGxvYmJ5XG4gICAqL1xuICBkZW55UGVlciA9IGNoZWNrUGVybWlzc2lvbnMoeyBhZG1pbjogdHJ1ZSB9KS52YWxpZGF0ZShcbiAgICAocGVlcklkKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbW92ZUxvYmJ5UGVlcihwZWVySWQpO1xuICAgICAgICB0aGlzLnNvY2tldC5wdWJsaXNoKFwiZGVueUxvYmJ5UGVlclwiLCB7IHBlZXJJZCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdXsxRjUzNH0gRXJyb3IgZGVueWluZyBwZWVyXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIC8qKlxuICAgKiBraWNrIHBlZXIgZnJvbSByb29tIHdpdGggcmVzcGVjdGl2ZSBwZWVySWRcbiAgICovXG4gIGtpY2tQZWVyID0gY2hlY2tQZXJtaXNzaW9ucyh7IGFkbWluOiB0cnVlIH0pLnZhbGlkYXRlKFxuICAgIChwZWVySWQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc29ja2V0LnB1Ymxpc2goXCJraWNrUGVlclwiLCB7IHBlZXJJZCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdXsxRjUzNH0gRXJyb3IgZGVueWluZyBwZWVyXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIC8qKlxuICAgKiBjbG9zaW5nIHRoZSByb29tIGZvciB0aGUgY3VycmVudCB1c2VyLCByb29tIHdpbGwga2VlcCBvbiBydW5uaW5nIGZvciB0aGUgcmVtb3RlIHVzZXJzXG4gICAqIEBkZXByZWNhdGVkIC0gVXNlIGBsZWF2ZVJvb21gIGZyb20gYGh1ZGRsZUNsaWVudGAgaW5zdGVhZFxuICAgKi9cbiAgY2xvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTM0fSBMZWF2aW5nIHRoZSByb29tXCIpO1xuICAgICAgdGhpcy5fX3Jvb21JZCA9IG51bGw7XG4gICAgICB0aGlzLnJlbW90ZVBlZXJzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvYmJ5UGVlcnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubWV0YWRhdGEgPSBcInt9XCI7XG4gICAgICB0aGlzLnN0YXRlID0gXCJsZWZ0XCI7XG4gICAgICB0aGlzLmVtaXQoXCJyb29tLWNsb3NlZFwiLCB7IHJlYXNvbjogcmVhc29uIHx8IFwiTEVGVFwiIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvcjogTGVhdmluZyB0aGUgUm9vbVwiKTtcbiAgICB9XG4gIH07XG59O1xudmFyIFJvb21fZGVmYXVsdCA9IFJvb207XG5cbmV4cG9ydCB7XG4gIFJvb21fZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU5FVzRGRUhFLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-NEW4FEHE.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-OKUP6CWC.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-OKUP6CWC.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transport_default: function() { return /* binding */ Transport_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-G7SIQXZ4.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-G7SIQXZ4.js\");\n/* harmony import */ var _chunk_7PO7E25R_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7PO7E25R.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7PO7E25R.js\");\n/* harmony import */ var _chunk_FE7RZJBI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-FE7RZJBI.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-FE7RZJBI.js\");\n/* harmony import */ var _chunk_CQH3TPW3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-CQH3TPW3.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-CQH3TPW3.js\");\n/* harmony import */ var _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-HVBBMWHF.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n\n\n\n\n\n\n\n\n// src/Transport.ts\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_5__.mainLogger.createSubLogger(\"Transport\");\nvar Transport = class _Transport extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_6__.EnhancedEventEmitter {\n  /**\n   * Peer Id, which handles the peer id.\n   */\n  peerId;\n  /**\n   *  MediaSoup Device Instance, which handles the browsers or mobile device init.\n   */\n  __device;\n  /**\n   * MediaSoup Transport Instance, which handles the media transport.\n   */\n  __mediasoupTransport;\n  /**\n   * Socket Instance, which handles the socket connection.\n   */\n  __socket;\n  /**\n   * Map of Producers, which handles the producers. ( Sending out Media Streams )\n   *\n   * `Mapped with {producerId => Producer}`\n   */\n  __producers = /* @__PURE__ */ new Map();\n  /**\n   * Map of DataProducers, which handles the dataProducers. ( Sending out Data )\n   *\n   * `Mapped with {label => DataProducer}`\n   */\n  __dataProducers = /* @__PURE__ */ new Map();\n  /**\n   * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )\n   *\n   * `Mapped with {label:label => DataConsumer}`\n   */\n  __dataConsumers = /* @__PURE__ */ new Map();\n  /**\n   * Map of Consumers, which handles the consumers. ( Receiving Media Streams )\n   *\n   * `Mapped with {label:RemotePeerId => Consumer}`\n   */\n  __consumers = new _chunk_7PO7E25R_js__WEBPACK_IMPORTED_MODULE_1__.EnhancedMap({});\n  /**\n   * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.\n   *\n   * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.\n   */\n  labelToProducerId = /* @__PURE__ */ new Map();\n  /**\n   * Transport Type, which handles the transport type. ( `send | recv` )\n   */\n  transportType;\n  /**\n   * Pending Producer Tasks, which handles the pending producer tasks.\n   * callback function is necessary to be called when the producer is created\n   * on the server as well as on the client side.\n   */\n  __pendingProducerTasks = /* @__PURE__ */ new Map();\n  /**\n   * Debounce to handle concurrent request to restart Ice. Waits for some time before sending\n   * more requests to restart ice.\n   */\n  __iceRestartDebounce = false;\n  get device() {\n    return this.__device;\n  }\n  get mediasoupTransport() {\n    return this.__mediasoupTransport;\n  }\n  get connectionState() {\n    return this.__mediasoupTransport.connectionState;\n  }\n  get producers() {\n    return this.__producers;\n  }\n  get dataProducers() {\n    return this.__dataProducers;\n  }\n  get dataConsumers() {\n    return this.__dataConsumers;\n  }\n  get consumers() {\n    return this.__consumers;\n  }\n  getProducerById(producerId) {\n    const producer = this.__producers.get(producerId);\n    if (!producer)\n      throw new Error(\"Producer not found\");\n    return producer;\n  }\n  removeProducerById(producerId) {\n    logger.info(`\\u{1F514} Removing Producer, id: ${producerId}`);\n    return this.__producers.delete(producerId);\n  }\n  /**\n   * Get the consumer by label and peerId\n   * @param data\n   * @returns Consumer | null; Returns null if consumer is not found\n   */\n  getConsumer = (data) => {\n    const consumer = this.__consumers.get(data.label, data.peerId);\n    if (!consumer)\n      return null;\n    return consumer;\n  };\n  get transport() {\n    const transport = this.__mediasoupTransport;\n    if (!transport)\n      throw new Error(\"Transport Not Initialized\");\n    return transport;\n  }\n  addPendingProducerTask = (data) => {\n    const key = `${data.peerId}-${data.label}`;\n    logger.info(\"\\u{1F514} Adding Pending Producer Task, key\", key);\n    if (this.__pendingProducerTasks.has(key)) {\n      logger.debug(\"\\u{1F534} Producer Creation is Pending for key: \", key);\n      return;\n    }\n    this.__pendingProducerTasks.set(key, data.callback);\n  };\n  resolvePendingProducerTask = (data) => {\n    const key = `${data.peerId}-${data.label}`;\n    logger.info(\"\\u{1F514} Resolving Pending Producer Task, key\", key);\n    const callback = this.__pendingProducerTasks.get(key);\n    if (!callback) {\n      logger.error(\"\\u{1F534} Producer Creation is not Pending for key: \", key);\n      return;\n    }\n    callback({ id: data.id });\n    this.__pendingProducerTasks.delete(key);\n  };\n  static create = (data) => {\n    try {\n      logger.info(\n        `\\u{1F514} Creating Client Side Transport, type: ${data.transportType}`\n      );\n      const { transportType, device } = data;\n      const payload = {\n        id: data.sdpInfo.id,\n        iceParameters: data.sdpInfo.iceParameters,\n        iceCandidates: data.sdpInfo.iceCandidates,\n        iceServers: data.iceServers,\n        dtlsParameters: data.sdpInfo.dtlsParameters,\n        sctpParameters: data.sdpInfo.sctpParameters,\n        proprietaryConstraints: {},\n        appData: {}\n      };\n      const mediasoupTransport = transportType === \"send\" ? device.createSendTransport(payload) : device.createRecvTransport(payload);\n      const transport = new _Transport({\n        peerId: data.peerId,\n        device: data.device,\n        transportType: data.transportType,\n        mediasoupTransport\n      });\n      return transport;\n    } catch (error) {\n      logger.error(`\\u274C Transport.create(), type: ${data.transportType}`);\n      logger.error(error);\n      throw error;\n    }\n  };\n  constructor(data) {\n    super();\n    this.__socket = _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_4__.Socket_default.getInstance();\n    this.__device = data.device;\n    this.transportType = data.transportType;\n    this.__mediasoupTransport = data.mediasoupTransport;\n    this.__mediasoupTransport.on(\"connectionstatechange\", (state) => {\n      this.__connectionStateChangeHandler(state);\n    });\n    this.peerId = data.peerId;\n    this.__listenTransportConnect();\n    this.__listenTransportProduce();\n    if (this.transportType === \"send\")\n      this.__listenTransportDataProduce();\n    logger.info(`\\u2705 ${data.transportType} Transport Initialized`);\n  }\n  __listenTransportConnect = () => {\n    this.__mediasoupTransport.on(\n      \"connect\",\n      ({ dtlsParameters }, callback, errback) => {\n        logger.info(\"\\u{1F514} Transport Connect Event Called\");\n        try {\n          this.once(\"connectTransportResponse\", () => {\n            callback();\n          });\n          this.__socket.publish(\"connectTransport\", {\n            dtlsParameters,\n            transportType: this.transportType\n          });\n        } catch (error) {\n          logger.error(\"\\u274C Error Transport Connect Event\");\n          logger.error(error);\n          errback(error);\n        }\n      }\n    );\n  };\n  __listenTransportProduce = () => {\n    this.__mediasoupTransport.on(\n      \"produce\",\n      async ({ kind, rtpParameters, appData }, callback, errback) => {\n        logger.info(`\\u{1F514} ${this.transportType} Produce Event Called`);\n        try {\n          const label = appData?.label;\n          if (!label)\n            throw new Error(\"\\u{1F534} Stream Identifier Not Found\");\n          this.__socket.publish(\"produce\", {\n            createProducerData: {\n              rtpParameters,\n              kind,\n              label,\n              appData,\n              paused: false\n            }\n          });\n          this.addPendingProducerTask({\n            peerId: this.peerId,\n            label,\n            callback\n          });\n        } catch (error) {\n          logger.error(\"\\u274C Error Transport Produce Event\");\n          logger.error(error);\n          errback(error);\n        }\n      }\n    );\n  };\n  __listenTransportDataProduce = () => {\n    logger.info(`\\u{1F514} producedata: ${this.transportType} `);\n    this.__mediasoupTransport.on(\n      \"producedata\",\n      async ({ label, appData, sctpStreamParameters, protocol }, callback, errback) => {\n        logger.info(`\\u{1F514} ${this.transportType} Produce Data Event Called`);\n        try {\n          this.__socket.publish(\"produceData\", {\n            createDataProducerData: {\n              transportId: this.__mediasoupTransport.id,\n              sctpStreamParameters,\n              label,\n              protocol,\n              appData\n            }\n          });\n          this.addPendingProducerTask({\n            peerId: this.peerId,\n            label,\n            callback\n          });\n        } catch (error) {\n          logger.error(\"\\u274C Error Transport Produce Data Event\");\n          logger.error(error);\n          errback(error);\n        }\n      }\n    );\n  };\n  produce = async (data) => {\n    const kind = (0,_chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_0__.getMediaStreamKind)(data.stream);\n    const track = (0,_chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_0__.getMediaTrack)({ stream: data.stream, kind });\n    logger.info(`\\u{1F514} Produce Called for kind: ${kind}, label: ${data.label}`);\n    try {\n      if (!this.__device.loaded) {\n        throw new Error(\"Device Not Loaded\");\n      }\n      if (!this.__device.rtpCapabilities.codecs) {\n        throw new Error(\"No Codecs Found\");\n      }\n      if (!this.__device.canProduce(kind)) {\n        throw new Error(`Device Cannot produce ${kind}`);\n      }\n      if (this.transportType !== \"send\") {\n        throw new Error(`Cannot produce on ${this.transportType} transport`);\n      }\n      const codecs = this.__device.rtpCapabilities?.codecs;\n      if (!codecs) {\n        throw new Error(\"\\u274C Device RTP Capabilities not found\");\n      }\n      const codecViaMediaType = {\n        video: codecs.find(\n          (codec) => codec.mimeType.toLowerCase() === \"video/h264\"\n        ),\n        \"screen-share-video\": codecs.find(\n          (codec) => codec.mimeType.toLowerCase() === \"video/h264\"\n        ),\n        audio: void 0\n      };\n      const mediaType = data.label === \"screen-share-video\" ? \"screen-share-video\" : kind;\n      const mediasoupProducer = await this.__mediasoupTransport.produce({\n        track,\n        encodings: _chunk_CQH3TPW3_js__WEBPACK_IMPORTED_MODULE_3__.encodingViaMediaType[mediaType],\n        codecOptions: _chunk_CQH3TPW3_js__WEBPACK_IMPORTED_MODULE_3__.codecOptionsViaKind[kind],\n        codec: codecViaMediaType[mediaType],\n        stopTracks: data.stopTrackOnClose,\n        zeroRtpOnPause: true,\n        disableTrackOnPause: true,\n        appData: {\n          ...data.appData,\n          producerPeerId: this.peerId\n        }\n      });\n      this.__producers.set(mediasoupProducer.id, mediasoupProducer);\n      this.labelToProducerId.set(data.label, mediasoupProducer.id);\n      logger.info(`\\u{1F514} Producer Created sucessfully with label : ${data.label}`);\n      return mediasoupProducer;\n    } catch (error) {\n      logger.error(\"\\u274C Error Transport Produce Event\");\n      logger.error(error);\n      throw error;\n    }\n  };\n  produceData = async (data) => {\n    logger.info(`\\u{1F514} Produce Data Called for label: ${data.label}`);\n    try {\n      if (this.transportType !== \"send\") {\n        throw new Error(`Cannot produce on ${this.transportType} transport`);\n      }\n      const dataProducer = await this.__mediasoupTransport.produceData({\n        label: data.label,\n        appData: {\n          ordered: true,\n          ...data.appData,\n          producerPeerId: this.peerId,\n          label: data.label\n        }\n      });\n      this.__dataProducers.set(dataProducer.label, dataProducer);\n      return dataProducer;\n    } catch (error) {\n      logger.error(\"\\u274C Error Transport Produce Data Event\");\n      logger.error(error);\n      throw error;\n    }\n  };\n  consume = async (data) => {\n    const { label, producerPeerId, kind } = data;\n    logger.info(\n      `\\u{1F514} Consume Called for ${kind} from remote peer ${producerPeerId}`\n    );\n    try {\n      if (this.transportType !== \"recv\") {\n        throw new Error(`Cannot consume on ${this.transportType} transport`);\n      }\n      const consumer = _chunk_FE7RZJBI_js__WEBPACK_IMPORTED_MODULE_2__.Consumer_default.create({\n        producerId: data.producerId,\n        producerPeerId,\n        label\n      });\n      if (!this.__device.loaded) {\n        throw new Error(\"Device Not Loaded\");\n      }\n      if (!this.__device.rtpCapabilities.codecs) {\n        throw new Error(\"No Codecs Found\");\n      }\n      const mediaSoupConsumer = await this.__mediasoupTransport.consume({\n        id: data.consumerId,\n        rtpParameters: data.rtpParameters,\n        kind: data.kind,\n        producerId: data.producerId,\n        appData: data.appData\n      });\n      mediaSoupConsumer.on(\"transportclose\", () => {\n        this.closeConsumer({ label, peerId: producerPeerId });\n      });\n      mediaSoupConsumer.on(\"trackended\", () => {\n        this.closeConsumer({ label, peerId: producerPeerId });\n      });\n      this.__consumers.set(consumer.label, consumer.producerPeerId, consumer);\n      consumer.setMediaSoupConsumer(mediaSoupConsumer);\n      return { consumer, mediaSoupConsumer };\n    } catch (error) {\n      logger.error(error);\n      throw new Error(\"\\u274C Error calling consume()\");\n    }\n  };\n  consumeData = async (data) => {\n    const {\n      label,\n      appData,\n      dataProducerId,\n      protocol,\n      id,\n      peerId,\n      sctpStreamParameters\n    } = data;\n    logger.info(\n      `\\u{1F514} ConsumeData from producer ${peerId} consumerIdFromServer:${id}`\n    );\n    try {\n      if (this.transportType !== \"recv\") {\n        throw new Error(`Cannot consume on ${this.transportType} transport`);\n      }\n      if (!this.__device.loaded) {\n        throw new Error(\"Device Not Loaded\");\n      }\n      if (!this.__device.rtpCapabilities.codecs) {\n        throw new Error(\"No Codecs Found\");\n      }\n      const dataConsumer = await this.transport.consumeData({\n        id,\n        dataProducerId,\n        sctpStreamParameters,\n        label,\n        protocol,\n        appData\n      });\n      dataConsumer.on(\"open\", () => {\n        logger.info(`\\u2705 DataConsumer with ${label} opened`);\n      });\n      dataConsumer.on(\"close\", () => {\n        logger.warn(`\\u2705 DataConsumer with ${label} closed`);\n        this.__dataConsumers.delete(label);\n      });\n      dataConsumer.on(\"error\", (error) => {\n        logger.error(`\\u2705 DataConsumer \"error\": ${error} closed`);\n      });\n      this.__dataConsumers.set(label, dataConsumer);\n      return dataConsumer;\n    } catch (error) {\n      logger.error(error);\n      throw new Error(\"\\u274C Error calling consumeData()\");\n    }\n  };\n  closeConsumer = (data) => {\n    try {\n      const consumer = this.getConsumer(data);\n      if (!consumer) {\n        throw new Error(\n          `\\u274C Consumer not found label: ${data.label}, peerId: ${data.peerId}`\n        );\n      }\n      consumer.close();\n      this.__consumers.delete(data.label, data.peerId);\n    } catch (error) {\n      logger.error(\"\\u274C Error closing consumer\");\n      logger.error(error);\n    }\n  };\n  close = async (data) => {\n    try {\n      if (data.retries <= 0) {\n        logger.error(\"\\u274C Error closing transport, max retries exceeded\");\n        return;\n      }\n      logger.info(`\\u{1F514} Closing ${this.transportType} transport`);\n      this.__mediasoupTransport.close();\n      logger.info(`\\u2705 ${this.transportType} transport closed`);\n    } catch (error) {\n      logger.error(\"\\u274C Error closing transport\");\n      logger.error(error);\n      logger.error(\"Retrying...\");\n      this.close({ retries: data.retries - 1 });\n    }\n  };\n  __connectionStateChangeHandler = (state) => {\n    try {\n      logger.debug(\n        `\\u{1F514} ${this.transportType} Transport Connection State Changed, state: ${state}`\n      );\n      const transportType = this.transportType;\n      const handler = {\n        connected: () => {\n          logger.debug(`\\u{1F514} ${this.transportType} Transport Connected`);\n        },\n        disconnected: () => {\n          if (this.__iceRestartDebounce)\n            return;\n          this.__iceRestartDebounce = true;\n          this.__socket.publish(\"restartTransportIce\", {\n            transportId: this.__mediasoupTransport.id,\n            transportType\n          });\n          setTimeout(() => {\n            this.__iceRestartDebounce = false;\n          }, 3e3);\n          logger.debug(`\\u{1F514} ${transportType} Transport Disconnected`);\n        },\n        failed: () => {\n          logger.debug(`\\u{1F514} ${transportType} Transport Failed`);\n        },\n        connecting: () => {\n          logger.debug(`\\u{1F514} ${transportType} Transport Connecting`);\n        },\n        closed: () => {\n          logger.debug(`\\u{1F514} ${transportType} Transport closed`);\n        },\n        new: () => {\n          logger.debug(`\\u{1F514} ${transportType} Transport new`);\n        }\n      };\n      handler[state]();\n    } catch (err) {\n      logger.error(\"\\u274C Error in connectionStateChangeHandler\");\n      logger.error(err);\n    }\n  };\n};\nvar Transport_default = Transport;\n\n\n//# sourceMappingURL=chunk-OKUP6CWC.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLU9LVVA2Q1dDLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRzZCO0FBR0E7QUFHQTtBQUlBO0FBR0E7QUFHQTtBQUdBOztBQUU3QjtBQUNBLGFBQWEsMERBQVU7QUFDdkIseUNBQXlDLG9FQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQSxvQkFBb0IsMkRBQVcsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPLHlCQUF5QixXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZLEdBQUcsV0FBVztBQUM3QyxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWSxHQUFHLFdBQVc7QUFDN0Msb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyx3Q0FBd0MsbUJBQW1CO0FBQzlFO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTix1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3Qyx3QkFBd0IsT0FBTyxFQUFFLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sZUFBZSxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9ELHdCQUF3QixPQUFPLEVBQUUsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzRUFBa0I7QUFDbkMsa0JBQWtCLGlFQUFhLEdBQUcsMkJBQTJCO0FBQzdELG9CQUFvQixPQUFPLDJCQUEyQixLQUFLLFdBQVcsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRUFBb0I7QUFDdkMsc0JBQXNCLG1FQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyw0Q0FBNEMsV0FBVztBQUNwRjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxpQ0FBaUMsV0FBVztBQUN2RTtBQUNBO0FBQ0EsNkNBQTZDLG9CQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLFVBQVUsT0FBTyxxQkFBcUIsTUFBTSxtQkFBbUIsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CO0FBQ2pFO0FBQ0EsdUJBQXVCLGdFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RCxPQUFPO0FBQ1A7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsT0FBTyw0QkFBNEIsUUFBUSx1QkFBdUIsR0FBRztBQUMvRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsT0FBTztBQUN2RCxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBLE9BQU87QUFDUDtBQUNBLHFEQUFxRCxPQUFPO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXLFlBQVksWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLFVBQVUsb0JBQW9CO0FBQzNEO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPLEVBQUUsb0JBQW9CLDZDQUE2QyxNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sRUFBRSxvQkFBb0I7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMkJBQTJCLE9BQU8sRUFBRSxlQUFlO0FBQ25ELFNBQVM7QUFDVDtBQUNBLDJCQUEyQixPQUFPLEVBQUUsZUFBZTtBQUNuRCxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsT0FBTyxFQUFFLGVBQWU7QUFDbkQsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLE9BQU8sRUFBRSxlQUFlO0FBQ25ELFNBQVM7QUFDVDtBQUNBLDJCQUEyQixPQUFPLEVBQUUsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLU9LVVA2Q1dDLmpzP2ZjNTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZ2V0TWVkaWFTdHJlYW1LaW5kLFxuICBnZXRNZWRpYVRyYWNrXG59IGZyb20gXCIuL2NodW5rLUc3U0lRWFo0LmpzXCI7XG5pbXBvcnQge1xuICBFbmhhbmNlZE1hcFxufSBmcm9tIFwiLi9jaHVuay03UE83RTI1Ui5qc1wiO1xuaW1wb3J0IHtcbiAgQ29uc3VtZXJfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1GRTdSWkpCSS5qc1wiO1xuaW1wb3J0IHtcbiAgY29kZWNPcHRpb25zVmlhS2luZCxcbiAgZW5jb2RpbmdWaWFNZWRpYVR5cGVcbn0gZnJvbSBcIi4vY2h1bmstQ1FIM1RQVzMuanNcIjtcbmltcG9ydCB7XG4gIFNvY2tldF9kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLUhWQkJNV0hGLmpzXCI7XG5pbXBvcnQge1xuICBtYWluTG9nZ2VyXG59IGZyb20gXCIuL2NodW5rLUVWWFdNQ05ULmpzXCI7XG5pbXBvcnQge1xuICBFbmhhbmNlZEV2ZW50RW1pdHRlclxufSBmcm9tIFwiLi9jaHVuay03T1RRQUZYRS5qc1wiO1xuXG4vLyBzcmMvVHJhbnNwb3J0LnRzXG52YXIgbG9nZ2VyID0gbWFpbkxvZ2dlci5jcmVhdGVTdWJMb2dnZXIoXCJUcmFuc3BvcnRcIik7XG52YXIgVHJhbnNwb3J0ID0gY2xhc3MgX1RyYW5zcG9ydCBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFBlZXIgSWQsIHdoaWNoIGhhbmRsZXMgdGhlIHBlZXIgaWQuXG4gICAqL1xuICBwZWVySWQ7XG4gIC8qKlxuICAgKiAgTWVkaWFTb3VwIERldmljZSBJbnN0YW5jZSwgd2hpY2ggaGFuZGxlcyB0aGUgYnJvd3NlcnMgb3IgbW9iaWxlIGRldmljZSBpbml0LlxuICAgKi9cbiAgX19kZXZpY2U7XG4gIC8qKlxuICAgKiBNZWRpYVNvdXAgVHJhbnNwb3J0IEluc3RhbmNlLCB3aGljaCBoYW5kbGVzIHRoZSBtZWRpYSB0cmFuc3BvcnQuXG4gICAqL1xuICBfX21lZGlhc291cFRyYW5zcG9ydDtcbiAgLyoqXG4gICAqIFNvY2tldCBJbnN0YW5jZSwgd2hpY2ggaGFuZGxlcyB0aGUgc29ja2V0IGNvbm5lY3Rpb24uXG4gICAqL1xuICBfX3NvY2tldDtcbiAgLyoqXG4gICAqIE1hcCBvZiBQcm9kdWNlcnMsIHdoaWNoIGhhbmRsZXMgdGhlIHByb2R1Y2Vycy4gKCBTZW5kaW5nIG91dCBNZWRpYSBTdHJlYW1zIClcbiAgICpcbiAgICogYE1hcHBlZCB3aXRoIHtwcm9kdWNlcklkID0+IFByb2R1Y2VyfWBcbiAgICovXG4gIF9fcHJvZHVjZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIE1hcCBvZiBEYXRhUHJvZHVjZXJzLCB3aGljaCBoYW5kbGVzIHRoZSBkYXRhUHJvZHVjZXJzLiAoIFNlbmRpbmcgb3V0IERhdGEgKVxuICAgKlxuICAgKiBgTWFwcGVkIHdpdGgge2xhYmVsID0+IERhdGFQcm9kdWNlcn1gXG4gICAqL1xuICBfX2RhdGFQcm9kdWNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogTWFwIG9mIERhdGFDb25zdW1lcnMsIHdoaWNoIGhhbmRsZXMgdGhlIGRhdGFDb25zdW1lcnMuICggUmVjZWl2aW5nIE1lZGlhIFN0cmVhbXMgKVxuICAgKlxuICAgKiBgTWFwcGVkIHdpdGgge2xhYmVsOmxhYmVsID0+IERhdGFDb25zdW1lcn1gXG4gICAqL1xuICBfX2RhdGFDb25zdW1lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogTWFwIG9mIENvbnN1bWVycywgd2hpY2ggaGFuZGxlcyB0aGUgY29uc3VtZXJzLiAoIFJlY2VpdmluZyBNZWRpYSBTdHJlYW1zIClcbiAgICpcbiAgICogYE1hcHBlZCB3aXRoIHtsYWJlbDpSZW1vdGVQZWVySWQgPT4gQ29uc3VtZXJ9YFxuICAgKi9cbiAgX19jb25zdW1lcnMgPSBuZXcgRW5oYW5jZWRNYXAoe30pO1xuICAvKipcbiAgICogTWFwIG9mIElkZW50aWZpZXJzIHRvIFByb2R1Y2VyIElkcywgd2hpY2ggaGFuZGxlcyB0aGUgbWFwcGluZyBvZiBpZGVudGlmaWVycyB0byBwcm9kdWNlciBpZHMuXG4gICAqXG4gICAqIGBpZGVudGlmaWVyc2AgYXJlIHRoZSB1bmlxdWUgaWRlbnRpZmllcnMgZm9yIHRoZSBzdHJlYW0sIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHN0cmVhbS5cbiAgICovXG4gIGxhYmVsVG9Qcm9kdWNlcklkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFRyYW5zcG9ydCBUeXBlLCB3aGljaCBoYW5kbGVzIHRoZSB0cmFuc3BvcnQgdHlwZS4gKCBgc2VuZCB8IHJlY3ZgIClcbiAgICovXG4gIHRyYW5zcG9ydFR5cGU7XG4gIC8qKlxuICAgKiBQZW5kaW5nIFByb2R1Y2VyIFRhc2tzLCB3aGljaCBoYW5kbGVzIHRoZSBwZW5kaW5nIHByb2R1Y2VyIHRhc2tzLlxuICAgKiBjYWxsYmFjayBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHByb2R1Y2VyIGlzIGNyZWF0ZWRcbiAgICogb24gdGhlIHNlcnZlciBhcyB3ZWxsIGFzIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAgICovXG4gIF9fcGVuZGluZ1Byb2R1Y2VyVGFza3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogRGVib3VuY2UgdG8gaGFuZGxlIGNvbmN1cnJlbnQgcmVxdWVzdCB0byByZXN0YXJ0IEljZS4gV2FpdHMgZm9yIHNvbWUgdGltZSBiZWZvcmUgc2VuZGluZ1xuICAgKiBtb3JlIHJlcXVlc3RzIHRvIHJlc3RhcnQgaWNlLlxuICAgKi9cbiAgX19pY2VSZXN0YXJ0RGVib3VuY2UgPSBmYWxzZTtcbiAgZ2V0IGRldmljZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RldmljZTtcbiAgfVxuICBnZXQgbWVkaWFzb3VwVHJhbnNwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl9fbWVkaWFzb3VwVHJhbnNwb3J0O1xuICB9XG4gIGdldCBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19tZWRpYXNvdXBUcmFuc3BvcnQuY29ubmVjdGlvblN0YXRlO1xuICB9XG4gIGdldCBwcm9kdWNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wcm9kdWNlcnM7XG4gIH1cbiAgZ2V0IGRhdGFQcm9kdWNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhUHJvZHVjZXJzO1xuICB9XG4gIGdldCBkYXRhQ29uc3VtZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YUNvbnN1bWVycztcbiAgfVxuICBnZXQgY29uc3VtZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9fY29uc3VtZXJzO1xuICB9XG4gIGdldFByb2R1Y2VyQnlJZChwcm9kdWNlcklkKSB7XG4gICAgY29uc3QgcHJvZHVjZXIgPSB0aGlzLl9fcHJvZHVjZXJzLmdldChwcm9kdWNlcklkKTtcbiAgICBpZiAoIXByb2R1Y2VyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZHVjZXIgbm90IGZvdW5kXCIpO1xuICAgIHJldHVybiBwcm9kdWNlcjtcbiAgfVxuICByZW1vdmVQcm9kdWNlckJ5SWQocHJvZHVjZXJJZCkge1xuICAgIGxvZ2dlci5pbmZvKGBcXHV7MUY1MTR9IFJlbW92aW5nIFByb2R1Y2VyLCBpZDogJHtwcm9kdWNlcklkfWApO1xuICAgIHJldHVybiB0aGlzLl9fcHJvZHVjZXJzLmRlbGV0ZShwcm9kdWNlcklkKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb25zdW1lciBieSBsYWJlbCBhbmQgcGVlcklkXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIENvbnN1bWVyIHwgbnVsbDsgUmV0dXJucyBudWxsIGlmIGNvbnN1bWVyIGlzIG5vdCBmb3VuZFxuICAgKi9cbiAgZ2V0Q29uc3VtZXIgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGNvbnN1bWVyID0gdGhpcy5fX2NvbnN1bWVycy5nZXQoZGF0YS5sYWJlbCwgZGF0YS5wZWVySWQpO1xuICAgIGlmICghY29uc3VtZXIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29uc3VtZXI7XG4gIH07XG4gIGdldCB0cmFuc3BvcnQoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fX21lZGlhc291cFRyYW5zcG9ydDtcbiAgICBpZiAoIXRyYW5zcG9ydClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBOb3QgSW5pdGlhbGl6ZWRcIik7XG4gICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgfVxuICBhZGRQZW5kaW5nUHJvZHVjZXJUYXNrID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCBrZXkgPSBgJHtkYXRhLnBlZXJJZH0tJHtkYXRhLmxhYmVsfWA7XG4gICAgbG9nZ2VyLmluZm8oXCJcXHV7MUY1MTR9IEFkZGluZyBQZW5kaW5nIFByb2R1Y2VyIFRhc2ssIGtleVwiLCBrZXkpO1xuICAgIGlmICh0aGlzLl9fcGVuZGluZ1Byb2R1Y2VyVGFza3MuaGFzKGtleSkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlxcdXsxRjUzNH0gUHJvZHVjZXIgQ3JlYXRpb24gaXMgUGVuZGluZyBmb3Iga2V5OiBcIiwga2V5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fX3BlbmRpbmdQcm9kdWNlclRhc2tzLnNldChrZXksIGRhdGEuY2FsbGJhY2spO1xuICB9O1xuICByZXNvbHZlUGVuZGluZ1Byb2R1Y2VyVGFzayA9IChkYXRhKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZGF0YS5wZWVySWR9LSR7ZGF0YS5sYWJlbH1gO1xuICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBSZXNvbHZpbmcgUGVuZGluZyBQcm9kdWNlciBUYXNrLCBrZXlcIiwga2V5KTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX19wZW5kaW5nUHJvZHVjZXJUYXNrcy5nZXQoa2V5KTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHV7MUY1MzR9IFByb2R1Y2VyIENyZWF0aW9uIGlzIG5vdCBQZW5kaW5nIGZvciBrZXk6IFwiLCBrZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayh7IGlkOiBkYXRhLmlkIH0pO1xuICAgIHRoaXMuX19wZW5kaW5nUHJvZHVjZXJUYXNrcy5kZWxldGUoa2V5KTtcbiAgfTtcbiAgc3RhdGljIGNyZWF0ZSA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgXFx1ezFGNTE0fSBDcmVhdGluZyBDbGllbnQgU2lkZSBUcmFuc3BvcnQsIHR5cGU6ICR7ZGF0YS50cmFuc3BvcnRUeXBlfWBcbiAgICAgICk7XG4gICAgICBjb25zdCB7IHRyYW5zcG9ydFR5cGUsIGRldmljZSB9ID0gZGF0YTtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIGlkOiBkYXRhLnNkcEluZm8uaWQsXG4gICAgICAgIGljZVBhcmFtZXRlcnM6IGRhdGEuc2RwSW5mby5pY2VQYXJhbWV0ZXJzLFxuICAgICAgICBpY2VDYW5kaWRhdGVzOiBkYXRhLnNkcEluZm8uaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgaWNlU2VydmVyczogZGF0YS5pY2VTZXJ2ZXJzLFxuICAgICAgICBkdGxzUGFyYW1ldGVyczogZGF0YS5zZHBJbmZvLmR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICBzY3RwUGFyYW1ldGVyczogZGF0YS5zZHBJbmZvLnNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzOiB7fSxcbiAgICAgICAgYXBwRGF0YToge31cbiAgICAgIH07XG4gICAgICBjb25zdCBtZWRpYXNvdXBUcmFuc3BvcnQgPSB0cmFuc3BvcnRUeXBlID09PSBcInNlbmRcIiA/IGRldmljZS5jcmVhdGVTZW5kVHJhbnNwb3J0KHBheWxvYWQpIDogZGV2aWNlLmNyZWF0ZVJlY3ZUcmFuc3BvcnQocGF5bG9hZCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgX1RyYW5zcG9ydCh7XG4gICAgICAgIHBlZXJJZDogZGF0YS5wZWVySWQsXG4gICAgICAgIGRldmljZTogZGF0YS5kZXZpY2UsXG4gICAgICAgIHRyYW5zcG9ydFR5cGU6IGRhdGEudHJhbnNwb3J0VHlwZSxcbiAgICAgICAgbWVkaWFzb3VwVHJhbnNwb3J0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgXFx1Mjc0QyBUcmFuc3BvcnQuY3JlYXRlKCksIHR5cGU6ICR7ZGF0YS50cmFuc3BvcnRUeXBlfWApO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3NvY2tldCA9IFNvY2tldF9kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgdGhpcy5fX2RldmljZSA9IGRhdGEuZGV2aWNlO1xuICAgIHRoaXMudHJhbnNwb3J0VHlwZSA9IGRhdGEudHJhbnNwb3J0VHlwZTtcbiAgICB0aGlzLl9fbWVkaWFzb3VwVHJhbnNwb3J0ID0gZGF0YS5tZWRpYXNvdXBUcmFuc3BvcnQ7XG4gICAgdGhpcy5fX21lZGlhc291cFRyYW5zcG9ydC5vbihcImNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLCAoc3RhdGUpID0+IHtcbiAgICAgIHRoaXMuX19jb25uZWN0aW9uU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLnBlZXJJZCA9IGRhdGEucGVlcklkO1xuICAgIHRoaXMuX19saXN0ZW5UcmFuc3BvcnRDb25uZWN0KCk7XG4gICAgdGhpcy5fX2xpc3RlblRyYW5zcG9ydFByb2R1Y2UoKTtcbiAgICBpZiAodGhpcy50cmFuc3BvcnRUeXBlID09PSBcInNlbmRcIilcbiAgICAgIHRoaXMuX19saXN0ZW5UcmFuc3BvcnREYXRhUHJvZHVjZSgpO1xuICAgIGxvZ2dlci5pbmZvKGBcXHUyNzA1ICR7ZGF0YS50cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgSW5pdGlhbGl6ZWRgKTtcbiAgfVxuICBfX2xpc3RlblRyYW5zcG9ydENvbm5lY3QgPSAoKSA9PiB7XG4gICAgdGhpcy5fX21lZGlhc291cFRyYW5zcG9ydC5vbihcbiAgICAgIFwiY29ubmVjdFwiLFxuICAgICAgKHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJcXHV7MUY1MTR9IFRyYW5zcG9ydCBDb25uZWN0IEV2ZW50IENhbGxlZFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm9uY2UoXCJjb25uZWN0VHJhbnNwb3J0UmVzcG9uc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9fc29ja2V0LnB1Ymxpc2goXCJjb25uZWN0VHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdHJhbnNwb3J0VHlwZTogdGhpcy50cmFuc3BvcnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBUcmFuc3BvcnQgQ29ubmVjdCBFdmVudFwiKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGVycmJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgX19saXN0ZW5UcmFuc3BvcnRQcm9kdWNlID0gKCkgPT4ge1xuICAgIHRoaXMuX19tZWRpYXNvdXBUcmFuc3BvcnQub24oXG4gICAgICBcInByb2R1Y2VcIixcbiAgICAgIGFzeW5jICh7IGtpbmQsIHJ0cFBhcmFtZXRlcnMsIGFwcERhdGEgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYFxcdXsxRjUxNH0gJHt0aGlzLnRyYW5zcG9ydFR5cGV9IFByb2R1Y2UgRXZlbnQgQ2FsbGVkYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSBhcHBEYXRhPy5sYWJlbDtcbiAgICAgICAgICBpZiAoIWxhYmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1ezFGNTM0fSBTdHJlYW0gSWRlbnRpZmllciBOb3QgRm91bmRcIik7XG4gICAgICAgICAgdGhpcy5fX3NvY2tldC5wdWJsaXNoKFwicHJvZHVjZVwiLCB7XG4gICAgICAgICAgICBjcmVhdGVQcm9kdWNlckRhdGE6IHtcbiAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgIGFwcERhdGEsXG4gICAgICAgICAgICAgIHBhdXNlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdQcm9kdWNlclRhc2soe1xuICAgICAgICAgICAgcGVlcklkOiB0aGlzLnBlZXJJZCxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIFRyYW5zcG9ydCBQcm9kdWNlIEV2ZW50XCIpO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgZXJyYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9O1xuICBfX2xpc3RlblRyYW5zcG9ydERhdGFQcm9kdWNlID0gKCkgPT4ge1xuICAgIGxvZ2dlci5pbmZvKGBcXHV7MUY1MTR9IHByb2R1Y2VkYXRhOiAke3RoaXMudHJhbnNwb3J0VHlwZX0gYCk7XG4gICAgdGhpcy5fX21lZGlhc291cFRyYW5zcG9ydC5vbihcbiAgICAgIFwicHJvZHVjZWRhdGFcIixcbiAgICAgIGFzeW5jICh7IGxhYmVsLCBhcHBEYXRhLCBzY3RwU3RyZWFtUGFyYW1ldGVycywgcHJvdG9jb2wgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYFxcdXsxRjUxNH0gJHt0aGlzLnRyYW5zcG9ydFR5cGV9IFByb2R1Y2UgRGF0YSBFdmVudCBDYWxsZWRgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9fc29ja2V0LnB1Ymxpc2goXCJwcm9kdWNlRGF0YVwiLCB7XG4gICAgICAgICAgICBjcmVhdGVEYXRhUHJvZHVjZXJEYXRhOiB7XG4gICAgICAgICAgICAgIHRyYW5zcG9ydElkOiB0aGlzLl9fbWVkaWFzb3VwVHJhbnNwb3J0LmlkLFxuICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICBhcHBEYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hZGRQZW5kaW5nUHJvZHVjZXJUYXNrKHtcbiAgICAgICAgICAgIHBlZXJJZDogdGhpcy5wZWVySWQsXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBUcmFuc3BvcnQgUHJvZHVjZSBEYXRhIEV2ZW50XCIpO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgZXJyYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9O1xuICBwcm9kdWNlID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICBjb25zdCBraW5kID0gZ2V0TWVkaWFTdHJlYW1LaW5kKGRhdGEuc3RyZWFtKTtcbiAgICBjb25zdCB0cmFjayA9IGdldE1lZGlhVHJhY2soeyBzdHJlYW06IGRhdGEuc3RyZWFtLCBraW5kIH0pO1xuICAgIGxvZ2dlci5pbmZvKGBcXHV7MUY1MTR9IFByb2R1Y2UgQ2FsbGVkIGZvciBraW5kOiAke2tpbmR9LCBsYWJlbDogJHtkYXRhLmxhYmVsfWApO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuX19kZXZpY2UubG9hZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRldmljZSBOb3QgTG9hZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fZGV2aWNlLnJ0cENhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gQ29kZWNzIEZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fZGV2aWNlLmNhblByb2R1Y2Uoa2luZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZXZpY2UgQ2Fubm90IHByb2R1Y2UgJHtraW5kfWApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhbnNwb3J0VHlwZSAhPT0gXCJzZW5kXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcHJvZHVjZSBvbiAke3RoaXMudHJhbnNwb3J0VHlwZX0gdHJhbnNwb3J0YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlY3MgPSB0aGlzLl9fZGV2aWNlLnJ0cENhcGFiaWxpdGllcz8uY29kZWNzO1xuICAgICAgaWYgKCFjb2RlY3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1Mjc0QyBEZXZpY2UgUlRQIENhcGFiaWxpdGllcyBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlY1ZpYU1lZGlhVHlwZSA9IHtcbiAgICAgICAgdmlkZW86IGNvZGVjcy5maW5kKFxuICAgICAgICAgIChjb2RlYykgPT4gY29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ2aWRlby9oMjY0XCJcbiAgICAgICAgKSxcbiAgICAgICAgXCJzY3JlZW4tc2hhcmUtdmlkZW9cIjogY29kZWNzLmZpbmQoXG4gICAgICAgICAgKGNvZGVjKSA9PiBjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInZpZGVvL2gyNjRcIlxuICAgICAgICApLFxuICAgICAgICBhdWRpbzogdm9pZCAwXG4gICAgICB9O1xuICAgICAgY29uc3QgbWVkaWFUeXBlID0gZGF0YS5sYWJlbCA9PT0gXCJzY3JlZW4tc2hhcmUtdmlkZW9cIiA/IFwic2NyZWVuLXNoYXJlLXZpZGVvXCIgOiBraW5kO1xuICAgICAgY29uc3QgbWVkaWFzb3VwUHJvZHVjZXIgPSBhd2FpdCB0aGlzLl9fbWVkaWFzb3VwVHJhbnNwb3J0LnByb2R1Y2Uoe1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZW5jb2RpbmdzOiBlbmNvZGluZ1ZpYU1lZGlhVHlwZVttZWRpYVR5cGVdLFxuICAgICAgICBjb2RlY09wdGlvbnM6IGNvZGVjT3B0aW9uc1ZpYUtpbmRba2luZF0sXG4gICAgICAgIGNvZGVjOiBjb2RlY1ZpYU1lZGlhVHlwZVttZWRpYVR5cGVdLFxuICAgICAgICBzdG9wVHJhY2tzOiBkYXRhLnN0b3BUcmFja09uQ2xvc2UsXG4gICAgICAgIHplcm9SdHBPblBhdXNlOiB0cnVlLFxuICAgICAgICBkaXNhYmxlVHJhY2tPblBhdXNlOiB0cnVlLFxuICAgICAgICBhcHBEYXRhOiB7XG4gICAgICAgICAgLi4uZGF0YS5hcHBEYXRhLFxuICAgICAgICAgIHByb2R1Y2VyUGVlcklkOiB0aGlzLnBlZXJJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19wcm9kdWNlcnMuc2V0KG1lZGlhc291cFByb2R1Y2VyLmlkLCBtZWRpYXNvdXBQcm9kdWNlcik7XG4gICAgICB0aGlzLmxhYmVsVG9Qcm9kdWNlcklkLnNldChkYXRhLmxhYmVsLCBtZWRpYXNvdXBQcm9kdWNlci5pZCk7XG4gICAgICBsb2dnZXIuaW5mbyhgXFx1ezFGNTE0fSBQcm9kdWNlciBDcmVhdGVkIHN1Y2Vzc2Z1bGx5IHdpdGggbGFiZWwgOiAke2RhdGEubGFiZWx9YCk7XG4gICAgICByZXR1cm4gbWVkaWFzb3VwUHJvZHVjZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgVHJhbnNwb3J0IFByb2R1Y2UgRXZlbnRcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBwcm9kdWNlRGF0YSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgbG9nZ2VyLmluZm8oYFxcdXsxRjUxNH0gUHJvZHVjZSBEYXRhIENhbGxlZCBmb3IgbGFiZWw6ICR7ZGF0YS5sYWJlbH1gKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMudHJhbnNwb3J0VHlwZSAhPT0gXCJzZW5kXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcHJvZHVjZSBvbiAke3RoaXMudHJhbnNwb3J0VHlwZX0gdHJhbnNwb3J0YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhUHJvZHVjZXIgPSBhd2FpdCB0aGlzLl9fbWVkaWFzb3VwVHJhbnNwb3J0LnByb2R1Y2VEYXRhKHtcbiAgICAgICAgbGFiZWw6IGRhdGEubGFiZWwsXG4gICAgICAgIGFwcERhdGE6IHtcbiAgICAgICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgICAgIC4uLmRhdGEuYXBwRGF0YSxcbiAgICAgICAgICBwcm9kdWNlclBlZXJJZDogdGhpcy5wZWVySWQsXG4gICAgICAgICAgbGFiZWw6IGRhdGEubGFiZWxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9fZGF0YVByb2R1Y2Vycy5zZXQoZGF0YVByb2R1Y2VyLmxhYmVsLCBkYXRhUHJvZHVjZXIpO1xuICAgICAgcmV0dXJuIGRhdGFQcm9kdWNlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBUcmFuc3BvcnQgUHJvZHVjZSBEYXRhIEV2ZW50XCIpO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3VtZSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgY29uc3QgeyBsYWJlbCwgcHJvZHVjZXJQZWVySWQsIGtpbmQgfSA9IGRhdGE7XG4gICAgbG9nZ2VyLmluZm8oXG4gICAgICBgXFx1ezFGNTE0fSBDb25zdW1lIENhbGxlZCBmb3IgJHtraW5kfSBmcm9tIHJlbW90ZSBwZWVyICR7cHJvZHVjZXJQZWVySWR9YFxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnRyYW5zcG9ydFR5cGUgIT09IFwicmVjdlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnN1bWUgb24gJHt0aGlzLnRyYW5zcG9ydFR5cGV9IHRyYW5zcG9ydGApO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3VtZXIgPSBDb25zdW1lcl9kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICAgIHByb2R1Y2VySWQ6IGRhdGEucHJvZHVjZXJJZCxcbiAgICAgICAgcHJvZHVjZXJQZWVySWQsXG4gICAgICAgIGxhYmVsXG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5fX2RldmljZS5sb2FkZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGV2aWNlIE5vdCBMb2FkZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19kZXZpY2UucnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBDb2RlY3MgRm91bmRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZWRpYVNvdXBDb25zdW1lciA9IGF3YWl0IHRoaXMuX19tZWRpYXNvdXBUcmFuc3BvcnQuY29uc3VtZSh7XG4gICAgICAgIGlkOiBkYXRhLmNvbnN1bWVySWQsXG4gICAgICAgIHJ0cFBhcmFtZXRlcnM6IGRhdGEucnRwUGFyYW1ldGVycyxcbiAgICAgICAga2luZDogZGF0YS5raW5kLFxuICAgICAgICBwcm9kdWNlcklkOiBkYXRhLnByb2R1Y2VySWQsXG4gICAgICAgIGFwcERhdGE6IGRhdGEuYXBwRGF0YVxuICAgICAgfSk7XG4gICAgICBtZWRpYVNvdXBDb25zdW1lci5vbihcInRyYW5zcG9ydGNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnN1bWVyKHsgbGFiZWwsIHBlZXJJZDogcHJvZHVjZXJQZWVySWQgfSk7XG4gICAgICB9KTtcbiAgICAgIG1lZGlhU291cENvbnN1bWVyLm9uKFwidHJhY2tlbmRlZFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VDb25zdW1lcih7IGxhYmVsLCBwZWVySWQ6IHByb2R1Y2VyUGVlcklkIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9fY29uc3VtZXJzLnNldChjb25zdW1lci5sYWJlbCwgY29uc3VtZXIucHJvZHVjZXJQZWVySWQsIGNvbnN1bWVyKTtcbiAgICAgIGNvbnN1bWVyLnNldE1lZGlhU291cENvbnN1bWVyKG1lZGlhU291cENvbnN1bWVyKTtcbiAgICAgIHJldHVybiB7IGNvbnN1bWVyLCBtZWRpYVNvdXBDb25zdW1lciB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1Mjc0QyBFcnJvciBjYWxsaW5nIGNvbnN1bWUoKVwiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN1bWVEYXRhID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIGFwcERhdGEsXG4gICAgICBkYXRhUHJvZHVjZXJJZCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgaWQsXG4gICAgICBwZWVySWQsXG4gICAgICBzY3RwU3RyZWFtUGFyYW1ldGVyc1xuICAgIH0gPSBkYXRhO1xuICAgIGxvZ2dlci5pbmZvKFxuICAgICAgYFxcdXsxRjUxNH0gQ29uc3VtZURhdGEgZnJvbSBwcm9kdWNlciAke3BlZXJJZH0gY29uc3VtZXJJZEZyb21TZXJ2ZXI6JHtpZH1gXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMudHJhbnNwb3J0VHlwZSAhPT0gXCJyZWN2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29uc3VtZSBvbiAke3RoaXMudHJhbnNwb3J0VHlwZX0gdHJhbnNwb3J0YCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19kZXZpY2UubG9hZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRldmljZSBOb3QgTG9hZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fZGV2aWNlLnJ0cENhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gQ29kZWNzIEZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YUNvbnN1bWVyID0gYXdhaXQgdGhpcy50cmFuc3BvcnQuY29uc3VtZURhdGEoe1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YVByb2R1Y2VySWQsXG4gICAgICAgIHNjdHBTdHJlYW1QYXJhbWV0ZXJzLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIGFwcERhdGFcbiAgICAgIH0pO1xuICAgICAgZGF0YUNvbnN1bWVyLm9uKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBcXHUyNzA1IERhdGFDb25zdW1lciB3aXRoICR7bGFiZWx9IG9wZW5lZGApO1xuICAgICAgfSk7XG4gICAgICBkYXRhQ29uc3VtZXIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBcXHUyNzA1IERhdGFDb25zdW1lciB3aXRoICR7bGFiZWx9IGNsb3NlZGApO1xuICAgICAgICB0aGlzLl9fZGF0YUNvbnN1bWVycy5kZWxldGUobGFiZWwpO1xuICAgICAgfSk7XG4gICAgICBkYXRhQ29uc3VtZXIub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBcXHUyNzA1IERhdGFDb25zdW1lciBcImVycm9yXCI6ICR7ZXJyb3J9IGNsb3NlZGApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9fZGF0YUNvbnN1bWVycy5zZXQobGFiZWwsIGRhdGFDb25zdW1lcik7XG4gICAgICByZXR1cm4gZGF0YUNvbnN1bWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFx1Mjc0QyBFcnJvciBjYWxsaW5nIGNvbnN1bWVEYXRhKClcIik7XG4gICAgfVxuICB9O1xuICBjbG9zZUNvbnN1bWVyID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uc3VtZXIgPSB0aGlzLmdldENvbnN1bWVyKGRhdGEpO1xuICAgICAgaWYgKCFjb25zdW1lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFxcdTI3NEMgQ29uc3VtZXIgbm90IGZvdW5kIGxhYmVsOiAke2RhdGEubGFiZWx9LCBwZWVySWQ6ICR7ZGF0YS5wZWVySWR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3VtZXIuY2xvc2UoKTtcbiAgICAgIHRoaXMuX19jb25zdW1lcnMuZGVsZXRlKGRhdGEubGFiZWwsIGRhdGEucGVlcklkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiXFx1Mjc0QyBFcnJvciBjbG9zaW5nIGNvbnN1bWVyXCIpO1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG4gIGNsb3NlID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGRhdGEucmV0cmllcyA8PSAwKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgY2xvc2luZyB0cmFuc3BvcnQsIG1heCByZXRyaWVzIGV4Y2VlZGVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnZXIuaW5mbyhgXFx1ezFGNTE0fSBDbG9zaW5nICR7dGhpcy50cmFuc3BvcnRUeXBlfSB0cmFuc3BvcnRgKTtcbiAgICAgIHRoaXMuX19tZWRpYXNvdXBUcmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgIGxvZ2dlci5pbmZvKGBcXHUyNzA1ICR7dGhpcy50cmFuc3BvcnRUeXBlfSB0cmFuc3BvcnQgY2xvc2VkYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdTI3NEMgRXJyb3IgY2xvc2luZyB0cmFuc3BvcnRcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgbG9nZ2VyLmVycm9yKFwiUmV0cnlpbmcuLi5cIik7XG4gICAgICB0aGlzLmNsb3NlKHsgcmV0cmllczogZGF0YS5yZXRyaWVzIC0gMSB9KTtcbiAgICB9XG4gIH07XG4gIF9fY29ubmVjdGlvblN0YXRlQ2hhbmdlSGFuZGxlciA9IChzdGF0ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBcXHV7MUY1MTR9ICR7dGhpcy50cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgQ29ubmVjdGlvbiBTdGF0ZSBDaGFuZ2VkLCBzdGF0ZTogJHtzdGF0ZX1gXG4gICAgICApO1xuICAgICAgY29uc3QgdHJhbnNwb3J0VHlwZSA9IHRoaXMudHJhbnNwb3J0VHlwZTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICAgIGNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgXFx1ezFGNTE0fSAke3RoaXMudHJhbnNwb3J0VHlwZX0gVHJhbnNwb3J0IENvbm5lY3RlZGApO1xuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0ZWQ6ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fX2ljZVJlc3RhcnREZWJvdW5jZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0aGlzLl9faWNlUmVzdGFydERlYm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9fc29ja2V0LnB1Ymxpc2goXCJyZXN0YXJ0VHJhbnNwb3J0SWNlXCIsIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydElkOiB0aGlzLl9fbWVkaWFzb3VwVHJhbnNwb3J0LmlkLFxuICAgICAgICAgICAgdHJhbnNwb3J0VHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX2ljZVJlc3RhcnREZWJvdW5jZSA9IGZhbHNlO1xuICAgICAgICAgIH0sIDNlMyk7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKGBcXHV7MUY1MTR9ICR7dHJhbnNwb3J0VHlwZX0gVHJhbnNwb3J0IERpc2Nvbm5lY3RlZGApO1xuICAgICAgICB9LFxuICAgICAgICBmYWlsZWQ6ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFxcdXsxRjUxNH0gJHt0cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgRmFpbGVkYCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Rpbmc6ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFxcdXsxRjUxNH0gJHt0cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgQ29ubmVjdGluZ2ApO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZWQ6ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFxcdXsxRjUxNH0gJHt0cmFuc3BvcnRUeXBlfSBUcmFuc3BvcnQgY2xvc2VkYCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5ldzogKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgXFx1ezFGNTE0fSAke3RyYW5zcG9ydFR5cGV9IFRyYW5zcG9ydCBuZXdgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGhhbmRsZXJbc3RhdGVdKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJcXHUyNzRDIEVycm9yIGluIGNvbm5lY3Rpb25TdGF0ZUNoYW5nZUhhbmRsZXJcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH07XG59O1xudmFyIFRyYW5zcG9ydF9kZWZhdWx0ID0gVHJhbnNwb3J0O1xuXG5leHBvcnQge1xuICBUcmFuc3BvcnRfZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU9LVVA2Q1dDLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-OKUP6CWC.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-PYD4CES4.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-PYD4CES4.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n//# sourceMappingURL=chunk-PYD4CES4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVBZRDRDRVM0LmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGh1ZGRsZTAxK3dlYi1jb3JlQDEuMC4wLWRldi42Ni9ub2RlX21vZHVsZXMvQGh1ZGRsZTAxL3dlYi1jb3JlL2Rpc3QvY2h1bmstUFlENENFUzQuanM/M2ZlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1QWUQ0Q0VTNC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-PYD4CES4.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SSCVNXAL.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SSCVNXAL.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionParameterSchema: function() { return /* binding */ ConnectionParameterSchema; },\n/* harmony export */   DataMessageSchema: function() { return /* binding */ DataMessageSchema; },\n/* harmony export */   GeolocationSchema: function() { return /* binding */ GeolocationSchema; },\n/* harmony export */   VolatileDataMessageSchema: function() { return /* binding */ VolatileDataMessageSchema; }\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(app-client)/./node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs\");\n// src/validators/common.validators.ts\n\nvar ConnectionParameterSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n  roomId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Room id must provided\"\n  }),\n  token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Token must provided\"\n  })\n});\nvar GeolocationSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n  country: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Country must provided\"\n  }),\n  latitude: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Latitude must provided\"\n  }),\n  longitude: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Longitude must provided\"\n  }),\n  region: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Region must provided\"\n  }),\n  globalRegion: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"Global region must provided\"\n  }),\n  ip: zod__WEBPACK_IMPORTED_MODULE_0__.z.string({\n    required_error: \"IP must provided\"\n  })\n});\nvar VolatileDataMessageSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n  from: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n  payload: zod__WEBPACK_IMPORTED_MODULE_0__.z.unknown(),\n  label: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional(),\n  to: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.literal(\"*\"), zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string())]).optional()\n});\nvar DataMessageSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n  from: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n  payload: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n  label: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional()\n});\n\n\n//# sourceMappingURL=chunk-SSCVNXAL.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVNTQ1ZOWEFMLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDeEIsZ0NBQWdDLGtDQUFDO0FBQ2pDLFVBQVUsa0NBQUM7QUFDWDtBQUNBLEdBQUc7QUFDSCxTQUFTLGtDQUFDO0FBQ1Y7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHdCQUF3QixrQ0FBQztBQUN6QixXQUFXLGtDQUFDO0FBQ1o7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQ0FBQztBQUNiO0FBQ0EsR0FBRztBQUNILGFBQWEsa0NBQUM7QUFDZDtBQUNBLEdBQUc7QUFDSCxVQUFVLGtDQUFDO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLGtDQUFDO0FBQ2pCO0FBQ0EsR0FBRztBQUNILE1BQU0sa0NBQUM7QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsZ0NBQWdDLGtDQUFDO0FBQ2pDLFFBQVEsa0NBQUM7QUFDVCxXQUFXLGtDQUFDO0FBQ1osU0FBUyxrQ0FBQztBQUNWLE1BQU0sa0NBQUMsUUFBUSxrQ0FBQyxlQUFlLGtDQUFDLE9BQU8sa0NBQUM7QUFDeEMsQ0FBQztBQUNELHdCQUF3QixrQ0FBQztBQUN6QixRQUFRLGtDQUFDO0FBQ1QsV0FBVyxrQ0FBQztBQUNaLFNBQVMsa0NBQUM7QUFDVixDQUFDOztBQU9DO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVNTQ1ZOWEFMLmpzPzU3YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3ZhbGlkYXRvcnMvY29tbW9uLnZhbGlkYXRvcnMudHNcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG52YXIgQ29ubmVjdGlvblBhcmFtZXRlclNjaGVtYSA9IHoub2JqZWN0KHtcbiAgcm9vbUlkOiB6LnN0cmluZyh7XG4gICAgcmVxdWlyZWRfZXJyb3I6IFwiUm9vbSBpZCBtdXN0IHByb3ZpZGVkXCJcbiAgfSksXG4gIHRva2VuOiB6LnN0cmluZyh7XG4gICAgcmVxdWlyZWRfZXJyb3I6IFwiVG9rZW4gbXVzdCBwcm92aWRlZFwiXG4gIH0pXG59KTtcbnZhciBHZW9sb2NhdGlvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgY291bnRyeTogei5zdHJpbmcoe1xuICAgIHJlcXVpcmVkX2Vycm9yOiBcIkNvdW50cnkgbXVzdCBwcm92aWRlZFwiXG4gIH0pLFxuICBsYXRpdHVkZTogei5zdHJpbmcoe1xuICAgIHJlcXVpcmVkX2Vycm9yOiBcIkxhdGl0dWRlIG11c3QgcHJvdmlkZWRcIlxuICB9KSxcbiAgbG9uZ2l0dWRlOiB6LnN0cmluZyh7XG4gICAgcmVxdWlyZWRfZXJyb3I6IFwiTG9uZ2l0dWRlIG11c3QgcHJvdmlkZWRcIlxuICB9KSxcbiAgcmVnaW9uOiB6LnN0cmluZyh7XG4gICAgcmVxdWlyZWRfZXJyb3I6IFwiUmVnaW9uIG11c3QgcHJvdmlkZWRcIlxuICB9KSxcbiAgZ2xvYmFsUmVnaW9uOiB6LnN0cmluZyh7XG4gICAgcmVxdWlyZWRfZXJyb3I6IFwiR2xvYmFsIHJlZ2lvbiBtdXN0IHByb3ZpZGVkXCJcbiAgfSksXG4gIGlwOiB6LnN0cmluZyh7XG4gICAgcmVxdWlyZWRfZXJyb3I6IFwiSVAgbXVzdCBwcm92aWRlZFwiXG4gIH0pXG59KTtcbnZhciBWb2xhdGlsZURhdGFNZXNzYWdlU2NoZW1hID0gei5vYmplY3Qoe1xuICBmcm9tOiB6LnN0cmluZygpLFxuICBwYXlsb2FkOiB6LnVua25vd24oKSxcbiAgbGFiZWw6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdG86IHoudW5pb24oW3oubGl0ZXJhbChcIipcIiksIHouYXJyYXkoei5zdHJpbmcoKSldKS5vcHRpb25hbCgpXG59KTtcbnZhciBEYXRhTWVzc2FnZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgZnJvbTogei5zdHJpbmcoKSxcbiAgcGF5bG9hZDogei5zdHJpbmcoKSxcbiAgbGFiZWw6IHouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5cbmV4cG9ydCB7XG4gIENvbm5lY3Rpb25QYXJhbWV0ZXJTY2hlbWEsXG4gIEdlb2xvY2F0aW9uU2NoZW1hLFxuICBWb2xhdGlsZURhdGFNZXNzYWdlU2NoZW1hLFxuICBEYXRhTWVzc2FnZVNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVNTQ1ZOWEFMLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SSCVNXAL.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SVY6TXJT.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SVY6TXJT.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HuddleClient_default: function() { return /* binding */ HuddleClient_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_BDLAILV7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-BDLAILV7.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-BDLAILV7.js\");\n/* harmony import */ var _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-NEW4FEHE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-NEW4FEHE.js\");\n/* harmony import */ var _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-HVBBMWHF.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-UXIASGQL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js\");\n\n\n\n\n\n\n// src/HuddleClient.ts\nvar import_socket = (0,_chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_4__.__toESM)((0,_chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_2__.require_socket_types)(), 1);\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_3__.mainLogger.createSubLogger(\"NezukoClient\");\nvar HuddleClient = class {\n  /**\n   * Connection Manager Instance, Hanlder socket connection and stores information about the connection\n   */\n  __socket;\n  /**\n   * Room Instance, Handles the room and its connection\n   */\n  __room;\n  /**\n   * Local Peer Instance, Handles the local peer and its connection\n   */\n  __localPeer;\n  /**\n   * isJoinRoomProcessing: boolean;\n   */\n  __isJoinRoomProcessing = false;\n  /**\n   * Project Id of the Huddle01 Project\n   */\n  projectId;\n  /**\n   * Returns the underlying socket connection\n   * @throws { Error } If the socket connection is not initialized\n   */\n  get socket() {\n    if (!this.__socket) {\n      throw new Error(\n        \"Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first\"\n      );\n    }\n    return this.__socket;\n  }\n  /**\n   * Returns the room instance, throws an error if the room is not created\n   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room\n   */\n  get room() {\n    return this.__room;\n  }\n  get localPeer() {\n    return this.__localPeer;\n  }\n  /**\n   * Room Id of the current room\n   */\n  get roomId() {\n    return this.room.roomId;\n  }\n  /**\n   * Set a new region for the Huddle01 Media Servers\n   */\n  setRegion = (region) => {\n    logger.info(\"Setting a new region, \", region);\n    this.socket.setRegion(region);\n  };\n  constructor(data) {\n    logger.info(\"\\u2705 Initializing HuddleClient\");\n    this.projectId = data.projectId;\n    this.__socket = _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_2__.Socket_default.create();\n    this.__room = _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_1__.Room_default.create({\n      autoConsume: data.options?.autoConsume,\n      activeSpeakers: data.options?.activeSpeakers\n    });\n    this.__localPeer = _chunk_BDLAILV7_js__WEBPACK_IMPORTED_MODULE_0__.LocalPeer_default.create();\n    const isLocalDev = this.projectId === \"development\";\n    if (isLocalDev) {\n      logger.info(\"\\u{1F534} Local Development Mode\");\n      this.socket.enableLocalDev();\n    }\n    this.__socket.on(\"closed\", (code) => {\n      logger.info(\n        \"\\u{1F50C} Socket Connection closed, closing the room and LocalPeer\"\n      );\n      if (code === import_socket.ESocketCloseCode.ROOM_CLOSED) {\n        this.room.close(\"CLOSED\");\n      } else if (code === import_socket.ESocketCloseCode.ROOM_ENTRY_DENIED) {\n        this.room.close(\"DENIED\");\n      } else if (code === import_socket.ESocketCloseCode.CONNECTION_EXPIRED) {\n        logger.info(\"\\u{1F50C} Socket Connection closed due to connection expired\");\n        this.room.close();\n      } else if (code === import_socket.ESocketCloseCode.KICKED) {\n        this.room.close(\"KICKED\");\n      } else {\n        this.room.close();\n      }\n      this.localPeer.close();\n    });\n  }\n  /**\n   * Default method to connect to the Huddle01 Media Room.\n   *\n   * This method connects to socket, creates a room, and then connects to the room;\n   */\n  joinRoom = async (data) => {\n    this.__isJoinRoomProcessing = true;\n    logger.info(\"\\u{1F514} Joining the room with roomId,\", data.roomId);\n    if (this.socket.connectionState === \"connecting\") {\n      logger.warn(\n        \"\\u{1F514} Socket is already connecting, waiting for the connection to be established\"\n      );\n      return this.room;\n    }\n    if (this.room.state === \"connecting\" || this.__isJoinRoomProcessing) {\n      logger.warn(\"\\u{1F514} Room join already in progress\");\n      return this.room;\n    }\n    if (this.localPeer.joined) {\n      logger.warn(\"\\u{1F514} Already joined the room\");\n      return this.room;\n    }\n    try {\n      await this.socket.connect({ token: data.token });\n      this.room.roomId = data.roomId;\n      const room = this.room.connect();\n      return room;\n    } catch (error) {\n      logger.error(\"\\u{1F534} Error While Joining the Room\");\n      logger.error(error);\n      throw error;\n    } finally {\n      this.__isJoinRoomProcessing = false;\n    }\n  };\n  /**\n   * Leave the room and disconnect from the socket\n   */\n  leaveRoom = () => {\n    logger.info(\"Leaving the room\");\n    this.socket.close(import_socket.ESocketCloseCode.NORMAL_CLOSURE);\n  };\n  /**\n   * Close the room and disconnect from the socket\n   */\n  closeRoom = () => {\n    logger.info(\"Closing the room\");\n    this.socket.publish(\"closeRoom\", void 0);\n  };\n};\nvar HuddleClient_default = HuddleClient;\n\n\n//# sourceMappingURL=chunk-SVY6TXJT.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVNWWTZUWEpULmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUU2QjtBQUdBO0FBSUE7QUFHQTtBQUdBOztBQUU3QjtBQUNBLG9CQUFvQiwyREFBTyxDQUFDLHdFQUFvQjtBQUNoRCxhQUFhLDBEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFjO0FBQ2xDLGtCQUFrQiw0REFBWTtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QixpRUFBaUI7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUix3QkFBd0IsT0FBTztBQUMvQjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVNWWTZUWEpULmpzP2I0ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgTG9jYWxQZWVyX2RlZmF1bHRcbn0gZnJvbSBcIi4vY2h1bmstQkRMQUlMVjcuanNcIjtcbmltcG9ydCB7XG4gIFJvb21fZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1ORVc0RkVIRS5qc1wiO1xuaW1wb3J0IHtcbiAgU29ja2V0X2RlZmF1bHQsXG4gIHJlcXVpcmVfc29ja2V0X3R5cGVzXG59IGZyb20gXCIuL2NodW5rLUhWQkJNV0hGLmpzXCI7XG5pbXBvcnQge1xuICBtYWluTG9nZ2VyXG59IGZyb20gXCIuL2NodW5rLUVWWFdNQ05ULmpzXCI7XG5pbXBvcnQge1xuICBfX3RvRVNNXG59IGZyb20gXCIuL2NodW5rLVVYSUFTR1FMLmpzXCI7XG5cbi8vIHNyYy9IdWRkbGVDbGllbnQudHNcbnZhciBpbXBvcnRfc29ja2V0ID0gX190b0VTTShyZXF1aXJlX3NvY2tldF90eXBlcygpLCAxKTtcbnZhciBsb2dnZXIgPSBtYWluTG9nZ2VyLmNyZWF0ZVN1YkxvZ2dlcihcIk5lenVrb0NsaWVudFwiKTtcbnZhciBIdWRkbGVDbGllbnQgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIE1hbmFnZXIgSW5zdGFuY2UsIEhhbmxkZXIgc29ja2V0IGNvbm5lY3Rpb24gYW5kIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29ubmVjdGlvblxuICAgKi9cbiAgX19zb2NrZXQ7XG4gIC8qKlxuICAgKiBSb29tIEluc3RhbmNlLCBIYW5kbGVzIHRoZSByb29tIGFuZCBpdHMgY29ubmVjdGlvblxuICAgKi9cbiAgX19yb29tO1xuICAvKipcbiAgICogTG9jYWwgUGVlciBJbnN0YW5jZSwgSGFuZGxlcyB0aGUgbG9jYWwgcGVlciBhbmQgaXRzIGNvbm5lY3Rpb25cbiAgICovXG4gIF9fbG9jYWxQZWVyO1xuICAvKipcbiAgICogaXNKb2luUm9vbVByb2Nlc3Npbmc6IGJvb2xlYW47XG4gICAqL1xuICBfX2lzSm9pblJvb21Qcm9jZXNzaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBQcm9qZWN0IElkIG9mIHRoZSBIdWRkbGUwMSBQcm9qZWN0XG4gICAqL1xuICBwcm9qZWN0SWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHNvY2tldCBjb25uZWN0aW9uXG4gICAqIEB0aHJvd3MgeyBFcnJvciB9IElmIHRoZSBzb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGdldCBzb2NrZXQoKSB7XG4gICAgaWYgKCF0aGlzLl9fc29ja2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiU29ja2V0IElzIE5vdCBJbml0aWFsaXplZCwgWW91IG5lZWQgdG8gY29ubmVjdCB0byB0aGUgSHVkZGxlMDEgU29ja2V0IFNlcnZlcnMgZmlyc3RcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19zb2NrZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb20gaW5zdGFuY2UsIHRocm93cyBhbiBlcnJvciBpZiB0aGUgcm9vbSBpcyBub3QgY3JlYXRlZFxuICAgKiBAdGhyb3dzIHsgRXJyb3IgfSBJZiB0aGUgcm9vbSBpcyBub3QgY3JlYXRlZCwgQ2FsbCBjcmVhdGVSb29tKCkgbWV0aG9kIGJlZm9yZSB5b3UgY2FuIGFjY2VzcyB0aGUgcm9vbVxuICAgKi9cbiAgZ2V0IHJvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19yb29tO1xuICB9XG4gIGdldCBsb2NhbFBlZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19sb2NhbFBlZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJvb20gSWQgb2YgdGhlIGN1cnJlbnQgcm9vbVxuICAgKi9cbiAgZ2V0IHJvb21JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb29tLnJvb21JZDtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgbmV3IHJlZ2lvbiBmb3IgdGhlIEh1ZGRsZTAxIE1lZGlhIFNlcnZlcnNcbiAgICovXG4gIHNldFJlZ2lvbiA9IChyZWdpb24pID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIlNldHRpbmcgYSBuZXcgcmVnaW9uLCBcIiwgcmVnaW9uKTtcbiAgICB0aGlzLnNvY2tldC5zZXRSZWdpb24ocmVnaW9uKTtcbiAgfTtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGxvZ2dlci5pbmZvKFwiXFx1MjcwNSBJbml0aWFsaXppbmcgSHVkZGxlQ2xpZW50XCIpO1xuICAgIHRoaXMucHJvamVjdElkID0gZGF0YS5wcm9qZWN0SWQ7XG4gICAgdGhpcy5fX3NvY2tldCA9IFNvY2tldF9kZWZhdWx0LmNyZWF0ZSgpO1xuICAgIHRoaXMuX19yb29tID0gUm9vbV9kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICBhdXRvQ29uc3VtZTogZGF0YS5vcHRpb25zPy5hdXRvQ29uc3VtZSxcbiAgICAgIGFjdGl2ZVNwZWFrZXJzOiBkYXRhLm9wdGlvbnM/LmFjdGl2ZVNwZWFrZXJzXG4gICAgfSk7XG4gICAgdGhpcy5fX2xvY2FsUGVlciA9IExvY2FsUGVlcl9kZWZhdWx0LmNyZWF0ZSgpO1xuICAgIGNvbnN0IGlzTG9jYWxEZXYgPSB0aGlzLnByb2plY3RJZCA9PT0gXCJkZXZlbG9wbWVudFwiO1xuICAgIGlmIChpc0xvY2FsRGV2KSB7XG4gICAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUzNH0gTG9jYWwgRGV2ZWxvcG1lbnQgTW9kZVwiKTtcbiAgICAgIHRoaXMuc29ja2V0LmVuYWJsZUxvY2FsRGV2KCk7XG4gICAgfVxuICAgIHRoaXMuX19zb2NrZXQub24oXCJjbG9zZWRcIiwgKGNvZGUpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBcIlxcdXsxRjUwQ30gU29ja2V0IENvbm5lY3Rpb24gY2xvc2VkLCBjbG9zaW5nIHRoZSByb29tIGFuZCBMb2NhbFBlZXJcIlxuICAgICAgKTtcbiAgICAgIGlmIChjb2RlID09PSBpbXBvcnRfc29ja2V0LkVTb2NrZXRDbG9zZUNvZGUuUk9PTV9DTE9TRUQpIHtcbiAgICAgICAgdGhpcy5yb29tLmNsb3NlKFwiQ0xPU0VEXCIpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSBpbXBvcnRfc29ja2V0LkVTb2NrZXRDbG9zZUNvZGUuUk9PTV9FTlRSWV9ERU5JRUQpIHtcbiAgICAgICAgdGhpcy5yb29tLmNsb3NlKFwiREVOSUVEXCIpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSBpbXBvcnRfc29ja2V0LkVTb2NrZXRDbG9zZUNvZGUuQ09OTkVDVElPTl9FWFBJUkVEKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTBDfSBTb2NrZXQgQ29ubmVjdGlvbiBjbG9zZWQgZHVlIHRvIGNvbm5lY3Rpb24gZXhwaXJlZFwiKTtcbiAgICAgICAgdGhpcy5yb29tLmNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGltcG9ydF9zb2NrZXQuRVNvY2tldENsb3NlQ29kZS5LSUNLRUQpIHtcbiAgICAgICAgdGhpcy5yb29tLmNsb3NlKFwiS0lDS0VEXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yb29tLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsUGVlci5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IG1ldGhvZCB0byBjb25uZWN0IHRvIHRoZSBIdWRkbGUwMSBNZWRpYSBSb29tLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjb25uZWN0cyB0byBzb2NrZXQsIGNyZWF0ZXMgYSByb29tLCBhbmQgdGhlbiBjb25uZWN0cyB0byB0aGUgcm9vbTtcbiAgICovXG4gIGpvaW5Sb29tID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICB0aGlzLl9faXNKb2luUm9vbVByb2Nlc3NpbmcgPSB0cnVlO1xuICAgIGxvZ2dlci5pbmZvKFwiXFx1ezFGNTE0fSBKb2luaW5nIHRoZSByb29tIHdpdGggcm9vbUlkLFwiLCBkYXRhLnJvb21JZCk7XG4gICAgaWYgKHRoaXMuc29ja2V0LmNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBcIlxcdXsxRjUxNH0gU29ja2V0IGlzIGFscmVhZHkgY29ubmVjdGluZywgd2FpdGluZyBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gYmUgZXN0YWJsaXNoZWRcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgfVxuICAgIGlmICh0aGlzLnJvb20uc3RhdGUgPT09IFwiY29ubmVjdGluZ1wiIHx8IHRoaXMuX19pc0pvaW5Sb29tUHJvY2Vzc2luZykge1xuICAgICAgbG9nZ2VyLndhcm4oXCJcXHV7MUY1MTR9IFJvb20gam9pbiBhbHJlYWR5IGluIHByb2dyZXNzXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9jYWxQZWVyLmpvaW5lZCkge1xuICAgICAgbG9nZ2VyLndhcm4oXCJcXHV7MUY1MTR9IEFscmVhZHkgam9pbmVkIHRoZSByb29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc29ja2V0LmNvbm5lY3QoeyB0b2tlbjogZGF0YS50b2tlbiB9KTtcbiAgICAgIHRoaXMucm9vbS5yb29tSWQgPSBkYXRhLnJvb21JZDtcbiAgICAgIGNvbnN0IHJvb20gPSB0aGlzLnJvb20uY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHJvb207XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlxcdXsxRjUzNH0gRXJyb3IgV2hpbGUgSm9pbmluZyB0aGUgUm9vbVwiKTtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fX2lzSm9pblJvb21Qcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogTGVhdmUgdGhlIHJvb20gYW5kIGRpc2Nvbm5lY3QgZnJvbSB0aGUgc29ja2V0XG4gICAqL1xuICBsZWF2ZVJvb20gPSAoKSA9PiB7XG4gICAgbG9nZ2VyLmluZm8oXCJMZWF2aW5nIHRoZSByb29tXCIpO1xuICAgIHRoaXMuc29ja2V0LmNsb3NlKGltcG9ydF9zb2NrZXQuRVNvY2tldENsb3NlQ29kZS5OT1JNQUxfQ0xPU1VSRSk7XG4gIH07XG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgcm9vbSBhbmQgZGlzY29ubmVjdCBmcm9tIHRoZSBzb2NrZXRcbiAgICovXG4gIGNsb3NlUm9vbSA9ICgpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcIkNsb3NpbmcgdGhlIHJvb21cIik7XG4gICAgdGhpcy5zb2NrZXQucHVibGlzaChcImNsb3NlUm9vbVwiLCB2b2lkIDApO1xuICB9O1xufTtcbnZhciBIdWRkbGVDbGllbnRfZGVmYXVsdCA9IEh1ZGRsZUNsaWVudDtcblxuZXhwb3J0IHtcbiAgSHVkZGxlQ2xpZW50X2RlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1TVlk2VFhKVC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SVY6TXJT.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __commonJS: function() { return /* binding */ __commonJS; },\n/* harmony export */   __toESM: function() { return /* binding */ __toESM; }\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n\n//# sourceMappingURL=chunk-UXIASGQL.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVVYSUFTR1FMLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7O0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGh1ZGRsZTAxK3dlYi1jb3JlQDEuMC4wLWRldi42Ni9ub2RlX21vZHVsZXMvQGh1ZGRsZTAxL3dlYi1jb3JlL2Rpc3QvY2h1bmstVVhJQVNHUUwuanM/YTE0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG5leHBvcnQge1xuICBfX2NvbW1vbkpTLFxuICBfX3RvRVNNXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstVVhJQVNHUUwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-V4S3N66D.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-V4S3N66D.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permissions_default: function() { return /* binding */ Permissions_default; },\n/* harmony export */   checkPermissions: function() { return /* binding */ checkPermissions; }\n/* harmony export */ });\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n\n\n\n// src/Permissions.ts\nvar logger = _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_0__.mainLogger.createSubLogger(\"Permissions\");\nvar Permissions = class _Permissions extends _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_1__.EnhancedEventEmitter {\n  /**\n   * Get the Singleton Instance of the Permissions Class.\n   */\n  static __instance;\n  /**\n   * Admin Access of the Room.\n   */\n  __admin = false;\n  /**\n   * Can Consume Media Stream of the Room from RemotePeers;\n   */\n  __canConsume = false;\n  /**\n   * Can Produce Media Stream to the Room\n   */\n  __canProduce = true;\n  /**\n   * Allowed Sources to Produce Media Stream to the Room\n   */\n  __canProduceSources = {\n    cam: true,\n    mic: true,\n    screen: true\n  };\n  /**\n   * Can Send Data to the Room, e.g. Chat Messages, update of avatar, name etc. to the room\n   */\n  __canSendData = false;\n  /**\n   * Can Receive Data from the Room, e.g. Chat Messages, update of avatar, name etc. from other Remote Peers.\n   */\n  __canRecvData = false;\n  /**\n   * Can Update Metadata of the Room, e.g. DisplayName, Avatar, etc.\n   */\n  __canUpdateMetadata = false;\n  /**\n   * Custom Role of the Peer in the Room.\n   */\n  __role = null;\n  /**\n   * Getter for the role of the peer.\n   */\n  get role() {\n    return this.__role;\n  }\n  set role(role) {\n    this.__role = role;\n  }\n  /**\n   * Get the Access Control List ( acl ) of the Local Peer in the Room.\n   */\n  get acl() {\n    return {\n      admin: this.__admin,\n      canConsume: this.__canConsume,\n      canProduce: this.__canProduce,\n      canProduceSources: this.__canProduceSources,\n      canSendData: this.__canSendData,\n      canRecvData: this.__canRecvData,\n      canUpdateMetadata: this.__canUpdateMetadata\n    };\n  }\n  /**\n   * Update the Permissions of the Local Peer in the Room. This will emit an event `updated` with the updated permissions.\n   *\n   * `NOTE: If the Peer is not an admin, then the permissions will not be updated on the server`\n   */\n  updatePermissions(permissions) {\n    logger.info(\"\\u{1F514} Updating Permissions\", permissions);\n    this.__admin = permissions.admin ?? this.__admin;\n    this.__canConsume = permissions.canConsume ?? this.__canConsume;\n    this.__canProduce = permissions.canProduce ?? this.__canProduce;\n    this.__canProduceSources = permissions.canProduceSources ?? this.__canProduceSources;\n    this.__canSendData = permissions.canSendData ?? this.__canSendData;\n    this.__canRecvData = permissions.canRecvData ?? this.__canRecvData;\n    this.__canUpdateMetadata = permissions.canUpdateMetadata ?? this.__canUpdateMetadata;\n  }\n  static createInstance() {\n    if (_Permissions.__instance)\n      return _Permissions.__instance;\n    _Permissions.__instance = new _Permissions();\n    return _Permissions.__instance;\n  }\n  static getInstance() {\n    if (!_Permissions.__instance) {\n      throw new Error(\"Permissions Instance not created yet.\");\n    }\n    return _Permissions.__instance;\n  }\n  constructor() {\n    super();\n  }\n  reset() {\n    this.__admin = false;\n    this.__canConsume = false;\n    this.__canProduce = true;\n    this.__canProduceSources = {\n      cam: true,\n      mic: true,\n      screen: true\n    };\n    this.__canSendData = false;\n    this.__canRecvData = false;\n    this.__canUpdateMetadata = false;\n    this.__role = null;\n  }\n};\nvar checkPermissions = (permission) => {\n  return {\n    validate: (fn) => {\n      return (...args) => {\n        const peerPermission = Permissions.getInstance().acl;\n        if (permission.admin && !peerPermission.admin) {\n          throw new Error(\"Admin Access Required.\");\n        }\n        if (permission.canConsume && !peerPermission.canConsume) {\n          throw new Error(\"Can Consume Access Required.\");\n        }\n        if (permission.canProduce && !peerPermission.canProduce) {\n          throw new Error(\"Can Produce Access Required.\");\n        }\n        if (permission.canProduceSources?.cam && !peerPermission.canProduceSources.cam) {\n          throw new Error(\"Produce Sources Access Required. for 'cam'\");\n        }\n        if (permission.canProduceSources?.mic && !peerPermission.canProduceSources.mic) {\n          throw new Error(\"Produce Sources Access Required. for 'mic'\");\n        }\n        if (permission.canProduceSources?.screen && !peerPermission.canProduceSources.screen) {\n          throw new Error(\"Produce Sources Access Required. for 'screen'\");\n        }\n        if (permission.canSendData && !peerPermission.canSendData) {\n          throw new Error(\"Can Send Data Access Required.\");\n        }\n        if (permission.canRecvData && !peerPermission.canRecvData) {\n          throw new Error(\"Can Recv Data Access Required.\");\n        }\n        return fn(...args);\n      };\n    }\n  };\n};\ncheckPermissions({\n  canProduceSources: {\n    cam: true,\n    mic: true,\n    screen: true\n  }\n});\nvar Permissions_default = Permissions;\n\n\n//# sourceMappingURL=chunk-V4S3N66D.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVY0UzNONjZELmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFNkI7QUFHQTs7QUFFN0I7QUFDQSxhQUFhLDBEQUFVO0FBQ3ZCLDZDQUE2QyxvRUFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVY0UzNONjZELmpzP2I2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgbWFpbkxvZ2dlclxufSBmcm9tIFwiLi9jaHVuay1FVlhXTUNOVC5qc1wiO1xuaW1wb3J0IHtcbiAgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbn0gZnJvbSBcIi4vY2h1bmstN09UUUFGWEUuanNcIjtcblxuLy8gc3JjL1Blcm1pc3Npb25zLnRzXG52YXIgbG9nZ2VyID0gbWFpbkxvZ2dlci5jcmVhdGVTdWJMb2dnZXIoXCJQZXJtaXNzaW9uc1wiKTtcbnZhciBQZXJtaXNzaW9ucyA9IGNsYXNzIF9QZXJtaXNzaW9ucyBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgU2luZ2xldG9uIEluc3RhbmNlIG9mIHRoZSBQZXJtaXNzaW9ucyBDbGFzcy5cbiAgICovXG4gIHN0YXRpYyBfX2luc3RhbmNlO1xuICAvKipcbiAgICogQWRtaW4gQWNjZXNzIG9mIHRoZSBSb29tLlxuICAgKi9cbiAgX19hZG1pbiA9IGZhbHNlO1xuICAvKipcbiAgICogQ2FuIENvbnN1bWUgTWVkaWEgU3RyZWFtIG9mIHRoZSBSb29tIGZyb20gUmVtb3RlUGVlcnM7XG4gICAqL1xuICBfX2NhbkNvbnN1bWUgPSBmYWxzZTtcbiAgLyoqXG4gICAqIENhbiBQcm9kdWNlIE1lZGlhIFN0cmVhbSB0byB0aGUgUm9vbVxuICAgKi9cbiAgX19jYW5Qcm9kdWNlID0gdHJ1ZTtcbiAgLyoqXG4gICAqIEFsbG93ZWQgU291cmNlcyB0byBQcm9kdWNlIE1lZGlhIFN0cmVhbSB0byB0aGUgUm9vbVxuICAgKi9cbiAgX19jYW5Qcm9kdWNlU291cmNlcyA9IHtcbiAgICBjYW06IHRydWUsXG4gICAgbWljOiB0cnVlLFxuICAgIHNjcmVlbjogdHJ1ZVxuICB9O1xuICAvKipcbiAgICogQ2FuIFNlbmQgRGF0YSB0byB0aGUgUm9vbSwgZS5nLiBDaGF0IE1lc3NhZ2VzLCB1cGRhdGUgb2YgYXZhdGFyLCBuYW1lIGV0Yy4gdG8gdGhlIHJvb21cbiAgICovXG4gIF9fY2FuU2VuZERhdGEgPSBmYWxzZTtcbiAgLyoqXG4gICAqIENhbiBSZWNlaXZlIERhdGEgZnJvbSB0aGUgUm9vbSwgZS5nLiBDaGF0IE1lc3NhZ2VzLCB1cGRhdGUgb2YgYXZhdGFyLCBuYW1lIGV0Yy4gZnJvbSBvdGhlciBSZW1vdGUgUGVlcnMuXG4gICAqL1xuICBfX2NhblJlY3ZEYXRhID0gZmFsc2U7XG4gIC8qKlxuICAgKiBDYW4gVXBkYXRlIE1ldGFkYXRhIG9mIHRoZSBSb29tLCBlLmcuIERpc3BsYXlOYW1lLCBBdmF0YXIsIGV0Yy5cbiAgICovXG4gIF9fY2FuVXBkYXRlTWV0YWRhdGEgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEN1c3RvbSBSb2xlIG9mIHRoZSBQZWVyIGluIHRoZSBSb29tLlxuICAgKi9cbiAgX19yb2xlID0gbnVsbDtcbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHJvbGUgb2YgdGhlIHBlZXIuXG4gICAqL1xuICBnZXQgcm9sZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3JvbGU7XG4gIH1cbiAgc2V0IHJvbGUocm9sZSkge1xuICAgIHRoaXMuX19yb2xlID0gcm9sZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBBY2Nlc3MgQ29udHJvbCBMaXN0ICggYWNsICkgb2YgdGhlIExvY2FsIFBlZXIgaW4gdGhlIFJvb20uXG4gICAqL1xuICBnZXQgYWNsKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZG1pbjogdGhpcy5fX2FkbWluLFxuICAgICAgY2FuQ29uc3VtZTogdGhpcy5fX2NhbkNvbnN1bWUsXG4gICAgICBjYW5Qcm9kdWNlOiB0aGlzLl9fY2FuUHJvZHVjZSxcbiAgICAgIGNhblByb2R1Y2VTb3VyY2VzOiB0aGlzLl9fY2FuUHJvZHVjZVNvdXJjZXMsXG4gICAgICBjYW5TZW5kRGF0YTogdGhpcy5fX2NhblNlbmREYXRhLFxuICAgICAgY2FuUmVjdkRhdGE6IHRoaXMuX19jYW5SZWN2RGF0YSxcbiAgICAgIGNhblVwZGF0ZU1ldGFkYXRhOiB0aGlzLl9fY2FuVXBkYXRlTWV0YWRhdGFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIFBlcm1pc3Npb25zIG9mIHRoZSBMb2NhbCBQZWVyIGluIHRoZSBSb29tLiBUaGlzIHdpbGwgZW1pdCBhbiBldmVudCBgdXBkYXRlZGAgd2l0aCB0aGUgdXBkYXRlZCBwZXJtaXNzaW9ucy5cbiAgICpcbiAgICogYE5PVEU6IElmIHRoZSBQZWVyIGlzIG5vdCBhbiBhZG1pbiwgdGhlbiB0aGUgcGVybWlzc2lvbnMgd2lsbCBub3QgYmUgdXBkYXRlZCBvbiB0aGUgc2VydmVyYFxuICAgKi9cbiAgdXBkYXRlUGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcbiAgICBsb2dnZXIuaW5mbyhcIlxcdXsxRjUxNH0gVXBkYXRpbmcgUGVybWlzc2lvbnNcIiwgcGVybWlzc2lvbnMpO1xuICAgIHRoaXMuX19hZG1pbiA9IHBlcm1pc3Npb25zLmFkbWluID8/IHRoaXMuX19hZG1pbjtcbiAgICB0aGlzLl9fY2FuQ29uc3VtZSA9IHBlcm1pc3Npb25zLmNhbkNvbnN1bWUgPz8gdGhpcy5fX2NhbkNvbnN1bWU7XG4gICAgdGhpcy5fX2NhblByb2R1Y2UgPSBwZXJtaXNzaW9ucy5jYW5Qcm9kdWNlID8/IHRoaXMuX19jYW5Qcm9kdWNlO1xuICAgIHRoaXMuX19jYW5Qcm9kdWNlU291cmNlcyA9IHBlcm1pc3Npb25zLmNhblByb2R1Y2VTb3VyY2VzID8/IHRoaXMuX19jYW5Qcm9kdWNlU291cmNlcztcbiAgICB0aGlzLl9fY2FuU2VuZERhdGEgPSBwZXJtaXNzaW9ucy5jYW5TZW5kRGF0YSA/PyB0aGlzLl9fY2FuU2VuZERhdGE7XG4gICAgdGhpcy5fX2NhblJlY3ZEYXRhID0gcGVybWlzc2lvbnMuY2FuUmVjdkRhdGEgPz8gdGhpcy5fX2NhblJlY3ZEYXRhO1xuICAgIHRoaXMuX19jYW5VcGRhdGVNZXRhZGF0YSA9IHBlcm1pc3Npb25zLmNhblVwZGF0ZU1ldGFkYXRhID8/IHRoaXMuX19jYW5VcGRhdGVNZXRhZGF0YTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoKSB7XG4gICAgaWYgKF9QZXJtaXNzaW9ucy5fX2luc3RhbmNlKVxuICAgICAgcmV0dXJuIF9QZXJtaXNzaW9ucy5fX2luc3RhbmNlO1xuICAgIF9QZXJtaXNzaW9ucy5fX2luc3RhbmNlID0gbmV3IF9QZXJtaXNzaW9ucygpO1xuICAgIHJldHVybiBfUGVybWlzc2lvbnMuX19pbnN0YW5jZTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCFfUGVybWlzc2lvbnMuX19pbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVybWlzc2lvbnMgSW5zdGFuY2Ugbm90IGNyZWF0ZWQgeWV0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9QZXJtaXNzaW9ucy5fX2luc3RhbmNlO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fX2FkbWluID0gZmFsc2U7XG4gICAgdGhpcy5fX2NhbkNvbnN1bWUgPSBmYWxzZTtcbiAgICB0aGlzLl9fY2FuUHJvZHVjZSA9IHRydWU7XG4gICAgdGhpcy5fX2NhblByb2R1Y2VTb3VyY2VzID0ge1xuICAgICAgY2FtOiB0cnVlLFxuICAgICAgbWljOiB0cnVlLFxuICAgICAgc2NyZWVuOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLl9fY2FuU2VuZERhdGEgPSBmYWxzZTtcbiAgICB0aGlzLl9fY2FuUmVjdkRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLl9fY2FuVXBkYXRlTWV0YWRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLl9fcm9sZSA9IG51bGw7XG4gIH1cbn07XG52YXIgY2hlY2tQZXJtaXNzaW9ucyA9IChwZXJtaXNzaW9uKSA9PiB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGU6IChmbikgPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlZXJQZXJtaXNzaW9uID0gUGVybWlzc2lvbnMuZ2V0SW5zdGFuY2UoKS5hY2w7XG4gICAgICAgIGlmIChwZXJtaXNzaW9uLmFkbWluICYmICFwZWVyUGVybWlzc2lvbi5hZG1pbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFkbWluIEFjY2VzcyBSZXF1aXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcm1pc3Npb24uY2FuQ29uc3VtZSAmJiAhcGVlclBlcm1pc3Npb24uY2FuQ29uc3VtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBDb25zdW1lIEFjY2VzcyBSZXF1aXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcm1pc3Npb24uY2FuUHJvZHVjZSAmJiAhcGVlclBlcm1pc3Npb24uY2FuUHJvZHVjZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBQcm9kdWNlIEFjY2VzcyBSZXF1aXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcm1pc3Npb24uY2FuUHJvZHVjZVNvdXJjZXM/LmNhbSAmJiAhcGVlclBlcm1pc3Npb24uY2FuUHJvZHVjZVNvdXJjZXMuY2FtKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZHVjZSBTb3VyY2VzIEFjY2VzcyBSZXF1aXJlZC4gZm9yICdjYW0nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJtaXNzaW9uLmNhblByb2R1Y2VTb3VyY2VzPy5taWMgJiYgIXBlZXJQZXJtaXNzaW9uLmNhblByb2R1Y2VTb3VyY2VzLm1pYykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2R1Y2UgU291cmNlcyBBY2Nlc3MgUmVxdWlyZWQuIGZvciAnbWljJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVybWlzc2lvbi5jYW5Qcm9kdWNlU291cmNlcz8uc2NyZWVuICYmICFwZWVyUGVybWlzc2lvbi5jYW5Qcm9kdWNlU291cmNlcy5zY3JlZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9kdWNlIFNvdXJjZXMgQWNjZXNzIFJlcXVpcmVkLiBmb3IgJ3NjcmVlbidcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcm1pc3Npb24uY2FuU2VuZERhdGEgJiYgIXBlZXJQZXJtaXNzaW9uLmNhblNlbmREYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIFNlbmQgRGF0YSBBY2Nlc3MgUmVxdWlyZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJtaXNzaW9uLmNhblJlY3ZEYXRhICYmICFwZWVyUGVybWlzc2lvbi5jYW5SZWN2RGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBSZWN2IERhdGEgQWNjZXNzIFJlcXVpcmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4oLi4uYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5jaGVja1Blcm1pc3Npb25zKHtcbiAgY2FuUHJvZHVjZVNvdXJjZXM6IHtcbiAgICBjYW06IHRydWUsXG4gICAgbWljOiB0cnVlLFxuICAgIHNjcmVlbjogdHJ1ZVxuICB9XG59KTtcbnZhciBQZXJtaXNzaW9uc19kZWZhdWx0ID0gUGVybWlzc2lvbnM7XG5cbmV4cG9ydCB7XG4gIGNoZWNrUGVybWlzc2lvbnMsXG4gIFBlcm1pc3Npb25zX2RlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1WNFMzTjY2RC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-V4S3N66D.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-WHLOPA5E.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-WHLOPA5E.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deviceConstraints_default: function() { return /* binding */ deviceConstraints_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_CQH3TPW3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-CQH3TPW3.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-CQH3TPW3.js\");\n\n\n// src/constants/deviceConstraints.ts\nvar videoDefaultConstraints = {\n  video: {\n    ..._chunk_CQH3TPW3_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CONSTRAINTS.hd\n  }\n};\nvar audioConstraints = {\n  audio: {\n    echoCancellation: true,\n    noiseSuppression: true\n  }\n};\nvar shareConstraints = {\n  video: {\n    displaySurface: \"monitor\",\n    logicalSurface: true,\n    cursor: true,\n    width: { ideal: 1920, max: 1920 },\n    height: { ideal: 1080, max: 1080 },\n    frameRate: { ideal: 25, max: 30 }\n  },\n  audio: {\n    echoCancellation: true,\n    noiseSuppression: true\n  }\n};\nvar defaultMediaConstraints = {\n  cam: videoDefaultConstraints,\n  mic: audioConstraints,\n  screen: shareConstraints\n};\nvar deviceConstraints_default = defaultMediaConstraints;\n\n\n//# sourceMappingURL=chunk-WHLOPA5E.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2NodW5rLVdITE9QQTVFLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlFQUFpQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGNBQWMsd0JBQXdCO0FBQ3RDLGlCQUFpQjtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaHVkZGxlMDErd2ViLWNvcmVAMS4wLjAtZGV2LjY2L25vZGVfbW9kdWxlcy9AaHVkZGxlMDEvd2ViLWNvcmUvZGlzdC9jaHVuay1XSExPUEE1RS5qcz81MzIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFZJREVPX0NPTlNUUkFJTlRTXG59IGZyb20gXCIuL2NodW5rLUNRSDNUUFczLmpzXCI7XG5cbi8vIHNyYy9jb25zdGFudHMvZGV2aWNlQ29uc3RyYWludHMudHNcbnZhciB2aWRlb0RlZmF1bHRDb25zdHJhaW50cyA9IHtcbiAgdmlkZW86IHtcbiAgICAuLi5WSURFT19DT05TVFJBSU5UUy5oZFxuICB9XG59O1xudmFyIGF1ZGlvQ29uc3RyYWludHMgPSB7XG4gIGF1ZGlvOiB7XG4gICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICBub2lzZVN1cHByZXNzaW9uOiB0cnVlXG4gIH1cbn07XG52YXIgc2hhcmVDb25zdHJhaW50cyA9IHtcbiAgdmlkZW86IHtcbiAgICBkaXNwbGF5U3VyZmFjZTogXCJtb25pdG9yXCIsXG4gICAgbG9naWNhbFN1cmZhY2U6IHRydWUsXG4gICAgY3Vyc29yOiB0cnVlLFxuICAgIHdpZHRoOiB7IGlkZWFsOiAxOTIwLCBtYXg6IDE5MjAgfSxcbiAgICBoZWlnaHQ6IHsgaWRlYWw6IDEwODAsIG1heDogMTA4MCB9LFxuICAgIGZyYW1lUmF0ZTogeyBpZGVhbDogMjUsIG1heDogMzAgfVxuICB9LFxuICBhdWRpbzoge1xuICAgIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZVxuICB9XG59O1xudmFyIGRlZmF1bHRNZWRpYUNvbnN0cmFpbnRzID0ge1xuICBjYW06IHZpZGVvRGVmYXVsdENvbnN0cmFpbnRzLFxuICBtaWM6IGF1ZGlvQ29uc3RyYWludHMsXG4gIHNjcmVlbjogc2hhcmVDb25zdHJhaW50c1xufTtcbnZhciBkZXZpY2VDb25zdHJhaW50c19kZWZhdWx0ID0gZGVmYXVsdE1lZGlhQ29uc3RyYWludHM7XG5cbmV4cG9ydCB7XG4gIGRldmljZUNvbnN0cmFpbnRzX2RlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1XSExPUEE1RS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-WHLOPA5E.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/index.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Consumer: function() { return /* reexport safe */ _chunk_FE7RZJBI_js__WEBPACK_IMPORTED_MODULE_5__.Consumer_default; },\n/* harmony export */   DeviceHandler: function() { return /* reexport safe */ _chunk_LU7T3V5U_js__WEBPACK_IMPORTED_MODULE_6__.DeviceHandler_default; },\n/* harmony export */   HuddleClient: function() { return /* reexport safe */ _chunk_SVY6TXJT_js__WEBPACK_IMPORTED_MODULE_0__.HuddleClient_default; },\n/* harmony export */   LocalPeer: function() { return /* reexport safe */ _chunk_BDLAILV7_js__WEBPACK_IMPORTED_MODULE_1__.LocalPeer_default; },\n/* harmony export */   Permissions: function() { return /* reexport safe */ _chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_10__.Permissions_default; },\n/* harmony export */   RemotePeer: function() { return /* reexport safe */ _chunk_BDLAILV7_js__WEBPACK_IMPORTED_MODULE_1__.RemotePeer_default; },\n/* harmony export */   Room: function() { return /* reexport safe */ _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_9__.Room_default; },\n/* harmony export */   Socket: function() { return /* reexport safe */ _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_11__.Socket_default; },\n/* harmony export */   Transport: function() { return /* reexport safe */ _chunk_OKUP6CWC_js__WEBPACK_IMPORTED_MODULE_2__.Transport_default; }\n/* harmony export */ });\n/* harmony import */ var _chunk_SVY6TXJT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-SVY6TXJT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SVY6TXJT.js\");\n/* harmony import */ var _chunk_BDLAILV7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-BDLAILV7.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-BDLAILV7.js\");\n/* harmony import */ var _chunk_OKUP6CWC_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-OKUP6CWC.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-OKUP6CWC.js\");\n/* harmony import */ var _chunk_G7SIQXZ4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-G7SIQXZ4.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-G7SIQXZ4.js\");\n/* harmony import */ var _chunk_7PO7E25R_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-7PO7E25R.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7PO7E25R.js\");\n/* harmony import */ var _chunk_FE7RZJBI_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-FE7RZJBI.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-FE7RZJBI.js\");\n/* harmony import */ var _chunk_LU7T3V5U_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-LU7T3V5U.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-LU7T3V5U.js\");\n/* harmony import */ var _chunk_WHLOPA5E_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunk-WHLOPA5E.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-WHLOPA5E.js\");\n/* harmony import */ var _chunk_CQH3TPW3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunk-CQH3TPW3.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-CQH3TPW3.js\");\n/* harmony import */ var _chunk_NEW4FEHE_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunk-NEW4FEHE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-NEW4FEHE.js\");\n/* harmony import */ var _chunk_V4S3N66D_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunk-V4S3N66D.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-V4S3N66D.js\");\n/* harmony import */ var _chunk_HVBBMWHF_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chunk-HVBBMWHF.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-HVBBMWHF.js\");\n/* harmony import */ var _chunk_PYD4CES4_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chunk-PYD4CES4.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-PYD4CES4.js\");\n/* harmony import */ var _chunk_SSCVNXAL_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chunk-SSCVNXAL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-SSCVNXAL.js\");\n/* harmony import */ var _chunk_EVXWMCNT_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chunk-EVXWMCNT.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-EVXWMCNT.js\");\n/* harmony import */ var _chunk_7OTQAFXE_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chunk-7OTQAFXE.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-7OTQAFXE.js\");\n/* harmony import */ var _chunk_UXIASGQL_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./chunk-UXIASGQL.js */ \"(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/chunk-UXIASGQL.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BodWRkbGUwMSt3ZWItY29yZUAxLjAuMC1kZXYuNjYvbm9kZV9tb2R1bGVzL0BodWRkbGUwMS93ZWItY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTZCO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXM0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGh1ZGRsZTAxK3dlYi1jb3JlQDEuMC4wLWRldi42Ni9ub2RlX21vZHVsZXMvQGh1ZGRsZTAxL3dlYi1jb3JlL2Rpc3QvaW5kZXguanM/ZTk4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIdWRkbGVDbGllbnRfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1TVlk2VFhKVC5qc1wiO1xuaW1wb3J0IHtcbiAgTG9jYWxQZWVyX2RlZmF1bHQsXG4gIFJlbW90ZVBlZXJfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1CRExBSUxWNy5qc1wiO1xuaW1wb3J0IHtcbiAgVHJhbnNwb3J0X2RlZmF1bHRcbn0gZnJvbSBcIi4vY2h1bmstT0tVUDZDV0MuanNcIjtcbmltcG9ydCBcIi4vY2h1bmstRzdTSVFYWjQuanNcIjtcbmltcG9ydCBcIi4vY2h1bmstN1BPN0UyNVIuanNcIjtcbmltcG9ydCB7XG4gIENvbnN1bWVyX2RlZmF1bHRcbn0gZnJvbSBcIi4vY2h1bmstRkU3UlpKQkkuanNcIjtcbmltcG9ydCB7XG4gIERldmljZUhhbmRsZXJfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1MVTdUM1Y1VS5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1XSExPUEE1RS5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1DUUgzVFBXMy5qc1wiO1xuaW1wb3J0IHtcbiAgUm9vbV9kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLU5FVzRGRUhFLmpzXCI7XG5pbXBvcnQge1xuICBQZXJtaXNzaW9uc19kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLVY0UzNONjZELmpzXCI7XG5pbXBvcnQge1xuICBTb2NrZXRfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1IVkJCTVdIRi5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1QWUQ0Q0VTNC5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1TU0NWTlhBTC5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1FVlhXTUNOVC5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay03T1RRQUZYRS5qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1VWElBU0dRTC5qc1wiO1xuZXhwb3J0IHtcbiAgQ29uc3VtZXJfZGVmYXVsdCBhcyBDb25zdW1lcixcbiAgRGV2aWNlSGFuZGxlcl9kZWZhdWx0IGFzIERldmljZUhhbmRsZXIsXG4gIEh1ZGRsZUNsaWVudF9kZWZhdWx0IGFzIEh1ZGRsZUNsaWVudCxcbiAgTG9jYWxQZWVyX2RlZmF1bHQgYXMgTG9jYWxQZWVyLFxuICBQZXJtaXNzaW9uc19kZWZhdWx0IGFzIFBlcm1pc3Npb25zLFxuICBSZW1vdGVQZWVyX2RlZmF1bHQgYXMgUmVtb3RlUGVlcixcbiAgUm9vbV9kZWZhdWx0IGFzIFJvb20sXG4gIFNvY2tldF9kZWZhdWx0IGFzIFNvY2tldCxcbiAgVHJhbnNwb3J0X2RlZmF1bHQgYXMgVHJhbnNwb3J0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/@huddle01+web-core@1.0.0-dev.66/node_modules/@huddle01/web-core/dist/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: function() { return /* binding */ BRAND; },\n/* harmony export */   DIRTY: function() { return /* binding */ DIRTY; },\n/* harmony export */   EMPTY_PATH: function() { return /* binding */ EMPTY_PATH; },\n/* harmony export */   INVALID: function() { return /* binding */ INVALID; },\n/* harmony export */   NEVER: function() { return /* binding */ NEVER; },\n/* harmony export */   OK: function() { return /* binding */ OK; },\n/* harmony export */   ParseStatus: function() { return /* binding */ ParseStatus; },\n/* harmony export */   Schema: function() { return /* binding */ ZodType; },\n/* harmony export */   ZodAny: function() { return /* binding */ ZodAny; },\n/* harmony export */   ZodArray: function() { return /* binding */ ZodArray; },\n/* harmony export */   ZodBigInt: function() { return /* binding */ ZodBigInt; },\n/* harmony export */   ZodBoolean: function() { return /* binding */ ZodBoolean; },\n/* harmony export */   ZodBranded: function() { return /* binding */ ZodBranded; },\n/* harmony export */   ZodCatch: function() { return /* binding */ ZodCatch; },\n/* harmony export */   ZodDate: function() { return /* binding */ ZodDate; },\n/* harmony export */   ZodDefault: function() { return /* binding */ ZodDefault; },\n/* harmony export */   ZodDiscriminatedUnion: function() { return /* binding */ ZodDiscriminatedUnion; },\n/* harmony export */   ZodEffects: function() { return /* binding */ ZodEffects; },\n/* harmony export */   ZodEnum: function() { return /* binding */ ZodEnum; },\n/* harmony export */   ZodError: function() { return /* binding */ ZodError; },\n/* harmony export */   ZodFirstPartyTypeKind: function() { return /* binding */ ZodFirstPartyTypeKind; },\n/* harmony export */   ZodFunction: function() { return /* binding */ ZodFunction; },\n/* harmony export */   ZodIntersection: function() { return /* binding */ ZodIntersection; },\n/* harmony export */   ZodIssueCode: function() { return /* binding */ ZodIssueCode; },\n/* harmony export */   ZodLazy: function() { return /* binding */ ZodLazy; },\n/* harmony export */   ZodLiteral: function() { return /* binding */ ZodLiteral; },\n/* harmony export */   ZodMap: function() { return /* binding */ ZodMap; },\n/* harmony export */   ZodNaN: function() { return /* binding */ ZodNaN; },\n/* harmony export */   ZodNativeEnum: function() { return /* binding */ ZodNativeEnum; },\n/* harmony export */   ZodNever: function() { return /* binding */ ZodNever; },\n/* harmony export */   ZodNull: function() { return /* binding */ ZodNull; },\n/* harmony export */   ZodNullable: function() { return /* binding */ ZodNullable; },\n/* harmony export */   ZodNumber: function() { return /* binding */ ZodNumber; },\n/* harmony export */   ZodObject: function() { return /* binding */ ZodObject; },\n/* harmony export */   ZodOptional: function() { return /* binding */ ZodOptional; },\n/* harmony export */   ZodParsedType: function() { return /* binding */ ZodParsedType; },\n/* harmony export */   ZodPipeline: function() { return /* binding */ ZodPipeline; },\n/* harmony export */   ZodPromise: function() { return /* binding */ ZodPromise; },\n/* harmony export */   ZodReadonly: function() { return /* binding */ ZodReadonly; },\n/* harmony export */   ZodRecord: function() { return /* binding */ ZodRecord; },\n/* harmony export */   ZodSchema: function() { return /* binding */ ZodType; },\n/* harmony export */   ZodSet: function() { return /* binding */ ZodSet; },\n/* harmony export */   ZodString: function() { return /* binding */ ZodString; },\n/* harmony export */   ZodSymbol: function() { return /* binding */ ZodSymbol; },\n/* harmony export */   ZodTransformer: function() { return /* binding */ ZodEffects; },\n/* harmony export */   ZodTuple: function() { return /* binding */ ZodTuple; },\n/* harmony export */   ZodType: function() { return /* binding */ ZodType; },\n/* harmony export */   ZodUndefined: function() { return /* binding */ ZodUndefined; },\n/* harmony export */   ZodUnion: function() { return /* binding */ ZodUnion; },\n/* harmony export */   ZodUnknown: function() { return /* binding */ ZodUnknown; },\n/* harmony export */   ZodVoid: function() { return /* binding */ ZodVoid; },\n/* harmony export */   addIssueToContext: function() { return /* binding */ addIssueToContext; },\n/* harmony export */   any: function() { return /* binding */ anyType; },\n/* harmony export */   array: function() { return /* binding */ arrayType; },\n/* harmony export */   bigint: function() { return /* binding */ bigIntType; },\n/* harmony export */   boolean: function() { return /* binding */ booleanType; },\n/* harmony export */   coerce: function() { return /* binding */ coerce; },\n/* harmony export */   custom: function() { return /* binding */ custom; },\n/* harmony export */   date: function() { return /* binding */ dateType; },\n/* harmony export */   \"default\": function() { return /* binding */ z; },\n/* harmony export */   defaultErrorMap: function() { return /* binding */ errorMap; },\n/* harmony export */   discriminatedUnion: function() { return /* binding */ discriminatedUnionType; },\n/* harmony export */   effect: function() { return /* binding */ effectsType; },\n/* harmony export */   \"enum\": function() { return /* binding */ enumType; },\n/* harmony export */   \"function\": function() { return /* binding */ functionType; },\n/* harmony export */   getErrorMap: function() { return /* binding */ getErrorMap; },\n/* harmony export */   getParsedType: function() { return /* binding */ getParsedType; },\n/* harmony export */   \"instanceof\": function() { return /* binding */ instanceOfType; },\n/* harmony export */   intersection: function() { return /* binding */ intersectionType; },\n/* harmony export */   isAborted: function() { return /* binding */ isAborted; },\n/* harmony export */   isAsync: function() { return /* binding */ isAsync; },\n/* harmony export */   isDirty: function() { return /* binding */ isDirty; },\n/* harmony export */   isValid: function() { return /* binding */ isValid; },\n/* harmony export */   late: function() { return /* binding */ late; },\n/* harmony export */   lazy: function() { return /* binding */ lazyType; },\n/* harmony export */   literal: function() { return /* binding */ literalType; },\n/* harmony export */   makeIssue: function() { return /* binding */ makeIssue; },\n/* harmony export */   map: function() { return /* binding */ mapType; },\n/* harmony export */   nan: function() { return /* binding */ nanType; },\n/* harmony export */   nativeEnum: function() { return /* binding */ nativeEnumType; },\n/* harmony export */   never: function() { return /* binding */ neverType; },\n/* harmony export */   \"null\": function() { return /* binding */ nullType; },\n/* harmony export */   nullable: function() { return /* binding */ nullableType; },\n/* harmony export */   number: function() { return /* binding */ numberType; },\n/* harmony export */   object: function() { return /* binding */ objectType; },\n/* harmony export */   objectUtil: function() { return /* binding */ objectUtil; },\n/* harmony export */   oboolean: function() { return /* binding */ oboolean; },\n/* harmony export */   onumber: function() { return /* binding */ onumber; },\n/* harmony export */   optional: function() { return /* binding */ optionalType; },\n/* harmony export */   ostring: function() { return /* binding */ ostring; },\n/* harmony export */   pipeline: function() { return /* binding */ pipelineType; },\n/* harmony export */   preprocess: function() { return /* binding */ preprocessType; },\n/* harmony export */   promise: function() { return /* binding */ promiseType; },\n/* harmony export */   quotelessJson: function() { return /* binding */ quotelessJson; },\n/* harmony export */   record: function() { return /* binding */ recordType; },\n/* harmony export */   set: function() { return /* binding */ setType; },\n/* harmony export */   setErrorMap: function() { return /* binding */ setErrorMap; },\n/* harmony export */   strictObject: function() { return /* binding */ strictObjectType; },\n/* harmony export */   string: function() { return /* binding */ stringType; },\n/* harmony export */   symbol: function() { return /* binding */ symbolType; },\n/* harmony export */   transformer: function() { return /* binding */ effectsType; },\n/* harmony export */   tuple: function() { return /* binding */ tupleType; },\n/* harmony export */   undefined: function() { return /* binding */ undefinedType; },\n/* harmony export */   union: function() { return /* binding */ unionType; },\n/* harmony export */   unknown: function() { return /* binding */ unknownType; },\n/* harmony export */   util: function() { return /* binding */ util; },\n/* harmony export */   \"void\": function() { return /* binding */ voidType; },\n/* harmony export */   z: function() { return /* binding */ z; }\n/* harmony export */ });\nvar util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * @deprecated Use z.string().min(1) instead.\n     * @see {@link ZodString.min}\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.issues.length) {\n                return {\n                    status: \"dirty\",\n                    value: ctx.data,\n                };\n            }\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        if (isValid(result)) {\n            result.value = Object.freeze(result.value);\n        }\n        return result;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\nconst custom = (check, params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjIyLjQvbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSwwREFBMEQ7QUFDMUQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWUsYUFBYSxlQUFlO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyREFBMkQ7QUFDcEg7QUFDQTtBQUNBLHdEQUF3RCxrQ0FBa0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwrQkFBK0I7QUFDOUY7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0IsY0FBYyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDBCQUEwQjtBQUN4RjtBQUNBLHFDQUFxQyxTQUFTLG9EQUFvRCwwQkFBMEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDRCQUE0QjtBQUM3RjtBQUNBO0FBQ0EsK0RBQStELDBCQUEwQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNFQUFzRSxFQUFFLGVBQWU7QUFDdkk7QUFDQSxpREFBaUQsaUVBQWlFLEVBQUUsZUFBZTtBQUNuSTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRSxjQUFjO0FBQzFEO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFLGdDQUFnQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFFQUFxRSxFQUFFLGVBQWU7QUFDdEk7QUFDQSxpREFBaUQsaUVBQWlFLEVBQUUsZUFBZTtBQUNuSTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSxjQUFjO0FBQ3ZEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFLGNBQWM7QUFDdkQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUUsZ0NBQWdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEIsd0JBQXdCO0FBQ3BELHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQTREO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUNBQW1DO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHO0FBQy9CO0FBQ0EsdUNBQXVDLEdBQUc7QUFDMUM7QUFDQSxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDekUsZ0NBQWdDLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsZUFBZSxHQUFHO0FBQ3ZHO0FBQ0E7QUFDQSw0REFBNEQsR0FBRyxtRkFBbUYsR0FBRztBQUNySjtBQUNBLHNDQUFzQyxzQkFBc0Isc0NBQXNDLHVCQUF1QixPQUFPLEdBQUcsY0FBYztBQUNqSjtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5Qiw0REFBNEQsRUFBRSxTQUFTLElBQUksTUFBTSxFQUFFLGlDQUFpQyxFQUFFLFNBQVMsSUFBSSx5QkFBeUIsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksR0FBRyxFQUFFLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUUsV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksR0FBRyxFQUFFLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxtQ0FBbUMsRUFBRSxTQUFTLElBQUksTUFBTSxFQUFFLGlDQUFpQyxFQUFFLFNBQVMsSUFBSSwwREFBMEQsR0FBRztBQUNybkI7QUFDQSxpREFBaUQsSUFBSSxrQ0FBa0MsS0FBSyw2Q0FBNkMsS0FBSztBQUM5STtBQUNBLGdDQUFnQyxFQUFFLCtCQUErQixFQUFFLDJOQUEyTixFQUFFO0FBQ2hTLCtGQUErRixHQUFHO0FBQ2xHO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQSwyQkFBMkIsc0JBQXNCLEtBQUssZ0JBQWdCO0FBQ3RFO0FBQ0Esc0RBQXNELEVBQUUsU0FBUyxJQUFJLE1BQU0sRUFBRSxpQ0FBaUMsRUFBRSxTQUFTLElBQUk7QUFDN0gsK0JBQStCLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUUsV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksR0FBRyxFQUFFLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUUsV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksbUNBQW1DLEVBQUUsU0FBUyxJQUFJLE1BQU0sRUFBRSxpQ0FBaUMsRUFBRSxTQUFTLElBQUk7QUFDM1k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsVUFBVSxFQUFFLE9BQU8sRUFBRTtBQUN2SDtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZ0JBQWdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQzlGO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxvQkFBb0IsRUFBRSxPQUFPLEVBQUU7QUFDeEc7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2RjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3REFBd0Q7QUFDakYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdEQUF3RDtBQUNqRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQWtEO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVELGlDQUFpQyx1Q0FBdUM7QUFDeEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1QkFBdUIsc0JBQXNCLGNBQWM7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBc0Q7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFzRDtBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLG1DQUFtQyw2Q0FBNkM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQTZDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2Q0FBNkM7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLHFDQUFxQztBQUM1SSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFLCtCQUErQixzQ0FBc0M7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0QseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUNBQXlDLHNCQUFzQjtBQUMvRCxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQyx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTRxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjIuNC9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanM/ZjUzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGRhdGEuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcblxuY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcblxubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cblxuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgZXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgcGFpci5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcbiAgICB9XG59XG5jb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5jb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHJlcXVpcmVkX2Vycm9yICE9PSBudWxsICYmIHJlcXVpcmVkX2Vycm9yICE9PSB2b2lkIDAgPyByZXF1aXJlZF9lcnJvciA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBpbnZhbGlkX3R5cGVfZXJyb3IgIT09IG51bGwgJiYgaW52YWxpZF90eXBlX2Vycm9yICE9PSB2b2lkIDAgPyBpbnZhbGlkX3R5cGVfZXJyb3IgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuY2xhc3MgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eW2Etel1bYS16MC05XSokLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8rLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuY29uc3QgaXB2NFJlZ2V4ID0gL14oKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5jb25zdCBkYXRldGltZVJlZ2V4ID0gKGFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9VFxcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19WiRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICBpZiAoYXJncy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVokYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhcmdzLm9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfShcXFxcLlxcXFxkKyk/KChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oXFxcXC5cXFxcZCspP1okYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkMihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1bGlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgaXAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcbiAgICAgICAgICAgIG9mZnNldDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgICAqIEBzZWUge0BsaW5rIFpvZFN0cmluZy5taW59XG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgICAgICAgY29lcmNlOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBwYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBwYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gTWF0aC5wb3coMTAsIGRlY0NvdW50KTtcbn1cbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImludFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IGlzSW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8XG4gICAgICAgICAgICAoY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKSk7XG4gICAgfVxuICAgIGdldCBpc0Zpbml0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGwsIG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcImludFwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XG4gICAgfVxufVxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBwYWlyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICB9XG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3JVdGlsLmVyclRvT2JqO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFzc3Rocm91Z2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gICAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gICAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgLy8gICApOiBab2RPYmplY3Q8XG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAgIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyAgID4gPT4ge1xuICAgIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgICAgLi4uZGVmLFxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgLy8gICAgICAgfSksXG4gICAgLy8gICAgIH0pIGFzIGFueTtcbiAgICAvLyAgIH07XG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIG1lcmdlKG1lcmdpbmcpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIC8vIG1lcmdlPFxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfSxcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9XG4gICAgLy8gPihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgICAvLyAgIE5ld091dHB1dCxcbiAgICAvLyAgIE5ld0lucHV0XG4gICAgLy8gPiB7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xuICAgIH1cbiAgICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gICAgLy8gWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAgIC8vID4ge1xuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAgIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAvLyAgIC8vICk7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IGluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGljayhtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9taXQobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVkKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlvZigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi52YWx1ZXMuaW5kZXhPZihpbnB1dC5kYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzKTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSk7XG4gICAgfVxufVxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVFbnVtVmFsdWVzLmluZGV4T2YoaW5wdXQuZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJlxuICAgICAgICAgICAgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZVxuICAgICAgICAgICAgPyBjdHguZGF0YVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgICAgICByZXR1cm4gT0socHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBzb3VyY2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xuICAgICAgICAgICAgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKVxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcbiAgICAgICAgICAgIC8vIGVmZmVjdDogUmVmaW5lbWVudEVmZmVjdDxhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBPYmplY3QuZnJlZXplKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IGN1c3RvbSA9IChjaGVjaywgcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkgPT4ge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgbWVzc2FnZTogcGFyYW1zIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IChfYiA9IChfYSA9IHAuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59O1xuY29uc3QgbGF0ZSA9IHtcbiAgICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlLFxufTtcbnZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24gKFpvZEZpcnN0UGFydHlUeXBlS2luZCkge1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN0cmluZ1wiXSA9IFwiWm9kU3RyaW5nXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVtYmVyXCJdID0gXCJab2ROdW1iZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJpZ0ludFwiXSA9IFwiWm9kQmlnSW50XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQm9vbGVhblwiXSA9IFwiWm9kQm9vbGVhblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTeW1ib2xcIl0gPSBcIlpvZFN5bWJvbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuZGVmaW5lZFwiXSA9IFwiWm9kVW5kZWZpbmVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5rbm93blwiXSA9IFwiWm9kVW5rbm93blwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBcnJheVwiXSA9IFwiWm9kQXJyYXlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiXSA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWNvcmRcIl0gPSBcIlpvZFJlY29yZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RGdW5jdGlvblwiXSA9IFwiWm9kRnVuY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVudW1cIl0gPSBcIlpvZEVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9wdGlvbmFsXCJdID0gXCJab2RPcHRpb25hbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RDYXRjaFwiXSA9IFwiWm9kQ2F0Y2hcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQnJhbmRlZFwiXSA9IFwiWm9kQnJhbmRlZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFBpcGVsaW5lXCJdID0gXCJab2RQaXBlbGluZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuY29uc3QgaW5zdGFuY2VPZlR5cGUgPSAoXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbmNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xuY29uc3QgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGU7XG5jb25zdCBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XG5jb25zdCB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlO1xuY29uc3QgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcbmNvbnN0IGFycmF5VHlwZSA9IFpvZEFycmF5LmNyZWF0ZTtcbmNvbnN0IG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XG5jb25zdCB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGU7XG5jb25zdCBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xuY29uc3QgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlO1xuY29uc3QgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG5jb25zdCBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcbmNvbnN0IHNldFR5cGUgPSBab2RTZXQuY3JlYXRlO1xuY29uc3QgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcbmNvbnN0IGxpdGVyYWxUeXBlID0gWm9kTGl0ZXJhbC5jcmVhdGU7XG5jb25zdCBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbmNvbnN0IHByb21pc2VUeXBlID0gWm9kUHJvbWlzZS5jcmVhdGU7XG5jb25zdCBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xuY29uc3Qgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xuY29uc3QgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlO1xuY29uc3QgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xuY29uc3Qgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBjb2VyY2UgPSB7XG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGJvb2xlYW46ICgoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgICAgIC4uLmFyZyxcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgIH0pKSxcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbn07XG5jb25zdCBORVZFUiA9IElOVkFMSUQ7XG5cbnZhciB6ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBkZWZhdWx0RXJyb3JNYXA6IGVycm9yTWFwLFxuICAgIHNldEVycm9yTWFwOiBzZXRFcnJvck1hcCxcbiAgICBnZXRFcnJvck1hcDogZ2V0RXJyb3JNYXAsXG4gICAgbWFrZUlzc3VlOiBtYWtlSXNzdWUsXG4gICAgRU1QVFlfUEFUSDogRU1QVFlfUEFUSCxcbiAgICBhZGRJc3N1ZVRvQ29udGV4dDogYWRkSXNzdWVUb0NvbnRleHQsXG4gICAgUGFyc2VTdGF0dXM6IFBhcnNlU3RhdHVzLFxuICAgIElOVkFMSUQ6IElOVkFMSUQsXG4gICAgRElSVFk6IERJUlRZLFxuICAgIE9LOiBPSyxcbiAgICBpc0Fib3J0ZWQ6IGlzQWJvcnRlZCxcbiAgICBpc0RpcnR5OiBpc0RpcnR5LFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgaXNBc3luYzogaXNBc3luYyxcbiAgICBnZXQgdXRpbCAoKSB7IHJldHVybiB1dGlsOyB9LFxuICAgIGdldCBvYmplY3RVdGlsICgpIHsgcmV0dXJuIG9iamVjdFV0aWw7IH0sXG4gICAgWm9kUGFyc2VkVHlwZTogWm9kUGFyc2VkVHlwZSxcbiAgICBnZXRQYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlLFxuICAgIFpvZFR5cGU6IFpvZFR5cGUsXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBab2ROdW1iZXIsXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBab2REYXRlOiBab2REYXRlLFxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxuICAgIFpvZE51bGw6IFpvZE51bGwsXG4gICAgWm9kQW55OiBab2RBbnksXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcbiAgICBab2ROZXZlcjogWm9kTmV2ZXIsXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcbiAgICBab2RBcnJheTogWm9kQXJyYXksXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBCUkFORDogQlJBTkQsXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXG4gICAgWm9kUmVhZG9ubHk6IFpvZFJlYWRvbmx5LFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/.pnpm/next@13.4.6_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2Fcommon%2FNavbar.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fcomponents%2FClientComponents%2FHuddleContextProvider.tsx&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fnode_modules%2F.pnpm%2Fnext%4013.4.6_biqbaboplfbrettd7655fr4n2y%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Framit%2Fwork%2Fhealphi%2Fhealyphi%2FHealPhi%2Fsrc%2Fapp%2Fglobals.css&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);