import {
  useRoom
} from "./chunk-BA3RUF65.js";
import {
  useHuddle01_default
} from "./chunk-B6M254MV.js";

// src/hooks/useRemoteMedia.ts
import { useEffect, useState } from "react";
var useRemoteMedia = (props) => {
  const { label, peerId } = props;
  const { room } = useRoom();
  const { huddleClient } = useHuddle01_default();
  const localPeer = huddleClient.localPeer;
  const [remotePeer, setRemotePeer] = useState(
    room.remotePeers.get(peerId) || null
  );
  const labelData = remotePeer?.getLabelData(label);
  const [consumers, setConsumers] = useState(remotePeer?.getConsumer(label));
  const [state, setState] = useState(() => {
    if (consumers?.state)
      return consumers.state;
    if (labelData)
      return "available";
    else
      return "unavailable";
  });
  const startConsuming = () => {
    const startedConsuming = localPeer.consume({ label, peerId, appData: {} });
    return startedConsuming;
  };
  const stopConsuming = () => {
    const stoppedConsuming = localPeer.stopConsuming({
      label,
      peerId
    });
    return stoppedConsuming;
  };
  useEffect(() => {
    const handleNewPeerJoined = (data) => {
      if (data.peer.peerId === peerId) {
        setRemotePeer(data.peer);
      }
    };
    const handleStreamAvailable = (data) => {
      if (data.label === label) {
        setState("available");
      }
    };
    const handleStreamPlayable = (data) => {
      if (data.label === label) {
        setState("playable");
        setConsumers(data.consumer);
        if (props.onPlayable) {
          const track2 = data.consumer.track;
          if (track2) {
            props.onPlayable({
              track: track2,
              label,
              stream: new MediaStream([track2])
            });
          }
        }
      }
    };
    const handleStreamClosed = (data) => {
      if (data.label === props.label) {
        setState("unavailable");
        setConsumers(null);
        if (props?.onClose) {
          props?.onClose();
        }
      }
    };
    room.on("new-peer-joined", handleNewPeerJoined);
    remotePeer?.on("stream-available", handleStreamAvailable);
    remotePeer?.on("stream-playable", handleStreamPlayable);
    remotePeer?.on("stream-closed", handleStreamClosed);
    return () => {
      room.off("new-peer-joined", handleNewPeerJoined);
      remotePeer?.off("stream-available", handleStreamAvailable);
      remotePeer?.off("stream-playable", handleStreamPlayable);
      remotePeer?.off("stream-closed", handleStreamClosed);
    };
  }, [remotePeer, consumers, state]);
  const track = consumers?.track || null;
  let stream = null;
  if (track) {
    stream = new MediaStream();
    stream.addTrack(track);
  }
  return { state, track, stream, stopConsuming, startConsuming };
};

export {
  useRemoteMedia
};
//# sourceMappingURL=chunk-LW4AZNF4.js.map