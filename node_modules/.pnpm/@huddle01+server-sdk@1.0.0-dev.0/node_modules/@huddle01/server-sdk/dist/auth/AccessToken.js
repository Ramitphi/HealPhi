"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenVerifier = exports.AccessToken = exports.ROLE_PERMISSIONS = exports.Permissions = exports.Role = exports.isDefaultRole = void 0;
const jose = __importStar(require("jose"));
const zod_1 = require("zod");
const MAX_METADATA_SIZE = 5 * 1024; // 5kb
const IRIKO_URL = 'https://gamma.iriko.huddle01.com';
const estimateSize = (obj) => {
    const str = JSON.stringify(obj);
    return new TextEncoder().encode(str).length;
};
function isDefaultRole(role) {
    return Object.values(exports.Role).includes(role);
}
exports.isDefaultRole = isDefaultRole;
exports.Role = {
    HOST: 'host',
    CO_HOST: 'coHost',
    SPEAKER: 'speaker',
    LISTENER: 'listener',
    GUEST: 'guest',
    BOT: 'bot',
};
exports.Permissions = zod_1.z.object({
    admin: zod_1.z.boolean(),
    canConsume: zod_1.z.boolean(),
    canProduce: zod_1.z.boolean(),
    canProduceSources: zod_1.z.object({
        cam: zod_1.z.boolean(),
        mic: zod_1.z.boolean(),
        screen: zod_1.z.boolean(),
    }),
    canSendData: zod_1.z.boolean(),
    canRecvData: zod_1.z.boolean(),
    canUpdateMetadata: zod_1.z.boolean(),
});
const DEFAULT_PERMISSIONS = {
    admin: false,
    canConsume: true,
    canProduce: true,
    canProduceSources: {
        cam: true,
        mic: true,
        screen: true,
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true,
};
exports.ROLE_PERMISSIONS = {
    [exports.Role.HOST]: {
        ...DEFAULT_PERMISSIONS,
        admin: true,
    },
    [exports.Role.CO_HOST]: {
        ...DEFAULT_PERMISSIONS,
        admin: true,
        /* ... other permissions for the co-host ... */
    },
    [exports.Role.LISTENER]: {
        admin: false,
        canConsume: true,
        canProduce: false,
        canProduceSources: {
            cam: false,
            mic: false,
            screen: false,
        },
        canRecvData: true,
        canSendData: true,
        canUpdateMetadata: true,
    },
    [exports.Role.SPEAKER]: {
        admin: false,
        canConsume: true,
        canProduce: true,
        canProduceSources: {
            cam: false,
            mic: true,
            screen: true,
        },
        canRecvData: true,
        canSendData: true,
        canUpdateMetadata: true,
    },
    [exports.Role.BOT]: {
        admin: false,
        canConsume: true,
        canProduce: false,
        canProduceSources: {
            cam: false,
            mic: false,
            screen: false,
        },
        canRecvData: false,
        canSendData: false,
        canUpdateMetadata: false,
    },
    [exports.Role.GUEST]: {
        ...DEFAULT_PERMISSIONS,
    },
};
/**
 *  Access token for a peer
 */
class AccessToken {
    apiKey;
    roomId;
    role;
    /**
     * Permissions for the token
     */
    permissions;
    /**
     * Time to live for the token or expiration time. can be a number of seconds or a string describing a time span zeit/ms
     * @example  6 * 60 * 60, "2 days", "10h", "7d"`
     * @default 4h
     */
    ttl = '4h';
    /**
     * custom app data for the peer
     */
    metadata;
    constructor(data) {
        if (!data.apiKey) {
            throw Error('api-key and api-secret must be set');
        }
        if (typeof document !== 'undefined') {
            // check against document rather than window because deno provides window
            console.error('You should not include your API secret in your web client bundle.\n\n' +
                'Your web client should request a token from your backend server which should then use ');
        }
        if (this.metadata && estimateSize(this.metadata) > MAX_METADATA_SIZE) {
            throw new Error('Metadata size exceeds the limit of 5kb');
        }
        this.apiKey = data.apiKey;
        this.roomId = data.roomId;
        this.metadata = data.options?.metadata;
        if (data.options?.ttl)
            this.ttl = data.options?.ttl;
        if ('role' in data) {
            if (isDefaultRole(data.role) && !('permissions' in data)) {
                this.role = data.role;
                this.permissions = exports.ROLE_PERMISSIONS[data.role];
            }
            else if (isDefaultRole(data.role) && 'permissions' in data) {
                this.role = data.role;
                this.permissions = {
                    ...exports.ROLE_PERMISSIONS[data.role],
                    ...data.permissions,
                };
            }
            else if (data.role === 'string' && 'permissions' in data) {
                if (data.role.length > 20) {
                    throw new Error(`Custom role exceeds the limit of ${20} characters.`);
                }
                this.role = data.role;
                this.permissions = {
                    ...DEFAULT_PERMISSIONS,
                    ...data.permissions,
                };
            }
            else {
                throw new Error(`Permissions must be provided for custom role: ${data.role}.`);
            }
        }
        else if ('permissions' in data) {
            this.permissions = {
                ...DEFAULT_PERMISSIONS,
                ...data.permissions,
            };
        }
        else {
            throw new Error('Either a role or permissions must be provided.');
        }
    }
    set updatePermissions(permissons) {
        this.permissions = permissons;
    }
    set updateMetaData(data) {
        if (data && estimateSize(data) > MAX_METADATA_SIZE) {
            throw new Error('Metadata size exceeds the limit of 5kb');
        }
        this.metadata = data;
    }
    /**
     * Generate a JWT token
     * @returns JWT token
     * @example
     * ```typescript
     * const accessToken = new AccessToken({...})
     * accessToken.toJwt()
     * ```
     */
    async toJwt() {
        const payload = {
            roomId: this.roomId,
            permissions: this.permissions,
            role: this.role,
            projectId: this.apiKey,
            metadata: JSON.stringify(this.metadata),
        };
        const resp = await fetch(`${IRIKO_URL}/api/v1/create-peer-token`, {
            //TODO: remove harcode
            method: 'POST',
            body: JSON.stringify(payload),
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': this.apiKey,
            },
        });
        const { token } = (await resp.json());
        // NOT removing comments for now for future ref
        // const secret = new TextEncoder().encode(this.apiSecret);
        // const alg = "HS256";
        // const token = new jose.SignJWT({
        //   permissions: this.permissons,
        //   displayName: this.displayName,
        //   appData: this.appData,
        // })
        //   .setProtectedHeader({ alg })
        //   .setIssuedAt()
        //   .setIssuer(this.apiKey)
        //   .setExpirationTime(this.ttl)
        //   .sign(secret);
        return token;
    }
}
exports.AccessToken = AccessToken;
/**
 * Token verifier
 */
// biome-ignore lint/complexity/noUselessTypeConstraint: no sure why this is needed
class TokenVerifier {
    JWKS;
    constructor() {
        this.JWKS = jose.createRemoteJWKSet(new URL('https://api.huddle01.com/jwks.json'));
    }
    /**
     * Verify a JWT token
     * @param token JWT token
     * @returns decoded token
     * @example
     * ```typescript
     * const verifier = new TokenVerifier()
     * verifier.verify(token)
     * ```
     * @throws {jose.errors.JWTExpired} if the token is expired
     * @throws {jose.errors.JWTClaimValidationFailed} if the token is invalid
     */
    async verify(token) {
        const { payload } = await jose.jwtVerify(token, this.JWKS);
        // NOT removing comments for now for future ref
        // const secret = new TextEncoder().encode(this.apiSecret);
        // const alg = "HS256";
        // const { payload } = await jose.jwtVerify(token, secret, {
        //   issuer: this.apiKey,
        //   algorithms: [alg],
        // });
        return payload;
    }
}
exports.TokenVerifier = TokenVerifier;
