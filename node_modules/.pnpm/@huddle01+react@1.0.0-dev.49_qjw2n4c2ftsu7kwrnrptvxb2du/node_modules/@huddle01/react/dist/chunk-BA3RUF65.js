import {
  useHuddle01_default
} from "./chunk-B6M254MV.js";

// src/hooks/useRoom.ts
import { useCallback, useEffect, useState } from "react";
var useRoom = (props) => {
  const { huddleClient } = useHuddle01_default();
  const room = huddleClient.room;
  const socket = huddleClient.socket;
  const joinRoom = huddleClient.joinRoom;
  const leaveRoom = huddleClient.leaveRoom;
  const closeRoom = huddleClient.closeRoom;
  const kickPeer = room.kickPeer;
  const [state, setState] = useState(room.state);
  const handleRoomClose = useCallback(
    (data) => {
      if (props?.onLeave)
        props.onLeave(data);
      if (data.reason === "LEFT")
        setState("left");
      else if (data.reason === "CLOSED")
        setState("closed");
    },
    [props?.onLeave]
  );
  const handleRoomJoin = useCallback(() => {
    if (props?.onJoin)
      props.onJoin({ room: huddleClient.room });
    setState("connected");
  }, [props?.onJoin]);
  const handleRoomJoinFailed = useCallback(
    (data) => {
      if (props?.onFailed)
        props.onFailed(data);
      if (data.status === "ROOM_ERRORED" || data.status === "ROOM_NOT_FOUND") {
        setState("failed");
      }
    },
    []
  );
  const handlePeerJoin = useCallback(
    ({ peer }) => {
      if (props?.onPeerJoin) {
        props.onPeerJoin(peer.peerId);
      }
    },
    [props?.onPeerJoin]
  );
  const handlePeerLeft = useCallback(
    (peerId) => {
      if (props?.onPeerLeft)
        props.onPeerLeft(peerId);
    },
    [props?.onPeerLeft]
  );
  const handleSocketConnecting = useCallback(() => {
    setState("connecting");
  }, []);
  useEffect(() => {
    room.once("room-joined", handleRoomJoin);
    room.once("room-closed", handleRoomClose);
    room.once("room-joined-failed", handleRoomJoinFailed);
    socket.once("connecting", handleSocketConnecting);
    props?.onPeerJoin && room.on("new-peer-joined", handlePeerJoin);
    props?.onPeerLeft && room.on("peer-left", handlePeerLeft);
    props?.onWaiting && room.on("room-waiting", props.onWaiting);
    return () => {
      props?.onPeerJoin && room.off("new-peer-joined", handlePeerJoin);
      props?.onPeerLeft && room.off("peer-left", handlePeerLeft);
      props?.onWaiting && room.off("room-waiting", props.onWaiting);
      room.off("room-joined", handleRoomJoin);
      room.off("room-closed", handleRoomClose);
      room.off("room-joined-failed", handleRoomJoinFailed);
      socket.off("connecting", handleSocketConnecting);
    };
  }, [
    handleRoomJoin,
    handleRoomClose,
    handlePeerJoin,
    handlePeerLeft,
    handleRoomJoinFailed
  ]);
  const closeStreamOfLabel = room.closeStreamOfLabel;
  const muteEveryone = room.muteEveryone;
  return {
    room,
    state,
    joinRoom,
    leaveRoom,
    closeRoom,
    kickPeer,
    muteEveryone,
    closeStreamOfLabel
  };
};

export {
  useRoom
};
//# sourceMappingURL=chunk-BA3RUF65.js.map