{"version":3,"sources":["../src/DeviceHandler.ts"],"sourcesContent":["import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter';\nimport defaultMediaConstraints from './constants/deviceConstraints';\nimport { mainLogger } from './logger';\n\nconst logger = mainLogger.createSubLogger('DeviceHandler');\n\nexport type StreamPermissions = 'granted' | 'denied' | 'prompt';\n\nexport type StreamPermissionsError = {\n  blocked?: {\n    byDeviceMissing?: boolean;\n    byDeviceInUse?: boolean;\n    byPermissions?: boolean;\n  };\n  errorStack?: unknown;\n  message: string;\n};\n\nexport type FetchStreamResponse = Promise<{\n  deviceId: string | null;\n  stream: MediaStream | null;\n  track: MediaStreamTrack | null;\n  error?: StreamPermissionsError;\n}>;\n\nexport type FetchScreenResponse = Promise<\n  Omit<Awaited<FetchStreamResponse>, 'track' | 'deviceId'>\n>;\n\nexport type CustomMediaKind = 'cam' | 'mic' | 'screen';\n\nexport type CustomMediaDevice = 'mic' | 'cam' | 'speaker';\n\nconst CustomMediaKindToSystemKind: Record<CustomMediaDevice, MediaDeviceKind> =\n  {\n    cam: 'videoinput',\n    mic: 'audioinput',\n    speaker: 'videoinput',\n  };\n\nexport type StreamAdded = {\n  stream: MediaStream;\n  track: MediaStreamTrack;\n  mediaKind: CustomMediaKind;\n};\n\nexport type DeviceHandlerEvents = {\n  'device-change': [];\n\n  'permission-granted': [data: { deviceKind: CustomMediaDevice }];\n\n  'permission-denied': [\n    data: { deviceKind: CustomMediaDevice; error: StreamPermissionsError },\n  ];\n\n  'preferred-device-change': [\n    data: { deviceKind: CustomMediaDevice; deviceId: string | null },\n  ];\n};\n\n/**\n * Handle the stream related operations for the Huddle01 SDK\n */\nclass DeviceHandler extends EnhancedEventEmitter<DeviceHandlerEvents> {\n  public readonly SCREEN_DEFAULT_DEVICE: string = 'monitor';\n\n  /**\n   * User Selected Devices, If no device is selected, it will use the default device of the system\n   *\n   * is preffered device is null, it will use the default device of the system\n   *\n   * `NOTE: User has the ability to select a preferred device for each media kind`\n   */\n  private __preferredDevices: Map<CustomMediaDevice, string | null> = new Map([\n    ['cam', null],\n    ['mic', null],\n    ['speaker', null],\n  ]);\n\n  /**\n   * Map the media devices currently present in the system\n   */\n  private __mediaDevicesInfo: Map<CustomMediaDevice, MediaDeviceInfo[] | []> =\n    new Map([\n      ['cam', []],\n      ['mic', []],\n      ['speaker', []],\n    ]);\n\n  /**\n   * Get all the devices which are currently available in the system\n   */\n  get devices() {\n    return this.__mediaDevicesInfo;\n  }\n\n  get preferredDevices() {\n    return this.__preferredDevices;\n  }\n\n  /**\n   * Get all the devices which are currently available in the system, also updates the `__mediaDevicesInfo` record\n   *\n   * Can also query for a specific device kind `audioinput` | `videoinput` | `audiooutput`\n   *\n   * @param deviceKind `cam` | `mic` | `speaker` | `undefined`\n   * @returns - MediaDeviceInfo[] | null\n   *\n   * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`\n   */\n  public getMediaDevices = async (\n    filterByDeviceKind?: CustomMediaDevice,\n  ): Promise<MediaDeviceInfo[]> => {\n    logger.info('üìπ Fetching Media Devices');\n\n    let constraints: MediaStreamConstraints;\n\n    if (filterByDeviceKind === 'speaker') {\n      constraints = defaultMediaConstraints.mic;\n    } else if (filterByDeviceKind) {\n      constraints = defaultMediaConstraints[filterByDeviceKind];\n    } else {\n      constraints = {\n        ...defaultMediaConstraints.mic,\n        ...defaultMediaConstraints.cam,\n      };\n    }\n\n    const stream = await navigator.mediaDevices\n      .getUserMedia(constraints)\n      .catch((err) => {\n        logger.error('fetching stream failed', err);\n      });\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    if (!filterByDeviceKind) {\n      this.__setMediaDeviceInfo({ devices, update: 'all' });\n    }\n\n    if (filterByDeviceKind === 'cam' || filterByDeviceKind === 'mic') {\n      this.__setMediaDeviceInfo({ devices, update: filterByDeviceKind });\n    }\n\n    if (stream) {\n      const tracks = stream.getTracks();\n\n      for (const track of tracks) {\n        track.stop();\n      }\n    }\n\n    const mediaDevices = devices.filter((device) => {\n      if (device.deviceId === '' || device.label === '') {\n        return false;\n      }\n\n      if (filterByDeviceKind) {\n        const systemDeviceKind =\n          CustomMediaKindToSystemKind[filterByDeviceKind];\n\n        return device.kind === systemDeviceKind;\n      }\n\n      return true;\n    });\n\n    return mediaDevices;\n  };\n\n  /**\n   * Get the device from the given facing type of device\n   *\n   * This function is used for only RN\n   *\n   * @param facing - facing of the device { 'environment' | 'front' | 'undefined' }\n   * @param mediaDeviceKind - mediaDeviceKind for the device { 'audioinput' | 'videoinput' }\n   * @returns - deviceId: string | null\n   *\n   * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`\n   */\n  public getDeviceFromFacingMode = (\n    facing: 'environment' | 'front' | undefined,\n    mediaDeviceKind: CustomMediaDevice,\n  ): string | null => {\n    const allDevices = this.__mediaDevicesInfo.get(mediaDeviceKind);\n\n    if (allDevices) {\n      // @ts-ignore\n      const d = allDevices.find((device) => device.facing === facing);\n\n      if (d) {\n        if (mediaDeviceKind === 'cam') {\n          return facing || d.deviceId;\n        }\n\n        return d.deviceId;\n      }\n    }\n\n    return null;\n  };\n\n  public setPreferredDevice = (data: {\n    deviceId: string | null;\n    deviceKind: CustomMediaDevice;\n  }) => {\n    const { deviceId, deviceKind } = data;\n\n    this.__preferredDevices.set(deviceKind, deviceId);\n\n    this.emit('preferred-device-change', {\n      deviceId,\n      deviceKind,\n    });\n  };\n\n  /**\n   * Fetches a stream of the screen of the device i.e the screen sharing stream\n   * based on the selected choice from the pop up returns the audio and video stream\n   * in one stream.\n   *\n   * `NOTE: This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK`\n   * @returns\n   */\n  fetchScreen = async (): Promise<FetchScreenResponse> => {\n    const constraints = defaultMediaConstraints.screen;\n    try {\n      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);\n\n      return { stream };\n    } catch (err) {\n      logger.error(err);\n\n      let error: StreamPermissionsError = {\n        message: 'Unknown Error',\n        errorStack: err,\n      };\n\n      if (err instanceof DOMException) {\n        error = {\n          blocked: {\n            byDeviceMissing: err.name === 'NotFoundError',\n            byDeviceInUse: err.name === 'OverconstrainedError',\n            byPermissions: err.name === 'NotAllowedError',\n          },\n          message: err.message,\n        };\n      }\n\n      return {\n        stream: null,\n        error,\n      };\n    }\n  };\n\n  /**\n   * Fetch the stream from the device for the given media kind, if no preferred device is found it will throw an error.\n   * by default the preferred device is the system default device\n   *\n   * `NOTE: If Preffered device is not found, it will use the system default device, if no default device is found it will throw an error`\n   * `Set the preferred device using setPreferredDevice()`\n   *\n   */\n  fetchStream = async (data: {\n    mediaDeviceKind: Exclude<CustomMediaDevice, 'speaker'>;\n  }): Promise<FetchStreamResponse> => {\n    const preferredDeviceId = this.__preferredDevices.get(data.mediaDeviceKind);\n\n    logger.info('üìπ Fetching Stream', {\n      mediaDeviceKind: data.mediaDeviceKind,\n      preferredDeviceId,\n    });\n\n    navigator.mediaDevices.ondevicechange = async () => {\n      const newMediaDevices = await this.getMediaDevices();\n\n      // set preffered device to null if the device is not found\n      for (const [deviceKind, deviceId] of this.__preferredDevices) {\n        const device = newMediaDevices.find((d) => d.deviceId === deviceId);\n        if (!device) {\n          this.setPreferredDevice({ deviceId: null, deviceKind });\n        }\n      }\n\n      this.emit('device-change');\n    };\n\n    try {\n      let fetchStreamFunc:\n        | typeof this.__fetchStreamFromDeviceForRN\n        | typeof this.__fetchStreamFromDeviceForWeb;\n\n      if (\n        typeof navigator === 'object' &&\n        navigator.product === 'ReactNative'\n      ) {\n        fetchStreamFunc = this.__fetchStreamFromDeviceForRN;\n      } else {\n        fetchStreamFunc = this.__fetchStreamFromDeviceForWeb;\n      }\n\n      const { stream, deviceId } = await fetchStreamFunc({\n        deviceId: preferredDeviceId ?? undefined,\n        mediaKind: data.mediaDeviceKind === 'mic' ? 'mic' : 'cam',\n      });\n\n      const track =\n        data.mediaDeviceKind === 'mic'\n          ? stream.getAudioTracks()[0]\n          : stream.getVideoTracks()[0];\n\n      if (!this.__preferredDevices.get(data.mediaDeviceKind)) {\n        this.setPreferredDevice({ deviceId, deviceKind: data.mediaDeviceKind });\n      }\n\n      return {\n        stream,\n        track,\n        deviceId,\n      };\n    } catch (err) {\n      logger.error(err);\n\n      let error: StreamPermissionsError = {\n        message: 'Unknown Error',\n        errorStack: err,\n      };\n\n      if (err instanceof DOMException) {\n        error = {\n          blocked: {\n            byDeviceMissing: err.name === 'NotFoundError',\n            byDeviceInUse: err.name === 'OverconstrainedError',\n            byPermissions: err.name === 'NotAllowedError',\n          },\n          message: err.message,\n        };\n      }\n\n      return {\n        stream: null,\n        track: null,\n        deviceId: null,\n        error,\n      };\n    }\n  };\n\n  public fetchStreamByGroupId = async (data: {\n    groupId: string;\n    mediaDeviceKind: Exclude<CustomMediaDevice, 'speaker'>;\n  }): Promise<MediaStream> => {\n    let constraints: MediaStreamConstraints;\n\n    if (data.mediaDeviceKind === 'mic') {\n      constraints = { audio: { groupId: data.groupId } };\n    } else {\n      constraints = { video: { groupId: data.groupId } };\n    }\n\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n    return stream;\n  };\n\n  /**\n   * Fetch the stream from the device for the React Native Based Application\n   *\n   * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK\n   * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`\n   *\n   * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped\n   *\n   * @param data - { deviceId: \"front\" | \"back\" | \"audio\" | string; kind: \"audioinput\" | \"videoinput\" }\n   * @returns - { stream: MediaStream, deviceId: string }\n   */\n  private __fetchStreamFromDeviceForRN = async (data: {\n    deviceId?: Exclude<VideoFacingModeEnum, 'left' | 'right'> | string;\n    mediaKind: CustomMediaKind;\n  }): Promise<{\n    stream: MediaStream;\n    deviceId: string;\n  }> => {\n    const constraints: MediaStreamConstraints =\n      defaultMediaConstraints[data.mediaKind];\n    let facingMode: 'environment' | 'front' | undefined;\n\n    if (data.mediaKind === 'cam') {\n      facingMode = data.deviceId === 'environment' ? 'environment' : 'front';\n\n      constraints.video = Object.assign({}, constraints.video, {\n        facingMode,\n      });\n    }\n\n    if (data.mediaKind === 'mic') {\n      constraints.audio = Object.assign({}, constraints.audio, {\n        deviceId: data.deviceId,\n      });\n    }\n\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n    const streamDeviceId = this.getDeviceFromFacingMode(\n      facingMode,\n      data.mediaKind === 'mic' ? 'mic' : 'cam',\n    );\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    if (data.mediaKind === 'cam' || data.mediaKind === 'mic') {\n      this.emit('permission-granted', { deviceKind: data.mediaKind });\n      this.__setMediaDeviceInfo({ devices, update: data.mediaKind });\n    }\n\n    if (!streamDeviceId) {\n      const tracks = stream.getTracks();\n      for (const track of tracks) {\n        track.stop();\n      }\n\n      throw new Error(\n        '‚ùå No DeviceId found for this stream, this is a bug in the SDK, please report it to the developers',\n      );\n    }\n\n    return {\n      stream,\n      deviceId: streamDeviceId,\n    };\n  };\n\n  /**\n   * Fetch the stream from the device for the web\n   *\n   * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK\n   * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`\n   *\n   * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped\n   *\n   * @param data - { deviceId: string; kind: 'audio' | 'video' }\n   * @returns - { stream: MediaStream, deviceId: string }\n   */\n  private __fetchStreamFromDeviceForWeb = async (data: {\n    deviceId?: string;\n    mediaKind: CustomMediaKind;\n  }): Promise<{ stream: MediaStream; deviceId: string }> => {\n    const constraints: MediaStreamConstraints = Object.assign(\n      {},\n      defaultMediaConstraints[data.mediaKind],\n    );\n\n    if (data.mediaKind === 'cam' && data.deviceId) {\n      constraints.video = Object.assign({}, constraints.video, {\n        deviceId: data.deviceId,\n      });\n    }\n\n    if (data.mediaKind === 'mic' && data.deviceId) {\n      constraints.audio = Object.assign({}, constraints.audio, {\n        deviceId: {\n          exact: data.deviceId,\n        },\n      });\n    }\n\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n    const streamDeviceId = stream.getTracks()[0].getSettings().deviceId;\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    if (data.mediaKind === 'cam' || data.mediaKind === 'mic') {\n      this.emit('permission-granted', { deviceKind: data.mediaKind });\n\n      this.__setMediaDeviceInfo({ devices, update: data.mediaKind });\n    }\n    //  for deviceId as default, `this is a issue with chrome it send back default as deviceId and not the Id itself`\n    // where default devices are stored and returned as deviceId: \"default\"\n\n    if (!streamDeviceId) {\n      const tracks = stream.getTracks();\n      for (const track of tracks) {\n        track.stop();\n      }\n\n      throw new Error(\n        '‚ùå No DeviceId found for this stream, this is a bug in the browser, please report it to the developers',\n      );\n    }\n\n    return {\n      stream,\n      deviceId: streamDeviceId,\n    };\n  };\n\n  /**\n   * @description Get the media permission for the given type\n   * @param data  { type: 'video' | 'audio' }\n   * @throws error { StreamPermissionsError }\n   * @example await getMediaPermission({ type: 'video' })\n   */\n  public getMediaPermission = async (data: {\n    mediaDeviceKind: CustomMediaDevice;\n  }): Promise<{\n    permission: 'granted' | 'denied';\n    error?: StreamPermissionsError;\n  }> => {\n    const { mediaDeviceKind } = data;\n\n    try {\n      await this.getMediaDevices(mediaDeviceKind);\n\n      this.emit('permission-granted', { deviceKind: mediaDeviceKind });\n\n      return {\n        permission: 'granted',\n      };\n    } catch (err) {\n      let error: StreamPermissionsError = {\n        message: 'Unknown Error',\n        errorStack: err,\n      };\n\n      if (err instanceof DOMException) {\n        error = {\n          blocked: {\n            byDeviceMissing: err.name === 'NotFoundError',\n            byDeviceInUse: err.name === 'OverconstrainedError',\n            byPermissions: err.name === 'NotAllowedError',\n          },\n          message: err.message,\n        };\n      }\n\n      this.emit('permission-denied', { deviceKind: mediaDeviceKind, error });\n\n      return {\n        permission: 'denied',\n        error,\n      };\n    }\n  };\n\n  public stopStream = (stream?: MediaStream) => {\n    if (!stream) return;\n    for (const track of stream.getTracks()) {\n      track.stop();\n    }\n  };\n\n  public destroy = (): void => {\n    this.__preferredDevices.clear();\n\n    this.__mediaDevicesInfo.clear();\n\n    logger.info('‚úÖ Destroyed StreamHandler');\n  };\n\n  /**\n   * Set the Media devices info based on the latest devices available in the system\n   */\n  private __setMediaDeviceInfo = (data: {\n    devices: MediaDeviceInfo[];\n    update: 'cam' | 'mic' | 'all';\n  }): void => {\n    const { devices, update } = data;\n\n    const camDevices: MediaDeviceInfo[] = [];\n    const micDevices: MediaDeviceInfo[] = [];\n    const speakerDevices: MediaDeviceInfo[] = [];\n\n    for (const device of devices) {\n      if (device.label === '' || device.deviceId === '') return; // skip empty devices\n\n      if (device.kind === 'videoinput') camDevices.push(device);\n      if (device.kind === 'audioinput') micDevices.push(device);\n      if (device.kind === 'audiooutput') speakerDevices.push(device);\n    }\n\n    if (update === 'all') {\n      this.__mediaDevicesInfo.set('cam', camDevices);\n      this.__mediaDevicesInfo.set('mic', micDevices);\n      this.__mediaDevicesInfo.set('speaker', speakerDevices);\n    }\n\n    if (update === 'cam') this.__mediaDevicesInfo.set('cam', camDevices);\n\n    if (update === 'mic') {\n      this.__mediaDevicesInfo.set('mic', micDevices);\n      this.__mediaDevicesInfo.set('speaker', speakerDevices);\n    }\n  };\n}\n\nexport default DeviceHandler;\n"],"mappings":"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","names":[]}