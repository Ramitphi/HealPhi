import { ClientToSushiEvents } from 'types/dist/clientToSushiEvents.types';
import { SushiToClientEvents } from 'types/dist/sushiToClientEvents.types';
import { ESocketCloseCode } from 'types/dist/socket.types';
import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter.js';
import { ConnectionState } from './types/common.types.js';
import './RemotePeer.js';
import './Consumer.js';
import 'mediasoup-client/lib/types';
import 'mediasoup-client/lib/RtpParameters';

type SocketEvents = {
    uninitialized: [];
    connecting: [];
    connected: [];
    failed: [];
    closed: [code: ESocketCloseCode];
    reconnecting: [];
    reconnected: [];
    'region-updated': [region: string];
    'token-updated': [token: string | null];
};
type MessagePayload<T = SushiToClientEvents> = {
    event: keyof T;
    data: Parameters<SushiToClientEvents[keyof SushiToClientEvents]>[0];
};
/**
 * Handles the underluying socket connection with the socket server
 */
declare class Socket<T = SushiToClientEvents> extends EnhancedEventEmitter<SocketEvents> {
    /**
     * Socket Instance, Singleton class
     */
    private static __instance;
    /**
     * Retry count for the socket connection, if the connection is closed abnormally, we try to reconnect 5 times
     */
    private __retryCount;
    /**
     * Current connection state of the socket connection
     */
    private __connectionState;
    /**
     * Underlying WebSocket connection, until we dont call Socket.connect(); this will be null
     */
    private __ws;
    /**
     * Map of all the subscribed events/topics for the socket connection
     */
    private __subscribedMap;
    /**
     * Region of the current socket connection, specific to the Local Peer who joined the meeting
     */
    private __region;
    /**
     * Endpoint of the socket server, this is fetched from the API server
     */
    private __ENDPOINT;
    /**
     * Flag to enable local development
     */
    private isLocalDev;
    /**
     * Token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    token: string | null;
    /**
     * Returns the underlying WebSocket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    get ws(): WebSocket;
    /**
     * Getter for the region of the current socket connection
     */
    get region(): string | null;
    /**
     * Returns the current connection state of the socket connection
     */
    get connectionState(): ConnectionState;
    /**
     * Returns true if the socket connection is connected
     */
    get connected(): boolean;
    /**
     * Returns true if the socket connection is connecting
     */
    get connecting(): boolean;
    /**
     * Returns true if the socket connection is closed
     */
    get closed(): boolean;
    /**
     * Sets the current connection state of the socket connection
     */
    set connectionState(state: ConnectionState);
    /**
     * Update the token for this socket
     * @throws `Error` if the token is already set
     */
    setToken(token: string): void;
    /**
     * Set a new region for the socket connection
     */
    setRegion(region: string): void;
    /**
     * Creates the socket and returns the instance of the socket if already initialized
     * you need to call connect method to connect to the server
     * @param data
     * @returns
     */
    static create(): Socket<SushiToClientEvents>;
    /**
     * Returns the instance of the socket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    static getInstance(): Socket<SushiToClientEvents>;
    private constructor();
    /**
     *
     */
    private __getRegion;
    enableLocalDev: () => void;
    /**
     * Connect to the socket server using the token
     * @param data - `{ token: string }`
     */
    connect: (data: {
        token: string;
    }) => Promise<Socket<SushiToClientEvents>>;
    /**
     * Closes the underlying socket connection, and clears all the event listeners and subscriptions to events as well as
     * any other information related to the connection.
     * @param code `{ ESocketCloseCode }`
     */
    close: (code: ESocketCloseCode) => void;
    /**
     * Publish a message to the server using the socket connection based on some events/topics
     */
    publish: <P extends keyof ClientToSushiEvents>(event: P, data: Parameters<ClientToSushiEvents[P]>[0]) => void;
    /**
     * Subscribe to a specific event/topic from the server
     */
    subscribe: <K extends keyof T, P extends T[K]>(event: K, fn: P) => void;
    /**
     * Get the config url for the socket connection based on the token and region
     * @param token Local Peer specific meeting token
     * @param region Local Peer specific region
     * @returns
     */
    private __getConfigUrl;
    /**
     * !Important
     * Handle the incoming message from the server based on the events received from the server and call the subscribed event handler
     */
    private __handleIncomingMessage;
    private __handleSocketError;
    /**
     * @description Handle the socket close event which is sent by the server
     * @param ev CloseEvent
     */
    private __handleSocketClose;
    /**
     * @description Handle the socket open event which is sent after the connection is established with the server
     * @param ev Event
     */
    private __handleSocketOpen;
    /**
     * @description Register the socket events
     * @param ws WebSocket
     */
    private __registerSocketEvents;
    /**
     * @description Unregister the socket events
     * @param ws WebSocket
     */
    private __unregisterSocketEvents;
}

export { MessagePayload, SocketEvents, Socket as default };
