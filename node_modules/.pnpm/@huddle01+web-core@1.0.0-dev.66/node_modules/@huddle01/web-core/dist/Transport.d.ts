import * as mediasoup from 'mediasoup-client';
import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter.js';
import { TSDPInfo } from 'types/dist/common.types';
import { TTransportType } from 'types/dist';
import { Producer, AppData } from 'mediasoup-client/lib/types';
import Socket from './Socket.js';
import Consumer from './Consumer.js';
import { TConsumeResponseData, TConsumeDataResponseData } from 'types/dist/mq/response.types';
import { EnhancedMap } from './common-js/EnhancedMap.js';
import 'types/dist/clientToSushiEvents.types';
import 'types/dist/sushiToClientEvents.types';
import 'types/dist/socket.types';
import './types/common.types.js';
import './RemotePeer.js';
import 'mediasoup-client/lib/RtpParameters';

type TransportEvents = {
    connectTransportResponse: [];
};
declare class Transport extends EnhancedEventEmitter<TransportEvents> {
    /**
     * Peer Id, which handles the peer id.
     */
    readonly peerId: string;
    /**
     *  MediaSoup Device Instance, which handles the browsers or mobile device init.
     */
    private __device;
    /**
     * MediaSoup Transport Instance, which handles the media transport.
     */
    private __mediasoupTransport;
    /**
     * Socket Instance, which handles the socket connection.
     */
    private readonly __socket;
    /**
     * Map of Producers, which handles the producers. ( Sending out Media Streams )
     *
     * `Mapped with {producerId => Producer}`
     */
    private readonly __producers;
    /**
     * Map of DataProducers, which handles the dataProducers. ( Sending out Data )
     *
     * `Mapped with {label => DataProducer}`
     */
    private readonly __dataProducers;
    /**
     * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:label => DataConsumer}`
     */
    private readonly __dataConsumers;
    /**
     * Map of Consumers, which handles the consumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:RemotePeerId => Consumer}`
     */
    private readonly __consumers;
    /**
     * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.
     *
     * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.
     */
    readonly labelToProducerId: Map<string, string>;
    /**
     * Transport Type, which handles the transport type. ( `send | recv` )
     */
    readonly transportType: TTransportType;
    /**
     * Pending Producer Tasks, which handles the pending producer tasks.
     * callback function is necessary to be called when the producer is created
     * on the server as well as on the client side.
     */
    private __pendingProducerTasks;
    /**
     * Debounce to handle concurrent request to restart Ice. Waits for some time before sending
     * more requests to restart ice.
     */
    private __iceRestartDebounce;
    get device(): mediasoup.types.Device;
    get mediasoupTransport(): mediasoup.types.Transport<mediasoup.types.AppData>;
    get connectionState(): mediasoup.types.ConnectionState;
    get producers(): Map<string, mediasoup.types.Producer<mediasoup.types.AppData>>;
    get dataProducers(): Map<string, mediasoup.types.DataProducer<mediasoup.types.AppData>>;
    get dataConsumers(): Map<string, mediasoup.types.DataConsumer<mediasoup.types.AppData>>;
    get consumers(): EnhancedMap<Consumer>;
    getProducerById(producerId: string): Producer;
    removeProducerById(producerId: string): boolean;
    /**
     * Get the consumer by label and peerId
     * @param data
     * @returns Consumer | null; Returns null if consumer is not found
     */
    getConsumer: (data: {
        label: string;
        peerId: string;
    }) => Consumer | null;
    get transport(): mediasoup.types.Transport;
    addPendingProducerTask: (data: {
        label: string;
        peerId: string;
        callback: ({ id, }: {
            id: string;
        }) => void;
    }) => void;
    resolvePendingProducerTask: (data: {
        label: string;
        peerId: string;
        id: string;
    }) => void;
    static create: (data: {
        peerId: string;
        sdpInfo: TSDPInfo;
        device: mediasoup.Device;
        iceServers: RTCIceServer[];
        transportType: TTransportType;
        socket: Socket;
    }) => Transport;
    private constructor();
    private __listenTransportConnect;
    private __listenTransportProduce;
    private __listenTransportDataProduce;
    produce: (data: {
        stream: MediaStream;
        label: string;
        stopTrackOnClose: boolean;
        appData?: AppData;
    }) => Promise<mediasoup.types.Producer<{
        producerPeerId: string;
    }>>;
    produceData: (data: {
        label: string;
        appData?: AppData;
    }) => Promise<mediasoup.types.DataProducer<{
        producerPeerId: string;
        label: string;
        ordered: boolean;
    }>>;
    consume: (data: TConsumeResponseData) => Promise<{
        consumer: Consumer;
        mediaSoupConsumer: mediasoup.types.Consumer<mediasoup.types.AppData>;
    }>;
    consumeData: (data: TConsumeDataResponseData) => Promise<mediasoup.types.DataConsumer<mediasoup.types.AppData>>;
    closeConsumer: (data: {
        label: string;
        peerId: string;
    }) => void;
    close: (data: {
        retries: number;
    }) => Promise<void>;
    private __connectionStateChangeHandler;
}

export { TransportEvents, Transport as default };
