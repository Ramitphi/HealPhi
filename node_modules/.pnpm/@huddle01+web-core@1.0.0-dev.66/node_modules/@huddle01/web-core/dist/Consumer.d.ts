import * as mediasoup_client_lib_types from 'mediasoup-client/lib/types';
import { Consumer as Consumer$1 } from 'mediasoup-client/lib/types';
import * as mediasoup_client_lib_RtpParameters from 'mediasoup-client/lib/RtpParameters';
import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter.js';

type ConsumerEvents = {
    closed: [];
};
/**
 * Consumer class, this class is responsible for consuming the media produced by the remote peers.
 *
 * Just likes Producer is responsible of producing a media stream in a room, similarly Consumer is responsible for consuming the media stream in a room.
 *
 * A Peer creates a Producer which takes the stream and produces that stream to all the Joined Remote Peer.
 * Remote Peers then make Consumers for that Producer to be able to consume the media stream.
 */
declare class Consumer extends EnhancedEventEmitter<ConsumerEvents> {
    #private;
    /**
     * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.
     */
    readonly producerId: string;
    /**
     * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.
     */
    readonly producerPeerId: string;
    /**
     * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.
     */
    readonly label: string;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     */
    private __consuming;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consuming(): boolean;
    /**
     * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.
     */
    get id(): string | undefined;
    /**
     *
     * @param consumer Sets the mediasoupConsumer for the Consumer
     */
    setMediaSoupConsumer(consumer: Consumer$1): void;
    /**
     * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consumerId(): string | undefined;
    /**
     * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get track(): MediaStreamTrack | undefined;
    /**
     * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get kind(): mediasoup_client_lib_RtpParameters.MediaKind | undefined;
    /**
     * If the Consumer is paused, it is only available when the Consumer is consuming a media.
     *
     * if paused the user is not consuming any media for the given producerId.
     */
    get paused(): boolean | undefined;
    /**
     * AppData of the Consumer, it is only available when the Consumer is consuming a media.
     */
    get appData(): mediasoup_client_lib_types.AppData | undefined;
    /**
     * State of a Consumer is defined by the following:
     * - `playable` - The Consumer is ready to play the media.
     * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.
     * - `paused` - The Consumer is paused and is not playing the media.
     * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: "video", appData: {} });` after which the state will change to `playable`.
     */
    get state(): 'playable' | 'unavailable' | 'paused' | 'available';
    /**
     * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.
     * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.
     * @returns - RTCStatsReport | null
     */
    getStats: () => Promise<RTCStatsReport | undefined>;
    /**
     * Resume the consumer, if the state of the consumer is `paused`.
     */
    resume: () => void;
    /**
     * Removes all the eventListeners attached to the Consumer.
     */
    removeListeners: () => void;
    /**
     * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.
     */
    static create: (data: {
        producerPeerId: string;
        producerId: string;
        label: string;
    }) => Consumer;
    close: () => void;
    private constructor();
}

export { ConsumerEvents, Consumer as default };
