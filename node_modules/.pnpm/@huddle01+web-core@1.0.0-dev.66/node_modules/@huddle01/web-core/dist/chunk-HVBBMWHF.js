import {
  GeolocationSchema
} from "./chunk-SSCVNXAL.js";
import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  EnhancedEventEmitter
} from "./chunk-7OTQAFXE.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UXIASGQL.js";

// ../types/dist/socket.types.js
var require_socket_types = __commonJS({
  "../types/dist/socket.types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketCloseReason = exports.ESocketCloseCode = void 0;
    var ESocketCloseCode2;
    (function(ESocketCloseCode3) {
      ESocketCloseCode3[ESocketCloseCode3["ABNORMAL_CLOSURE"] = 1006] = "ABNORMAL_CLOSURE";
      ESocketCloseCode3[ESocketCloseCode3["NORMAL_CLOSURE"] = 1e3] = "NORMAL_CLOSURE";
      ESocketCloseCode3[ESocketCloseCode3["BROWSER_TAB_CLOSE"] = 1001] = "BROWSER_TAB_CLOSE";
      ESocketCloseCode3[ESocketCloseCode3["GOING_AWAY"] = 4001] = "GOING_AWAY";
      ESocketCloseCode3[ESocketCloseCode3["CONNECTION_EXPIRED"] = 4002] = "CONNECTION_EXPIRED";
      ESocketCloseCode3[ESocketCloseCode3["CONNECTION_ERROR"] = 4006] = "CONNECTION_ERROR";
      ESocketCloseCode3[ESocketCloseCode3["ROOM_CLOSED"] = 4007] = "ROOM_CLOSED";
      ESocketCloseCode3[ESocketCloseCode3["ROOM_ENTRY_DENIED"] = 4008] = "ROOM_ENTRY_DENIED";
      ESocketCloseCode3[ESocketCloseCode3["KICKED"] = 4009] = "KICKED";
    })(ESocketCloseCode2 || (exports.ESocketCloseCode = ESocketCloseCode2 = {}));
    exports.SocketCloseReason = {
      [ESocketCloseCode2.ROOM_CLOSED]: "ROOM_CLOSED",
      [ESocketCloseCode2.ABNORMAL_CLOSURE]: "ABNORMAL_CLOSURE",
      [ESocketCloseCode2.NORMAL_CLOSURE]: "NORMAL_CLOSURE",
      [ESocketCloseCode2.BROWSER_TAB_CLOSE]: "BROWSER_TAB_CLOSE",
      [ESocketCloseCode2.GOING_AWAY]: "GOING_AWAY",
      [ESocketCloseCode2.CONNECTION_ERROR]: "CONNECTION_ERROR",
      [ESocketCloseCode2.CONNECTION_EXPIRED]: "CONNECTION_EXPIRED",
      [ESocketCloseCode2.ROOM_ENTRY_DENIED]: "ROOM_ENTRY_DENIED",
      [ESocketCloseCode2.KICKED]: "KICKED"
    };
  }
});

// src/Socket.ts
var import_socket = __toESM(require_socket_types(), 1);
var logger = mainLogger.createSubLogger("Socket.ts");
var Socket = class _Socket extends EnhancedEventEmitter {
  /**
   * Socket Instance, Singleton class
   */
  static __instance = null;
  /**
   * Retry count for the socket connection, if the connection is closed abnormally, we try to reconnect 5 times
   */
  __retryCount = 0;
  /**
   * Current connection state of the socket connection
   */
  __connectionState = "uninitialized";
  /**
   * Underlying WebSocket connection, until we dont call Socket.connect(); this will be null
   */
  __ws = null;
  /**
   * Map of all the subscribed events/topics for the socket connection
   */
  __subscribedMap = /* @__PURE__ */ new Map();
  /**
   * Region of the current socket connection, specific to the Local Peer who joined the meeting
   */
  __region = null;
  /**
   * Endpoint of the socket server, this is fetched from the API server
   */
  __ENDPOINT = null;
  /**
   * Flag to enable local development
   */
  isLocalDev = false;
  /**
   * Token of the current socket connection, specific to the Local Peer who joined the meeting
   */
  token = null;
  /**
   * Returns the underlying WebSocket connection, throws an error if the connection is not initialized
   * @throws `Error` if the connection is not initialized
   */
  get ws() {
    if (!this.__ws) {
      throw new Error("\u{1F534} Socket Not Initialised");
    }
    return this.__ws;
  }
  /**
   * Getter for the region of the current socket connection
   */
  get region() {
    return this.__region;
  }
  /**
   * Returns the current connection state of the socket connection
   */
  get connectionState() {
    return this.__connectionState;
  }
  /**
   * Returns true if the socket connection is connected
   */
  get connected() {
    return this.ws.OPEN === 1 && this.connectionState === "connected";
  }
  /**
   * Returns true if the socket connection is connecting
   */
  get connecting() {
    return this.ws.CONNECTING === 0 && this.connectionState === "connecting";
  }
  /**
   * Returns true if the socket connection is closed
   */
  get closed() {
    return this.ws.CLOSED === 3 || this.ws.CLOSING === 2;
  }
  /**
   * Sets the current connection state of the socket connection
   */
  set connectionState(state) {
    logger.info(`Connection state changed to ${state}`);
    this.__connectionState = state;
  }
  /**
   * Update the token for this socket
   * @throws `Error` if the token is already set
   */
  setToken(token) {
    if (this.token) {
      throw new Error("\u{1F534} Token Already Set");
    }
    this.token = token;
    this.emit("token-updated", token);
  }
  /**
   * Set a new region for the socket connection
   */
  setRegion(region) {
    this.__region = region;
    this.emit("region-updated", region);
  }
  /**
   * Creates the socket and returns the instance of the socket if already initialized
   * you need to call connect method to connect to the server
   * @param data
   * @returns
   */
  static create() {
    if (!this.__instance) {
      this.__instance = new _Socket();
    }
    return this.__instance;
  }
  /**
   * Returns the instance of the socket connection, throws an error if the connection is not initialized
   * @throws `Error` if the connection is not initialized
   */
  static getInstance() {
    if (!_Socket.__instance) {
      throw new Error(
        "\u{1F534} Socket Instance Not Initialised, You are trying to do something which is not possible"
      );
    }
    return _Socket.__instance;
  }
  constructor() {
    super();
  }
  /**
   *
   */
  __getRegion = async () => {
    const resp = await fetch(
      "https://shinigami.huddle01.com/api/get-geolocation"
    );
    const data = await resp?.json();
    const geolocationdata = GeolocationSchema.safeParse(data);
    if (!geolocationdata.success) {
      throw new Error("\u{1F534} Error While Finding the Region to connect to");
    }
    const region = geolocationdata.data.globalRegion;
    return region;
  };
  enableLocalDev = () => {
    this.isLocalDev = true;
  };
  /**
   * Connect to the socket server using the token
   * @param data - `{ token: string }`
   */
  connect = async (data) => {
    if (!_Socket.__instance) {
      throw new Error("\u{1F534} Socket Instance Not Initialised");
    }
    if (!this.token) {
      this.setToken(data.token);
    }
    if (this.connectionState === "connected") {
      logger.error("\u{1F534} Socket Already Connected");
      return _Socket.__instance;
    }
    if (this.connectionState === "connecting") {
      logger.error("\u{1F534} Socket Connecting");
      return _Socket.__instance;
    }
    if (this.__ws) {
      logger.error("\u{1F534} Socket Already Initialized");
      return _Socket.__instance;
    }
    logger.info("\u{1F50C} Connecting to the socket server");
    if (this.connectionState === "awaiting-reconnection") {
      logger.info(
        "\u{1F50C} Socket connection was awaiting reconnection , creating a new socket connection"
      );
      this.emit("reconnecting");
    }
    if (!this.__region) {
      const region = await this.__getRegion();
      this.__region = region;
    }
    const url = await this.__getConfigUrl(data.token, this.__region);
    this.__ws = new WebSocket(url);
    this.__ws.onerror = (ev) => {
      logger.error(ev);
    };
    this.connectionState = "connecting";
    this.emit("connecting");
    this.__ws.addEventListener("message", this.__handleIncomingMessage);
    this.__registerSocketEvents(this.ws);
    this.__ws.onclose = async (ev) => {
      logger.info("\u{1F514} Socket connection closed", ev);
      if (ev.code === import_socket.ESocketCloseCode.ABNORMAL_CLOSURE) {
        logger.info(
          "\u{1F514} Socket connection closed abnormally, Trying to Reconnect"
        );
        if (this.__retryCount < 7) {
          const delay = 2 ** this.__retryCount * 1e3;
          setTimeout(async () => {
            if (this.token) {
              try {
                await this.connect({ token: this.token });
                this.emit("reconnected");
                this.__retryCount = 0;
              } catch (err) {
                logger.error(
                  `Reconnection Attempt ${this.__retryCount} failed`
                );
              }
            }
          }, Math.min(delay, 2e4));
          this.__retryCount++;
        } else {
          logger.error(
            "\u{1F534} Socket connection closed abnormally, reconnecting failed"
          );
          this.close(import_socket.ESocketCloseCode.CONNECTION_EXPIRED);
        }
      }
    };
    const socketConnectionPromise = new Promise((resolve, reject) => {
      const handleSuccess = () => {
        logger.info("\u2705 Socket Connection Established");
        handleRemoveListeners();
        resolve();
      };
      const handleError = () => {
        logger.error("\u{1F534} Error While Connecting to the Socket");
        handleRemoveListeners();
        reject(new Error("\u274C Socket Connection Failed"));
      };
      const handleRemoveListeners = () => {
        this.off("connected", handleSuccess);
        this.off("failed", handleError);
      };
      this.once("connected", handleSuccess);
      this.once("failed", handleError);
    });
    await socketConnectionPromise;
    return _Socket.__instance;
  };
  /**
   * Closes the underlying socket connection, and clears all the event listeners and subscriptions to events as well as
   * any other information related to the connection.
   * @param code `{ ESocketCloseCode }`
   */
  close = (code) => {
    this.ws.removeEventListener("message", this.__handleIncomingMessage);
    const reason = import_socket.SocketCloseReason[code];
    logger.info(`\u{1F50C} Closing the connection, ${code} ${reason}`);
    if (code >= 3e3 && code <= 4999 || code === 1e3) {
      this.ws.close(code, reason);
      this.token = null;
      this.__ENDPOINT = null;
      this.emit("token-updated", null);
    } else {
      this.ws.close();
    }
    this.__unregisterSocketEvents(this.ws);
    this.__ws = null;
    if (code === 1006) {
      this.connectionState = "awaiting-reconnection";
      logger.info("\u{1F50C} Socket Connection closed abnormally, reconnecting");
      return;
    }
    this.connectionState = "closed";
    this.emit("closed", code);
    logger.info("\u{1F50C} Socket Connection closed");
  };
  /**
   * Publish a message to the server using the socket connection based on some events/topics
   */
  publish = (event, data) => {
    const payload = JSON.stringify({
      event,
      data: data || {}
    });
    this.ws.send(payload);
  };
  /**
   * Subscribe to a specific event/topic from the server
   */
  subscribe = (event, fn) => {
    if (this.__subscribedMap.has(event)) {
      logger.warn("\u26A0\uFE0F Overriding existing event handler");
    }
    this.__subscribedMap.set(event, fn);
  };
  /**
   * Get the config url for the socket connection based on the token and region
   * @param token Local Peer specific meeting token
   * @param region Local Peer specific region
   * @returns
   */
  async __getConfigUrl(token, region) {
    if (this.__ENDPOINT) {
      return this.__ENDPOINT;
    }
    const apiServerUrl = this.isLocalDev ? "http://localhost:8000/api/v1" : "https://apira.huddle01.com/api/v1";
    const res = await fetch(`${apiServerUrl}/getSushiUrl`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        authorization: `Bearer ${token}`
      }
    });
    if (!res.ok) {
      throw new Error("\u{1F534} Error While Fetching the Url");
    }
    const { url } = await res.json();
    this.__ENDPOINT = url.replace("https://", "wss://").replace("http://", "ws://");
    const wssAddress = `${this.__ENDPOINT}/ws`;
    const wsAddress = `${wssAddress}?${[
      `token=${token}`,
      `version=${2}`,
      `region=${region}`
    ].join("&")}`;
    this.__ENDPOINT = wsAddress;
    return wsAddress;
  }
  /**
   * !Important
   * Handle the incoming message from the server based on the events received from the server and call the subscribed event handler
   */
  __handleIncomingMessage = (event) => {
    const { event: eventName, data } = JSON.parse(event.data);
    logger.info("\u{1F4E8} Incoming message event name: ", eventName);
    const fn = this.__subscribedMap.get(eventName);
    if (fn) {
      fn(data);
    }
  };
  __handleSocketError = (ev) => {
    logger.error("Socket connection error", ev);
    this.connectionState = "failed";
    this.emit("failed");
  };
  /**
   * @description Handle the socket close event which is sent by the server
   * @param ev CloseEvent
   */
  __handleSocketClose = (ev) => {
    logger.info("Socket connection closed", ev);
    const code = ev.code;
    const reason = import_socket.SocketCloseReason[code];
    logger.info(`\u{1F534} { Server }: Closing the connection, ${code} ${reason}`);
    this.close(code);
  };
  /**
   * @description Handle the socket open event which is sent after the connection is established with the server
   * @param ev Event
   */
  __handleSocketOpen = (ev) => {
    logger.info("Socket Connection Open", ev);
    this.connectionState = "connected";
    this.emit("connected");
  };
  /**
   * @description Register the socket events
   * @param ws WebSocket
   */
  __registerSocketEvents = (ws) => {
    ws.addEventListener("error", this.__handleSocketError);
    ws.addEventListener("close", this.__handleSocketClose);
    ws.addEventListener("open", this.__handleSocketOpen);
  };
  /**
   * @description Unregister the socket events
   * @param ws WebSocket
   */
  __unregisterSocketEvents = (ws) => {
    ws.removeEventListener("error", this.__handleSocketError);
    ws.removeEventListener("close", this.__handleSocketClose);
    ws.removeEventListener("open", this.__handleSocketOpen);
  };
};
var Socket_default = Socket;

export {
  require_socket_types,
  Socket_default
};
//# sourceMappingURL=chunk-HVBBMWHF.js.map