import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  EnhancedEventEmitter
} from "./chunk-7OTQAFXE.js";

// src/Consumer.ts
var logger = mainLogger.createSubLogger("Consumer");
var Consumer = class _Consumer extends EnhancedEventEmitter {
  /**
   * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.
   */
  producerId;
  /**
   * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.
   */
  producerPeerId;
  /**
   * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.
   */
  label;
  /**
   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
   *
   * @default false
   */
  __consuming = false;
  /**
   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
   *
   * @default false
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get consuming() {
    return this.__consuming;
  }
  /**
   * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.
   * @remarks This is a private property and should not be accessed directly.
   *
   * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.
   */
  #mediasoupConsumer = null;
  /**
   * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.
   */
  get id() {
    return this.#mediasoupConsumer?.id;
  }
  /**
   *
   * @param consumer Sets the mediasoupConsumer for the Consumer
   */
  setMediaSoupConsumer(consumer) {
    if (this.consuming) {
      throw new Error("Consumer is already consuming");
    }
    if (this.#mediasoupConsumer) {
      throw new Error("Consumer already has a mediasoupConsumer");
    }
    this.#mediasoupConsumer = consumer;
    this.__consuming = true;
  }
  /**
   * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get consumerId() {
    return this.#mediasoupConsumer?.id;
  }
  /**
   * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get track() {
    return this.#mediasoupConsumer?.track;
  }
  /**
   * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.
   *
   * @remarks
   * There are two ways a Peer can Consume any media produced in the room.
   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  get kind() {
    return this.#mediasoupConsumer?.kind;
  }
  /**
   * If the Consumer is paused, it is only available when the Consumer is consuming a media.
   *
   * if paused the user is not consuming any media for the given producerId.
   */
  get paused() {
    return this.#mediasoupConsumer?.paused;
  }
  /**
   * AppData of the Consumer, it is only available when the Consumer is consuming a media.
   */
  get appData() {
    return this.#mediasoupConsumer?.appData;
  }
  /**
   * State of a Consumer is defined by the following:
   * - `playable` - The Consumer is ready to play the media.
   * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.
   * - `paused` - The Consumer is paused and is not playing the media.
   * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: "video", appData: {} });` after which the state will change to `playable`.
   */
  get state() {
    if (this?.consuming)
      return "playable";
    if (this?.paused)
      return "paused";
    return "available";
  }
  /**
   * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.
   * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.
   * @returns - RTCStatsReport | null
   */
  getStats = async () => {
    const stats = await this.#mediasoupConsumer?.getStats();
    return stats;
  };
  /**
   * Resume the consumer, if the state of the consumer is `paused`.
   */
  resume = () => {
    this.#mediasoupConsumer?.resume();
  };
  /**
   * Removes all the eventListeners attached to the Consumer.
   */
  removeListeners = () => {
    this.removeAllListeners();
  };
  /**
   * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.
   */
  static create = (data) => {
    try {
      const consumer = new _Consumer(data);
      return consumer;
    } catch (error) {
      logger.error(error);
      throw new Error("\u274C Error creating Consumer");
    }
  };
  close = () => {
    try {
      this.#mediasoupConsumer?.close();
      this.__consuming = false;
      this.emit("closed");
      this.removeAllListeners();
    } catch (error) {
      logger.error("\u274C Error Closing Consumer");
      logger.error({
        consumerId: this.consumerId,
        producerId: this.producerId
      });
    }
  };
  constructor(data) {
    super();
    this.producerPeerId = data.producerPeerId;
    this.producerId = data.producerId;
    this.label = data.label;
  }
};
var Consumer_default = Consumer;

export {
  Consumer_default
};
//# sourceMappingURL=chunk-FE7RZJBI.js.map