import {
  LocalPeer_default
} from "./chunk-BDLAILV7.js";
import {
  Room_default
} from "./chunk-NEW4FEHE.js";
import {
  Socket_default,
  require_socket_types
} from "./chunk-HVBBMWHF.js";
import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// src/HuddleClient.ts
var import_socket = __toESM(require_socket_types(), 1);
var logger = mainLogger.createSubLogger("NezukoClient");
var HuddleClient = class {
  /**
   * Connection Manager Instance, Hanlder socket connection and stores information about the connection
   */
  __socket;
  /**
   * Room Instance, Handles the room and its connection
   */
  __room;
  /**
   * Local Peer Instance, Handles the local peer and its connection
   */
  __localPeer;
  /**
   * isJoinRoomProcessing: boolean;
   */
  __isJoinRoomProcessing = false;
  /**
   * Project Id of the Huddle01 Project
   */
  projectId;
  /**
   * Returns the underlying socket connection
   * @throws { Error } If the socket connection is not initialized
   */
  get socket() {
    if (!this.__socket) {
      throw new Error(
        "Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first"
      );
    }
    return this.__socket;
  }
  /**
   * Returns the room instance, throws an error if the room is not created
   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room
   */
  get room() {
    return this.__room;
  }
  get localPeer() {
    return this.__localPeer;
  }
  /**
   * Room Id of the current room
   */
  get roomId() {
    return this.room.roomId;
  }
  /**
   * Set a new region for the Huddle01 Media Servers
   */
  setRegion = (region) => {
    logger.info("Setting a new region, ", region);
    this.socket.setRegion(region);
  };
  constructor(data) {
    logger.info("\u2705 Initializing HuddleClient");
    this.projectId = data.projectId;
    this.__socket = Socket_default.create();
    this.__room = Room_default.create({
      autoConsume: data.options?.autoConsume,
      activeSpeakers: data.options?.activeSpeakers
    });
    this.__localPeer = LocalPeer_default.create();
    const isLocalDev = this.projectId === "development";
    if (isLocalDev) {
      logger.info("\u{1F534} Local Development Mode");
      this.socket.enableLocalDev();
    }
    this.__socket.on("closed", (code) => {
      logger.info(
        "\u{1F50C} Socket Connection closed, closing the room and LocalPeer"
      );
      if (code === import_socket.ESocketCloseCode.ROOM_CLOSED) {
        this.room.close("CLOSED");
      } else if (code === import_socket.ESocketCloseCode.ROOM_ENTRY_DENIED) {
        this.room.close("DENIED");
      } else if (code === import_socket.ESocketCloseCode.CONNECTION_EXPIRED) {
        logger.info("\u{1F50C} Socket Connection closed due to connection expired");
        this.room.close();
      } else if (code === import_socket.ESocketCloseCode.KICKED) {
        this.room.close("KICKED");
      } else {
        this.room.close();
      }
      this.localPeer.close();
    });
  }
  /**
   * Default method to connect to the Huddle01 Media Room.
   *
   * This method connects to socket, creates a room, and then connects to the room;
   */
  joinRoom = async (data) => {
    this.__isJoinRoomProcessing = true;
    logger.info("\u{1F514} Joining the room with roomId,", data.roomId);
    if (this.socket.connectionState === "connecting") {
      logger.warn(
        "\u{1F514} Socket is already connecting, waiting for the connection to be established"
      );
      return this.room;
    }
    if (this.room.state === "connecting" || this.__isJoinRoomProcessing) {
      logger.warn("\u{1F514} Room join already in progress");
      return this.room;
    }
    if (this.localPeer.joined) {
      logger.warn("\u{1F514} Already joined the room");
      return this.room;
    }
    try {
      await this.socket.connect({ token: data.token });
      this.room.roomId = data.roomId;
      const room = this.room.connect();
      return room;
    } catch (error) {
      logger.error("\u{1F534} Error While Joining the Room");
      logger.error(error);
      throw error;
    } finally {
      this.__isJoinRoomProcessing = false;
    }
  };
  /**
   * Leave the room and disconnect from the socket
   */
  leaveRoom = () => {
    logger.info("Leaving the room");
    this.socket.close(import_socket.ESocketCloseCode.NORMAL_CLOSURE);
  };
  /**
   * Close the room and disconnect from the socket
   */
  closeRoom = () => {
    logger.info("Closing the room");
    this.socket.publish("closeRoom", void 0);
  };
};
var HuddleClient_default = HuddleClient;

export {
  HuddleClient_default
};
//# sourceMappingURL=chunk-SVY6TXJT.js.map