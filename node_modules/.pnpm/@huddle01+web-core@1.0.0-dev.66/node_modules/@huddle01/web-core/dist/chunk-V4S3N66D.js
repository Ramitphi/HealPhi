import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  EnhancedEventEmitter
} from "./chunk-7OTQAFXE.js";

// src/Permissions.ts
var logger = mainLogger.createSubLogger("Permissions");
var Permissions = class _Permissions extends EnhancedEventEmitter {
  /**
   * Get the Singleton Instance of the Permissions Class.
   */
  static __instance;
  /**
   * Admin Access of the Room.
   */
  __admin = false;
  /**
   * Can Consume Media Stream of the Room from RemotePeers;
   */
  __canConsume = false;
  /**
   * Can Produce Media Stream to the Room
   */
  __canProduce = true;
  /**
   * Allowed Sources to Produce Media Stream to the Room
   */
  __canProduceSources = {
    cam: true,
    mic: true,
    screen: true
  };
  /**
   * Can Send Data to the Room, e.g. Chat Messages, update of avatar, name etc. to the room
   */
  __canSendData = false;
  /**
   * Can Receive Data from the Room, e.g. Chat Messages, update of avatar, name etc. from other Remote Peers.
   */
  __canRecvData = false;
  /**
   * Can Update Metadata of the Room, e.g. DisplayName, Avatar, etc.
   */
  __canUpdateMetadata = false;
  /**
   * Custom Role of the Peer in the Room.
   */
  __role = null;
  /**
   * Getter for the role of the peer.
   */
  get role() {
    return this.__role;
  }
  set role(role) {
    this.__role = role;
  }
  /**
   * Get the Access Control List ( acl ) of the Local Peer in the Room.
   */
  get acl() {
    return {
      admin: this.__admin,
      canConsume: this.__canConsume,
      canProduce: this.__canProduce,
      canProduceSources: this.__canProduceSources,
      canSendData: this.__canSendData,
      canRecvData: this.__canRecvData,
      canUpdateMetadata: this.__canUpdateMetadata
    };
  }
  /**
   * Update the Permissions of the Local Peer in the Room. This will emit an event `updated` with the updated permissions.
   *
   * `NOTE: If the Peer is not an admin, then the permissions will not be updated on the server`
   */
  updatePermissions(permissions) {
    logger.info("\u{1F514} Updating Permissions", permissions);
    this.__admin = permissions.admin ?? this.__admin;
    this.__canConsume = permissions.canConsume ?? this.__canConsume;
    this.__canProduce = permissions.canProduce ?? this.__canProduce;
    this.__canProduceSources = permissions.canProduceSources ?? this.__canProduceSources;
    this.__canSendData = permissions.canSendData ?? this.__canSendData;
    this.__canRecvData = permissions.canRecvData ?? this.__canRecvData;
    this.__canUpdateMetadata = permissions.canUpdateMetadata ?? this.__canUpdateMetadata;
  }
  static createInstance() {
    if (_Permissions.__instance)
      return _Permissions.__instance;
    _Permissions.__instance = new _Permissions();
    return _Permissions.__instance;
  }
  static getInstance() {
    if (!_Permissions.__instance) {
      throw new Error("Permissions Instance not created yet.");
    }
    return _Permissions.__instance;
  }
  constructor() {
    super();
  }
  reset() {
    this.__admin = false;
    this.__canConsume = false;
    this.__canProduce = true;
    this.__canProduceSources = {
      cam: true,
      mic: true,
      screen: true
    };
    this.__canSendData = false;
    this.__canRecvData = false;
    this.__canUpdateMetadata = false;
    this.__role = null;
  }
};
var checkPermissions = (permission) => {
  return {
    validate: (fn) => {
      return (...args) => {
        const peerPermission = Permissions.getInstance().acl;
        if (permission.admin && !peerPermission.admin) {
          throw new Error("Admin Access Required.");
        }
        if (permission.canConsume && !peerPermission.canConsume) {
          throw new Error("Can Consume Access Required.");
        }
        if (permission.canProduce && !peerPermission.canProduce) {
          throw new Error("Can Produce Access Required.");
        }
        if (permission.canProduceSources?.cam && !peerPermission.canProduceSources.cam) {
          throw new Error("Produce Sources Access Required. for 'cam'");
        }
        if (permission.canProduceSources?.mic && !peerPermission.canProduceSources.mic) {
          throw new Error("Produce Sources Access Required. for 'mic'");
        }
        if (permission.canProduceSources?.screen && !peerPermission.canProduceSources.screen) {
          throw new Error("Produce Sources Access Required. for 'screen'");
        }
        if (permission.canSendData && !peerPermission.canSendData) {
          throw new Error("Can Send Data Access Required.");
        }
        if (permission.canRecvData && !peerPermission.canRecvData) {
          throw new Error("Can Recv Data Access Required.");
        }
        return fn(...args);
      };
    }
  };
};
checkPermissions({
  canProduceSources: {
    cam: true,
    mic: true,
    screen: true
  }
});
var Permissions_default = Permissions;

export {
  checkPermissions,
  Permissions_default
};
//# sourceMappingURL=chunk-V4S3N66D.js.map