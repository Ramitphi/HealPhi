import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter.js';

type StreamPermissions = 'granted' | 'denied' | 'prompt';
type StreamPermissionsError = {
    blocked?: {
        byDeviceMissing?: boolean;
        byDeviceInUse?: boolean;
        byPermissions?: boolean;
    };
    errorStack?: unknown;
    message: string;
};
type FetchStreamResponse = Promise<{
    deviceId: string | null;
    stream: MediaStream | null;
    track: MediaStreamTrack | null;
    error?: StreamPermissionsError;
}>;
type FetchScreenResponse = Promise<Omit<Awaited<FetchStreamResponse>, 'track' | 'deviceId'>>;
type CustomMediaKind = 'cam' | 'mic' | 'screen';
type CustomMediaDevice = 'mic' | 'cam' | 'speaker';
type StreamAdded = {
    stream: MediaStream;
    track: MediaStreamTrack;
    mediaKind: CustomMediaKind;
};
type DeviceHandlerEvents = {
    'device-change': [];
    'permission-granted': [data: {
        deviceKind: CustomMediaDevice;
    }];
    'permission-denied': [
        data: {
            deviceKind: CustomMediaDevice;
            error: StreamPermissionsError;
        }
    ];
    'preferred-device-change': [
        data: {
            deviceKind: CustomMediaDevice;
            deviceId: string | null;
        }
    ];
};
/**
 * Handle the stream related operations for the Huddle01 SDK
 */
declare class DeviceHandler extends EnhancedEventEmitter<DeviceHandlerEvents> {
    readonly SCREEN_DEFAULT_DEVICE: string;
    /**
     * User Selected Devices, If no device is selected, it will use the default device of the system
     *
     * is preffered device is null, it will use the default device of the system
     *
     * `NOTE: User has the ability to select a preferred device for each media kind`
     */
    private __preferredDevices;
    /**
     * Map the media devices currently present in the system
     */
    private __mediaDevicesInfo;
    /**
     * Get all the devices which are currently available in the system
     */
    get devices(): Map<CustomMediaDevice, [] | MediaDeviceInfo[]>;
    get preferredDevices(): Map<CustomMediaDevice, string | null>;
    /**
     * Get all the devices which are currently available in the system, also updates the `__mediaDevicesInfo` record
     *
     * Can also query for a specific device kind `audioinput` | `videoinput` | `audiooutput`
     *
     * @param deviceKind `cam` | `mic` | `speaker` | `undefined`
     * @returns - MediaDeviceInfo[] | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getMediaDevices: (filterByDeviceKind?: CustomMediaDevice) => Promise<MediaDeviceInfo[]>;
    /**
     * Get the device from the given facing type of device
     *
     * This function is used for only RN
     *
     * @param facing - facing of the device { 'environment' | 'front' | 'undefined' }
     * @param mediaDeviceKind - mediaDeviceKind for the device { 'audioinput' | 'videoinput' }
     * @returns - deviceId: string | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getDeviceFromFacingMode: (facing: 'environment' | 'front' | undefined, mediaDeviceKind: CustomMediaDevice) => string | null;
    setPreferredDevice: (data: {
        deviceId: string | null;
        deviceKind: CustomMediaDevice;
    }) => void;
    /**
     * Fetches a stream of the screen of the device i.e the screen sharing stream
     * based on the selected choice from the pop up returns the audio and video stream
     * in one stream.
     *
     * `NOTE: This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK`
     * @returns
     */
    fetchScreen: () => Promise<FetchScreenResponse>;
    /**
     * Fetch the stream from the device for the given media kind, if no preferred device is found it will throw an error.
     * by default the preferred device is the system default device
     *
     * `NOTE: If Preffered device is not found, it will use the system default device, if no default device is found it will throw an error`
     * `Set the preferred device using setPreferredDevice()`
     *
     */
    fetchStream: (data: {
        mediaDeviceKind: Exclude<CustomMediaDevice, 'speaker'>;
    }) => Promise<FetchStreamResponse>;
    fetchStreamByGroupId: (data: {
        groupId: string;
        mediaDeviceKind: Exclude<CustomMediaDevice, 'speaker'>;
    }) => Promise<MediaStream>;
    /**
     * Fetch the stream from the device for the React Native Based Application
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: "front" | "back" | "audio" | string; kind: "audioinput" | "videoinput" }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    private __fetchStreamFromDeviceForRN;
    /**
     * Fetch the stream from the device for the web
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: string; kind: 'audio' | 'video' }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    private __fetchStreamFromDeviceForWeb;
    /**
     * @description Get the media permission for the given type
     * @param data  { type: 'video' | 'audio' }
     * @throws error { StreamPermissionsError }
     * @example await getMediaPermission({ type: 'video' })
     */
    getMediaPermission: (data: {
        mediaDeviceKind: CustomMediaDevice;
    }) => Promise<{
        permission: 'granted' | 'denied';
        error?: StreamPermissionsError;
    }>;
    stopStream: (stream?: MediaStream) => void;
    destroy: () => void;
    /**
     * Set the Media devices info based on the latest devices available in the system
     */
    private __setMediaDeviceInfo;
}

export { CustomMediaDevice, CustomMediaKind, DeviceHandlerEvents, FetchScreenResponse, FetchStreamResponse, StreamAdded, StreamPermissions, StreamPermissionsError, DeviceHandler as default };
