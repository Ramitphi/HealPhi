import {
  Transport_default
} from "./chunk-OKUP6CWC.js";
import {
  estimateSize,
  getMediaDeviceKind
} from "./chunk-G7SIQXZ4.js";
import {
  DeviceHandler_default
} from "./chunk-LU7T3V5U.js";
import {
  Room_default
} from "./chunk-NEW4FEHE.js";
import {
  Permissions_default,
  checkPermissions
} from "./chunk-V4S3N66D.js";
import {
  Socket_default
} from "./chunk-HVBBMWHF.js";
import {
  VolatileDataMessageSchema
} from "./chunk-SSCVNXAL.js";
import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  EnhancedEventEmitter
} from "./chunk-7OTQAFXE.js";

// src/LocalPeer.ts
import { Device, detectDevice } from "mediasoup-client";
var logger = mainLogger.createSubLogger("LocalPeer");
var MAX_DATA_MESSAGE_SIZE = 1 * 1024;
var LocalPeer = class _LocalPeer extends EnhancedEventEmitter {
  /**
   * LocalPeer Instance, Singleton class, only one instance of this class can be created
   */
  static __instance = null;
  /**
   * PeerId of the current client, specific to the Local Peer who joined the meeting
   *
   * `NOTE: Until you dont join the room, this will be *null*`
   */
  peerId = null;
  /**
   * Current Devices of the current client
   * e.g. Chrome, Firefox, Safari, ReactNative
   */
  __device = null;
  /**
   * SendTransport handles the sending of media from the client to the server
   */
  __sendTransport = null;
  /**
   * RecvTransport handles the receiving of media from the server to the client
   */
  __recvTransport = null;
  /**
   * Returns the room instance, throws an error if the room is not created
   *
   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room in the LocalPeer
   */
  get room() {
    const room = Room_default.getInstance();
    if (!room)
      throw new Error("\u274C Room Not Initialized");
    return room;
  }
  /**
   * Returns the underlying socket connection
   * @throws { Error } If the socket connection is not initialized
   */
  get socket() {
    const socket = Socket_default.getInstance();
    if (!socket)
      throw new Error("\u274C Socket Not Initialized");
    return socket;
  }
  /**
   * Remote Peers Map, Stores all the remote peers
   */
  get __remotePeers() {
    return this.room.remotePeers;
  }
  /**
   * Turn Server used for this client
   */
  __turn = [
    {
      username: "test-turn",
      urls: "turn:turn.huddle01.com:443?transport=udp",
      credential: "test-turn"
    },
    {
      username: "test-turn",
      urls: "turn:turn.huddle01.com:443?transport=tcp",
      credential: "test-turn"
    }
  ];
  /**
   * Get the current device ( chrome, firefox, safari, reactnative ) for this client
   *
   * @throws { Error } If the device is not initialized
   */
  get device() {
    if (!this.__device)
      throw new Error("Device Not Initialized");
    const loaded = this.__device.loaded;
    if (!loaded)
      throw new Error("Device Not Loaded");
    return this.__device;
  }
  // !important
  // Consumer creation tasks awaiting to be processed.
  // Stores the lables of the pending consumers { producerId: string ==> Promise<Consumer> }
  __pendingConsumerTasks = /* @__PURE__ */ new Map();
  // !important
  // Producer creation tasks awaiting to be processed.
  // Stores the lables of the pending producers { label: string }
  // Used to handle transport callbacks most important;
  __pendingProducerTasks = /* @__PURE__ */ new Map();
  // !important
  // Map to store pending tasks, Stores the label and the promise of the task
  __pendingTasks = /* @__PURE__ */ new Map();
  /**
   * Pending Transport Tasks, Stores the transportType and the promise of the transport
   *
   * `NOTE: Useful to check if the transport is already being created and pause all producing
   * and consuming until the transport is created`
   */
  __pendingTransportTasks = /* @__PURE__ */ new Map();
  /**
   * Stores all the pending fetching stream tasks which are awaiting to be processed
   * If fetching called multiple times at once, it will handle the concurrency issues
   */
  __pendingFetchingStream = /* @__PURE__ */ new Map();
  /**
   * Stores all the pending produce tasks which are awaiting to be processed
   * Mostly used when the room is not joined and produce functionality needs to be handled
   *
   * Cases such as socket experiencing a reconnect and produce is called.
   * Or in the cases where room is not joined and enableVideo or enableAudio is called
   */
  __waitingToProduce = /* @__PURE__ */ new Map();
  /**
   * Stores all the pending consume tasks which are waiting for recv transport to be re-connected
   */
  __waitingToConsume = [];
  /**
   * DeviceHandler Instance, Handles the media devices for this client
   * e.g. Camera, Microphone
   */
  deviceHandler = new DeviceHandler_default();
  /**
   * ActiveStream Map holds MediaStream as Value and Key as Label
   */
  __activeStreams = /* @__PURE__ */ new Map();
  /**
   * Handle the Client Side Permission for the Local Peer.
   */
  __permissions = Permissions_default.createInstance();
  /**
   * Stores the Metadata for the Local Peer.
   */
  __metadata = null;
  /**
   * Variable to check if the user has joined the room
   */
  joined = false;
  /**
   * Return the labels of the Media Stream that the Local Peer is producing to the room
   */
  get labels() {
    const sendTransport = this.__sendTransport;
    if (sendTransport) {
      const labels = Array.from(sendTransport.labelToProducerId.keys());
      return labels;
    }
    return [];
  }
  /**
   * Get the Permissions of the Local Peer. (e.g canProduce, canConsume, canSendData, canRecvData etc)
   */
  get permissions() {
    const acl = this.__permissions.acl;
    return acl;
  }
  /**
   * Get the Role of the Local Peer.
   */
  get role() {
    return this.__permissions.role;
  }
  /**
   * Returns the token of the current socket connection, specific to the Local Peer who joined the meeting
   */
  get token() {
    return this.socket.token;
  }
  /**
   * Returns the roomId of the current joined room.
   */
  get roomId() {
    return this.room.roomId;
  }
  /**
   * Returns the SendTransport
   * @returns { Transport } SendTransport
   * @throws { Error } If the SendTransport is not initialized
   */
  get sendTransport() {
    if (!this.__sendTransport)
      throw new Error("Send Transport Not Initialized");
    return this.__sendTransport;
  }
  /**
   * Returns the recvTransport
   * @returns { Transport } recvTransport
   * @throws { Error } If the recvTransport is not initialized
   */
  get recvTransport() {
    if (!this.__recvTransport)
      throw new Error("Recv Transport Not Initialized");
    return this.__recvTransport;
  }
  /**
   * Returns the metadata associated to the LocalPeer
   */
  getMetadata() {
    const data = JSON.parse(this.__metadata || "{}");
    return data;
  }
  /**
   * getStream returns the stream with the given label
   */
  getStream = (data) => {
    const stream = this.__activeStreams.get(data.label);
    if (stream === void 0) {
      return null;
    }
    return stream;
  };
  /**
   * Updates the metadata associated to the LocalPeer, Triggers the `metadata-updated` event
   * @param metadata
   */
  __updateMetadata = (metadata) => {
    this.__metadata = metadata;
    const parse = JSON.parse(metadata);
    this.emit("metadata-updated", {
      metadata: parse
    });
  };
  /**
   * Returns the producer with the given label
   * @param label - Identifier of the producer
   * @returns { Producer } Producer
   * @returns { null } If the producer is not found
   */
  getProducerWithLabel = (label) => {
    try {
      const producerId = this.__sendTransport?.labelToProducerId.get(label);
      if (producerId) {
        const producer = this.sendTransport.getProducerById(producerId);
        return producer;
      }
      return null;
    } catch (error) {
      logger.error("\u274C Cannot Find Producer With Identifier: ", label);
      logger.error(error);
      return null;
    }
  };
  /**
   * Registers the event handlers for the socket connection
   * @param socket - Socket Instance
   */
  __registerHandlerEvents = (socket) => {
    let cnt = 0;
    const keys = Object.keys(this.__handler);
    for (const key of keys) {
      try {
        const fn = this.__handler[key];
        if (fn)
          socket.subscribe(key, fn);
      } catch (error) {
        logger.error(`\u274C Error Registered For Event: ${key}`);
        logger.error(error);
      }
      cnt++;
    }
    logger.info("\u2705 LocalPeerEventHandler Registered");
  };
  static create() {
    if (_LocalPeer.__instance) {
      return _LocalPeer.__instance;
    }
    _LocalPeer.__instance = new _LocalPeer();
    return _LocalPeer.__instance;
  }
  static getInstance() {
    if (!_LocalPeer.__instance) {
      throw new Error("LocalPeer not initialized");
    }
    return _LocalPeer.__instance;
  }
  constructor() {
    super();
    this.__registerHandlerEvents(this.socket);
    this.socket.on("reconnected", () => {
      this.__registerHandlerEvents(this.socket);
      this.socket.publish("syncMeetingState", void 0);
      if (this.__sendTransport) {
        this.socket.publish("restartTransportIce", {
          transportId: this.__sendTransport.mediasoupTransport.id,
          transportType: "send"
        });
      }
      if (this.__recvTransport) {
        this.socket.publish("restartTransportIce", {
          transportId: this.__recvTransport.mediasoupTransport.id,
          transportType: "recv"
        });
      }
    });
  }
  /**
   * Destroy the current peer, closes all the transports, producers and consumers
   *
   * @param code - Close Code
   */
  close = () => {
    this.__device = null;
    this.__pendingConsumerTasks.clear();
    this.__pendingProducerTasks.clear();
    this.__pendingTransportTasks.clear();
    this.__pendingFetchingStream.clear();
    this.__waitingToProduce.clear();
    for (const stream of this.__activeStreams.values()) {
      for (const track of stream.getTracks())
        track.stop();
    }
    this.joined = false;
    this.deviceHandler.destroy();
    if (this.__sendTransport) {
      this.__sendTransport.close({ retries: 3 });
    }
    if (this.__recvTransport) {
      this.__recvTransport.close({ retries: 3 });
    }
    this.__sendTransport = null;
    this.__recvTransport = null;
    this.__permissions.reset();
    this.emit("permissions-updated", {
      permissions: this.permissions,
      role: this.role ?? ""
    });
  };
  /**
   * LocalPeer Handler Functions Begins Here ðŸ‘‡
   */
  /**
   * Produce a stream with a given label and appData to all the Remote Peers
   *
   * `canProduce must be true to produce a stream`
   *
   * `NOTE: This will notify all the RemotePeers that this producer has started producing and they should start consuming it if they want to`
   *
   * @param data - Data to produce a stream
   *  - `label` - Unique Identifier for the stream ( string )
   *  - `stream` - MediaStream to produce ( MediaStream )
   *  - `stopTrackOnClose` - If true, it will stop the track when the producer is closed using stopProducing ( boolean )
   *  - `appData` - Application level custom data which can be added to the producer for the LocalPeer, this data will be available in the producer object and can be used only by the LocalPeer. ( Unknown Object )
   *
   * @summary This function is used to produce a stream with a given label and appData to all the Remote Peers if the send transport is not initialised
   * it will create a send transport and then produce the stream with the given label and appData to all the Remote Peers
   *
   * Send Transport is a secure channel which is used to send media from LocalPeer to all the RemotePeers in the room
   *
   * `localPeer.on('new-producer', ({label: string; producer: Producer}) => {})`
   */
  produce = checkPermissions({
    canProduce: true
  }).validate(
    async (data) => {
      const track = data.stream.getTracks()[0];
      if (track) {
        track.addEventListener("ended", () => {
          this.stopProducing({ label: data.label });
        });
      }
      if (!this.joined || this.__sendTransport && this.__sendTransport?.connectionState !== "connected") {
        return new Promise((resolve) => {
          const fn = async () => {
            const producer2 = await this.produce(data).then((data2) => {
              resolve(data2);
              return data2;
            }).finally(() => {
              this.__pendingProducerTasks.delete(data.label);
            });
            return producer2;
          };
          this.__waitingToProduce.set(data.label, fn);
        });
      }
      const { stream } = data;
      const producerPromise = this.__pendingProducerTasks.get(data.label);
      if (producerPromise) {
        logger.info(
          "\u{1F514} Producer Task Already Pending for this label ",
          data.label
        );
        const producer2 = await producerPromise;
        return producer2;
      }
      if (!this.__sendTransport) {
        await this.__createTransportOnServer({
          transportType: "send"
        });
      }
      const ongoingPromise = this.__pendingProducerTasks.get(data.label);
      if (ongoingPromise) {
        const producer2 = await ongoingPromise;
        return producer2;
      }
      const promise = this.__createProducer({
        stream,
        label: data.label,
        appData: { ...data.appData, label: data.label }
      });
      this.__pendingProducerTasks.set(data.label, promise);
      const producer = await promise.catch(() => {
        logger.error("\u274C Error Create Producer Failed");
        throw new Error("\u274C Error Create Producer Failed");
      }).finally(() => {
        this.__pendingProducerTasks.delete(data.label);
      });
      return producer;
    }
  );
  /**
   * Enables the local web cam and starts producing the stream with the label `video`
   *
   * @summary This functions handle the producing of media streams to all the remote peers in the room.
   * it enables the local web cam fetches the stream opens you web cam indicator light on the device
   * upon successfull fetching of the stream it produces the stream with the label `video` and `stopTrackOnClose: true` to all the remote peers in the room.
   * when closing using disableVideo it will stop the local track and close the producer which will notify all the RemotePeers that this producer has stopped producing
   * and they should stop consuming it.
   *
   * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will throw an error`
   *
   * @throws { Error } If the stream is not found
   */
  enableVideo = checkPermissions({
    canProduce: true
  }).validate(async (customVideoStream) => {
    try {
      if (!this.permissions.canProduceSources.cam) {
        logger.error("\u274C Cannot Enable Video, Permission Denied");
        throw new Error("\u274C Cannot Enable Video, Permission Denied");
      }
      const existingStream = this.__activeStreams.get("video");
      if (existingStream) {
        logger.warn("\u{1F514} Cam Stream Already Enabled");
        return;
      }
      let stream;
      if (customVideoStream) {
        stream = customVideoStream;
      } else {
        const ongoingStreamPromise = this.__pendingFetchingStream.get("cam");
        if (ongoingStreamPromise) {
          await ongoingStreamPromise;
        } else {
          const streamPromise = this.deviceHandler.fetchStream({
            mediaDeviceKind: "cam"
          });
          this.__pendingFetchingStream.set("cam", streamPromise);
        }
        const pendingPromise = this.__pendingFetchingStream.get("cam");
        if (!pendingPromise) {
          logger.info("\u{1F514} Pending Promise Not Found");
          return;
        }
        const { stream: fetchedStream, error } = await pendingPromise;
        if (error) {
          logger.error("\u274C Error Fetching Stream From Device");
          logger.error(error);
          throw new Error("\u274C Error Fetching Stream From Device");
        }
        if (!fetchedStream) {
          logger.error("\u274C Stream Not Found, cannot do enableVideo");
          throw new Error("\u274C Stream Not Found");
        }
        stream = fetchedStream;
      }
      this.__activeStreams.set("video", stream);
      this.emit("stream-fetched", {
        mediaKind: "cam",
        label: "video",
        stream
      });
      this.produce({
        label: "video",
        stream,
        appData: {
          producerPeerId: this.peerId
        },
        stopTrackOnClose: true
      }).then(() => {
        this.__pendingProducerTasks.delete("video");
      }).catch((error) => {
        logger.error("\u274C Error Producing Video");
        this.deviceHandler.stopStream(this.__activeStreams.get("video"));
        this.__activeStreams.delete("video");
        this.__pendingFetchingStream.delete("cam");
        logger.error(error);
      });
      this.__pendingFetchingStream.delete("cam");
      return stream;
    } catch (error) {
      logger.error("\u274C Error Enabling Video");
      logger.error(error);
      this.deviceHandler.stopStream(this.__activeStreams.get("video"));
      this.__activeStreams.delete("video");
      this.__pendingFetchingStream.delete("cam");
      throw error;
    }
  });
  /**
   * Enables the local screen share  and starts producing the screen sharing stream
   *
   *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
   *
   * @summary This functions handle the producing of media streams to all the remote peers in the room.
   * it enables the local mic fetches the stream opens you mic active indicator light on the device
   * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
   * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
   * and they should stop consuming it.
   *
   *
   */
  startScreenShare = checkPermissions({ canProduce: true }).validate(
    async () => {
      try {
        if (!this.permissions.canProduceSources.screen) {
          logger.error("\u274C Cannot Enable Screen Share, Permission Denied");
          throw new Error("\u274C Cannot Enable Screen Share, Permission Denied");
        }
        const existingStream = this.__activeStreams.get("screen-share");
        if (existingStream) {
          logger.warn("\u{1F514} Screen Stream Already Enabled");
          return;
        }
        const onGoingStreamPromise = this.__pendingFetchingStream.get("screen-share");
        if (onGoingStreamPromise) {
          await onGoingStreamPromise;
        } else {
          const streamPromise = this.deviceHandler.fetchScreen();
          this.__pendingFetchingStream.set("screen-share", streamPromise);
        }
        const pendingPromise = this.__pendingFetchingStream.get("screen-share");
        if (!pendingPromise) {
          logger.info("\u{1F514} Pending Screen Share Promise Not Found");
          return;
        }
        const { stream, error } = await pendingPromise;
        if (error) {
          logger.error("\u274C Error Fetching Screen Share Stream From Device");
          logger.error(error);
          throw new Error("\u274C Error Fetching Screen ShareStream From Device");
        }
        if (!stream) {
          logger.error("\u274C Stream Not Found, cannot do startScreenShare");
          throw new Error("\u274C Stream Not Found, cannot do startScreenShare");
        }
        this.__activeStreams.set("screen-share", stream);
        this.emit("stream-fetched", {
          mediaKind: "screen",
          label: "screen-share",
          stream
        });
        const videoTrack = stream.getVideoTracks()?.[0];
        const audioTrack = stream.getAudioTracks()?.[0];
        const videoProduce = async () => {
          return this.produce({
            label: "screen-share-video",
            stream: new MediaStream([videoTrack]),
            appData: {
              producerPeerId: this.peerId
            },
            stopTrackOnClose: true
          });
        };
        const audioProduce = async () => {
          return this.produce({
            label: "screen-share-audio",
            stream: new MediaStream([audioTrack]),
            appData: {
              producerPeerId: this.peerId
            },
            stopTrackOnClose: true
          });
        };
        if (videoTrack) {
          videoProduce().then(() => {
            this.__pendingProducerTasks.delete("screen-share-video");
          }).catch((error2) => {
            logger.error("\u274C Error Producing Screen Share Video");
            this.deviceHandler.stopStream(
              this.__activeStreams.get("screen-share")
            );
            this.__activeStreams.delete("screen-share");
            logger.error(error2);
          });
        }
        if (audioTrack) {
          audioProduce().then(() => {
            this.__pendingProducerTasks.delete("screen-share-audio");
          }).catch((error2) => {
            logger.error("\u274C Error Producing Audio");
            this.deviceHandler.stopStream(
              this.__activeStreams.get("screen-share")
            );
            this.__activeStreams.delete("screen-share");
            logger.error(error2);
          });
        }
        this.__pendingFetchingStream.delete("screen-share");
        return stream;
      } catch (error) {
        logger.error("\u274C Error Enabling Screen Share");
        logger.error(error);
        this.deviceHandler.stopStream(this.__activeStreams.get("screen-share"));
        this.__activeStreams.delete("screen-share");
        this.__pendingFetchingStream.delete("screen-share");
        throw error;
      }
    }
  );
  /**
   * Enables the local mic and starts producing the stream with the label `audio`
   *
   *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
   *
   * @summary This functions handle the producing of media streams to all the remote peers in the room.
   * it enables the local mic fetches the stream opens you mic active indicator light on the device
   * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
   * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
   * and they should stop consuming it.
   */
  enableAudio = checkPermissions({
    canProduce: true
  }).validate(async (customAudioStream) => {
    try {
      if (!this.permissions.canProduceSources.mic) {
        logger.error("\u274C Cannot Enable Audio, Permission Denied");
        throw new Error("\u274C Cannot Enable Audio, Permission Denied");
      }
      const existingStream = this.__activeStreams.get("audio");
      if (existingStream) {
        logger.warn("\u{1F514} Mic Stream Already Enabled");
        return;
      }
      let stream;
      if (customAudioStream) {
        stream = customAudioStream;
      } else {
        const ongoingStreamPromise = this.__pendingFetchingStream.get("mic");
        if (ongoingStreamPromise) {
          await ongoingStreamPromise;
        } else {
          const streamPromise = this.deviceHandler.fetchStream({
            mediaDeviceKind: "mic"
          });
          this.__pendingFetchingStream.set("mic", streamPromise);
        }
        const pendingPromise = this.__pendingFetchingStream.get("mic");
        if (!pendingPromise) {
          logger.info("\u{1F514} Pending Mic Promise Not Found");
          return;
        }
        const { stream: fetchedStream, error } = await pendingPromise;
        if (error) {
          logger.error("\u274C Error Fetching Stream From Device");
          logger.error(error);
          throw new Error("\u274C Error Fetching Stream From Device");
        }
        if (!fetchedStream) {
          logger.error("\u274C Stream Not Found, cannot do enableAudio");
          throw new Error("\u274C Stream Not Found");
        }
        stream = fetchedStream;
      }
      this.__activeStreams.set("audio", stream);
      this.emit("stream-fetched", {
        mediaKind: "mic",
        stream,
        label: "audio"
      });
      this.produce({
        label: "audio",
        stream,
        appData: {
          producerPeerId: this.peerId
        },
        stopTrackOnClose: true
      }).then(() => {
        this.__pendingProducerTasks.delete("audio");
      }).catch((error) => {
        logger.error("\u274C Error Producing Audio");
        this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
        this.__activeStreams.delete("audio");
        logger.error(error);
      });
      this.__pendingFetchingStream.delete("mic");
      return stream;
    } catch (error) {
      logger.error("\u274C Error Enabling Audio");
      logger.error(error);
      this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
      this.__activeStreams.delete("audio");
      this.__pendingFetchingStream.delete("mic");
      throw error;
    }
  });
  /**
   * Stops the underlying producing of a stream for a particular label
   *
   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
   *
   * @param data Data to stop producing { label: string }
   */
  stopProducing = (data) => {
    this.__waitingToProduce.delete(data.label);
    this.__pendingProducerTasks.delete(data.label);
    let closedStream = false;
    const producer = this.getProducerWithLabel(data.label);
    if (producer) {
      logger.info("\u{1F514} Closing Producer", {
        label: data.label,
        producerId: producer.id
      });
      producer.close();
      producer.on("trackended", () => {
        console.debug("\u{1F514} Track Ended For the Producer");
      });
      this.__sendTransport?.removeProducerById(producer.id);
      closedStream = true;
      this.socket.publish("closeProducer", {
        producerId: producer.id
      });
    }
    const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
    const stream = this.__activeStreams.get(closedStreamLabel);
    if (stream) {
      this.deviceHandler.stopStream(stream);
      this.__activeStreams.delete(closedStreamLabel);
      closedStream = true;
    }
    if (closedStream) {
      this.emit("stream-closed", {
        label: data.label,
        reason: {
          code: 1200,
          tag: "STREAM_CLOSED",
          message: "Stopped Streaming"
        }
      });
    }
  };
  /**
   * Stops the underlying producing of a camera stream, stops the local track and closes the producer
   *
   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
   *
   * @param data Data to stop producing { label: string }
   */
  disableVideo = async () => {
    this.stopProducing({
      label: "video"
    });
  };
  /**
   * Replaces the current video stream with the new stream
   *
   * if you have produced a stream with label `video` or used the default function `enableVideo` and you want to replace it with a new stream
   * @param stream - New Video Stream
   */
  replaceVideoStream = async (stream) => {
    await this.replaceStream({
      label: "video",
      newStream: stream
    });
  };
  /**
   * Changes the Video source to the given deviceId, sets the preferred cam device as the given deviceId
   * @param deviceId
   */
  changeVideoSource = async (deviceId) => {
    this.deviceHandler.setPreferredDevice({
      deviceId,
      deviceKind: "cam"
    });
    const stream = this.__activeStreams.get("video");
    if (!stream) {
      return;
    }
    const { stream: newStream } = await this.deviceHandler.fetchStream({
      mediaDeviceKind: "cam"
    });
    if (!newStream)
      return;
    await this.replaceVideoStream(newStream);
  };
  /**
   * Replaces the current audio stream with the new stream
   * if you have produced a stream with label `audio` or used the default function `enableAudio` and you want to replace it with a new stream
   * @param stream - New Audio Stream
   *
   */
  replaceAudioStream = async (stream) => {
    await this.replaceStream({
      label: "audio",
      newStream: stream
    });
  };
  /**
   * Replace the current stream with the new stream based on the label used to produce the stream
   *
   * @example
   * For Video
   * await localPeer.replaceStream({
   *  label: 'video',
   *  newStream: newStream
   * })
   *
   * For Screen-Share
   * await localPeer.replaceStream({
   *  label: 'screen-share-video',
   *  newStream: newStream
   * })
   *
   * If any custom label used
   * await localPeer.replaceStream({
   *  label: 'custom',
   *  newStream: newStream
   * })
   *
   * @param data - { label: string, newStream: MediaStream }
   */
  replaceStream = async (data) => {
    logger.info(`\u{1F514} Replacing ${data.label} Stream `);
    const producer = this.getProducerWithLabel(data.label);
    const track = data.newStream.getTracks()[0];
    if (track) {
      track.addEventListener("ended", () => {
        this.stopProducing({ label: data.label });
      });
    }
    if (producer) {
      await producer.replaceTrack({ track });
    }
    const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
    const prevStream = this.__activeStreams.get(closedStreamLabel);
    if (prevStream && !this.__waitingToProduce.has(closedStreamLabel)) {
      this.deviceHandler.stopStream(prevStream);
      this.__activeStreams.delete(closedStreamLabel);
      this.__activeStreams.set(closedStreamLabel, data.newStream);
    } else if (prevStream && this.__waitingToProduce.has(closedStreamLabel)) {
      for (const track2 of prevStream.getTracks()) {
        prevStream.removeTrack(track2);
        track2.stop();
      }
      for (const track2 of data.newStream.getTracks()) {
        prevStream.addTrack(track2);
      }
    }
    const mediaDeviceKind = getMediaDeviceKind(track);
    this.emit("stream-fetched", {
      label: data.label,
      stream: data.newStream,
      mediaKind: mediaDeviceKind
    });
  };
  /**
   * Changes the Audio source to the given deviceId, sets the preferred mic device as the given deviceId
   * @param deviceId
   */
  changeAudioSource = async (deviceId) => {
    this.deviceHandler.setPreferredDevice({
      deviceId,
      deviceKind: "mic"
    });
    const stream = this.__activeStreams.get("audio");
    if (!stream) {
      return;
    }
    const { stream: newStream } = await this.deviceHandler.fetchStream({
      mediaDeviceKind: "mic"
    });
    if (!newStream)
      return;
    await this.replaceAudioStream(newStream);
  };
  /**
   * Stops the underlying producing of a microphone stream, stops the local track and closes the producer
   *
   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
   */
  disableAudio = async () => {
    this.stopProducing({
      label: "audio"
    });
  };
  /**
   * Stops the underlying producing of a screen-share stream, stops the local track and closes the producer
   *
   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
   */
  stopScreenShare = async () => {
    try {
      this.stopProducing({
        label: "screen-share-video"
      });
      this.stopProducing({
        label: "screen-share-audio"
      });
    } catch (error) {
      logger.error(error);
      logger.error("Error Disabling Screen Share");
    }
  };
  /**
   * Consumes a stream with the producerId and peerId of the RemotePeer, appData is application level custom data which
   * can be added to the consumer for the LocalPeer, this data will be available in the consumer object and can be used only by the LocalPeer.
   *
   * `NOTE: This will not notify the RemotePeers that you are consuming a stream, you have to notify them manually`
   * @summary Every time a RemotePeer is producing a Media in the Room, LocalPeer will be notified about it and it will be able to consume it.
   * Consuming is a process where the media is received from the RemotePeer and the stream can be played on the LocalPeers device.
   *
   * To get the consumer back you can use
   *
   * const remotePeer = this.room.getRemotePeerById(data.peerId);
   *
   * `remotePeer.on('stream-playable', ({ label: string; consumer: Consumer }) => {})`
   *
   * @param data - {peerId: string, label: string, appData: Record<string, unknown>}
   *
   */
  consume = checkPermissions({
    canConsume: true
  }).validate(
    async (data) => {
      const remotePeer = this.__remotePeers.get(data.peerId);
      if (!remotePeer) {
        throw new Error(`Remote Peer Not Found with PeerId ${data.peerId}`);
      }
      const labelData = remotePeer.getLabelData(data.label);
      if (!labelData) {
        throw new Error(
          `Remote Peer is not producing with Label ${data.label}`
        );
      }
      const consumerExists = remotePeer.getConsumer(data.label);
      if (consumerExists?.consuming) {
        logger.warn("\u{1F514} Consumer Already Exists with label ", data.label);
        return consumerExists;
      }
      const pendingPromise = this.__pendingConsumerTasks.get(
        labelData?.producerId
      );
      if (pendingPromise) {
        logger.warn(
          `\u{1F514} Consumer Task Pending to be Consumed with label ${data.label}, Returning`
        );
        const consumer2 = await pendingPromise;
        return consumer2;
      }
      logger.info("\u{1F514} Consuming Stream with label ", data.label);
      if (!this.__recvTransport) {
        logger.info(
          "\u{1F514} Recv Transport Not Initialized, Creaitng RecvTransport"
        );
        await this.__createTransportOnServer({
          transportType: "recv"
        });
      }
      const consumerPromise = new Promise((resolve) => {
        const handleStreamPlayable = (streamData) => {
          if (streamData.label === data.label) {
            remotePeer.off("stream-playable", handleStreamPlayable);
            resolve(streamData.consumer);
          }
        };
        remotePeer.once("stream-playable", handleStreamPlayable);
        this.socket.publish("consume", {
          createConsumerData: {
            appData: data.appData,
            producerId: labelData.producerId,
            producerPeerId: data.peerId
          }
        });
      });
      this.__pendingConsumerTasks.set(labelData.producerId, consumerPromise);
      const consumer = await consumerPromise.catch((error) => {
        logger.error("\u274C Error Consuming Stream");
        logger.error(error);
        throw error;
      }).finally(() => {
        this.__pendingConsumerTasks.delete(labelData.producerId);
      });
      return consumer;
    }
  );
  /**
   * Stops the underlying consuming of a stream for a particular label
   *
   * `NOTE: This does not notify the remote peers that you are not consuming a stream`
   *
   * @param data
   */
  stopConsuming = (data) => {
    const remotePeer = this.room.getRemotePeerById(data.peerId);
    if (!remotePeer.hasLabel(data.label)) {
      logger.error(
        `\u274C Remote Peer is not producing anything with label: ${data.label}`
      );
      return;
    }
    const consumer = this.recvTransport.getConsumer(data);
    if (!consumer) {
      logger.error("\u274C Consumer Not Found", data);
      return;
    }
    if (!consumer.consuming) {
      logger.error("\u274C You are not Consuming any Stream, Consumer Not Found");
      return;
    }
    const consumerId = consumer.id;
    if (!consumerId) {
      logger.error("\u274C ConsumerId Not Found");
      return;
    }
    this.socket.publish("closeConsumer", {
      consumerId: consumer.id
    });
    remotePeer.emit("stream-closed", {
      label: data.label
    });
    this.recvTransport.closeConsumer(data);
  };
  /**
   * Function to activate the volatile data messaging
   * @throws {Error} If activation of notification fails.
   */
  activateSpeakerNotification = async () => {
    logger.info("\u{1F514} Activating Speaker Notification, size: '9'");
    const botDataProducer = this.__sendTransport?.dataProducers.get("bot");
    if (botDataProducer) {
      logger.info("\u{1F514} Bot Data Producer Already Exists");
      return;
    }
    const ongoingActiveSpeakerPromise = this.__pendingTasks.get("bot");
    if (ongoingActiveSpeakerPromise) {
      logger.info("\u{1F514} Bot Data Producer Task Already Pending");
      await ongoingActiveSpeakerPromise;
    } else {
      const activateNotificationPromise = async () => {
        if (!this.__recvTransport) {
          logger.info(
            "\u{1F514} Recv Transport Not Initialized, Creating RecvTransport"
          );
          await this.__createTransportOnServer({
            transportType: "recv"
          });
        }
        this.socket.publish("activateSpeakerNotification", {
          size: this.room.activeSpeakers.size
        });
      };
      const promise = activateNotificationPromise();
      this.__pendingTasks.set("bot", promise);
      await promise;
    }
  };
  sendData = checkPermissions({
    canSendData: true
  }).validate(
    (data) => {
      if (estimateSize(data.payload) > MAX_DATA_MESSAGE_SIZE) {
        logger.error("\u274C Data message exceeds 1kb in size");
        return;
      }
      this.socket.publish("sendData", data);
    }
  );
  produceData = () => {
    logger.info("\u{1F514} Producing Data,");
  };
  /**
   * Send Message to update the metadata of the Local Peer
   *
   * `NOTE: This will notify every user in the room about the metadata update`
   */
  updateMetadata = checkPermissions({
    canUpdateMetadata: true
  }).validate((data) => {
    if (!this.joined) {
      logger.error(
        "\u274C Cannot Update Metadata, You have not joined the room yet"
      );
      return;
    }
    const peerId = this.peerId;
    if (!peerId) {
      logger.error("\u274C Cannot Update Metadata, PeerId Not Found");
      return;
    }
    const newMetadata = JSON.stringify(data);
    this.socket.publish("updatePeerMetadata", {
      peerId,
      metadata: newMetadata
    });
  });
  /**
   * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
   */
  updateRole = (data) => {
    try {
      if (!this.joined) {
        throw new Error(
          "\u274C Cannot Update Role, You have not joined the room yet"
        );
      }
      if (data.role === this.role) {
        logger.warn("\u{1F514} Peer Role is already set to", data.role);
        return;
      }
      if (!this.peerId) {
        logger.error(
          "\u274C Cannot Update Role, PeerId Not Found, (You have not joined the room yet)"
        );
        return;
      }
      this.socket.publish("updatePeerRole", {
        peerId: this.peerId,
        role: data.role
      });
    } catch (error) {
      logger.error("\u{1F514} Error Updating Role", data);
      logger.error(error);
    }
  };
  __handler = {
    error: (data) => {
      logger.error("\u274C Error Event");
      logger.error(data);
    },
    /**
     * When Huddle01 Node has successfully accepted the connection request
     * it sents back some usefull metadata for the client to use
     * at this point the socket is assumed to the connected and the localPeer is ready to join the room
     *
     * @param data - Data from server { peerId }
     */
    hello: (data) => {
      logger.info("\u2705 Hello From Server, Connection Success");
      logger.info(data);
      this.peerId = data.peerId;
      this.__permissions.updatePermissions(data.acl);
      if (data.role)
        this.__permissions.role = data.role;
      this.emit("permissions-updated", {
        permissions: data.acl,
        role: data.role
      });
      if (data.metadata) {
        this.__updateMetadata(data.metadata);
      }
    },
    waitingRoom: (data) => {
      logger.info("\u{1F514} Waiting Room");
      this.room.emit("room-waiting", data);
    },
    /**
     * @description Uponn successful joining of the room, the server sends back some usefull metadata such as remotePeers in the room.
     * @emits "room-joined" - When the client has successfully joined the room.
     * @emits "join-error" - When the client has failed to join the room.
     * @param data - Data from server { roomId, roomInfo, routerRTPCapabilities, turnServer }
     */
    connectRoomResponse: async (data) => {
      logger.info("\u2705 Join Success Event");
      logger.info({ roomInfo: data.roomInfo });
      try {
        const { roomInfo, routerRTPCapabilities, turnServers } = data;
        this.room.config = roomInfo.config;
        this.room.metadata = roomInfo.metadata;
        const deviceType = detectDevice();
        if (!deviceType) {
          logger.error(
            "\u274C Device is not supported, valid devices are : 'Chrome111' | 'Chrome74' | 'Chrome70' | 'Chrome67' | 'Chrome55' | 'Firefox60' | 'Safari12' | 'Safari11' | 'Edge11' | 'ReactNativeUnifiedPlan' | 'ReactNative'"
          );
          throw new Error("\u274C Device is not supported");
        }
        this.__device = new Device({ handlerName: deviceType });
        await this.__device.load({
          routerRtpCapabilities: routerRTPCapabilities
        });
        if (!this.device.loaded) {
          throw new Error("\u274C Cannot Load Device");
        }
        this.emit("device-created", { device: this.__device });
        this.__setRemotePeers(roomInfo);
        this.__setLobbyPeers(roomInfo);
        if (turnServers.length) {
          logger.info("\u{1F514} Setting Turn Server", turnServers);
          this.__turn = [...turnServers, ...this.__turn];
        }
        this.room.state = "connected";
        this.joined = true;
        this.room.emit("room-joined");
      } catch (error) {
        logger.error("\u274C Error Joining Room");
        logger.error(error);
        this.room.emit("room-joined-failed", {
          message: "\u274C Error Joining Room",
          status: "ROOM_ERRORED"
        });
      }
      this.__handleWaitingToProduce();
    },
    /**
     * @description update the remote peers in the room , remove the remote peers which are not in the room anymore
     * @param roomInfo
     */
    syncMeetingStateResponse: async (roomInfo) => {
      try {
        logger.info("\u2705 Client recovered after reconnecting");
        const { peers: latestPeers } = roomInfo;
        const latestPeersSet = new Set(latestPeers.map((p) => p.peerId));
        for (const [peerId, peer] of this.__remotePeers.entries()) {
          if (!latestPeersSet.has(peerId)) {
            for (const label of peer.labels) {
              this.__closeRemotePeerConsumer({
                peerId,
                label
              });
            }
            peer.close();
            this.__remotePeers.delete(peerId);
            this.room.emit("peer-left", peerId);
            return;
          }
          const latestPeerInfo = latestPeers.find((p) => p.peerId === peerId);
          if (!latestPeerInfo)
            return;
          const newProducerSet = new Set(
            latestPeerInfo.producers.map((p) => p.label)
          );
          for (const label of peer.labels) {
            if (!newProducerSet.has(label)) {
              this.__closeRemotePeerConsumer({ peerId, label });
            }
          }
          const currentProducerSet = new Set(peer.producerIds);
          for (const producer of latestPeerInfo.producers) {
            if (!currentProducerSet.has(producer.id)) {
              if (!this.__recvTransport || this.__recvTransport.connectionState === "connected") {
                peer._addLabelData({
                  producerId: producer.id,
                  label: producer.label
                });
              } else {
                this.__waitingToConsume.push(() => {
                  return peer._addLabelData({
                    producerId: producer.id,
                    label: producer.label
                  });
                });
              }
            }
          }
        }
        const filteredPeers = latestPeers.filter(
          (latestPeer) => !this.__remotePeers.has(latestPeer.peerId) && latestPeer.peerId !== this.peerId
        ).values();
        for (const latestPeer of filteredPeers) {
          const remotePeer = new RemotePeer_default({
            peerId: latestPeer.peerId,
            role: latestPeer.role,
            metadata: latestPeer.metadata
          });
          const remoteProducers = latestPeer.producers;
          for (const p of remoteProducers) {
            if (!this.__recvTransport || this.__recvTransport.connectionState === "connected") {
              remotePeer._addLabelData({ producerId: p.id, label: p.label });
            } else {
              this.__waitingToConsume.push(() => {
                return remotePeer._addLabelData({
                  producerId: p.id,
                  label: p.label
                });
              });
            }
          }
          this.__remotePeers.set(latestPeer.peerId, remotePeer);
          this.room.emit("new-peer-joined", { peer: remotePeer });
        }
      } catch (error) {
        logger.error("\u274C Error Syncing Meeting State, Can't Recover");
        logger.error(error);
      }
    },
    /**
     * Upon creation of server side transport, the server sends back some usefull metadata for the client to use
     * to create a client side transport, i.e. `send | recv` Transport.
     * @param data - Data from server { transportSDPInfo, transportType }
     */
    createTransportOnClient: async (data) => {
      try {
        const device = this.device;
        if (!this.peerId)
          throw new Error(
            "\u274C Cannot Create Transport, No PeerId Found for the user."
          );
        const transport = Transport_default.create({
          device,
          peerId: this.peerId,
          socket: this.socket,
          sdpInfo: data.transportSDPInfo,
          iceServers: this.__turn,
          transportType: data.transportType
        });
        if (transport.transportType === "send") {
          this.__sendTransport = transport;
          this.__sendTransport.mediasoupTransport.on(
            "connectionstatechange",
            (connectionState) => {
              if (connectionState === "connected") {
                this.__handleWaitingToProduce();
              }
            }
          );
          this.emit("new-send-transport", {
            transport
          });
        }
        if (transport.transportType === "recv") {
          this.__recvTransport = transport;
          this.__recvTransport.mediasoupTransport.on(
            "connectionstatechange",
            (connectionState) => {
              if (connectionState === "connected") {
                this.__handleWaitingToConsume();
              }
            }
          );
          this.emit("new-recv-transport", {
            transport
          });
        }
      } catch (error) {
        logger.error(
          "\u274C Error Creating MediasoupTransport On Client, transportType",
          data.transportType
        );
        logger.error(error);
      }
    },
    /**
     * !Important
     * When the server has successfully connected the transport, it sends a ack back to the client
     * which handles the callback() function which triggers the process of creation of producer and consumer
     * for reference see: packages/nezuko/src/Transport.ts
     * @param data
     */
    connectTransportResponse: async (data) => {
      logger.info(
        `\u2705 Connect ${data.transportType} Transport On Server Response`
      );
      try {
        const transportType = data.transportType;
        const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (!transport) {
          throw new Error(`${transportType} Transport Not Initialized`);
        }
        transport.emit("connectTransportResponse");
      } catch (error) {
        logger.error("\u274C Error Connecting Transport On Server Response");
        logger.error(error);
      }
    },
    produceResponse: async (data) => {
      logger.info("\u2705 Produce Response");
      logger.info(data);
      try {
        const { peerId, producerId, label } = data;
        if (peerId === this.peerId) {
          this.sendTransport.resolvePendingProducerTask({
            id: producerId,
            label,
            peerId
          });
        } else {
          const remotePeer = this.room.getRemotePeerById(peerId);
          if (!this.__recvTransport || this.__recvTransport.connectionState === "connected") {
            remotePeer._addLabelData({
              producerId,
              label
            });
          } else {
            this.__waitingToConsume.push(() => {
              return remotePeer._addLabelData({
                producerId,
                label
              });
            });
          }
        }
      } catch (error) {
        logger.error("\u274C Error Produce Response");
        logger.error(error);
      }
    },
    produceDataResponse: async (data) => {
      logger.info("\u2705 Produce Data Response consumerIdFromServer:%o", data.id);
      logger.info(data);
      try {
        const {
          id,
          peerId,
          dataProducerId,
          label,
          appData,
          protocol,
          sctpStreamParameters
        } = data;
        if (peerId === this.peerId && label !== "bot") {
          this.sendTransport.resolvePendingProducerTask({
            id: dataProducerId,
            label,
            peerId
          });
        }
        const botDataConsumer = this.recvTransport.dataConsumers.get(label);
        if (botDataConsumer) {
          logger.error("\u274C Bot Data Consumer Already Exists, Can't Create", {
            label
          });
          return;
        }
        const dataConsumer = await this.recvTransport.consumeData({
          appData,
          dataProducerId,
          id,
          label,
          peerId,
          protocol,
          sctpStreamParameters
        });
        dataConsumer.on("message", (message) => {
          const parsedJsonData = JSON.parse(message);
          const result = VolatileDataMessageSchema.safeParse(parsedJsonData);
          if (result.success) {
            this.emit("receive-volatile-data", result.data);
          } else {
            throw new Error(
              "\u274C Data Consumer Message Schema Validation Failed"
            );
          }
        });
        if (label === "bot") {
          this.__pendingTasks.delete("bot");
        }
      } catch (error) {
        logger.error("\u274C Error Produce Data Response");
        logger.error({ error });
      }
    },
    consumeResponse: async (data) => {
      logger.info("\u2705 Consume Response");
      logger.info({
        id: data.consumerId,
        label: data.label,
        consumerId: data.consumerId,
        producerPeerId: data.producerPeerId
      });
      try {
        const remotePeer = this.room.getRemotePeerById(data.producerPeerId);
        if (!remotePeer.hasLabel(data.label)) {
          logger.error("\u274C Remote Peer is not producing this label", {
            label: data.label
          });
          throw new Error(
            `\u274C Remote Peer is not producing this label: ${data.label}`
          );
        }
        const { consumer, mediaSoupConsumer } = await this.recvTransport.consume(data);
        remotePeer.emit("stream-playable", {
          consumer,
          label: consumer.label
        });
        this.room.emit("stream-added", {
          label: consumer.label,
          peerId: data.producerPeerId
        });
        this.socket.publish("resumeConsumer", {
          consumerId: data.consumerId,
          producerPeerId: data.producerPeerId
        });
        mediaSoupConsumer.resume();
      } catch (error) {
        logger.error("\u274C Error Consume Response");
        logger.error(error);
        this.__pendingConsumerTasks.delete(data.producerId);
      }
    },
    closeProducerSuccess: async (data) => {
      logger.info("\u2705 Producer Closed", data);
      if (this.peerId === data.peerId)
        return;
      const { peerId, label } = data;
      try {
        this.__closeRemotePeerConsumer({
          peerId,
          label
        });
      } catch (err) {
        logger.error("\u274C Error Closing Producer");
        logger.error(err);
      }
    },
    closeConsumerSuccess: async (data) => {
      logger.info("\u2705 Consumer Closed, ", data);
    },
    restartTransportIceResponse: async (data) => {
      const { transportType, iceParameters } = data;
      logger.info("\u2705 Restart Transport Ice Response ", transportType);
      const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
      if (!transport) {
        logger.error(`\u274C ${transportType} Transport Not Found`);
        return;
      }
      try {
        await transport.mediasoupTransport.restartIce({ iceParameters });
        logger.info("\u2705 Restarted Ice for type: ", transportType);
      } catch (error) {
        logger.error("\u274C Error Restarting Ice for type: ", transportType);
        logger.error(error);
      }
    },
    newPeerJoined: (data) => {
      if (this.peerId === data.peerId)
        return;
      logger.info("\u2705 New Peer Joined", { data });
      try {
        const { peerId } = data;
        const remotePeer = new RemotePeer_default({
          peerId,
          role: data.role,
          metadata: data.metadata
        });
        this.__remotePeers.set(peerId, remotePeer);
        const lobbyPeers = this.room.lobbyPeersMap;
        if (lobbyPeers.has(peerId)) {
          lobbyPeers.delete(peerId);
          this.room.lobbyPeersMap = lobbyPeers;
        }
        this.room.emit("new-peer-joined", { peer: remotePeer });
      } catch (error) {
        logger.error("\u274C Error New Peer Joined");
        logger.error(error);
      }
    },
    newLobbyPeer: (data) => {
      try {
        logger.info("\u2705 New Lobby Peer", { data });
        this.room.newlobbyPeers = [data];
      } catch (error) {
        logger.error("\u274C Error New Lobb Peer");
        logger.error(error);
      }
    },
    newPermissions: (data) => {
      try {
        this.__permissions.updatePermissions(data);
        this.emit("permissions-updated", {
          permissions: this.permissions
        });
      } catch (error) {
        logger.error("\u274C Error Updating Permissions");
        logger.error(error);
      }
    },
    newRoomControls: (data) => {
      logger.info("\u2705 Received New Room Controls", { data });
      this.room.config = {
        ...this.room.config,
        [data.type]: data.value
      };
      this.room.emit("room-controls-updated", data);
    },
    newPeerRole: (data) => {
      logger.info("\u2705 Received New Peer's Role", { data });
      try {
        const { peerId, role } = data;
        if (peerId === this.peerId) {
          logger.info("\u2705 Updating Local Peer's Role");
          this.__permissions.role = role;
          this.emit("role-updated", {
            role
          });
          return;
        }
        const remotePeer = this.room.getRemotePeerById(peerId);
        const prevRole = remotePeer.role || "";
        remotePeer.role = role;
        this.room.emit("room-role-updated", {
          peerId,
          newRole: role,
          prevRole
        });
      } catch (error) {
        logger.error("\u274C Error Updating Peer's Role");
        logger.error(error);
      }
    },
    roomClosedProducers: (data) => {
      logger.info("\u2705 Received Room's Closed Producers", { data });
      try {
        const { producers, reason } = data;
        for (const producer of producers) {
          const { label, peerId } = producer;
          if (peerId === this.peerId) {
            this.stopProducing({ label });
            continue;
          }
          try {
            const remotePeer = this.room.getRemotePeerById(peerId);
            const consumer = this.recvTransport.getConsumer({
              label,
              peerId
            });
            if (consumer) {
              this.recvTransport.closeConsumer({ label, peerId });
              remotePeer._removeLabelData(label);
              this.room.emit("stream-closed", {
                label,
                peerId
              });
            }
          } catch (error) {
            logger.error("\u274C Error Closing Producer");
            logger.error(error);
          }
        }
        this.room.emit("room-notification", reason);
      } catch (error) {
        logger.error("\u274C Error Updating Room's Closed Producers");
        logger.error(error);
      }
    },
    receiveData: (data) => {
      logger.info("\u2705 Received Data", { data });
      try {
        this.emit("receive-data", data);
      } catch (error) {
        logger.error("\u274C Error Receive Data");
        logger.error(error);
      }
    },
    peerMetadataUpdated: (data) => {
      try {
        logger.info("\u2705 Metadata Updated", { data });
        const { peerId, metadata } = data;
        if (this.peerId === peerId) {
          this.__updateMetadata(data.metadata);
          return;
        }
        const remotePeer = this.room.getRemotePeerById(peerId);
        remotePeer.metadata = JSON.parse(metadata);
      } catch (error) {
        logger.error("\u274C Error Updating Metadata");
        logger.error(error);
      }
    },
    roomMetadataUpdated: (data) => {
      logger.info("\u2705 Room Metadata Updated", { data });
      try {
        const { metadata } = data;
        this.room.metadata = metadata;
      } catch (error) {
        logger.error("\u274C Error Updating Room Metadata");
        logger.error(error);
      }
    },
    peerLeft: (data) => {
      logger.info("\u2705 Peer Left", { peerId: data.peerId });
      try {
        const { peerId } = data;
        const remotePeer = this.room.getRemotePeerById(peerId);
        const labels = remotePeer.labels;
        for (const label of labels) {
          this.__closeRemotePeerConsumer({
            peerId: remotePeer.peerId,
            label
          });
        }
        remotePeer.close();
        this.__remotePeers.delete(peerId);
        this.room.emit("peer-left", data.peerId);
      } catch (error) {
        logger.error("\u274C Error Peer Left");
        logger.error(error);
      }
    },
    lobbyPeerLeft: (data) => {
      logger.info("\u2705 Lobby Peer Left", { peerId: data.peerId });
      try {
        const { peerId } = data;
        const lobbyPeers = this.room.lobbyPeersMap;
        if (lobbyPeers.has(peerId)) {
          lobbyPeers.delete(peerId);
          this.room.lobbyPeersMap = lobbyPeers;
        }
      } catch (error) {
        logger.error("\u274C Error Lobby Peer's Left");
        logger.error(error);
      }
    }
  };
  /**
   * @description Creates a Producer, if send transport is not initialized, it creates one and then creates a producer
   * @param data - Data to create a producer { label, stream, stopTrackOnClose, appData }
   * @returns - Producer
   */
  __createProducer = async (data) => {
    if (!this.__sendTransport) {
      throw new Error("\u274C Send Transport Not Initialized, Internal Error");
    }
    const producer = await this.__sendTransport.produce({
      stream: data.stream,
      stopTrackOnClose: data.stopTrackOnClose ?? true,
      label: data.label,
      appData: {
        ...data.appData,
        label: data.label
      }
    });
    producer.on("transportclose", () => {
      this.stopProducing({ label: data.label });
    });
    this.emit("stream-playable", {
      label: data.label,
      producer
    });
    return producer;
  };
  __createTransportOnServer = async (data) => {
    const pendingPromise = this.__pendingTransportTasks.get(data.transportType);
    if (pendingPromise) {
      logger.info(
        `\u{1F514} Transport Task Already Pending for this transportType ${data.transportType}`
      );
      return pendingPromise;
    }
    const { transportType } = data;
    const promise = new Promise((resolve, reject) => {
      const handleNewTransport = (data2) => {
        if (data2.transport.transportType === transportType) {
          this.__pendingTransportTasks.delete(transportType);
          resolve(data2.transport);
        }
      };
      if (transportType === "send") {
        this.once("new-send-transport", handleNewTransport);
      }
      if (transportType === "recv") {
        this.once("new-recv-transport", handleNewTransport);
      }
      const device = this.device;
      const transport = data.transportType === "send" ? this.__sendTransport : this.__recvTransport;
      if (transport) {
        reject(
          new Error(`\u274C Transport Already Initialized, type: ${transportType}`)
        );
      }
      logger.info(`\u{1F514} Creating ${data.transportType} Transport On Server`);
      this.socket.publish("createTransport", {
        sctpCapabilities: device.sctpCapabilities,
        transportType
      });
    });
    this.__pendingTransportTasks.set(data.transportType, promise);
    return promise;
  };
  /**
   * Sets the Remote Peers in the Room
   * @param roomInfo
   */
  __setRemotePeers = (roomInfo) => {
    this.__remotePeers.clear();
    const { peers } = roomInfo;
    for (const peer of peers) {
      if (peer.peerId === this.peerId)
        continue;
      const remotePeer = new RemotePeer_default({
        peerId: peer.peerId,
        metadata: peer.metadata,
        role: peer.role
      });
      const producers = peer.producers;
      this.__remotePeers.set(peer.peerId, remotePeer);
      producers.map((p) => {
        if (!this.__recvTransport || this.__recvTransport.connectionState === "connected") {
          remotePeer._addLabelData({
            producerId: p.id,
            label: p.label
          });
        } else {
          this.__waitingToConsume.push(() => {
            return remotePeer._addLabelData({
              producerId: p.id,
              label: p.label
            });
          });
        }
      });
    }
  };
  /**
   * Sets the Lobby Peers in the Room
   * @param roomInfo - RoomInfo
   */
  __setLobbyPeers = (roomInfo) => {
    this.room.lobbyPeers.clear();
    const { lobbyPeers } = roomInfo;
    this.room.newlobbyPeers = lobbyPeers;
  };
  /**
   * Helper Function to close the consumer of a remote peer
   * @param data - Data to close the consumer { peerId, label }
   */
  __closeRemotePeerConsumer = (data) => {
    try {
      const { peerId, label } = data;
      const remotePeer = this.room.getRemotePeerById(peerId);
      const consumer = this.recvTransport.getConsumer({
        label,
        peerId
      });
      if (consumer) {
        this.recvTransport.closeConsumer({ label, peerId });
        remotePeer._removeLabelData(label);
      }
      this.room.emit("stream-closed", {
        label,
        peerId: data.peerId
      });
    } catch (error) {
      logger.error("\u274C Error Closing Remote Peer's Consumer");
      logger.error(error);
    }
  };
  /**
   * !important
   * Handler Function to handle the waiting to produce tasks when user is joining
   * the room with active stream, check if the user has valid permissions and based on
   * that allows the user to produce the stream
   */
  __handleWaitingToProduce = () => {
    try {
      const permissions = this.permissions;
      const closeStream = (label) => {
        const stream = this.__activeStreams.get(label);
        if (stream) {
          this.deviceHandler.stopStream(stream);
          this.__activeStreams.delete(label);
          this.emit("stream-closed", {
            label,
            reason: {
              code: 4444,
              message: "User's Permissions Denied",
              tag: "CLOSED_BY_ADMIN"
            }
          });
        }
        this.__waitingToProduce.delete(label);
      };
      if (!permissions.canProduce) {
        for (const [label, _] of this.__waitingToProduce) {
          closeStream(label);
        }
        this.__waitingToProduce.clear();
        return;
      }
      for (const [label, pendingStreamTask] of this.__waitingToProduce) {
        if (label === "video" && !permissions.canProduceSources.cam) {
          closeStream(label);
          continue;
        }
        if (label === "audio" && !permissions.canProduceSources.mic) {
          closeStream(label);
          continue;
        }
        pendingStreamTask().catch((error) => {
          logger.error(
            "\u274C Error Producing Stream which was waiting to be produced with label :",
            label
          );
          logger.error(error);
          closeStream(label);
        });
      }
      this.__waitingToProduce.clear();
    } catch (error) {
      logger.error("\u274C Error Handling Waiting To Produce");
      logger.error(error);
    }
  };
  __handleWaitingToConsume = () => {
    for (const consumeTask of this.__waitingToConsume) {
      consumeTask().catch(() => {
        logger.error("Unable to Consume after ice restart");
      });
    }
    this.__waitingToConsume = [];
  };
  testEvent = (data) => {
    try {
      if (!this.peerId) {
        throw new Error("\u274C Cannot Test Event, PeerId Not Found");
      }
      this.socket.publish("testEvent", {
        break: data.break,
        peerId: this.peerId
      });
    } catch (error) {
      logger.error("\u274C Error Test Event");
    }
  };
};
var LocalPeer_default = LocalPeer;

// src/RemotePeer.ts
var logger2 = mainLogger.createSubLogger("RemotePeer");
var RemotePeer = class extends EnhancedEventEmitter {
  /**
   * peerId of the remote peer, this is unique for each peer
   */
  peerId;
  /**
   * Stores the Metadata for the Remote Peer.
   */
  __metadata = "{}";
  /**
   * Stores the Role of the Remote Peer.
   */
  __role = null;
  /**
   * Labels are the unique identifier for the media stream that the remote peer is producing
   */
  __labelsToProducerId = /* @__PURE__ */ new Map();
  /**
   * Returns the list of labels that the remote peer is producing
   */
  get labels() {
    return Array.from(this.__labelsToProducerId.keys());
  }
  get producerIds() {
    return Array.from(this.__labelsToProducerId.values()).map(
      (labelData) => labelData.producerId
    );
  }
  /**
   * Role of the Peer.
   * @returns The Role of the Peer which if passed in the options when creating the token
   */
  get role() {
    if (!this.__role)
      return null;
    return this.__role;
  }
  set role(role) {
    this.__role = role;
    this.emit("role-updated", {
      role
    });
  }
  /**
   * Checks if the remote peer is producing the label
   * @param label - Label to check if the remote peer is producing
   * @returns - Returns true if the remote peer is producing the label
   */
  hasLabel(label) {
    return this.__labelsToProducerId.has(label);
  }
  /**
   * Returns the data associated to the label, this is the producerId
   *
   * @returns
   * producerId - Unique identifier for the producer
   */
  getLabelData(label) {
    return this.__labelsToProducerId.get(label);
  }
  /**
   * Get the associated consumer for the label
   * @param label - Unique identifier for the consumer e.g. `video` | `audio` | `screen-share-video` | string
   * @returns Consumer | null
   */
  getConsumer(label) {
    try {
      const localPeer = LocalPeer_default.getInstance();
      const consumer = localPeer.recvTransport.getConsumer({
        label,
        peerId: this.peerId
      });
      return consumer;
    } catch (error) {
      return null;
    }
  }
  /**
   * Returns the metadata associated to the RemotePeer
   */
  getMetadata() {
    return this.__metadata;
  }
  /**
   * Setter function to update the Remote Peer Metadata
   *
   * `NOTE: This will NOT notify other Remote Peers of the update`
   */
  set metadata(data) {
    this.__metadata = data;
    this.emit("metadata-updated", {
      metadata: data
    });
  }
  /**
   * Update the Permissions of the Remote Peer in the Room. This will emit an event `updated` with the updated permissions.
   */
  updatePermissions = checkPermissions({
    admin: true
  }).validate(async (data) => {
    try {
      logger2.info("\u{1F514} Updating Permissions", data);
      const localPeer = LocalPeer_default.getInstance();
      const socket = localPeer.socket;
      socket.publish("updatePeerPermission", {
        peerId: this.peerId,
        permission: data
      });
    } catch (error) {
      logger2.error("\u{1F514} Error Updating Permissions");
      logger2.error(error);
    }
  });
  /**
   * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
   */
  updateRole = checkPermissions({
    admin: true
  }).validate((data) => {
    try {
      logger2.info("\u{1F514} Updating Peer Role", data);
      if (data.role === this.__role) {
        logger2.warn("\u{1F514} Role is already set to", data.role);
        return;
      }
      const localPeer = LocalPeer_default.getInstance();
      const socket = localPeer.socket;
      socket.publish("updatePeerRole", {
        peerId: this.peerId,
        role: data.role
      });
    } catch (error) {
      logger2.error("\u{1F514} Error Updating Role", data);
      logger2.error(error);
    }
  });
  /**
   * Removes all the states of the remote peer and clears memory;
   *
   * `NOTE`: You need to close consumers using the `recvTransport.closeConsumer` of the local peer
   */
  close = () => {
    logger2.info("Closing Remote Peer");
    this.removeAllListeners();
  };
  constructor(data) {
    super();
    this.peerId = data.peerId;
    if (data.metadata) {
      this.metadata = JSON.parse(data.metadata);
    }
    if (data.role) {
      this.__role = data.role;
    }
  }
  /**
   * @protected
   * Add a New Label to the Remote Peer and associate it with the ProducerId
   *
   * `NOTE: This is used internally by the Peer`
   *
   * @param data - Data to add the new label `label` and the `producerId` to associate it with
   */
  _addLabelData = async (data) => {
    const { label, producerId } = data;
    this.__labelsToProducerId.set(label, { producerId });
    try {
      const autoConsume = Room_default.getInstance().autoConsume;
      const localPeer = LocalPeer_default.getInstance();
      if (autoConsume) {
        logger2.debug(
          "AUTO CONSUME IS ENABLED, CONSUMING THE PRODUCER'S STREAM"
        );
        localPeer.consume({
          appData: {},
          label,
          peerId: this.peerId
        });
      } else {
        this.emit("stream-available", {
          label,
          labelData: {
            producerId
          }
        });
      }
    } catch (error) {
      logger2.error("\u274C Error While Consuming", {
        label,
        peerId: this.peerId
      });
      logger2.error(error);
      this.emit("stream-available", {
        label,
        labelData: {
          producerId
        }
      });
    }
  };
  /**
   * @protected
   * Remove a Label from the Remote Peer and emit a `stream-closed` event
   *
   * `NOTE: This is used internally by the Peer`
   *
   * @param data - Data to remove the label from the Remote Peer
   */
  _removeLabelData = (label, reason) => {
    this.__labelsToProducerId.delete(label);
    this.emit("stream-closed", {
      label,
      reason
    });
  };
};
var RemotePeer_default = RemotePeer;

export {
  RemotePeer_default,
  LocalPeer_default
};
//# sourceMappingURL=chunk-BDLAILV7.js.map