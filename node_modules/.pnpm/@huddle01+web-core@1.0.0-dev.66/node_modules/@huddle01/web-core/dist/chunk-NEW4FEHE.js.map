{"version":3,"sources":["../src/Room.ts"],"sourcesContent":["import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter';\nimport Socket from './Socket';\nimport RemotePeer from './RemotePeer';\nimport { mainLogger } from './logger';\nimport { NewPeerJoined } from './types';\nimport { checkPermissions } from './Permissions';\nimport type { RoomInfo, NewRoomControls, ProduceSources } from './types';\n\nexport type RoomEvents = {\n  'room-joined': [];\n\n  'room-joined-failed': [\n    data: {\n      status: 'ROOM_NOT_FOUND' | 'ROOM_ERRORED';\n      message: string;\n    },\n  ];\n\n  /**\n   * Emitted when the room is left\n   */\n  'room-closed': [\n    {\n      reason: 'LEFT' | 'CLOSED' | 'KICKED' | 'DENIED';\n      message?: string;\n    },\n  ];\n\n  'room-connecting': [];\n\n  'new-peer-joined': [data: NewPeerJoined];\n\n  'lobby-peers-updated': [peerIds: string[]];\n\n  'metadata-updated': [data: { metadata: unknown }];\n\n  'peer-left': [peerId: string];\n\n  'room-controls-updated': [data: NewRoomControls];\n\n  'room-notification': [data: { tag: string; message: string; code: number }];\n\n  'room-role-updated': [\n    data: { peerId: string; newRole: string; prevRole: string },\n  ];\n\n  'room-waiting': [\n    data: {\n      reason:\n        | 'WAITING_FOR_PERMISSIONS'\n        | 'WAITING_FOR_ROOM_TO_START'\n        | 'WAITING_FOR_ADMIN_TO_JOIN';\n      message?: string;\n    },\n  ];\n\n  'stream-added': [data: { peerId: string; label: string }];\n\n  'stream-closed': [data: { peerId: string; label: string }];\n};\n\nexport type RoomStates =\n  | 'idle'\n  | 'connecting'\n  | 'connected'\n  | 'failed'\n  | 'left'\n  | 'closed';\n\nconst logger = mainLogger.createSubLogger('Room.ts');\nclass Room extends EnhancedEventEmitter<RoomEvents> {\n  /**\n   * Room Instance, Singleton class\n   */\n  private static __instance: Room | null = null;\n\n  /**\n   * Socket Instance, Singleton class\n   */\n  private __socket = Socket.getInstance();\n\n  /**\n   * Returns the instance of the socket connection\n   */\n  private get socket() {\n    return this.__socket;\n  }\n\n  /**\n   * Room Id of the current room\n   */\n  private __roomId: string | null = null;\n\n  /**\n   * Lobby PeerIds\n   */\n  private __lobbyPeers: Map<string, { peerId: string; metadata?: string }> =\n    new Map();\n\n  /**\n   * Removed Lobby PeerId from the lobby\n   * @param peerId - PeerId of the peer who joined the room\n   */\n  private removeLobbyPeer = (peerId: string) => {\n    this.__lobbyPeers.delete(peerId);\n\n    this.emit('lobby-peers-updated', this.lobbyPeerIds);\n  };\n\n  /**\n   * Room Config Object\n   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams\n   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams\n   * - `allowSendData`: Allow non-admin Peers in the Room to send data message\n   * - `roomLocked`: If the room is locked\n   */\n  private __config: RoomInfo['config'] = {\n    roomLocked: false,\n    allowProduce: true,\n    allowProduceSources: {\n      cam: true,\n      mic: true,\n      screen: true,\n    },\n    allowConsume: true,\n    allowSendData: true,\n  };\n\n  /**\n   * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers\n   *\n   * @default true\n   *\n   * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,\n   * - if set to false, the user will have to manually consume the media streams of the remote peers\n   * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  public readonly autoConsume: boolean = true;\n\n  /**\n   * If using activeSpeakerNotification, Returns back the size of peers which are returned for the activeSpeakers in the Room;\n   * `Default` value is 8\n   */\n  public readonly activeSpeakers = {\n    size: 8,\n  };\n\n  /**\n   * State of the Room\n   */\n  private __state: RoomStates = 'idle';\n\n  /**\n   * Set the state of the room\n   */\n  public set state(newState: RoomStates) {\n    if (this.state !== newState) {\n      this.__state = newState;\n    }\n  }\n\n  /**\n   * State of the room\n   */\n  public get state(): RoomStates {\n    return this.__state;\n  }\n\n  /**\n   * Get the lobby peers in the form of map\n   * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}\n   * @example\n   * ```ts\n   * const lobbyPeers = room.lobbyPeersMap;\n   *\n   * for (const [peerId, metadata] of lobbyPeers) {}\n   *\n   * ```\n   */\n  public get lobbyPeersMap() {\n    return this.__lobbyPeers;\n  }\n\n  /**\n   * Get lobby peers in the form of array\n   */\n  public get lobbyPeerIds() {\n    return Array.from(this.__lobbyPeers.keys());\n  }\n\n  /**\n   * Get lobby peers in the form of array\n   * @returns - Array of Lobby PeerIds\n   */\n  public get lobbyPeers() {\n    return this.__lobbyPeers;\n  }\n\n  /**\n   * Set lobby peers in the form of map\n   * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`\n   */\n  public set lobbyPeersMap(peers: Map<\n    string,\n    { peerId: string; metadata?: string }\n  >) {\n    this.__lobbyPeers = peers;\n\n    this.emit('lobby-peers-updated', this.lobbyPeerIds);\n  }\n\n  /**\n   * Get\n   * @returns\n   */\n  public getLobbyPeerMetadata = <T = unknown>(peerId: string) => {\n    const lobbyPeer = this.lobbyPeers.get(peerId);\n\n    let metadata = {} as T;\n\n    if (lobbyPeer?.metadata) {\n      metadata = JSON.parse(lobbyPeer.metadata) as T;\n    }\n\n    return {\n      peerId,\n      metadata,\n    };\n  };\n\n  /**\n   * Set lobby peers in the form of array\n   */\n  public set newlobbyPeers(peers: { peerId: string; metadata?: string }[]) {\n    for (const peer of peers) {\n      this.__lobbyPeers.set(peer.peerId, peer);\n    }\n\n    this.emit('lobby-peers-updated', this.lobbyPeerIds);\n  }\n\n  /**\n   * Room Config Object\n   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams\n   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams\n   * - `allowSendData`: Allow non-admin Peers in the Room to send data message\n   * - `roomLocked`: If the room is locked\n   */\n  public get config() {\n    return this.__config;\n  }\n\n  public set config(config: RoomInfo['config']) {\n    this.__config = config;\n  }\n\n  /**\n   * Remote Peers Map, Stores all the remote peers\n   */\n  public remotePeers: Map<string, RemotePeer> = new Map();\n\n  /**\n   * Metadata of the room.\n   */\n  private __metadata: string | null = '{}';\n\n  /**\n   * Setter function for the metadata of the room\n   * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`\n   * `To notify everyone in the room about the metadata change, use the updateMetadata function`\n   */\n  public set metadata(metadata: string) {\n    this.__metadata = metadata;\n\n    const parse = JSON.parse(metadata);\n\n    this.emit('metadata-updated', parse);\n  }\n\n  /**\n   * Get the metadata of the room\n   */\n  public getMetadata = <T = unknown>() => {\n    const data = JSON.parse(this.__metadata || '{}');\n\n    return data as T;\n  };\n\n  /**\n   * Update Metadata of the room\n   */\n  public updateMetadata = checkPermissions({}).validate(\n    <T = unknown>(data: T) => {\n      try {\n        if (\n          this.state === 'closed' ||\n          this.state === 'failed' ||\n          this.state === 'left'\n        ) {\n          logger.error(\n            'âŒ Cannot Update Metadata, You have not joined the room yet',\n          );\n\n          return;\n        }\n\n        const metadata = JSON.stringify(data);\n\n        this.metadata = metadata;\n\n        this.socket.publish('updateRoomMetadata', {\n          metadata,\n        });\n      } catch (error) {\n        logger.error('âŒ Error Updating Metadata');\n        logger.error(error);\n      }\n    },\n  );\n\n  /**\n   * Create a new Room Instance if not created, else return the existing Room Instance\n   *\n   * @returns - Room Instance\n   */\n  public static create(data?: {\n    autoConsume?: boolean;\n    activeSpeakers?: {\n      size: number;\n    };\n  }) {\n    if (Room.__instance) {\n      return Room.__instance;\n    }\n\n    logger.debug({ data });\n\n    Room.__instance = new Room(data);\n\n    return Room.__instance;\n  }\n\n  /**\n   * Get the Room Instance if its not initialized it will throw an error\n   * @returns - Room Instance\n   * @throws { Error } If the Room Instance is not initialized\n   */\n  public static getInstance = () => {\n    if (!Room.__instance) {\n      throw new Error('âŒ Room Instance Not Initialized');\n    }\n\n    return Room.__instance;\n  };\n\n  /**\n   * RoomId of the currently joined room.\n   */\n  public get roomId(): string | null {\n    if (!this.__roomId) return null;\n    return this.__roomId;\n  }\n\n  public set roomId(roomId: string) {\n    if (this.__roomId) {\n      logger.warn(\n        'RoomId is already set, Ignoring the new roomId, end this room and create a new room',\n      );\n      return;\n    }\n\n    this.__roomId = roomId;\n  }\n\n  /**\n   * Returns the PeerIds of the remote peers\n   */\n  public get peerIds() {\n    return Array.from(this.remotePeers.keys());\n  }\n\n  /**\n   * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData\n   * @param data: TNewRoomControls\n   */\n\n  public updateRoomControls = checkPermissions({\n    admin: true,\n  }).validate((data: NewRoomControls) => {\n    logger.info('ðŸ”” Updating Room Controls', data);\n\n    this.config[data.type] = data.value as boolean & ProduceSources;\n\n    this.emit('room-controls-updated', { ...data });\n\n    this.socket.publish('updateRoomControls', data);\n  });\n\n  /**\n   * Close a particular stream of remote peers\n   *  @param data: { label: string; peerIds?: string[] }\n   *  @param label: Label of the stream\n   *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers\n   */\n  public closeStreamOfLabel = checkPermissions({}).validate(\n    (data: { label: string; peerIds?: string[] }) => {\n      logger.info('ðŸ”” Closing Stream of Label', data);\n\n      this.socket.publish('closeStreamOfLabel', data);\n    },\n  );\n\n  /**\n   * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions\n   *\n   * `NOTE: This will target all the audio stream in the room with the label \"audio\"`\n   */\n  public muteEveryone = checkPermissions({ admin: true }).validate(() => {\n    logger.info('ðŸ”” Muting Everyone');\n\n    this.socket.publish('closeStreamOfLabel', {\n      label: 'audio',\n    });\n  });\n\n  /**\n   * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.\n   *\n   * @param peerId - PeerId of the remote peer\n   * @returns - RemotePeer Instance\n   * @return - null if the peer is not present in the room\n   */\n  public remotePeerExists = (peerId: string) => {\n    const peer = this.remotePeers.get(peerId);\n\n    if (!peer) {\n      return null;\n    }\n\n    return peer;\n  };\n\n  /**\n   * Returns the Remote Peer if present in room.\n   * @param peerId - PeerId of the remote peer\n   * @returns - RemotePeer Instance\n   * @throws { Error } If the Remote Peer is not found\n   */\n  public getRemotePeerById(peerId: string): RemotePeer {\n    const peer = this.remotePeers.get(peerId);\n\n    if (!peer) {\n      throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);\n    }\n\n    return peer;\n  }\n\n  private constructor(data?: {\n    autoConsume?: boolean;\n    activeSpeakers?: {\n      size: number;\n    };\n  }) {\n    super();\n    logger.debug({ data });\n    if (data?.activeSpeakers?.size) {\n      this.activeSpeakers.size = data?.activeSpeakers?.size;\n    }\n\n    if (data?.autoConsume !== undefined) {\n      this.autoConsume = data.autoConsume;\n    }\n  }\n\n  /**\n   * Connects to the room and returns the instance of the room\n   * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting\n   */\n  public connect = (): Room => {\n    if (Room.__instance === null) {\n      throw new Error('Room Instance Not Initialized');\n    }\n\n    if (!this.socket.connected) {\n      throw new Error('Socket is Not Connected');\n    }\n\n    if (this.socket.connecting) {\n      throw new Error('Socket is Connecting, Wait for it to be connected');\n    }\n\n    if (!this.roomId) {\n      throw new Error('Room Id is required to connect to the room');\n    }\n\n    this.socket.publish('connectRoom', { roomId: this.roomId });\n\n    this.__state = 'connecting';\n\n    this.emit('room-connecting');\n\n    return Room.__instance;\n  };\n\n  /**\n   * Admit a Peer to the room who is in the lobby\n   */\n  public admitPeer = checkPermissions({ admin: true }).validate(\n    (peerId: string) => {\n      try {\n        this.removeLobbyPeer(peerId);\n\n        this.socket.publish('acceptLobbyPeer', { peerId });\n      } catch (error) {\n        logger.error('ðŸ”´ Error admitting peer', error);\n      }\n    },\n  );\n\n  /**\n   * Denies the peer from joining the room, who is in the lobby\n   */\n  public denyPeer = checkPermissions({ admin: true }).validate(\n    (peerId: string) => {\n      try {\n        this.removeLobbyPeer(peerId);\n\n        this.socket.publish('denyLobbyPeer', { peerId });\n      } catch (error) {\n        logger.error('ðŸ”´ Error denying peer', error);\n      }\n    },\n  );\n\n  /**\n   * kick peer from room with respective peerId\n   */\n  public kickPeer = checkPermissions({ admin: true }).validate(\n    (peerId: string) => {\n      try {\n        this.socket.publish('kickPeer', { peerId });\n      } catch (error) {\n        logger.error('ðŸ”´ Error denying peer', error);\n      }\n    },\n  );\n\n  /**\n   * closing the room for the current user, room will keep on running for the remote users\n   * @deprecated - Use `leaveRoom` from `huddleClient` instead\n   */\n  public close = (reason?: 'LEFT' | 'CLOSED' | 'KICKED' | 'DENIED') => {\n    try {\n      logger.info('ðŸ”´ Leaving the room');\n\n      this.__roomId = null;\n\n      this.remotePeers.clear();\n\n      this.lobbyPeers.clear();\n\n      this.metadata = '{}';\n\n      this.state = 'left';\n\n      this.emit('room-closed', { reason: reason || 'LEFT' });\n    } catch (error) {\n      logger.error('Error: Leaving the Room');\n    }\n  };\n}\n\nexport default Room;\n"],"mappings":"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","names":[]}