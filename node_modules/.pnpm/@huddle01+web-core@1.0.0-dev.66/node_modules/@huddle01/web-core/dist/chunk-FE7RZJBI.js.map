{"version":3,"sources":["../src/Consumer.ts"],"sourcesContent":["import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter';\nimport type { Consumer as mediasoupConsumer } from 'mediasoup-client/lib/types';\nimport { mainLogger } from './logger';\n\nexport type ConsumerEvents = {\n  closed: [];\n};\n\nconst logger = mainLogger.createSubLogger('Consumer');\n\n/**\n * Consumer class, this class is responsible for consuming the media produced by the remote peers.\n *\n * Just likes Producer is responsible of producing a media stream in a room, similarly Consumer is responsible for consuming the media stream in a room.\n *\n * A Peer creates a Producer which takes the stream and produces that stream to all the Joined Remote Peer.\n * Remote Peers then make Consumers for that Producer to be able to consume the media stream.\n */\nclass Consumer extends EnhancedEventEmitter<ConsumerEvents> {\n  /**\n   * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.\n   */\n  public readonly producerId: string;\n\n  /**\n   * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.\n   */\n  public readonly producerPeerId: string;\n\n  /**\n   * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.\n   */\n  public readonly label: string;\n\n  /**\n   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.\n   *\n   * @default false\n   */\n  private __consuming = false;\n\n  /**\n   * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.\n   *\n   * @default false\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get consuming() {\n    return this.__consuming;\n  }\n\n  /**\n   * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.\n   * @remarks This is a private property and should not be accessed directly.\n   *\n   * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.\n   */\n  #mediasoupConsumer: mediasoupConsumer | null = null;\n\n  /**\n   * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.\n   */\n  get id() {\n    return this.#mediasoupConsumer?.id;\n  }\n\n  /**\n   *\n   * @param consumer Sets the mediasoupConsumer for the Consumer\n   */\n  public setMediaSoupConsumer(consumer: mediasoupConsumer) {\n    if (this.consuming) {\n      throw new Error('Consumer is already consuming');\n    }\n\n    if (this.#mediasoupConsumer) {\n      throw new Error('Consumer already has a mediasoupConsumer');\n    }\n\n    this.#mediasoupConsumer = consumer;\n\n    this.__consuming = true;\n  }\n\n  /**\n   * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get consumerId() {\n    return this.#mediasoupConsumer?.id;\n  }\n\n  /**\n   * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get track() {\n    return this.#mediasoupConsumer?.track;\n  }\n\n  /**\n   * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.\n   *\n   * @remarks\n   * There are two ways a Peer can Consume any media produced in the room.\n   * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.\n   * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: \"video\", appData: {} });`\n   */\n  get kind() {\n    return this.#mediasoupConsumer?.kind;\n  }\n\n  /**\n   * If the Consumer is paused, it is only available when the Consumer is consuming a media.\n   *\n   * if paused the user is not consuming any media for the given producerId.\n   */\n  get paused() {\n    return this.#mediasoupConsumer?.paused;\n  }\n\n  /**\n   * AppData of the Consumer, it is only available when the Consumer is consuming a media.\n   */\n  get appData() {\n    return this.#mediasoupConsumer?.appData;\n  }\n\n  /**\n   * State of a Consumer is defined by the following:\n   * - `playable` - The Consumer is ready to play the media.\n   * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.\n   * - `paused` - The Consumer is paused and is not playing the media.\n   * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: \"video\", appData: {} });` after which the state will change to `playable`.\n   */\n  get state(): 'playable' | 'unavailable' | 'paused' | 'available' {\n    if (this?.consuming) return 'playable';\n    if (this?.paused) return 'paused';\n\n    return 'available';\n  }\n\n  /**\n   * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.\n   * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.\n   * @returns - RTCStatsReport | null\n   */\n  getStats = async () => {\n    const stats = await this.#mediasoupConsumer?.getStats();\n\n    return stats;\n  };\n\n  /**\n   * Resume the consumer, if the state of the consumer is `paused`.\n   */\n  public resume = () => {\n    this.#mediasoupConsumer?.resume();\n  };\n\n  /**\n   * Removes all the eventListeners attached to the Consumer.\n   */\n  public removeListeners = () => {\n    this.removeAllListeners();\n  };\n\n  /**\n   * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.\n   */\n  public static create = (data: {\n    producerPeerId: string;\n    producerId: string;\n    label: string;\n  }) => {\n    try {\n      const consumer = new Consumer(data);\n\n      return consumer;\n    } catch (error) {\n      logger.error(error);\n      throw new Error('❌ Error creating Consumer');\n    }\n  };\n\n  public close = () => {\n    try {\n      this.#mediasoupConsumer?.close();\n\n      this.__consuming = false;\n\n      this.emit('closed');\n\n      this.removeAllListeners();\n    } catch (error) {\n      logger.error('❌ Error Closing Consumer');\n      logger.error({\n        consumerId: this.consumerId,\n        producerId: this.producerId,\n      });\n    }\n  };\n\n  private constructor(data: {\n    producerPeerId: string;\n    producerId: string;\n    label: string;\n  }) {\n    super();\n\n    this.producerPeerId = data.producerPeerId;\n    this.producerId = data.producerId;\n    this.label = data.label;\n  }\n}\n\nexport default Consumer;\n"],"mappings":";;;;;;;;AAQA,IAAM,SAAS,WAAW,gBAAgB,UAAU;AAUpD,IAAM,WAAN,MAAM,kBAAiB,qBAAqC;AAAA;AAAA;AAAA;AAAA,EAI1C;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOR,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYtB,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,qBAA+C;AAAA;AAAA;AAAA;AAAA,EAK/C,IAAI,KAAK;AACP,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,qBAAqB,UAA6B;AACvD,QAAI,KAAK,WAAW;AAClB,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAEA,QAAI,KAAK,oBAAoB;AAC3B,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAEA,SAAK,qBAAqB;AAE1B,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,aAAa;AACf,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,QAAQ;AACV,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,OAAO;AACT,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,SAAS;AACX,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACZ,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAI,QAA6D;AAC/D,QAAI,MAAM;AAAW,aAAO;AAC5B,QAAI,MAAM;AAAQ,aAAO;AAEzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,YAAY;AACrB,UAAM,QAAQ,MAAM,KAAK,oBAAoB,SAAS;AAEtD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,SAAS,MAAM;AACpB,SAAK,oBAAoB,OAAO;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAkB,MAAM;AAC7B,SAAK,mBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,SAAS,CAAC,SAIlB;AACJ,QAAI;AACF,YAAM,WAAW,IAAI,UAAS,IAAI;AAElC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO,MAAM,KAAK;AAClB,YAAM,IAAI,MAAM,gCAA2B;AAAA,IAC7C;AAAA,EACF;AAAA,EAEO,QAAQ,MAAM;AACnB,QAAI;AACF,WAAK,oBAAoB,MAAM;AAE/B,WAAK,cAAc;AAEnB,WAAK,KAAK,QAAQ;AAElB,WAAK,mBAAmB;AAAA,IAC1B,SAAS,OAAO;AACd,aAAO,MAAM,+BAA0B;AACvC,aAAO,MAAM;AAAA,QACX,YAAY,KAAK;AAAA,QACjB,YAAY,KAAK;AAAA,MACnB,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,YAAY,MAIjB;AACD,UAAM;AAEN,SAAK,iBAAiB,KAAK;AAC3B,SAAK,aAAa,KAAK;AACvB,SAAK,QAAQ,KAAK;AAAA,EACpB;AACF;AAEA,IAAO,mBAAQ;","names":[]}