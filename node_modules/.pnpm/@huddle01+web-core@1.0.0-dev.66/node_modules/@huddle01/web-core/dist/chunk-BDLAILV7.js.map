{"version":3,"sources":["../src/LocalPeer.ts","../src/RemotePeer.ts"],"sourcesContent":["import type { AppData, Producer } from 'mediasoup-client/lib/types';\n\nimport { Device, detectDevice } from 'mediasoup-client';\n\nimport type { SushiToClientEvents } from 'types/dist/sushiToClientEvents.types';\n\nimport type { TTransportType } from 'types/dist';\n\nimport {\n  type TDataMessage,\n  type TPermissions,\n  type RoomInfo,\n  TVolatileDataMessage,\n} from 'types/dist/common.types';\n\nimport DeviceHandler, {\n  CustomMediaKind,\n  FetchScreenResponse,\n  FetchStreamResponse,\n} from './DeviceHandler';\n\nimport RemotePeer from './RemotePeer';\nimport Transport from './Transport';\nimport { mainLogger } from './logger';\nimport Consumer from './Consumer';\nimport Socket from './Socket';\nimport Room from './Room';\nimport { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter';\n\nimport Permissions, { checkPermissions } from './Permissions';\nimport { VolatileDataMessageSchema } from './validators';\nimport { estimateSize, getMediaDeviceKind } from './helpers';\n\nconst logger = mainLogger.createSubLogger('LocalPeer');\n\nconst MAX_DATA_MESSAGE_SIZE = 1 * 1024; //1kb\n\nexport type LocalPeerEvents = {\n  // When a new stream is fetched from the device and now is beign produced to the room.\n  'stream-playable': [data: { label: string; producer: Producer }];\n\n  // When a stream is closed, either by the LocalPeer or by the system.\n  'stream-closed': [\n    data: {\n      label: string;\n      mediaKind?: CustomMediaKind;\n      reason?: { code: number; tag: string; message?: string };\n    },\n  ];\n\n  // When a new stream is fetched from the device, but not yet produced to the room.\n  'stream-fetched': [\n    data: { mediaKind: CustomMediaKind; stream: MediaStream; label: string },\n  ];\n\n  // When a new data message is received from the other Remote Peers.\n  'receive-data': [data: TDataMessage];\n\n  // When a new volatile data message is received from the other Remote Peers.\n  'receive-volatile-data': [data: TVolatileDataMessage];\n\n  // when the LocalPeer is reconnected\n  reconnected: [data: Socket];\n\n  // when LocalPeer updates the metadata\n  'metadata-updated': [data: { metadata: unknown }];\n\n  // when the permissions of the LocalPeer are updated\n  'permissions-updated': [data: { permissions: TPermissions; role?: string }];\n\n  // when the role of the LocalPeer is changed.\n  'role-updated': [data: { role: string }];\n\n  // when a new devie is created which notifies which kind of device LocalPeer is using\n  // i.e. Browser or ReactNative with versions supporting (e.g. Chrome, Firefox, Safari, ReactNative)\n  'device-created': [data: { device: Device }];\n\n  // when the LocalPeer is ready to produce streams to the Room.\n  'new-send-transport': [data: { transport: Transport }];\n\n  // when the LocalPeer is ready to consume stream from the Room.\n  'new-recv-transport': [data: { transport: Transport }];\n};\n\n/**\n * LocalPeer is the main class which handles all the functionality of the client\n * Where Client Means the currently Running Application.\n */\nclass LocalPeer extends EnhancedEventEmitter<LocalPeerEvents> {\n  /**\n   * LocalPeer Instance, Singleton class, only one instance of this class can be created\n   */\n  private static __instance: LocalPeer | null = null;\n\n  /**\n   * PeerId of the current client, specific to the Local Peer who joined the meeting\n   *\n   * `NOTE: Until you dont join the room, this will be *null*`\n   */\n  public peerId: string | null = null;\n\n  /**\n   * Current Devices of the current client\n   * e.g. Chrome, Firefox, Safari, ReactNative\n   */\n  private __device: Device | null = null;\n\n  /**\n   * SendTransport handles the sending of media from the client to the server\n   */\n  private __sendTransport: Transport | null = null;\n\n  /**\n   * RecvTransport handles the receiving of media from the server to the client\n   */\n  private __recvTransport: Transport | null = null;\n\n  /**\n   * Returns the room instance, throws an error if the room is not created\n   *\n   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room in the LocalPeer\n   */\n  private get room(): Room {\n    const room = Room.getInstance();\n\n    if (!room) throw new Error('❌ Room Not Initialized');\n\n    return room;\n  }\n\n  /**\n   * Returns the underlying socket connection\n   * @throws { Error } If the socket connection is not initialized\n   */\n  get socket(): Socket {\n    const socket = Socket.getInstance();\n\n    if (!socket) throw new Error('❌ Socket Not Initialized');\n\n    return socket;\n  }\n\n  /**\n   * Remote Peers Map, Stores all the remote peers\n   */\n  private get __remotePeers() {\n    return this.room.remotePeers;\n  }\n\n  /**\n   * Turn Server used for this client\n   */\n  private __turn: RTCIceServer[] = [\n    {\n      username: 'test-turn',\n      urls: 'turn:turn.huddle01.com:443?transport=udp',\n      credential: 'test-turn',\n    },\n    {\n      username: 'test-turn',\n      urls: 'turn:turn.huddle01.com:443?transport=tcp',\n      credential: 'test-turn',\n    },\n  ];\n\n  /**\n   * Get the current device ( chrome, firefox, safari, reactnative ) for this client\n   *\n   * @throws { Error } If the device is not initialized\n   */\n  private get device(): Device {\n    if (!this.__device) throw new Error('Device Not Initialized');\n\n    const loaded = this.__device.loaded;\n\n    if (!loaded) throw new Error('Device Not Loaded');\n\n    return this.__device;\n  }\n\n  // !important\n  // Consumer creation tasks awaiting to be processed.\n  // Stores the lables of the pending consumers { producerId: string ==> Promise<Consumer> }\n  private __pendingConsumerTasks: Map<string, Promise<Consumer>> = new Map();\n\n  // !important\n  // Producer creation tasks awaiting to be processed.\n  // Stores the lables of the pending producers { label: string }\n  // Used to handle transport callbacks most important;\n  private __pendingProducerTasks: Map<string, Promise<Producer>> = new Map();\n\n  // !important\n  // Map to store pending tasks, Stores the label and the promise of the task\n  private __pendingTasks: Map<string, Promise<unknown>> = new Map();\n\n  /**\n   * Pending Transport Tasks, Stores the transportType and the promise of the transport\n   *\n   * `NOTE: Useful to check if the transport is already being created and pause all producing\n   * and consuming until the transport is created`\n   */\n  private __pendingTransportTasks: Map<TTransportType, Promise<Transport>> =\n    new Map();\n\n  /**\n   * Stores all the pending fetching stream tasks which are awaiting to be processed\n   * If fetching called multiple times at once, it will handle the concurrency issues\n   */\n  private __pendingFetchingStream: Map<\n    string,\n    Promise<FetchStreamResponse | FetchScreenResponse>\n  > = new Map();\n\n  /**\n   * Stores all the pending produce tasks which are awaiting to be processed\n   * Mostly used when the room is not joined and produce functionality needs to be handled\n   *\n   * Cases such as socket experiencing a reconnect and produce is called.\n   * Or in the cases where room is not joined and enableVideo or enableAudio is called\n   */\n  private __waitingToProduce = new Map<string, () => Promise<Producer>>();\n\n  /**\n   * Stores all the pending consume tasks which are waiting for recv transport to be re-connected\n   */\n  private __waitingToConsume: Array<() => Promise<unknown>> = [];\n\n  /**\n   * DeviceHandler Instance, Handles the media devices for this client\n   * e.g. Camera, Microphone\n   */\n  public deviceHandler = new DeviceHandler();\n\n  /**\n   * ActiveStream Map holds MediaStream as Value and Key as Label\n   */\n  private __activeStreams = new Map<string, MediaStream>();\n\n  /**\n   * Handle the Client Side Permission for the Local Peer.\n   */\n  private __permissions = Permissions.createInstance();\n\n  /**\n   * Stores the Metadata for the Local Peer.\n   */\n  private __metadata: string | null = null;\n\n  /**\n   * Variable to check if the user has joined the room\n   */\n  public joined = false;\n\n  /**\n   * Return the labels of the Media Stream that the Local Peer is producing to the room\n   */\n  public get labels() {\n    const sendTransport = this.__sendTransport;\n\n    if (sendTransport) {\n      const labels = Array.from(sendTransport.labelToProducerId.keys());\n\n      return labels;\n    }\n\n    return [];\n  }\n\n  /**\n   * Get the Permissions of the Local Peer. (e.g canProduce, canConsume, canSendData, canRecvData etc)\n   */\n  get permissions() {\n    const acl = this.__permissions.acl;\n\n    return acl;\n  }\n\n  /**\n   * Get the Role of the Local Peer.\n   */\n  get role() {\n    return this.__permissions.role;\n  }\n\n  /**\n   * Returns the token of the current socket connection, specific to the Local Peer who joined the meeting\n   */\n  get token(): string | null {\n    return this.socket.token;\n  }\n\n  /**\n   * Returns the roomId of the current joined room.\n   */\n  get roomId(): string | null {\n    return this.room.roomId;\n  }\n\n  /**\n   * Returns the SendTransport\n   * @returns { Transport } SendTransport\n   * @throws { Error } If the SendTransport is not initialized\n   */\n  get sendTransport(): Transport {\n    if (!this.__sendTransport)\n      throw new Error('Send Transport Not Initialized');\n\n    return this.__sendTransport;\n  }\n\n  /**\n   * Returns the recvTransport\n   * @returns { Transport } recvTransport\n   * @throws { Error } If the recvTransport is not initialized\n   */\n  get recvTransport(): Transport {\n    if (!this.__recvTransport)\n      throw new Error('Recv Transport Not Initialized');\n\n    return this.__recvTransport;\n  }\n\n  /**\n   * Returns the metadata associated to the LocalPeer\n   */\n  getMetadata<T = unknown>() {\n    const data = JSON.parse(this.__metadata || '{}');\n\n    return data as T;\n  }\n\n  /**\n   * getStream returns the stream with the given label\n   */\n  public getStream = (data: { label: string }) => {\n    const stream = this.__activeStreams.get(data.label);\n\n    if (stream === undefined) {\n      return null;\n    }\n\n    return stream;\n  };\n\n  /**\n   * Updates the metadata associated to the LocalPeer, Triggers the `metadata-updated` event\n   * @param metadata\n   */\n  private __updateMetadata = (metadata: string) => {\n    this.__metadata = metadata;\n\n    const parse = JSON.parse(metadata);\n\n    this.emit('metadata-updated', {\n      metadata: parse,\n    });\n  };\n\n  /**\n   * Returns the producer with the given label\n   * @param label - Identifier of the producer\n   * @returns { Producer } Producer\n   * @returns { null } If the producer is not found\n   */\n  public getProducerWithLabel = (label: string): Producer | null => {\n    try {\n      const producerId = this.__sendTransport?.labelToProducerId.get(label);\n\n      if (producerId) {\n        const producer = this.sendTransport.getProducerById(producerId);\n\n        return producer;\n      }\n\n      return null;\n    } catch (error) {\n      logger.error('❌ Cannot Find Producer With Identifier: ', label);\n\n      logger.error(error);\n\n      return null;\n    }\n  };\n\n  /**\n   * Registers the event handlers for the socket connection\n   * @param socket - Socket Instance\n   */\n  private __registerHandlerEvents = (socket: Socket) => {\n    let cnt = 0;\n    const keys = Object.keys(this.__handler) as Array<\n      keyof SushiToClientEvents\n    >;\n\n    for (const key of keys) {\n      try {\n        const fn = this.__handler[key];\n\n        if (fn) socket.subscribe(key, fn);\n      } catch (error) {\n        logger.error(`❌ Error Registered For Event: ${key}`);\n        logger.error(error);\n      }\n      cnt++;\n    }\n\n    logger.info('✅ LocalPeerEventHandler Registered');\n  };\n\n  public static create() {\n    if (LocalPeer.__instance) {\n      return LocalPeer.__instance;\n    }\n\n    LocalPeer.__instance = new LocalPeer();\n\n    return LocalPeer.__instance;\n  }\n\n  static getInstance() {\n    if (!LocalPeer.__instance) {\n      throw new Error('LocalPeer not initialized');\n    }\n    return LocalPeer.__instance;\n  }\n\n  private constructor() {\n    super();\n\n    this.__registerHandlerEvents(this.socket);\n\n    this.socket.on('reconnected', () => {\n      this.__registerHandlerEvents(this.socket);\n\n      this.socket.publish('syncMeetingState', undefined);\n\n      if (this.__sendTransport) {\n        this.socket.publish('restartTransportIce', {\n          transportId: this.__sendTransport.mediasoupTransport.id,\n          transportType: 'send',\n        });\n      }\n\n      if (this.__recvTransport) {\n        this.socket.publish('restartTransportIce', {\n          transportId: this.__recvTransport.mediasoupTransport.id,\n          transportType: 'recv',\n        });\n      }\n    });\n  }\n\n  /**\n   * Destroy the current peer, closes all the transports, producers and consumers\n   *\n   * @param code - Close Code\n   */\n  public close = () => {\n    this.__device = null;\n\n    this.__pendingConsumerTasks.clear();\n\n    this.__pendingProducerTasks.clear();\n\n    this.__pendingTransportTasks.clear();\n\n    this.__pendingFetchingStream.clear();\n\n    this.__waitingToProduce.clear();\n\n    for (const stream of this.__activeStreams.values()) {\n      for (const track of stream.getTracks()) track.stop();\n    }\n\n    this.joined = false;\n\n    this.deviceHandler.destroy();\n\n    if (this.__sendTransport) {\n      this.__sendTransport.close({ retries: 3 });\n    }\n\n    if (this.__recvTransport) {\n      this.__recvTransport.close({ retries: 3 });\n    }\n\n    this.__sendTransport = null;\n\n    this.__recvTransport = null;\n\n    this.__permissions.reset();\n\n    this.emit('permissions-updated', {\n      permissions: this.permissions,\n      role: this.role ?? '',\n    });\n  };\n\n  /**\n   * LocalPeer Handler Functions Begins Here 👇\n   */\n\n  /**\n   * Produce a stream with a given label and appData to all the Remote Peers\n   *\n   * `canProduce must be true to produce a stream`\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has started producing and they should start consuming it if they want to`\n   *\n   * @param data - Data to produce a stream\n   *  - `label` - Unique Identifier for the stream ( string )\n   *  - `stream` - MediaStream to produce ( MediaStream )\n   *  - `stopTrackOnClose` - If true, it will stop the track when the producer is closed using stopProducing ( boolean )\n   *  - `appData` - Application level custom data which can be added to the producer for the LocalPeer, this data will be available in the producer object and can be used only by the LocalPeer. ( Unknown Object )\n   *\n   * @summary This function is used to produce a stream with a given label and appData to all the Remote Peers if the send transport is not initialised\n   * it will create a send transport and then produce the stream with the given label and appData to all the Remote Peers\n   *\n   * Send Transport is a secure channel which is used to send media from LocalPeer to all the RemotePeers in the room\n   *\n   * `localPeer.on('new-producer', ({label: string; producer: Producer}) => {})`\n   */\n  public produce = checkPermissions({\n    canProduce: true,\n  }).validate(\n    async (data: {\n      label: string;\n      stream: MediaStream;\n      stopTrackOnClose?: boolean;\n      appData?: AppData;\n    }): Promise<Producer> => {\n      const track = data.stream.getTracks()[0];\n\n      if (track) {\n        track.addEventListener('ended', () => {\n          this.stopProducing({ label: data.label });\n        });\n      }\n\n      if (\n        !this.joined ||\n        (this.__sendTransport &&\n          this.__sendTransport?.connectionState !== 'connected')\n      ) {\n        return new Promise<Producer>((resolve) => {\n          const fn = async () => {\n            const producer = await this.produce(data)\n              .then((data) => {\n                resolve(data);\n\n                return data;\n              })\n              .finally(() => {\n                this.__pendingProducerTasks.delete(data.label);\n              });\n\n            return producer;\n          };\n\n          this.__waitingToProduce.set(data.label, fn);\n        });\n      }\n\n      const { stream } = data;\n\n      const producerPromise = this.__pendingProducerTasks.get(data.label);\n\n      if (producerPromise) {\n        logger.info(\n          '🔔 Producer Task Already Pending for this label ',\n          data.label,\n        );\n\n        const producer = await producerPromise;\n\n        return producer;\n      }\n\n      if (!this.__sendTransport) {\n        await this.__createTransportOnServer({\n          transportType: 'send',\n        });\n      }\n\n      const ongoingPromise = this.__pendingProducerTasks.get(data.label);\n\n      if (ongoingPromise) {\n        const producer = await ongoingPromise;\n\n        return producer;\n      }\n\n      const promise = this.__createProducer({\n        stream,\n        label: data.label,\n        appData: { ...data.appData, label: data.label },\n      });\n\n      this.__pendingProducerTasks.set(data.label, promise);\n\n      const producer = await promise\n        .catch(() => {\n          logger.error('❌ Error Create Producer Failed');\n          throw new Error('❌ Error Create Producer Failed');\n        })\n        .finally(() => {\n          this.__pendingProducerTasks.delete(data.label);\n        });\n\n      return producer;\n    },\n  );\n\n  /**\n   * Enables the local web cam and starts producing the stream with the label `video`\n   *\n   * @summary This functions handle the producing of media streams to all the remote peers in the room.\n   * it enables the local web cam fetches the stream opens you web cam indicator light on the device\n   * upon successfull fetching of the stream it produces the stream with the label `video` and `stopTrackOnClose: true` to all the remote peers in the room.\n   * when closing using disableVideo it will stop the local track and close the producer which will notify all the RemotePeers that this producer has stopped producing\n   * and they should stop consuming it.\n   *\n   * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will throw an error`\n   *\n   * @throws { Error } If the stream is not found\n   */\n  public enableVideo = checkPermissions({\n    canProduce: true,\n  }).validate(async (customVideoStream?: MediaStream) => {\n    try {\n      if (!this.permissions.canProduceSources.cam) {\n        logger.error('❌ Cannot Enable Video, Permission Denied');\n\n        throw new Error('❌ Cannot Enable Video, Permission Denied');\n      }\n\n      const existingStream = this.__activeStreams.get('video');\n\n      if (existingStream) {\n        logger.warn('🔔 Cam Stream Already Enabled');\n\n        return;\n      }\n\n      let stream: MediaStream;\n\n      if (customVideoStream) {\n        stream = customVideoStream;\n      } else {\n        const ongoingStreamPromise = this.__pendingFetchingStream.get('cam');\n\n        if (ongoingStreamPromise) {\n          await ongoingStreamPromise;\n        } else {\n          const streamPromise = this.deviceHandler.fetchStream({\n            mediaDeviceKind: 'cam',\n          });\n\n          this.__pendingFetchingStream.set('cam', streamPromise);\n        }\n\n        const pendingPromise = this.__pendingFetchingStream.get('cam');\n\n        if (!pendingPromise) {\n          logger.info('🔔 Pending Promise Not Found');\n\n          return;\n        }\n\n        const { stream: fetchedStream, error } = await pendingPromise;\n\n        if (error) {\n          logger.error('❌ Error Fetching Stream From Device');\n          logger.error(error);\n\n          throw new Error('❌ Error Fetching Stream From Device');\n        }\n\n        if (!fetchedStream) {\n          logger.error('❌ Stream Not Found, cannot do enableVideo');\n\n          throw new Error('❌ Stream Not Found');\n        }\n\n        stream = fetchedStream;\n      }\n\n      this.__activeStreams.set('video', stream);\n\n      this.emit('stream-fetched', {\n        mediaKind: 'cam',\n        label: 'video',\n        stream,\n      });\n\n      this.produce({\n        label: 'video',\n        stream,\n        appData: {\n          producerPeerId: this.peerId,\n        },\n        stopTrackOnClose: true,\n      })\n        .then(() => {\n          this.__pendingProducerTasks.delete('video');\n        })\n        .catch((error) => {\n          logger.error('❌ Error Producing Video');\n\n          this.deviceHandler.stopStream(this.__activeStreams.get('video'));\n\n          this.__activeStreams.delete('video');\n\n          this.__pendingFetchingStream.delete('cam');\n\n          logger.error(error);\n        });\n\n      this.__pendingFetchingStream.delete('cam');\n\n      return stream;\n    } catch (error) {\n      logger.error('❌ Error Enabling Video');\n      logger.error(error);\n\n      this.deviceHandler.stopStream(this.__activeStreams.get('video'));\n\n      this.__activeStreams.delete('video');\n\n      this.__pendingFetchingStream.delete('cam');\n\n      throw error;\n    }\n  });\n\n  /**\n   * Enables the local screen share  and starts producing the screen sharing stream\n   *\n   *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`\n   *\n   * @summary This functions handle the producing of media streams to all the remote peers in the room.\n   * it enables the local mic fetches the stream opens you mic active indicator light on the device\n   * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.\n   * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing\n   * and they should stop consuming it.\n   *\n   *\n   */\n  public startScreenShare = checkPermissions({ canProduce: true }).validate(\n    async () => {\n      try {\n        if (!this.permissions.canProduceSources.screen) {\n          logger.error('❌ Cannot Enable Screen Share, Permission Denied');\n\n          throw new Error('❌ Cannot Enable Screen Share, Permission Denied');\n        }\n\n        const existingStream = this.__activeStreams.get('screen-share');\n\n        if (existingStream) {\n          logger.warn('🔔 Screen Stream Already Enabled');\n\n          return;\n        }\n\n        const onGoingStreamPromise =\n          this.__pendingFetchingStream.get('screen-share');\n\n        if (onGoingStreamPromise) {\n          await onGoingStreamPromise;\n        } else {\n          const streamPromise = this.deviceHandler.fetchScreen();\n\n          this.__pendingFetchingStream.set('screen-share', streamPromise);\n        }\n\n        const pendingPromise = this.__pendingFetchingStream.get('screen-share');\n\n        if (!pendingPromise) {\n          logger.info('🔔 Pending Screen Share Promise Not Found');\n          return;\n        }\n\n        const { stream, error } = await pendingPromise;\n\n        if (error) {\n          logger.error('❌ Error Fetching Screen Share Stream From Device');\n          logger.error(error);\n\n          throw new Error('❌ Error Fetching Screen ShareStream From Device');\n        }\n\n        if (!stream) {\n          logger.error('❌ Stream Not Found, cannot do startScreenShare');\n\n          throw new Error('❌ Stream Not Found, cannot do startScreenShare');\n        }\n\n        this.__activeStreams.set('screen-share', stream);\n\n        this.emit('stream-fetched', {\n          mediaKind: 'screen',\n          label: 'screen-share',\n          stream,\n        });\n\n        const videoTrack = stream.getVideoTracks()?.[0];\n\n        const audioTrack = stream.getAudioTracks()?.[0];\n\n        const videoProduce = async () => {\n          return this.produce({\n            label: 'screen-share-video',\n            stream: new MediaStream([videoTrack]),\n            appData: {\n              producerPeerId: this.peerId,\n            },\n            stopTrackOnClose: true,\n          });\n        };\n\n        const audioProduce = async () => {\n          return this.produce({\n            label: 'screen-share-audio',\n            stream: new MediaStream([audioTrack]),\n            appData: {\n              producerPeerId: this.peerId,\n            },\n            stopTrackOnClose: true,\n          });\n        };\n\n        if (videoTrack) {\n          videoProduce()\n            .then(() => {\n              this.__pendingProducerTasks.delete('screen-share-video');\n            })\n            .catch((error) => {\n              logger.error('❌ Error Producing Screen Share Video');\n\n              this.deviceHandler.stopStream(\n                this.__activeStreams.get('screen-share'),\n              );\n\n              this.__activeStreams.delete('screen-share');\n\n              logger.error(error);\n            });\n        }\n\n        if (audioTrack) {\n          audioProduce()\n            .then(() => {\n              this.__pendingProducerTasks.delete('screen-share-audio');\n            })\n            .catch((error) => {\n              logger.error('❌ Error Producing Audio');\n              this.deviceHandler.stopStream(\n                this.__activeStreams.get('screen-share'),\n              );\n              this.__activeStreams.delete('screen-share');\n              logger.error(error);\n            });\n        }\n\n        this.__pendingFetchingStream.delete('screen-share');\n\n        return stream;\n      } catch (error) {\n        logger.error('❌ Error Enabling Screen Share');\n        logger.error(error);\n\n        this.deviceHandler.stopStream(this.__activeStreams.get('screen-share'));\n\n        this.__activeStreams.delete('screen-share');\n\n        this.__pendingFetchingStream.delete('screen-share');\n\n        throw error;\n      }\n    },\n  );\n\n  /**\n   * Enables the local mic and starts producing the stream with the label `audio`\n   *\n   *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`\n   *\n   * @summary This functions handle the producing of media streams to all the remote peers in the room.\n   * it enables the local mic fetches the stream opens you mic active indicator light on the device\n   * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.\n   * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing\n   * and they should stop consuming it.\n   */\n  public enableAudio = checkPermissions({\n    canProduce: true,\n  }).validate(async (customAudioStream?: MediaStream) => {\n    try {\n      if (!this.permissions.canProduceSources.mic) {\n        logger.error('❌ Cannot Enable Audio, Permission Denied');\n\n        throw new Error('❌ Cannot Enable Audio, Permission Denied');\n      }\n\n      const existingStream = this.__activeStreams.get('audio');\n\n      if (existingStream) {\n        logger.warn('🔔 Mic Stream Already Enabled');\n\n        return;\n      }\n\n      let stream: MediaStream;\n\n      if (customAudioStream) {\n        stream = customAudioStream;\n      } else {\n        const ongoingStreamPromise = this.__pendingFetchingStream.get('mic');\n\n        if (ongoingStreamPromise) {\n          await ongoingStreamPromise;\n        } else {\n          const streamPromise = this.deviceHandler.fetchStream({\n            mediaDeviceKind: 'mic',\n          });\n\n          this.__pendingFetchingStream.set('mic', streamPromise);\n        }\n\n        const pendingPromise = this.__pendingFetchingStream.get('mic');\n\n        if (!pendingPromise) {\n          logger.info('🔔 Pending Mic Promise Not Found');\n\n          return;\n        }\n\n        const { stream: fetchedStream, error } = await pendingPromise;\n\n        if (error) {\n          logger.error('❌ Error Fetching Stream From Device');\n          logger.error(error);\n\n          throw new Error('❌ Error Fetching Stream From Device');\n        }\n\n        if (!fetchedStream) {\n          logger.error('❌ Stream Not Found, cannot do enableAudio');\n\n          throw new Error('❌ Stream Not Found');\n        }\n\n        stream = fetchedStream;\n      }\n\n      this.__activeStreams.set('audio', stream);\n\n      this.emit('stream-fetched', {\n        mediaKind: 'mic',\n        stream,\n        label: 'audio',\n      });\n\n      this.produce({\n        label: 'audio',\n        stream,\n        appData: {\n          producerPeerId: this.peerId,\n        },\n        stopTrackOnClose: true,\n      })\n        .then(() => {\n          this.__pendingProducerTasks.delete('audio');\n        })\n        .catch((error) => {\n          logger.error('❌ Error Producing Audio');\n\n          this.deviceHandler.stopStream(this.__activeStreams.get('audio'));\n\n          this.__activeStreams.delete('audio');\n\n          logger.error(error);\n        });\n\n      this.__pendingFetchingStream.delete('mic');\n\n      return stream;\n    } catch (error) {\n      logger.error('❌ Error Enabling Audio');\n      logger.error(error);\n\n      this.deviceHandler.stopStream(this.__activeStreams.get('audio'));\n\n      this.__activeStreams.delete('audio');\n\n      this.__pendingFetchingStream.delete('mic');\n\n      throw error;\n    }\n  });\n\n  /**\n   * Stops the underlying producing of a stream for a particular label\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`\n   *\n   * @param data Data to stop producing { label: string }\n   */\n\n  public stopProducing = (data: {\n    label: string;\n  }) => {\n    this.__waitingToProduce.delete(data.label);\n\n    this.__pendingProducerTasks.delete(data.label);\n\n    let closedStream = false;\n\n    const producer = this.getProducerWithLabel(data.label);\n\n    if (producer) {\n      logger.info('🔔 Closing Producer', {\n        label: data.label,\n        producerId: producer.id,\n      });\n\n      producer.close();\n\n      producer.on('trackended', () => {\n        console.debug('🔔 Track Ended For the Producer');\n      });\n\n      this.__sendTransport?.removeProducerById(producer.id);\n\n      closedStream = true;\n\n      this.socket.publish('closeProducer', {\n        producerId: producer.id,\n      });\n    }\n\n    const closedStreamLabel = data.label.startsWith('screen-share')\n      ? 'screen-share'\n      : data.label;\n\n    const stream = this.__activeStreams.get(closedStreamLabel);\n\n    if (stream) {\n      this.deviceHandler.stopStream(stream);\n\n      this.__activeStreams.delete(closedStreamLabel);\n\n      closedStream = true;\n    }\n\n    if (closedStream) {\n      this.emit('stream-closed', {\n        label: data.label,\n        reason: {\n          code: 1200,\n          tag: 'STREAM_CLOSED',\n          message: 'Stopped Streaming',\n        },\n      });\n    }\n  };\n\n  /**\n   * Stops the underlying producing of a camera stream, stops the local track and closes the producer\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`\n   *\n   * @param data Data to stop producing { label: string }\n   */\n  public disableVideo = async () => {\n    this.stopProducing({\n      label: 'video',\n    });\n  };\n\n  /**\n   * Replaces the current video stream with the new stream\n   *\n   * if you have produced a stream with label `video` or used the default function `enableVideo` and you want to replace it with a new stream\n   * @param stream - New Video Stream\n   */\n  public replaceVideoStream = async (stream: MediaStream) => {\n    await this.replaceStream({\n      label: 'video',\n      newStream: stream,\n    });\n  };\n\n  /**\n   * Changes the Video source to the given deviceId, sets the preferred cam device as the given deviceId\n   * @param deviceId\n   */\n  public changeVideoSource = async (deviceId: string) => {\n    this.deviceHandler.setPreferredDevice({\n      deviceId,\n      deviceKind: 'cam',\n    });\n\n    const stream = this.__activeStreams.get('video');\n    if (!stream) {\n      return;\n    }\n\n    const { stream: newStream } = await this.deviceHandler.fetchStream({\n      mediaDeviceKind: 'cam',\n    });\n\n    if (!newStream) return;\n\n    await this.replaceVideoStream(newStream);\n  };\n\n  /**\n   * Replaces the current audio stream with the new stream\n   * if you have produced a stream with label `audio` or used the default function `enableAudio` and you want to replace it with a new stream\n   * @param stream - New Audio Stream\n   *\n   */\n  public replaceAudioStream = async (stream: MediaStream) => {\n    await this.replaceStream({\n      label: 'audio',\n      newStream: stream,\n    });\n  };\n\n  /**\n   * Replace the current stream with the new stream based on the label used to produce the stream\n   *\n   * @example\n   * For Video\n   * await localPeer.replaceStream({\n   *  label: 'video',\n   *  newStream: newStream\n   * })\n   *\n   * For Screen-Share\n   * await localPeer.replaceStream({\n   *  label: 'screen-share-video',\n   *  newStream: newStream\n   * })\n   *\n   * If any custom label used\n   * await localPeer.replaceStream({\n   *  label: 'custom',\n   *  newStream: newStream\n   * })\n   *\n   * @param data - { label: string, newStream: MediaStream }\n   */\n  public replaceStream = async (data: {\n    label: string;\n    newStream: MediaStream;\n  }) => {\n    logger.info(`🔔 Replacing ${data.label} Stream `);\n\n    const producer = this.getProducerWithLabel(data.label);\n\n    const track = data.newStream.getTracks()[0];\n\n    if (track) {\n      track.addEventListener('ended', () => {\n        this.stopProducing({ label: data.label });\n      });\n    }\n\n    if (producer) {\n      await producer.replaceTrack({ track });\n    }\n\n    const closedStreamLabel = data.label.startsWith('screen-share')\n      ? 'screen-share'\n      : data.label;\n\n    const prevStream = this.__activeStreams.get(closedStreamLabel);\n\n    if (prevStream && !this.__waitingToProduce.has(closedStreamLabel)) {\n      this.deviceHandler.stopStream(prevStream);\n\n      this.__activeStreams.delete(closedStreamLabel);\n\n      this.__activeStreams.set(closedStreamLabel, data.newStream);\n    } else if (prevStream && this.__waitingToProduce.has(closedStreamLabel)) {\n      for (const track of prevStream.getTracks()) {\n        prevStream.removeTrack(track);\n        track.stop();\n      }\n\n      for (const track of data.newStream.getTracks()) {\n        prevStream.addTrack(track);\n      }\n    }\n\n    const mediaDeviceKind = getMediaDeviceKind(track);\n\n    this.emit('stream-fetched', {\n      label: data.label,\n      stream: data.newStream,\n      mediaKind: mediaDeviceKind,\n    });\n  };\n\n  /**\n   * Changes the Audio source to the given deviceId, sets the preferred mic device as the given deviceId\n   * @param deviceId\n   */\n  public changeAudioSource = async (deviceId: string) => {\n    this.deviceHandler.setPreferredDevice({\n      deviceId,\n      deviceKind: 'mic',\n    });\n\n    const stream = this.__activeStreams.get('audio');\n\n    if (!stream) {\n      return;\n    }\n\n    const { stream: newStream } = await this.deviceHandler.fetchStream({\n      mediaDeviceKind: 'mic',\n    });\n\n    if (!newStream) return;\n\n    await this.replaceAudioStream(newStream);\n  };\n\n  /**\n   * Stops the underlying producing of a microphone stream, stops the local track and closes the producer\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`\n   */\n  public disableAudio = async () => {\n    this.stopProducing({\n      label: 'audio',\n    });\n  };\n\n  /**\n   * Stops the underlying producing of a screen-share stream, stops the local track and closes the producer\n   *\n   * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`\n   */\n  public stopScreenShare = async () => {\n    try {\n      this.stopProducing({\n        label: 'screen-share-video',\n      });\n\n      this.stopProducing({\n        label: 'screen-share-audio',\n      });\n    } catch (error) {\n      logger.error(error);\n      logger.error('Error Disabling Screen Share');\n    }\n  };\n\n  /**\n   * Consumes a stream with the producerId and peerId of the RemotePeer, appData is application level custom data which\n   * can be added to the consumer for the LocalPeer, this data will be available in the consumer object and can be used only by the LocalPeer.\n   *\n   * `NOTE: This will not notify the RemotePeers that you are consuming a stream, you have to notify them manually`\n   * @summary Every time a RemotePeer is producing a Media in the Room, LocalPeer will be notified about it and it will be able to consume it.\n   * Consuming is a process where the media is received from the RemotePeer and the stream can be played on the LocalPeers device.\n   *\n   * To get the consumer back you can use\n   *\n   * const remotePeer = this.room.getRemotePeerById(data.peerId);\n   *\n   * `remotePeer.on('stream-playable', ({ label: string; consumer: Consumer }) => {})`\n   *\n   * @param data - {peerId: string, label: string, appData: Record<string, unknown>}\n   *\n   */\n\n  public consume = checkPermissions({\n    canConsume: true,\n  }).validate(\n    async (data: {\n      peerId: string;\n      label: string;\n      appData: AppData;\n    }): Promise<Consumer> => {\n      const remotePeer = this.__remotePeers.get(data.peerId);\n\n      if (!remotePeer) {\n        throw new Error(`Remote Peer Not Found with PeerId ${data.peerId}`);\n      }\n\n      const labelData = remotePeer.getLabelData(data.label);\n\n      if (!labelData) {\n        throw new Error(\n          `Remote Peer is not producing with Label ${data.label}`,\n        );\n      }\n\n      const consumerExists = remotePeer.getConsumer(data.label);\n\n      if (consumerExists?.consuming) {\n        logger.warn('🔔 Consumer Already Exists with label ', data.label);\n\n        return consumerExists;\n      }\n\n      const pendingPromise = this.__pendingConsumerTasks.get(\n        labelData?.producerId,\n      );\n\n      if (pendingPromise) {\n        logger.warn(\n          `🔔 Consumer Task Pending to be Consumed with label ${data.label}, Returning`,\n        );\n\n        const consumer = await pendingPromise;\n\n        return consumer;\n      }\n\n      logger.info('🔔 Consuming Stream with label ', data.label);\n\n      if (!this.__recvTransport) {\n        logger.info(\n          '🔔 Recv Transport Not Initialized, Creaitng RecvTransport',\n        );\n\n        await this.__createTransportOnServer({\n          transportType: 'recv',\n        });\n      }\n\n      const consumerPromise = new Promise<Consumer>((resolve) => {\n        const handleStreamPlayable = (streamData: {\n          label: string;\n          consumer: Consumer;\n        }) => {\n          if (streamData.label === data.label) {\n            remotePeer.off('stream-playable', handleStreamPlayable);\n\n            resolve(streamData.consumer);\n          }\n        };\n\n        remotePeer.once('stream-playable', handleStreamPlayable);\n\n        this.socket.publish('consume', {\n          createConsumerData: {\n            appData: data.appData,\n            producerId: labelData.producerId,\n            producerPeerId: data.peerId,\n          },\n        });\n      });\n\n      this.__pendingConsumerTasks.set(labelData.producerId, consumerPromise);\n\n      const consumer = await consumerPromise\n        .catch((error) => {\n          logger.error('❌ Error Consuming Stream');\n          logger.error(error);\n\n          throw error;\n        })\n        .finally(() => {\n          this.__pendingConsumerTasks.delete(labelData.producerId);\n        });\n\n      return consumer;\n    },\n  );\n\n  /**\n   * Stops the underlying consuming of a stream for a particular label\n   *\n   * `NOTE: This does not notify the remote peers that you are not consuming a stream`\n   *\n   * @param data\n   */\n  public stopConsuming = (data: {\n    peerId: string;\n    label: string;\n  }) => {\n    const remotePeer = this.room.getRemotePeerById(data.peerId);\n\n    if (!remotePeer.hasLabel(data.label)) {\n      logger.error(\n        `❌ Remote Peer is not producing anything with label: ${data.label}`,\n      );\n\n      return;\n    }\n\n    const consumer = this.recvTransport.getConsumer(data);\n\n    if (!consumer) {\n      logger.error('❌ Consumer Not Found', data);\n\n      return;\n    }\n\n    if (!consumer.consuming) {\n      logger.error('❌ You are not Consuming any Stream, Consumer Not Found');\n\n      return;\n    }\n\n    const consumerId = consumer.id;\n\n    if (!consumerId) {\n      logger.error('❌ ConsumerId Not Found');\n\n      return;\n    }\n\n    this.socket.publish('closeConsumer', {\n      consumerId: consumer.id,\n    });\n\n    remotePeer.emit('stream-closed', {\n      label: data.label,\n    });\n\n    this.recvTransport.closeConsumer(data);\n  };\n\n  /**\n   * Function to activate the volatile data messaging\n   * @throws {Error} If activation of notification fails.\n   */\n  public activateSpeakerNotification = async () => {\n    logger.info(\"🔔 Activating Speaker Notification, size: '9'\");\n\n    const botDataProducer = this.__sendTransport?.dataProducers.get('bot');\n\n    if (botDataProducer) {\n      logger.info('🔔 Bot Data Producer Already Exists');\n\n      return;\n    }\n\n    const ongoingActiveSpeakerPromise = this.__pendingTasks.get('bot');\n\n    if (ongoingActiveSpeakerPromise) {\n      logger.info('🔔 Bot Data Producer Task Already Pending');\n\n      await ongoingActiveSpeakerPromise;\n    } else {\n      const activateNotificationPromise = async () => {\n        if (!this.__recvTransport) {\n          logger.info(\n            '🔔 Recv Transport Not Initialized, Creating RecvTransport',\n          );\n\n          await this.__createTransportOnServer({\n            transportType: 'recv',\n          });\n        }\n\n        this.socket.publish('activateSpeakerNotification', {\n          size: this.room.activeSpeakers.size,\n        });\n      };\n\n      const promise = activateNotificationPromise();\n\n      this.__pendingTasks.set('bot', promise);\n\n      await promise;\n    }\n  };\n\n  public sendData = checkPermissions({\n    canSendData: true,\n  }).validate(\n    (data: { to: string[] | '*'; payload: string; label?: string }) => {\n      if (estimateSize(data.payload) > MAX_DATA_MESSAGE_SIZE) {\n        logger.error('❌ Data message exceeds 1kb in size');\n        return;\n      }\n\n      this.socket.publish('sendData', data);\n    },\n  );\n\n  public produceData = () => {\n    logger.info('🔔 Producing Data,');\n  };\n\n  /**\n   * Send Message to update the metadata of the Local Peer\n   *\n   * `NOTE: This will notify every user in the room about the metadata update`\n   */\n  public updateMetadata = checkPermissions({\n    canUpdateMetadata: true,\n  }).validate(<T = unknown>(data: T) => {\n    if (!this.joined) {\n      logger.error(\n        '❌ Cannot Update Metadata, You have not joined the room yet',\n      );\n\n      return;\n    }\n\n    const peerId = this.peerId;\n\n    if (!peerId) {\n      logger.error('❌ Cannot Update Metadata, PeerId Not Found');\n\n      return;\n    }\n\n    const newMetadata = JSON.stringify(data);\n\n    this.socket.publish('updatePeerMetadata', {\n      peerId,\n      metadata: newMetadata,\n    });\n  });\n\n  /**\n   * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.\n   */\n  public updateRole = (data: { role: string }) => {\n    try {\n      if (!this.joined) {\n        throw new Error(\n          '❌ Cannot Update Role, You have not joined the room yet',\n        );\n      }\n\n      if (data.role === this.role) {\n        logger.warn('🔔 Peer Role is already set to', data.role);\n\n        return;\n      }\n\n      if (!this.peerId) {\n        logger.error(\n          '❌ Cannot Update Role, PeerId Not Found, (You have not joined the room yet)',\n        );\n\n        return;\n      }\n\n      this.socket.publish('updatePeerRole', {\n        peerId: this.peerId,\n        role: data.role,\n      });\n    } catch (error) {\n      logger.error('🔔 Error Updating Role', data);\n      logger.error(error);\n    }\n  };\n\n  private __handler: SushiToClientEvents = {\n    error: (data) => {\n      logger.error('❌ Error Event');\n      logger.error(data);\n    },\n    /**\n     * When Huddle01 Node has successfully accepted the connection request\n     * it sents back some usefull metadata for the client to use\n     * at this point the socket is assumed to the connected and the localPeer is ready to join the room\n     *\n     * @param data - Data from server { peerId }\n     */\n    hello: (data) => {\n      logger.info('✅ Hello From Server, Connection Success');\n\n      logger.info(data);\n\n      this.peerId = data.peerId;\n\n      this.__permissions.updatePermissions(data.acl);\n\n      if (data.role) this.__permissions.role = data.role;\n\n      this.emit('permissions-updated', {\n        permissions: data.acl,\n        role: data.role,\n      });\n\n      if (data.metadata) {\n        this.__updateMetadata(data.metadata);\n      }\n    },\n\n    waitingRoom: (data) => {\n      logger.info('🔔 Waiting Room');\n\n      this.room.emit('room-waiting', data);\n    },\n\n    /**\n     * @description Uponn successful joining of the room, the server sends back some usefull metadata such as remotePeers in the room.\n     * @emits \"room-joined\" - When the client has successfully joined the room.\n     * @emits \"join-error\" - When the client has failed to join the room.\n     * @param data - Data from server { roomId, roomInfo, routerRTPCapabilities, turnServer }\n     */\n    connectRoomResponse: async (data) => {\n      logger.info('✅ Join Success Event');\n      logger.info({ roomInfo: data.roomInfo });\n\n      try {\n        const { roomInfo, routerRTPCapabilities, turnServers } = data;\n\n        this.room.config = roomInfo.config;\n\n        this.room.metadata = roomInfo.metadata;\n\n        const deviceType = detectDevice();\n\n        if (!deviceType) {\n          logger.error(\n            \"❌ Device is not supported, valid devices are : 'Chrome111' | 'Chrome74' | 'Chrome70' | 'Chrome67' | 'Chrome55' | 'Firefox60' | 'Safari12' | 'Safari11' | 'Edge11' | 'ReactNativeUnifiedPlan' | 'ReactNative'\",\n          );\n\n          throw new Error('❌ Device is not supported');\n        }\n\n        this.__device = new Device({ handlerName: deviceType });\n\n        await this.__device.load({\n          routerRtpCapabilities: routerRTPCapabilities,\n        });\n\n        if (!this.device.loaded) {\n          throw new Error('❌ Cannot Load Device');\n        }\n\n        this.emit('device-created', { device: this.__device });\n\n        this.__setRemotePeers(roomInfo);\n\n        this.__setLobbyPeers(roomInfo);\n\n        if (turnServers.length) {\n          logger.info('🔔 Setting Turn Server', turnServers);\n          this.__turn = [...turnServers, ...this.__turn];\n        }\n\n        this.room.state = 'connected';\n\n        this.joined = true;\n\n        this.room.emit('room-joined');\n      } catch (error) {\n        logger.error('❌ Error Joining Room');\n        logger.error(error);\n\n        this.room.emit('room-joined-failed', {\n          message: '❌ Error Joining Room',\n          status: 'ROOM_ERRORED',\n        });\n      }\n\n      this.__handleWaitingToProduce();\n    },\n    /**\n     * @description update the remote peers in the room , remove the remote peers which are not in the room anymore\n     * @param roomInfo\n     */\n    syncMeetingStateResponse: async (roomInfo) => {\n      try {\n        logger.info('✅ Client recovered after reconnecting');\n\n        const { peers: latestPeers } = roomInfo;\n\n        const latestPeersSet = new Set(latestPeers.map((p) => p.peerId));\n\n        for (const [peerId, peer] of this.__remotePeers.entries()) {\n          if (!latestPeersSet.has(peerId)) {\n            // Handle peer removal\n            for (const label of peer.labels) {\n              this.__closeRemotePeerConsumer({\n                peerId,\n                label,\n              });\n            }\n\n            peer.close();\n            this.__remotePeers.delete(peerId);\n\n            this.room.emit('peer-left', peerId);\n\n            return;\n          }\n\n          // close already closed streams of remote peer\n          const latestPeerInfo = latestPeers.find((p) => p.peerId === peerId);\n          if (!latestPeerInfo) return;\n\n          const newProducerSet = new Set(\n            latestPeerInfo.producers.map((p) => p.label),\n          );\n          for (const label of peer.labels) {\n            if (!newProducerSet.has(label)) {\n              this.__closeRemotePeerConsumer({ peerId, label });\n            }\n          }\n\n          // add label data for new producers if not already present\n\n          const currentProducerSet = new Set(peer.producerIds);\n\n          for (const producer of latestPeerInfo.producers) {\n            if (!currentProducerSet.has(producer.id)) {\n              if (\n                !this.__recvTransport ||\n                this.__recvTransport.connectionState === 'connected'\n              ) {\n                peer._addLabelData({\n                  producerId: producer.id,\n                  label: producer.label,\n                });\n              } else {\n                this.__waitingToConsume.push(() => {\n                  return peer._addLabelData({\n                    producerId: producer.id,\n                    label: producer.label,\n                  });\n                });\n              }\n            }\n          }\n        }\n\n        // Handle new peers\n        const filteredPeers = latestPeers\n          .filter(\n            (latestPeer) =>\n              !this.__remotePeers.has(latestPeer.peerId) &&\n              latestPeer.peerId !== this.peerId,\n          )\n          .values();\n\n        for (const latestPeer of filteredPeers) {\n          const remotePeer = new RemotePeer({\n            peerId: latestPeer.peerId,\n            role: latestPeer.role,\n            metadata: latestPeer.metadata,\n          });\n          const remoteProducers = latestPeer.producers;\n          for (const p of remoteProducers) {\n            if (\n              !this.__recvTransport ||\n              this.__recvTransport.connectionState === 'connected'\n            ) {\n              remotePeer._addLabelData({ producerId: p.id, label: p.label });\n            } else {\n              this.__waitingToConsume.push(() => {\n                return remotePeer._addLabelData({\n                  producerId: p.id,\n                  label: p.label,\n                });\n              });\n            }\n          }\n          this.__remotePeers.set(latestPeer.peerId, remotePeer);\n          this.room.emit('new-peer-joined', { peer: remotePeer });\n        }\n      } catch (error) {\n        logger.error(\"❌ Error Syncing Meeting State, Can't Recover\");\n        logger.error(error);\n      }\n    },\n\n    /**\n     * Upon creation of server side transport, the server sends back some usefull metadata for the client to use\n     * to create a client side transport, i.e. `send | recv` Transport.\n     * @param data - Data from server { transportSDPInfo, transportType }\n     */\n    createTransportOnClient: async (data) => {\n      try {\n        const device = this.device;\n\n        if (!this.peerId)\n          throw new Error(\n            '❌ Cannot Create Transport, No PeerId Found for the user.',\n          );\n\n        const transport = Transport.create({\n          device,\n          peerId: this.peerId,\n          socket: this.socket,\n          sdpInfo: data.transportSDPInfo,\n          iceServers: this.__turn,\n          transportType: data.transportType,\n        });\n\n        if (transport.transportType === 'send') {\n          this.__sendTransport = transport;\n\n          this.__sendTransport.mediasoupTransport.on(\n            'connectionstatechange',\n            (connectionState) => {\n              if (connectionState === 'connected') {\n                this.__handleWaitingToProduce();\n              }\n            },\n          );\n\n          this.emit('new-send-transport', {\n            transport,\n          });\n        }\n\n        if (transport.transportType === 'recv') {\n          this.__recvTransport = transport;\n\n          this.__recvTransport.mediasoupTransport.on(\n            'connectionstatechange',\n            (connectionState) => {\n              if (connectionState === 'connected') {\n                this.__handleWaitingToConsume();\n              }\n            },\n          );\n\n          this.emit('new-recv-transport', {\n            transport,\n          });\n        }\n      } catch (error) {\n        logger.error(\n          '❌ Error Creating MediasoupTransport On Client, transportType',\n          data.transportType,\n        );\n        logger.error(error);\n      }\n    },\n\n    /**\n     * !Important\n     * When the server has successfully connected the transport, it sends a ack back to the client\n     * which handles the callback() function which triggers the process of creation of producer and consumer\n     * for reference see: packages/nezuko/src/Transport.ts\n     * @param data\n     */\n    connectTransportResponse: async (data) => {\n      logger.info(\n        `✅ Connect ${data.transportType} Transport On Server Response`,\n      );\n\n      try {\n        const transportType = data.transportType;\n\n        const transport =\n          transportType === 'send'\n            ? this.__sendTransport\n            : this.__recvTransport;\n\n        if (!transport) {\n          throw new Error(`${transportType} Transport Not Initialized`);\n        }\n\n        transport.emit('connectTransportResponse');\n      } catch (error) {\n        logger.error('❌ Error Connecting Transport On Server Response');\n        logger.error(error);\n      }\n    },\n\n    produceResponse: async (data) => {\n      logger.info('✅ Produce Response');\n      logger.info(data);\n      try {\n        const { peerId, producerId, label } = data;\n\n        if (peerId === this.peerId) {\n          this.sendTransport.resolvePendingProducerTask({\n            id: producerId,\n            label,\n            peerId,\n          });\n        } else {\n          const remotePeer = this.room.getRemotePeerById(peerId);\n          if (\n            !this.__recvTransport ||\n            this.__recvTransport.connectionState === 'connected'\n          ) {\n            remotePeer._addLabelData({\n              producerId,\n              label,\n            });\n          } else {\n            this.__waitingToConsume.push(() => {\n              return remotePeer._addLabelData({\n                producerId,\n                label,\n              });\n            });\n          }\n        }\n      } catch (error) {\n        logger.error('❌ Error Produce Response');\n        logger.error(error);\n      }\n    },\n\n    produceDataResponse: async (data) => {\n      logger.info('✅ Produce Data Response consumerIdFromServer:%o', data.id);\n      logger.info(data);\n      try {\n        const {\n          id,\n          peerId,\n          dataProducerId,\n          label,\n          appData,\n          protocol,\n          sctpStreamParameters,\n        } = data;\n\n        if (peerId === this.peerId && label !== 'bot') {\n          this.sendTransport.resolvePendingProducerTask({\n            id: dataProducerId,\n            label,\n            peerId,\n          });\n        }\n\n        const botDataConsumer = this.recvTransport.dataConsumers.get(label);\n\n        if (botDataConsumer) {\n          logger.error(\"❌ Bot Data Consumer Already Exists, Can't Create\", {\n            label,\n          });\n\n          return;\n        }\n\n        const dataConsumer = await this.recvTransport.consumeData({\n          appData,\n          dataProducerId,\n          id,\n          label,\n          peerId,\n          protocol,\n          sctpStreamParameters,\n        });\n\n        dataConsumer.on('message', (message: string) => {\n          const parsedJsonData = JSON.parse(message);\n\n          const result = VolatileDataMessageSchema.safeParse(parsedJsonData);\n\n          if (result.success) {\n            this.emit('receive-volatile-data', result.data);\n          } else {\n            throw new Error(\n              '❌ Data Consumer Message Schema Validation Failed',\n            );\n          }\n        });\n\n        if (label === 'bot') {\n          this.__pendingTasks.delete('bot');\n        }\n      } catch (error) {\n        logger.error('❌ Error Produce Data Response');\n        logger.error({ error });\n      }\n    },\n\n    consumeResponse: async (data) => {\n      logger.info('✅ Consume Response');\n\n      logger.info({\n        id: data.consumerId,\n        label: data.label,\n        consumerId: data.consumerId,\n        producerPeerId: data.producerPeerId,\n      });\n\n      try {\n        const remotePeer = this.room.getRemotePeerById(data.producerPeerId);\n\n        if (!remotePeer.hasLabel(data.label)) {\n          logger.error('❌ Remote Peer is not producing this label', {\n            label: data.label,\n          });\n\n          throw new Error(\n            `❌ Remote Peer is not producing this label: ${data.label}`,\n          );\n        }\n\n        const { consumer, mediaSoupConsumer } =\n          await this.recvTransport.consume(data);\n\n        remotePeer.emit('stream-playable', {\n          consumer,\n          label: consumer.label,\n        });\n\n        this.room.emit('stream-added', {\n          label: consumer.label,\n          peerId: data.producerPeerId,\n        });\n\n        this.socket.publish('resumeConsumer', {\n          consumerId: data.consumerId,\n          producerPeerId: data.producerPeerId,\n        });\n\n        mediaSoupConsumer.resume();\n      } catch (error) {\n        logger.error('❌ Error Consume Response');\n        logger.error(error);\n\n        this.__pendingConsumerTasks.delete(data.producerId);\n      }\n    },\n\n    closeProducerSuccess: async (data) => {\n      logger.info('✅ Producer Closed', data);\n\n      if (this.peerId === data.peerId) return;\n\n      const { peerId, label } = data;\n\n      try {\n        this.__closeRemotePeerConsumer({\n          peerId,\n          label,\n        });\n      } catch (err) {\n        logger.error('❌ Error Closing Producer');\n        logger.error(err);\n      }\n    },\n\n    closeConsumerSuccess: async (data) => {\n      logger.info('✅ Consumer Closed, ', data);\n    },\n\n    restartTransportIceResponse: async (data) => {\n      const { transportType, iceParameters } = data;\n\n      logger.info('✅ Restart Transport Ice Response ', transportType);\n\n      const transport =\n        transportType === 'send' ? this.__sendTransport : this.__recvTransport;\n\n      if (!transport) {\n        logger.error(`❌ ${transportType} Transport Not Found`);\n        return;\n      }\n\n      try {\n        await transport.mediasoupTransport.restartIce({ iceParameters });\n        logger.info('✅ Restarted Ice for type: ', transportType);\n      } catch (error) {\n        logger.error('❌ Error Restarting Ice for type: ', transportType);\n        logger.error(error);\n      }\n    },\n\n    newPeerJoined: (data) => {\n      if (this.peerId === data.peerId) return;\n\n      logger.info('✅ New Peer Joined', { data });\n\n      try {\n        const { peerId } = data;\n\n        const remotePeer = new RemotePeer({\n          peerId,\n          role: data.role,\n          metadata: data.metadata,\n        });\n\n        this.__remotePeers.set(peerId, remotePeer);\n\n        const lobbyPeers = this.room.lobbyPeersMap;\n\n        if (lobbyPeers.has(peerId)) {\n          lobbyPeers.delete(peerId);\n\n          this.room.lobbyPeersMap = lobbyPeers;\n        }\n\n        this.room.emit('new-peer-joined', { peer: remotePeer });\n      } catch (error) {\n        logger.error('❌ Error New Peer Joined');\n        logger.error(error);\n      }\n    },\n\n    newLobbyPeer: (data) => {\n      try {\n        logger.info('✅ New Lobby Peer', { data });\n\n        this.room.newlobbyPeers = [data];\n      } catch (error) {\n        logger.error('❌ Error New Lobb Peer');\n        logger.error(error);\n      }\n    },\n\n    newPermissions: (data) => {\n      try {\n        this.__permissions.updatePermissions(data);\n\n        this.emit('permissions-updated', {\n          permissions: this.permissions,\n        });\n      } catch (error) {\n        logger.error('❌ Error Updating Permissions');\n        logger.error(error);\n      }\n    },\n\n    newRoomControls: (data) => {\n      logger.info('✅ Received New Room Controls', { data });\n\n      this.room.config = {\n        ...this.room.config,\n        [data.type]: data.value,\n      };\n\n      //TODO: Update the permission of the peer;\n\n      this.room.emit('room-controls-updated', data);\n    },\n\n    newPeerRole: (data) => {\n      logger.info(\"✅ Received New Peer's Role\", { data });\n\n      try {\n        const { peerId, role } = data;\n\n        if (peerId === this.peerId) {\n          logger.info(\"✅ Updating Local Peer's Role\");\n\n          this.__permissions.role = role;\n\n          this.emit('role-updated', {\n            role,\n          });\n\n          return;\n        }\n\n        const remotePeer = this.room.getRemotePeerById(peerId);\n\n        const prevRole = remotePeer.role || '';\n\n        remotePeer.role = role;\n\n        this.room.emit('room-role-updated', {\n          peerId,\n          newRole: role,\n          prevRole,\n        });\n      } catch (error) {\n        logger.error(\"❌ Error Updating Peer's Role\");\n        logger.error(error);\n      }\n    },\n\n    roomClosedProducers: (data) => {\n      logger.info(\"✅ Received Room's Closed Producers\", { data });\n\n      try {\n        const { producers, reason } = data;\n\n        for (const producer of producers) {\n          const { label, peerId } = producer;\n\n          if (peerId === this.peerId) {\n            this.stopProducing({ label });\n\n            continue;\n          }\n\n          try {\n            const remotePeer = this.room.getRemotePeerById(peerId);\n\n            const consumer = this.recvTransport.getConsumer({\n              label,\n              peerId,\n            });\n\n            if (consumer) {\n              this.recvTransport.closeConsumer({ label, peerId });\n\n              remotePeer._removeLabelData(label);\n\n              this.room.emit('stream-closed', {\n                label,\n                peerId,\n              });\n            }\n          } catch (error) {\n            logger.error('❌ Error Closing Producer');\n            logger.error(error);\n          }\n        }\n\n        this.room.emit('room-notification', reason);\n      } catch (error) {\n        logger.error(\"❌ Error Updating Room's Closed Producers\");\n        logger.error(error);\n      }\n    },\n\n    receiveData: (data) => {\n      logger.info('✅ Received Data', { data });\n      try {\n        this.emit('receive-data', data);\n      } catch (error) {\n        logger.error('❌ Error Receive Data');\n        logger.error(error);\n      }\n    },\n\n    peerMetadataUpdated: (data) => {\n      try {\n        logger.info('✅ Metadata Updated', { data });\n\n        const { peerId, metadata } = data;\n\n        if (this.peerId === peerId) {\n          this.__updateMetadata(data.metadata);\n\n          return;\n        }\n\n        const remotePeer = this.room.getRemotePeerById(peerId);\n\n        remotePeer.metadata = JSON.parse(metadata);\n      } catch (error) {\n        logger.error('❌ Error Updating Metadata');\n        logger.error(error);\n      }\n    },\n\n    roomMetadataUpdated: (data) => {\n      logger.info('✅ Room Metadata Updated', { data });\n\n      try {\n        const { metadata } = data;\n\n        this.room.metadata = metadata;\n      } catch (error) {\n        logger.error('❌ Error Updating Room Metadata');\n        logger.error(error);\n      }\n    },\n\n    peerLeft: (data) => {\n      logger.info('✅ Peer Left', { peerId: data.peerId });\n\n      try {\n        const { peerId } = data;\n\n        const remotePeer = this.room.getRemotePeerById(peerId);\n\n        const labels = remotePeer.labels;\n\n        for (const label of labels) {\n          this.__closeRemotePeerConsumer({\n            peerId: remotePeer.peerId,\n            label,\n          });\n        }\n\n        remotePeer.close();\n\n        this.__remotePeers.delete(peerId);\n\n        this.room.emit('peer-left', data.peerId);\n      } catch (error) {\n        logger.error('❌ Error Peer Left');\n        logger.error(error);\n      }\n    },\n\n    lobbyPeerLeft: (data) => {\n      logger.info('✅ Lobby Peer Left', { peerId: data.peerId });\n\n      try {\n        const { peerId } = data;\n        const lobbyPeers = this.room.lobbyPeersMap;\n\n        if (lobbyPeers.has(peerId)) {\n          lobbyPeers.delete(peerId);\n\n          this.room.lobbyPeersMap = lobbyPeers;\n        }\n      } catch (error) {\n        logger.error(\"❌ Error Lobby Peer's Left\");\n        logger.error(error);\n      }\n    },\n  };\n\n  /**\n   * @description Creates a Producer, if send transport is not initialized, it creates one and then creates a producer\n   * @param data - Data to create a producer { label, stream, stopTrackOnClose, appData }\n   * @returns - Producer\n   */\n  private __createProducer = async (data: {\n    label: string;\n    stream: MediaStream;\n    stopTrackOnClose?: boolean;\n    appData?: AppData;\n  }): Promise<Producer> => {\n    if (!this.__sendTransport) {\n      throw new Error('❌ Send Transport Not Initialized, Internal Error');\n    }\n\n    const producer = await this.__sendTransport.produce({\n      stream: data.stream,\n      stopTrackOnClose: data.stopTrackOnClose ?? true,\n      label: data.label,\n      appData: {\n        ...data.appData,\n        label: data.label,\n      },\n    });\n\n    producer.on('transportclose', () => {\n      this.stopProducing({ label: data.label });\n    });\n\n    this.emit('stream-playable', {\n      label: data.label,\n      producer,\n    });\n\n    return producer;\n  };\n\n  private __createTransportOnServer = async (data: {\n    transportType: TTransportType;\n  }): Promise<Transport> => {\n    const pendingPromise = this.__pendingTransportTasks.get(data.transportType);\n\n    if (pendingPromise) {\n      logger.info(\n        `🔔 Transport Task Already Pending for this transportType ${data.transportType}`,\n      );\n\n      return pendingPromise;\n    }\n\n    const { transportType } = data;\n\n    const promise = new Promise<Transport>((resolve, reject) => {\n      const handleNewTransport = (data: { transport: Transport }) => {\n        if (data.transport.transportType === transportType) {\n          this.__pendingTransportTasks.delete(transportType);\n\n          resolve(data.transport);\n        }\n      };\n      if (transportType === 'send') {\n        this.once('new-send-transport', handleNewTransport);\n      }\n\n      if (transportType === 'recv') {\n        this.once('new-recv-transport', handleNewTransport);\n      }\n\n      const device = this.device;\n\n      const transport =\n        data.transportType === 'send'\n          ? this.__sendTransport\n          : this.__recvTransport;\n\n      if (transport) {\n        reject(\n          new Error(`❌ Transport Already Initialized, type: ${transportType}`),\n        );\n      }\n\n      logger.info(`🔔 Creating ${data.transportType} Transport On Server`);\n\n      this.socket.publish('createTransport', {\n        sctpCapabilities: device.sctpCapabilities,\n        transportType,\n      });\n    });\n\n    this.__pendingTransportTasks.set(data.transportType, promise);\n\n    return promise;\n  };\n\n  /**\n   * Sets the Remote Peers in the Room\n   * @param roomInfo\n   */\n  private __setRemotePeers = (roomInfo: RoomInfo) => {\n    this.__remotePeers.clear();\n\n    const { peers } = roomInfo;\n\n    for (const peer of peers) {\n      if (peer.peerId === this.peerId) continue;\n\n      const remotePeer = new RemotePeer({\n        peerId: peer.peerId,\n        metadata: peer.metadata,\n        role: peer.role,\n      });\n\n      const producers = peer.producers;\n\n      this.__remotePeers.set(peer.peerId, remotePeer);\n\n      producers.map((p) => {\n        if (\n          !this.__recvTransport ||\n          this.__recvTransport.connectionState === 'connected'\n        ) {\n          remotePeer._addLabelData({\n            producerId: p.id,\n            label: p.label,\n          });\n        } else {\n          this.__waitingToConsume.push(() => {\n            return remotePeer._addLabelData({\n              producerId: p.id,\n              label: p.label,\n            });\n          });\n        }\n      });\n    }\n  };\n\n  /**\n   * Sets the Lobby Peers in the Room\n   * @param roomInfo - RoomInfo\n   */\n  private __setLobbyPeers = (roomInfo: RoomInfo) => {\n    this.room.lobbyPeers.clear();\n\n    const { lobbyPeers } = roomInfo;\n\n    this.room.newlobbyPeers = lobbyPeers;\n  };\n\n  /**\n   * Helper Function to close the consumer of a remote peer\n   * @param data - Data to close the consumer { peerId, label }\n   */\n  private __closeRemotePeerConsumer = (data: {\n    peerId: string;\n    label: string;\n  }) => {\n    try {\n      const { peerId, label } = data;\n\n      const remotePeer = this.room.getRemotePeerById(peerId);\n\n      const consumer = this.recvTransport.getConsumer({\n        label,\n        peerId,\n      });\n\n      if (consumer) {\n        this.recvTransport.closeConsumer({ label, peerId });\n\n        remotePeer._removeLabelData(label);\n      }\n\n      this.room.emit('stream-closed', {\n        label,\n        peerId: data.peerId,\n      });\n    } catch (error) {\n      logger.error(\"❌ Error Closing Remote Peer's Consumer\");\n      logger.error(error);\n    }\n  };\n\n  /**\n   * !important\n   * Handler Function to handle the waiting to produce tasks when user is joining\n   * the room with active stream, check if the user has valid permissions and based on\n   * that allows the user to produce the stream\n   */\n  private __handleWaitingToProduce = () => {\n    try {\n      const permissions = this.permissions;\n\n      const closeStream = (label: string) => {\n        const stream = this.__activeStreams.get(label);\n\n        if (stream) {\n          this.deviceHandler.stopStream(stream);\n\n          this.__activeStreams.delete(label);\n\n          this.emit('stream-closed', {\n            label,\n            reason: {\n              code: 4444,\n              message: \"User's Permissions Denied\",\n              tag: 'CLOSED_BY_ADMIN',\n            },\n          });\n        }\n\n        this.__waitingToProduce.delete(label);\n      };\n\n      if (!permissions.canProduce) {\n        for (const [label, _] of this.__waitingToProduce) {\n          closeStream(label);\n        }\n\n        this.__waitingToProduce.clear();\n\n        return;\n      }\n\n      for (const [label, pendingStreamTask] of this.__waitingToProduce) {\n        if (label === 'video' && !permissions.canProduceSources.cam) {\n          closeStream(label);\n          continue;\n        }\n\n        if (label === 'audio' && !permissions.canProduceSources.mic) {\n          closeStream(label);\n          continue;\n        }\n\n        pendingStreamTask().catch((error) => {\n          logger.error(\n            '❌ Error Producing Stream which was waiting to be produced with label :',\n            label,\n          );\n          logger.error(error);\n\n          closeStream(label);\n        });\n      }\n\n      this.__waitingToProduce.clear();\n    } catch (error) {\n      logger.error('❌ Error Handling Waiting To Produce');\n      logger.error(error);\n    }\n  };\n\n  private __handleWaitingToConsume = () => {\n    for (const consumeTask of this.__waitingToConsume) {\n      consumeTask().catch(() => {\n        logger.error('Unable to Consume after ice restart');\n      });\n    }\n    this.__waitingToConsume = [];\n  };\n\n  public testEvent = (data: {\n    break: boolean;\n  }) => {\n    try {\n      if (!this.peerId) {\n        throw new Error('❌ Cannot Test Event, PeerId Not Found');\n      }\n\n      this.socket.publish('testEvent', {\n        break: data.break,\n        peerId: this.peerId,\n      });\n    } catch (error) {\n      logger.error('❌ Error Test Event');\n    }\n  };\n}\n\nexport default LocalPeer;\n","import Consumer from './Consumer';\nimport LocalPeer from './LocalPeer';\nimport Room from './Room';\n\nimport { mainLogger } from './logger';\nimport { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter';\nimport { TPermissions } from 'types/dist/common.types';\nimport { checkPermissions } from './Permissions';\n\nexport type RemotePeerEvents = {\n  'stream-available': [\n    data: {\n      label: string;\n      labelData: {\n        producerId: string;\n      };\n    },\n  ];\n\n  'stream-playable': [\n    data: {\n      label: string;\n      consumer: Consumer;\n    },\n  ];\n\n  'stream-closed': [\n    data: {\n      label: string;\n      reason?: { code: number; tag: string; message: string };\n    },\n  ];\n\n  'metadata-updated': [\n    data: {\n      metadata: string;\n    },\n  ];\n\n  'role-updated': [\n    data: {\n      role?: string;\n    },\n  ];\n};\n\nconst logger = mainLogger.createSubLogger('RemotePeer');\n\nclass RemotePeer extends EnhancedEventEmitter<RemotePeerEvents> {\n  /**\n   * peerId of the remote peer, this is unique for each peer\n   */\n  public peerId: string;\n\n  /**\n   * Stores the Metadata for the Remote Peer.\n   */\n  private __metadata: unknown = '{}';\n\n  /**\n   * Stores the Role of the Remote Peer.\n   */\n  private __role: string | null = null;\n\n  /**\n   * Labels are the unique identifier for the media stream that the remote peer is producing\n   */\n  private readonly __labelsToProducerId: Map<string, { producerId: string }> =\n    new Map();\n\n  /**\n   * Returns the list of labels that the remote peer is producing\n   */\n  public get labels() {\n    return Array.from(this.__labelsToProducerId.keys());\n  }\n\n  public get producerIds() {\n    return Array.from(this.__labelsToProducerId.values()).map(\n      (labelData) => labelData.producerId,\n    );\n  }\n\n  /**\n   * Role of the Peer.\n   * @returns The Role of the Peer which if passed in the options when creating the token\n   */\n  public get role(): string | null {\n    if (!this.__role) return null;\n\n    return this.__role;\n  }\n\n  public set role(role: string) {\n    this.__role = role;\n\n    this.emit('role-updated', {\n      role,\n    });\n  }\n\n  /**\n   * Checks if the remote peer is producing the label\n   * @param label - Label to check if the remote peer is producing\n   * @returns - Returns true if the remote peer is producing the label\n   */\n  public hasLabel(label: string) {\n    return this.__labelsToProducerId.has(label);\n  }\n\n  /**\n   * Returns the data associated to the label, this is the producerId\n   *\n   * @returns\n   * producerId - Unique identifier for the producer\n   */\n  public getLabelData(label: string) {\n    return this.__labelsToProducerId.get(label);\n  }\n\n  /**\n   * Get the associated consumer for the label\n   * @param label - Unique identifier for the consumer e.g. `video` | `audio` | `screen-share-video` | string\n   * @returns Consumer | null\n   */\n  public getConsumer(label: string) {\n    try {\n      const localPeer = LocalPeer.getInstance();\n      const consumer = localPeer.recvTransport.getConsumer({\n        label,\n        peerId: this.peerId,\n      });\n\n      return consumer;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Returns the metadata associated to the RemotePeer\n   */\n  getMetadata<T = unknown>() {\n    return this.__metadata as T;\n  }\n\n  /**\n   * Setter function to update the Remote Peer Metadata\n   *\n   * `NOTE: This will NOT notify other Remote Peers of the update`\n   */\n  public set metadata(data: string) {\n    this.__metadata = data;\n\n    this.emit('metadata-updated', {\n      metadata: data,\n    });\n  }\n\n  /**\n   * Update the Permissions of the Remote Peer in the Room. This will emit an event `updated` with the updated permissions.\n   */\n  public updatePermissions = checkPermissions({\n    admin: true,\n  }).validate(async (data: Partial<TPermissions>) => {\n    try {\n      logger.info('🔔 Updating Permissions', data);\n\n      const localPeer = LocalPeer.getInstance();\n\n      const socket = localPeer.socket;\n\n      socket.publish('updatePeerPermission', {\n        peerId: this.peerId,\n        permission: data,\n      });\n    } catch (error) {\n      logger.error('🔔 Error Updating Permissions');\n      logger.error(error);\n    }\n  });\n\n  /**\n   * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.\n   */\n\n  public updateRole = checkPermissions({\n    admin: true,\n  }).validate((data: { role: string }) => {\n    try {\n      logger.info('🔔 Updating Peer Role', data);\n\n      if (data.role === this.__role) {\n        logger.warn('🔔 Role is already set to', data.role);\n\n        return;\n      }\n\n      const localPeer = LocalPeer.getInstance();\n\n      const socket = localPeer.socket;\n\n      socket.publish('updatePeerRole', {\n        peerId: this.peerId,\n        role: data.role,\n      });\n    } catch (error) {\n      logger.error('🔔 Error Updating Role', data);\n      logger.error(error);\n    }\n  });\n\n  /**\n   * Removes all the states of the remote peer and clears memory;\n   *\n   * `NOTE`: You need to close consumers using the `recvTransport.closeConsumer` of the local peer\n   */\n  public close = () => {\n    logger.info('Closing Remote Peer');\n\n    this.removeAllListeners();\n  };\n\n  constructor(data: { peerId: string; metadata?: string; role?: string }) {\n    super();\n\n    this.peerId = data.peerId;\n\n    if (data.metadata) {\n      this.metadata = JSON.parse(data.metadata);\n    }\n\n    if (data.role) {\n      this.__role = data.role;\n    }\n  }\n\n  /**\n   * @protected\n   * Add a New Label to the Remote Peer and associate it with the ProducerId\n   *\n   * `NOTE: This is used internally by the Peer`\n   *\n   * @param data - Data to add the new label `label` and the `producerId` to associate it with\n   */\n  public _addLabelData = async (data: {\n    label: string;\n    producerId: string;\n  }) => {\n    const { label, producerId } = data;\n\n    this.__labelsToProducerId.set(label, { producerId });\n\n    try {\n      const autoConsume = Room.getInstance().autoConsume;\n\n      const localPeer = LocalPeer.getInstance();\n\n      if (autoConsume) {\n        logger.debug(\n          \"AUTO CONSUME IS ENABLED, CONSUMING THE PRODUCER'S STREAM\",\n        );\n\n        localPeer.consume({\n          appData: {},\n          label,\n          peerId: this.peerId,\n        });\n      } else {\n        this.emit('stream-available', {\n          label,\n          labelData: {\n            producerId,\n          },\n        });\n      }\n    } catch (error) {\n      logger.error('❌ Error While Consuming', {\n        label,\n        peerId: this.peerId,\n      });\n      logger.error(error);\n\n      this.emit('stream-available', {\n        label,\n        labelData: {\n          producerId,\n        },\n      });\n    }\n  };\n\n  /**\n   * @protected\n   * Remove a Label from the Remote Peer and emit a `stream-closed` event\n   *\n   * `NOTE: This is used internally by the Peer`\n   *\n   * @param data - Data to remove the label from the Remote Peer\n   */\n  public _removeLabelData = (\n    label: string,\n    reason?: {\n      code: number;\n      tag: string;\n      message: string;\n    },\n  ) => {\n    this.__labelsToProducerId.delete(label);\n\n    this.emit('stream-closed', {\n      label,\n      reason,\n    });\n  };\n}\n\nexport default RemotePeer;\n"],"mappings":"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","names":["producer","data","error","track","consumer","logger"]}