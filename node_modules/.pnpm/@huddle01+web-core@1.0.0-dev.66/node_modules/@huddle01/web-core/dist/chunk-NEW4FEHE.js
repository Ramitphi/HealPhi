import {
  checkPermissions
} from "./chunk-V4S3N66D.js";
import {
  Socket_default
} from "./chunk-HVBBMWHF.js";
import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  EnhancedEventEmitter
} from "./chunk-7OTQAFXE.js";

// src/Room.ts
var logger = mainLogger.createSubLogger("Room.ts");
var Room = class _Room extends EnhancedEventEmitter {
  /**
   * Room Instance, Singleton class
   */
  static __instance = null;
  /**
   * Socket Instance, Singleton class
   */
  __socket = Socket_default.getInstance();
  /**
   * Returns the instance of the socket connection
   */
  get socket() {
    return this.__socket;
  }
  /**
   * Room Id of the current room
   */
  __roomId = null;
  /**
   * Lobby PeerIds
   */
  __lobbyPeers = /* @__PURE__ */ new Map();
  /**
   * Removed Lobby PeerId from the lobby
   * @param peerId - PeerId of the peer who joined the room
   */
  removeLobbyPeer = (peerId) => {
    this.__lobbyPeers.delete(peerId);
    this.emit("lobby-peers-updated", this.lobbyPeerIds);
  };
  /**
   * Room Config Object
   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
   * - `allowSendData`: Allow non-admin Peers in the Room to send data message
   * - `roomLocked`: If the room is locked
   */
  __config = {
    roomLocked: false,
    allowProduce: true,
    allowProduceSources: {
      cam: true,
      mic: true,
      screen: true
    },
    allowConsume: true,
    allowSendData: true
  };
  /**
   * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers
   *
   * @default true
   *
   * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,
   * - if set to false, the user will have to manually consume the media streams of the remote peers
   * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: "video", appData: {} });`
   */
  autoConsume = true;
  /**
   * If using activeSpeakerNotification, Returns back the size of peers which are returned for the activeSpeakers in the Room;
   * `Default` value is 8
   */
  activeSpeakers = {
    size: 8
  };
  /**
   * State of the Room
   */
  __state = "idle";
  /**
   * Set the state of the room
   */
  set state(newState) {
    if (this.state !== newState) {
      this.__state = newState;
    }
  }
  /**
   * State of the room
   */
  get state() {
    return this.__state;
  }
  /**
   * Get the lobby peers in the form of map
   * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}
   * @example
   * ```ts
   * const lobbyPeers = room.lobbyPeersMap;
   *
   * for (const [peerId, metadata] of lobbyPeers) {}
   *
   * ```
   */
  get lobbyPeersMap() {
    return this.__lobbyPeers;
  }
  /**
   * Get lobby peers in the form of array
   */
  get lobbyPeerIds() {
    return Array.from(this.__lobbyPeers.keys());
  }
  /**
   * Get lobby peers in the form of array
   * @returns - Array of Lobby PeerIds
   */
  get lobbyPeers() {
    return this.__lobbyPeers;
  }
  /**
   * Set lobby peers in the form of map
   * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`
   */
  set lobbyPeersMap(peers) {
    this.__lobbyPeers = peers;
    this.emit("lobby-peers-updated", this.lobbyPeerIds);
  }
  /**
   * Get
   * @returns
   */
  getLobbyPeerMetadata = (peerId) => {
    const lobbyPeer = this.lobbyPeers.get(peerId);
    let metadata = {};
    if (lobbyPeer?.metadata) {
      metadata = JSON.parse(lobbyPeer.metadata);
    }
    return {
      peerId,
      metadata
    };
  };
  /**
   * Set lobby peers in the form of array
   */
  set newlobbyPeers(peers) {
    for (const peer of peers) {
      this.__lobbyPeers.set(peer.peerId, peer);
    }
    this.emit("lobby-peers-updated", this.lobbyPeerIds);
  }
  /**
   * Room Config Object
   * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
   * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
   * - `allowSendData`: Allow non-admin Peers in the Room to send data message
   * - `roomLocked`: If the room is locked
   */
  get config() {
    return this.__config;
  }
  set config(config) {
    this.__config = config;
  }
  /**
   * Remote Peers Map, Stores all the remote peers
   */
  remotePeers = /* @__PURE__ */ new Map();
  /**
   * Metadata of the room.
   */
  __metadata = "{}";
  /**
   * Setter function for the metadata of the room
   * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`
   * `To notify everyone in the room about the metadata change, use the updateMetadata function`
   */
  set metadata(metadata) {
    this.__metadata = metadata;
    const parse = JSON.parse(metadata);
    this.emit("metadata-updated", parse);
  }
  /**
   * Get the metadata of the room
   */
  getMetadata = () => {
    const data = JSON.parse(this.__metadata || "{}");
    return data;
  };
  /**
   * Update Metadata of the room
   */
  updateMetadata = checkPermissions({}).validate(
    (data) => {
      try {
        if (this.state === "closed" || this.state === "failed" || this.state === "left") {
          logger.error(
            "\u274C Cannot Update Metadata, You have not joined the room yet"
          );
          return;
        }
        const metadata = JSON.stringify(data);
        this.metadata = metadata;
        this.socket.publish("updateRoomMetadata", {
          metadata
        });
      } catch (error) {
        logger.error("\u274C Error Updating Metadata");
        logger.error(error);
      }
    }
  );
  /**
   * Create a new Room Instance if not created, else return the existing Room Instance
   *
   * @returns - Room Instance
   */
  static create(data) {
    if (_Room.__instance) {
      return _Room.__instance;
    }
    logger.debug({ data });
    _Room.__instance = new _Room(data);
    return _Room.__instance;
  }
  /**
   * Get the Room Instance if its not initialized it will throw an error
   * @returns - Room Instance
   * @throws { Error } If the Room Instance is not initialized
   */
  static getInstance = () => {
    if (!_Room.__instance) {
      throw new Error("\u274C Room Instance Not Initialized");
    }
    return _Room.__instance;
  };
  /**
   * RoomId of the currently joined room.
   */
  get roomId() {
    if (!this.__roomId)
      return null;
    return this.__roomId;
  }
  set roomId(roomId) {
    if (this.__roomId) {
      logger.warn(
        "RoomId is already set, Ignoring the new roomId, end this room and create a new room"
      );
      return;
    }
    this.__roomId = roomId;
  }
  /**
   * Returns the PeerIds of the remote peers
   */
  get peerIds() {
    return Array.from(this.remotePeers.keys());
  }
  /**
   * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData
   * @param data: TNewRoomControls
   */
  updateRoomControls = checkPermissions({
    admin: true
  }).validate((data) => {
    logger.info("\u{1F514} Updating Room Controls", data);
    this.config[data.type] = data.value;
    this.emit("room-controls-updated", { ...data });
    this.socket.publish("updateRoomControls", data);
  });
  /**
   * Close a particular stream of remote peers
   *  @param data: { label: string; peerIds?: string[] }
   *  @param label: Label of the stream
   *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers
   */
  closeStreamOfLabel = checkPermissions({}).validate(
    (data) => {
      logger.info("\u{1F514} Closing Stream of Label", data);
      this.socket.publish("closeStreamOfLabel", data);
    }
  );
  /**
   * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions
   *
   * `NOTE: This will target all the audio stream in the room with the label "audio"`
   */
  muteEveryone = checkPermissions({ admin: true }).validate(() => {
    logger.info("\u{1F514} Muting Everyone");
    this.socket.publish("closeStreamOfLabel", {
      label: "audio"
    });
  });
  /**
   * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.
   *
   * @param peerId - PeerId of the remote peer
   * @returns - RemotePeer Instance
   * @return - null if the peer is not present in the room
   */
  remotePeerExists = (peerId) => {
    const peer = this.remotePeers.get(peerId);
    if (!peer) {
      return null;
    }
    return peer;
  };
  /**
   * Returns the Remote Peer if present in room.
   * @param peerId - PeerId of the remote peer
   * @returns - RemotePeer Instance
   * @throws { Error } If the Remote Peer is not found
   */
  getRemotePeerById(peerId) {
    const peer = this.remotePeers.get(peerId);
    if (!peer) {
      throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);
    }
    return peer;
  }
  constructor(data) {
    super();
    logger.debug({ data });
    if (data?.activeSpeakers?.size) {
      this.activeSpeakers.size = data?.activeSpeakers?.size;
    }
    if (data?.autoConsume !== void 0) {
      this.autoConsume = data.autoConsume;
    }
  }
  /**
   * Connects to the room and returns the instance of the room
   * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting
   */
  connect = () => {
    if (_Room.__instance === null) {
      throw new Error("Room Instance Not Initialized");
    }
    if (!this.socket.connected) {
      throw new Error("Socket is Not Connected");
    }
    if (this.socket.connecting) {
      throw new Error("Socket is Connecting, Wait for it to be connected");
    }
    if (!this.roomId) {
      throw new Error("Room Id is required to connect to the room");
    }
    this.socket.publish("connectRoom", { roomId: this.roomId });
    this.__state = "connecting";
    this.emit("room-connecting");
    return _Room.__instance;
  };
  /**
   * Admit a Peer to the room who is in the lobby
   */
  admitPeer = checkPermissions({ admin: true }).validate(
    (peerId) => {
      try {
        this.removeLobbyPeer(peerId);
        this.socket.publish("acceptLobbyPeer", { peerId });
      } catch (error) {
        logger.error("\u{1F534} Error admitting peer", error);
      }
    }
  );
  /**
   * Denies the peer from joining the room, who is in the lobby
   */
  denyPeer = checkPermissions({ admin: true }).validate(
    (peerId) => {
      try {
        this.removeLobbyPeer(peerId);
        this.socket.publish("denyLobbyPeer", { peerId });
      } catch (error) {
        logger.error("\u{1F534} Error denying peer", error);
      }
    }
  );
  /**
   * kick peer from room with respective peerId
   */
  kickPeer = checkPermissions({ admin: true }).validate(
    (peerId) => {
      try {
        this.socket.publish("kickPeer", { peerId });
      } catch (error) {
        logger.error("\u{1F534} Error denying peer", error);
      }
    }
  );
  /**
   * closing the room for the current user, room will keep on running for the remote users
   * @deprecated - Use `leaveRoom` from `huddleClient` instead
   */
  close = (reason) => {
    try {
      logger.info("\u{1F534} Leaving the room");
      this.__roomId = null;
      this.remotePeers.clear();
      this.lobbyPeers.clear();
      this.metadata = "{}";
      this.state = "left";
      this.emit("room-closed", { reason: reason || "LEFT" });
    } catch (error) {
      logger.error("Error: Leaving the Room");
    }
  };
};
var Room_default = Room;

export {
  Room_default
};
//# sourceMappingURL=chunk-NEW4FEHE.js.map