{"version":3,"sources":["../src/HuddleClient.ts"],"sourcesContent":["import LocalPeer from './LocalPeer';\nimport { mainLogger } from './logger';\nimport Socket from './Socket';\nimport Room from './Room';\nimport { ESocketCloseCode } from 'types/dist/socket.types';\n\nconst logger = mainLogger.createSubLogger('NezukoClient');\n\nclass HuddleClient {\n  /**\n   * Connection Manager Instance, Hanlder socket connection and stores information about the connection\n   */\n  private __socket: Socket;\n\n  /**\n   * Room Instance, Handles the room and its connection\n   */\n  private __room: Room;\n\n  /**\n   * Local Peer Instance, Handles the local peer and its connection\n   */\n  private __localPeer: LocalPeer;\n\n  /**\n   * isJoinRoomProcessing: boolean;\n   */\n  private __isJoinRoomProcessing = false;\n\n  /**\n   * Project Id of the Huddle01 Project\n   */\n  public projectId: string;\n\n  /**\n   * Returns the underlying socket connection\n   * @throws { Error } If the socket connection is not initialized\n   */\n  get socket(): Socket {\n    if (!this.__socket) {\n      throw new Error(\n        'Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first',\n      );\n    }\n\n    return this.__socket;\n  }\n\n  /**\n   * Returns the room instance, throws an error if the room is not created\n   * @throws { Error } If the room is not created, Call createRoom() method before you can access the room\n   */\n  get room(): Room {\n    return this.__room;\n  }\n\n  get localPeer(): LocalPeer {\n    return this.__localPeer;\n  }\n\n  /**\n   * Room Id of the current room\n   */\n  public get roomId(): string | null {\n    return this.room.roomId;\n  }\n\n  /**\n   * Set a new region for the Huddle01 Media Servers\n   */\n  public setRegion = (region: string) => {\n    logger.info('Setting a new region, ', region);\n\n    this.socket.setRegion(region);\n  };\n\n  constructor(data: {\n    projectId: string;\n    options?: {\n      autoConsume?: boolean;\n      activeSpeakers?: {\n        size: number;\n      };\n    };\n  }) {\n    logger.info('âœ… Initializing HuddleClient');\n\n    this.projectId = data.projectId;\n\n    this.__socket = Socket.create();\n\n    this.__room = Room.create({\n      autoConsume: data.options?.autoConsume,\n      activeSpeakers: data.options?.activeSpeakers,\n    });\n\n    this.__localPeer = LocalPeer.create();\n\n    const isLocalDev = this.projectId === 'development';\n\n    if (isLocalDev) {\n      logger.info('ðŸ”´ Local Development Mode');\n      this.socket.enableLocalDev();\n    }\n\n    this.__socket.on('closed', (code) => {\n      logger.info(\n        'ðŸ”Œ Socket Connection closed, closing the room and LocalPeer',\n      );\n      if (code === ESocketCloseCode.ROOM_CLOSED) {\n        this.room.close('CLOSED');\n      } else if (code === ESocketCloseCode.ROOM_ENTRY_DENIED) {\n        this.room.close('DENIED'); // banned is right?\n      } else if (code === ESocketCloseCode.CONNECTION_EXPIRED) {\n        logger.info('ðŸ”Œ Socket Connection closed due to connection expired');\n        this.room.close();\n      } else if (code === ESocketCloseCode.KICKED) {\n        this.room.close('KICKED');\n      } else {\n        this.room.close();\n      }\n\n      this.localPeer.close();\n    });\n  }\n\n  /**\n   * Default method to connect to the Huddle01 Media Room.\n   *\n   * This method connects to socket, creates a room, and then connects to the room;\n   */\n  public joinRoom = async (data: {\n    roomId: string;\n    token: string;\n  }): Promise<Room> => {\n    this.__isJoinRoomProcessing = true;\n    logger.info('ðŸ”” Joining the room with roomId,', data.roomId);\n\n    if (this.socket.connectionState === 'connecting') {\n      logger.warn(\n        'ðŸ”” Socket is already connecting, waiting for the connection to be established',\n      );\n\n      return this.room;\n    }\n\n    if (this.room.state === 'connecting' || this.__isJoinRoomProcessing) {\n      logger.warn('ðŸ”” Room join already in progress');\n\n      return this.room;\n    }\n\n    if (this.localPeer.joined) {\n      logger.warn('ðŸ”” Already joined the room');\n\n      return this.room;\n    }\n\n    try {\n      await this.socket.connect({ token: data.token });\n\n      this.room.roomId = data.roomId;\n\n      const room = this.room.connect();\n\n      return room;\n    } catch (error) {\n      logger.error('ðŸ”´ Error While Joining the Room');\n      logger.error(error);\n\n      throw error;\n    } finally {\n      this.__isJoinRoomProcessing = false;\n    }\n  };\n\n  /**\n   * Leave the room and disconnect from the socket\n   */\n  public leaveRoom = () => {\n    logger.info('Leaving the room');\n\n    this.socket.close(ESocketCloseCode.NORMAL_CLOSURE);\n  };\n\n  /**\n   * Close the room and disconnect from the socket\n   */\n  public closeRoom = () => {\n    logger.info('Closing the room');\n\n    this.socket.publish('closeRoom', undefined);\n  };\n}\nexport default HuddleClient;\n"],"mappings":"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","names":[]}