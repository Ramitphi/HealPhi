import { EnhancedEventEmitter } from './common-js/EnhancedEventEmitter.js';
import RemotePeer from './RemotePeer.js';
import { NewPeerJoined } from './types/common.types.js';
import { z } from 'zod';

type RoomEvents = {
    'room-joined': [];
    'room-joined-failed': [
        data: {
            status: 'ROOM_NOT_FOUND' | 'ROOM_ERRORED';
            message: string;
        }
    ];
    /**
     * Emitted when the room is left
     */
    'room-closed': [
        {
            reason: 'LEFT' | 'CLOSED' | 'KICKED' | 'DENIED';
            message?: string;
        }
    ];
    'room-connecting': [];
    'new-peer-joined': [data: NewPeerJoined];
    'lobby-peers-updated': [peerIds: string[]];
    'metadata-updated': [data: {
        metadata: unknown;
    }];
    'peer-left': [peerId: string];
    'room-controls-updated': [data: NewRoomControls];
    'room-notification': [data: {
        tag: string;
        message: string;
        code: number;
    }];
    'room-role-updated': [
        data: {
            peerId: string;
            newRole: string;
            prevRole: string;
        }
    ];
    'room-waiting': [
        data: {
            reason: 'WAITING_FOR_PERMISSIONS' | 'WAITING_FOR_ROOM_TO_START' | 'WAITING_FOR_ADMIN_TO_JOIN';
            message?: string;
        }
    ];
    'stream-added': [data: {
        peerId: string;
        label: string;
    }];
    'stream-closed': [data: {
        peerId: string;
        label: string;
    }];
};
type RoomStates = 'idle' | 'connecting' | 'connected' | 'failed' | 'left' | 'closed';
declare class Room extends EnhancedEventEmitter<RoomEvents> {
    /**
     * Room Instance, Singleton class
     */
    private static __instance;
    /**
     * Socket Instance, Singleton class
     */
    private __socket;
    /**
     * Returns the instance of the socket connection
     */
    private get socket();
    /**
     * Room Id of the current room
     */
    private __roomId;
    /**
     * Lobby PeerIds
     */
    private __lobbyPeers;
    /**
     * Removed Lobby PeerId from the lobby
     * @param peerId - PeerId of the peer who joined the room
     */
    private removeLobbyPeer;
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    private __config;
    /**
     * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers
     *
     * @default true
     *
     * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,
     * - if set to false, the user will have to manually consume the media streams of the remote peers
     * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    readonly autoConsume: boolean;
    /**
     * If using activeSpeakerNotification, Returns back the size of peers which are returned for the activeSpeakers in the Room;
     * `Default` value is 8
     */
    readonly activeSpeakers: {
        size: number;
    };
    /**
     * State of the Room
     */
    private __state;
    /**
     * Set the state of the room
     */
    set state(newState: RoomStates);
    /**
     * State of the room
     */
    get state(): RoomStates;
    /**
     * Get the lobby peers in the form of map
     * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}
     * @example
     * ```ts
     * const lobbyPeers = room.lobbyPeersMap;
     *
     * for (const [peerId, metadata] of lobbyPeers) {}
     *
     * ```
     */
    get lobbyPeersMap(): Map<string, {
        peerId: string;
        metadata?: string;
    }>;
    /**
     * Get lobby peers in the form of array
     */
    get lobbyPeerIds(): string[];
    /**
     * Get lobby peers in the form of array
     * @returns - Array of Lobby PeerIds
     */
    get lobbyPeers(): Map<string, {
        peerId: string;
        metadata?: string | undefined;
    }>;
    /**
     * Set lobby peers in the form of map
     * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`
     */
    set lobbyPeersMap(peers: Map<string, {
        peerId: string;
        metadata?: string;
    }>);
    /**
     * Get
     * @returns
     */
    getLobbyPeerMetadata: <T = unknown>(peerId: string) => {
        peerId: string;
        metadata: T;
    };
    /**
     * Set lobby peers in the form of array
     */
    set newlobbyPeers(peers: {
        peerId: string;
        metadata?: string;
    }[]);
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    get config(): RoomInfo['config'];
    set config(config: RoomInfo['config']);
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    remotePeers: Map<string, RemotePeer>;
    /**
     * Metadata of the room.
     */
    private __metadata;
    /**
     * Setter function for the metadata of the room
     * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`
     * `To notify everyone in the room about the metadata change, use the updateMetadata function`
     */
    set metadata(metadata: string);
    /**
     * Get the metadata of the room
     */
    getMetadata: <T = unknown>() => T;
    /**
     * Update Metadata of the room
     */
    updateMetadata: <T = unknown>(data: T) => void;
    /**
     * Create a new Room Instance if not created, else return the existing Room Instance
     *
     * @returns - Room Instance
     */
    static create(data?: {
        autoConsume?: boolean;
        activeSpeakers?: {
            size: number;
        };
    }): Room;
    /**
     * Get the Room Instance if its not initialized it will throw an error
     * @returns - Room Instance
     * @throws { Error } If the Room Instance is not initialized
     */
    static getInstance: () => Room;
    /**
     * RoomId of the currently joined room.
     */
    get roomId(): string | null;
    set roomId(roomId: string);
    /**
     * Returns the PeerIds of the remote peers
     */
    get peerIds(): string[];
    /**
     * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData
     * @param data: TNewRoomControls
     */
    updateRoomControls: (data: NewRoomControls) => void;
    /**
     * Close a particular stream of remote peers
     *  @param data: { label: string; peerIds?: string[] }
     *  @param label: Label of the stream
     *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers
     */
    closeStreamOfLabel: (data: {
        label: string;
        peerIds?: string[] | undefined;
    }) => void;
    /**
     * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions
     *
     * `NOTE: This will target all the audio stream in the room with the label "audio"`
     */
    muteEveryone: () => void;
    /**
     * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.
     *
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @return - null if the peer is not present in the room
     */
    remotePeerExists: (peerId: string) => RemotePeer | null;
    /**
     * Returns the Remote Peer if present in room.
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @throws { Error } If the Remote Peer is not found
     */
    getRemotePeerById(peerId: string): RemotePeer;
    private constructor();
    /**
     * Connects to the room and returns the instance of the room
     * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting
     */
    connect: () => Room;
    /**
     * Admit a Peer to the room who is in the lobby
     */
    admitPeer: (peerId: string) => void;
    /**
     * Denies the peer from joining the room, who is in the lobby
     */
    denyPeer: (peerId: string) => void;
    /**
     * kick peer from room with respective peerId
     */
    kickPeer: (peerId: string) => void;
    /**
     * closing the room for the current user, room will keep on running for the remote users
     * @deprecated - Use `leaveRoom` from `huddleClient` instead
     */
    close: (reason?: 'LEFT' | 'CLOSED' | 'KICKED' | 'DENIED') => void;
}

type TProducerInfo = {
    id: string;
    label: string;
    appData: Record<string, unknown>;
}[];
type ProduceSources = RoomControls['allowProduceSources'];
type RoomInfo = {
    roomLocked: boolean;
    config: RoomControls;
    peerIds: string[];
    peers: {
        peerId: string;
        producers: TProducerInfo;
        metadata?: string;
        role?: string;
    }[];
    lobbyPeers: {
        peerId: string;
        metadata?: string;
    }[];
    metadata: string;
};
declare const RoomControlsSchema: z.ZodObject<{
    roomLocked: z.ZodBoolean;
    allowProduce: z.ZodBoolean;
    allowProduceSources: z.ZodObject<{
        cam: z.ZodDefault<z.ZodBoolean>;
        mic: z.ZodDefault<z.ZodBoolean>;
        screen: z.ZodDefault<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    }, {
        cam?: boolean | undefined;
        mic?: boolean | undefined;
        screen?: boolean | undefined;
    }>;
    allowConsume: z.ZodBoolean;
    allowSendData: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    roomLocked: boolean;
    allowProduce: boolean;
    allowProduceSources: {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    };
    allowConsume: boolean;
    allowSendData: boolean;
}, {
    roomLocked: boolean;
    allowProduce: boolean;
    allowProduceSources: {
        cam?: boolean | undefined;
        mic?: boolean | undefined;
        screen?: boolean | undefined;
    };
    allowConsume: boolean;
    allowSendData: boolean;
}>;
type RoomControls = z.infer<typeof RoomControlsSchema>;
type NewRoomControls = {
    value: boolean;
    type: 'roomLocked' | 'allowProduce' | 'allowConsume' | 'allowSendData';
} | {
    value: {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    };
    type: 'allowProduceSources';
};
declare const PermissionSchema: z.ZodObject<{
    admin: z.ZodBoolean;
    canConsume: z.ZodBoolean;
    canProduce: z.ZodBoolean;
    canProduceSources: z.ZodObject<{
        cam: z.ZodBoolean;
        mic: z.ZodBoolean;
        screen: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    }, {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    }>;
    canSendData: z.ZodBoolean;
    canRecvData: z.ZodBoolean;
    canUpdateMetadata: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    admin: boolean;
    canConsume: boolean;
    canProduce: boolean;
    canProduceSources: {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    };
    canSendData: boolean;
    canRecvData: boolean;
    canUpdateMetadata: boolean;
}, {
    admin: boolean;
    canConsume: boolean;
    canProduce: boolean;
    canProduceSources: {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    };
    canSendData: boolean;
    canRecvData: boolean;
    canUpdateMetadata: boolean;
}>;
type TPermissions = z.infer<typeof PermissionSchema>;

export { NewRoomControls as N, ProduceSources as P, Room as R, TPermissions as T, RoomEvents as a, RoomStates as b, RoomInfo as c, RoomControls as d };
