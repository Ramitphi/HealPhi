import {
  getMediaStreamKind,
  getMediaTrack
} from "./chunk-G7SIQXZ4.js";
import {
  EnhancedMap
} from "./chunk-7PO7E25R.js";
import {
  Consumer_default
} from "./chunk-FE7RZJBI.js";
import {
  codecOptionsViaKind,
  encodingViaMediaType
} from "./chunk-CQH3TPW3.js";
import {
  Socket_default
} from "./chunk-HVBBMWHF.js";
import {
  mainLogger
} from "./chunk-EVXWMCNT.js";
import {
  EnhancedEventEmitter
} from "./chunk-7OTQAFXE.js";

// src/Transport.ts
var logger = mainLogger.createSubLogger("Transport");
var Transport = class _Transport extends EnhancedEventEmitter {
  /**
   * Peer Id, which handles the peer id.
   */
  peerId;
  /**
   *  MediaSoup Device Instance, which handles the browsers or mobile device init.
   */
  __device;
  /**
   * MediaSoup Transport Instance, which handles the media transport.
   */
  __mediasoupTransport;
  /**
   * Socket Instance, which handles the socket connection.
   */
  __socket;
  /**
   * Map of Producers, which handles the producers. ( Sending out Media Streams )
   *
   * `Mapped with {producerId => Producer}`
   */
  __producers = /* @__PURE__ */ new Map();
  /**
   * Map of DataProducers, which handles the dataProducers. ( Sending out Data )
   *
   * `Mapped with {label => DataProducer}`
   */
  __dataProducers = /* @__PURE__ */ new Map();
  /**
   * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )
   *
   * `Mapped with {label:label => DataConsumer}`
   */
  __dataConsumers = /* @__PURE__ */ new Map();
  /**
   * Map of Consumers, which handles the consumers. ( Receiving Media Streams )
   *
   * `Mapped with {label:RemotePeerId => Consumer}`
   */
  __consumers = new EnhancedMap({});
  /**
   * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.
   *
   * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.
   */
  labelToProducerId = /* @__PURE__ */ new Map();
  /**
   * Transport Type, which handles the transport type. ( `send | recv` )
   */
  transportType;
  /**
   * Pending Producer Tasks, which handles the pending producer tasks.
   * callback function is necessary to be called when the producer is created
   * on the server as well as on the client side.
   */
  __pendingProducerTasks = /* @__PURE__ */ new Map();
  /**
   * Debounce to handle concurrent request to restart Ice. Waits for some time before sending
   * more requests to restart ice.
   */
  __iceRestartDebounce = false;
  get device() {
    return this.__device;
  }
  get mediasoupTransport() {
    return this.__mediasoupTransport;
  }
  get connectionState() {
    return this.__mediasoupTransport.connectionState;
  }
  get producers() {
    return this.__producers;
  }
  get dataProducers() {
    return this.__dataProducers;
  }
  get dataConsumers() {
    return this.__dataConsumers;
  }
  get consumers() {
    return this.__consumers;
  }
  getProducerById(producerId) {
    const producer = this.__producers.get(producerId);
    if (!producer)
      throw new Error("Producer not found");
    return producer;
  }
  removeProducerById(producerId) {
    logger.info(`\u{1F514} Removing Producer, id: ${producerId}`);
    return this.__producers.delete(producerId);
  }
  /**
   * Get the consumer by label and peerId
   * @param data
   * @returns Consumer | null; Returns null if consumer is not found
   */
  getConsumer = (data) => {
    const consumer = this.__consumers.get(data.label, data.peerId);
    if (!consumer)
      return null;
    return consumer;
  };
  get transport() {
    const transport = this.__mediasoupTransport;
    if (!transport)
      throw new Error("Transport Not Initialized");
    return transport;
  }
  addPendingProducerTask = (data) => {
    const key = `${data.peerId}-${data.label}`;
    logger.info("\u{1F514} Adding Pending Producer Task, key", key);
    if (this.__pendingProducerTasks.has(key)) {
      logger.debug("\u{1F534} Producer Creation is Pending for key: ", key);
      return;
    }
    this.__pendingProducerTasks.set(key, data.callback);
  };
  resolvePendingProducerTask = (data) => {
    const key = `${data.peerId}-${data.label}`;
    logger.info("\u{1F514} Resolving Pending Producer Task, key", key);
    const callback = this.__pendingProducerTasks.get(key);
    if (!callback) {
      logger.error("\u{1F534} Producer Creation is not Pending for key: ", key);
      return;
    }
    callback({ id: data.id });
    this.__pendingProducerTasks.delete(key);
  };
  static create = (data) => {
    try {
      logger.info(
        `\u{1F514} Creating Client Side Transport, type: ${data.transportType}`
      );
      const { transportType, device } = data;
      const payload = {
        id: data.sdpInfo.id,
        iceParameters: data.sdpInfo.iceParameters,
        iceCandidates: data.sdpInfo.iceCandidates,
        iceServers: data.iceServers,
        dtlsParameters: data.sdpInfo.dtlsParameters,
        sctpParameters: data.sdpInfo.sctpParameters,
        proprietaryConstraints: {},
        appData: {}
      };
      const mediasoupTransport = transportType === "send" ? device.createSendTransport(payload) : device.createRecvTransport(payload);
      const transport = new _Transport({
        peerId: data.peerId,
        device: data.device,
        transportType: data.transportType,
        mediasoupTransport
      });
      return transport;
    } catch (error) {
      logger.error(`\u274C Transport.create(), type: ${data.transportType}`);
      logger.error(error);
      throw error;
    }
  };
  constructor(data) {
    super();
    this.__socket = Socket_default.getInstance();
    this.__device = data.device;
    this.transportType = data.transportType;
    this.__mediasoupTransport = data.mediasoupTransport;
    this.__mediasoupTransport.on("connectionstatechange", (state) => {
      this.__connectionStateChangeHandler(state);
    });
    this.peerId = data.peerId;
    this.__listenTransportConnect();
    this.__listenTransportProduce();
    if (this.transportType === "send")
      this.__listenTransportDataProduce();
    logger.info(`\u2705 ${data.transportType} Transport Initialized`);
  }
  __listenTransportConnect = () => {
    this.__mediasoupTransport.on(
      "connect",
      ({ dtlsParameters }, callback, errback) => {
        logger.info("\u{1F514} Transport Connect Event Called");
        try {
          this.once("connectTransportResponse", () => {
            callback();
          });
          this.__socket.publish("connectTransport", {
            dtlsParameters,
            transportType: this.transportType
          });
        } catch (error) {
          logger.error("\u274C Error Transport Connect Event");
          logger.error(error);
          errback(error);
        }
      }
    );
  };
  __listenTransportProduce = () => {
    this.__mediasoupTransport.on(
      "produce",
      async ({ kind, rtpParameters, appData }, callback, errback) => {
        logger.info(`\u{1F514} ${this.transportType} Produce Event Called`);
        try {
          const label = appData?.label;
          if (!label)
            throw new Error("\u{1F534} Stream Identifier Not Found");
          this.__socket.publish("produce", {
            createProducerData: {
              rtpParameters,
              kind,
              label,
              appData,
              paused: false
            }
          });
          this.addPendingProducerTask({
            peerId: this.peerId,
            label,
            callback
          });
        } catch (error) {
          logger.error("\u274C Error Transport Produce Event");
          logger.error(error);
          errback(error);
        }
      }
    );
  };
  __listenTransportDataProduce = () => {
    logger.info(`\u{1F514} producedata: ${this.transportType} `);
    this.__mediasoupTransport.on(
      "producedata",
      async ({ label, appData, sctpStreamParameters, protocol }, callback, errback) => {
        logger.info(`\u{1F514} ${this.transportType} Produce Data Event Called`);
        try {
          this.__socket.publish("produceData", {
            createDataProducerData: {
              transportId: this.__mediasoupTransport.id,
              sctpStreamParameters,
              label,
              protocol,
              appData
            }
          });
          this.addPendingProducerTask({
            peerId: this.peerId,
            label,
            callback
          });
        } catch (error) {
          logger.error("\u274C Error Transport Produce Data Event");
          logger.error(error);
          errback(error);
        }
      }
    );
  };
  produce = async (data) => {
    const kind = getMediaStreamKind(data.stream);
    const track = getMediaTrack({ stream: data.stream, kind });
    logger.info(`\u{1F514} Produce Called for kind: ${kind}, label: ${data.label}`);
    try {
      if (!this.__device.loaded) {
        throw new Error("Device Not Loaded");
      }
      if (!this.__device.rtpCapabilities.codecs) {
        throw new Error("No Codecs Found");
      }
      if (!this.__device.canProduce(kind)) {
        throw new Error(`Device Cannot produce ${kind}`);
      }
      if (this.transportType !== "send") {
        throw new Error(`Cannot produce on ${this.transportType} transport`);
      }
      const codecs = this.__device.rtpCapabilities?.codecs;
      if (!codecs) {
        throw new Error("\u274C Device RTP Capabilities not found");
      }
      const codecViaMediaType = {
        video: codecs.find(
          (codec) => codec.mimeType.toLowerCase() === "video/h264"
        ),
        "screen-share-video": codecs.find(
          (codec) => codec.mimeType.toLowerCase() === "video/h264"
        ),
        audio: void 0
      };
      const mediaType = data.label === "screen-share-video" ? "screen-share-video" : kind;
      const mediasoupProducer = await this.__mediasoupTransport.produce({
        track,
        encodings: encodingViaMediaType[mediaType],
        codecOptions: codecOptionsViaKind[kind],
        codec: codecViaMediaType[mediaType],
        stopTracks: data.stopTrackOnClose,
        zeroRtpOnPause: true,
        disableTrackOnPause: true,
        appData: {
          ...data.appData,
          producerPeerId: this.peerId
        }
      });
      this.__producers.set(mediasoupProducer.id, mediasoupProducer);
      this.labelToProducerId.set(data.label, mediasoupProducer.id);
      logger.info(`\u{1F514} Producer Created sucessfully with label : ${data.label}`);
      return mediasoupProducer;
    } catch (error) {
      logger.error("\u274C Error Transport Produce Event");
      logger.error(error);
      throw error;
    }
  };
  produceData = async (data) => {
    logger.info(`\u{1F514} Produce Data Called for label: ${data.label}`);
    try {
      if (this.transportType !== "send") {
        throw new Error(`Cannot produce on ${this.transportType} transport`);
      }
      const dataProducer = await this.__mediasoupTransport.produceData({
        label: data.label,
        appData: {
          ordered: true,
          ...data.appData,
          producerPeerId: this.peerId,
          label: data.label
        }
      });
      this.__dataProducers.set(dataProducer.label, dataProducer);
      return dataProducer;
    } catch (error) {
      logger.error("\u274C Error Transport Produce Data Event");
      logger.error(error);
      throw error;
    }
  };
  consume = async (data) => {
    const { label, producerPeerId, kind } = data;
    logger.info(
      `\u{1F514} Consume Called for ${kind} from remote peer ${producerPeerId}`
    );
    try {
      if (this.transportType !== "recv") {
        throw new Error(`Cannot consume on ${this.transportType} transport`);
      }
      const consumer = Consumer_default.create({
        producerId: data.producerId,
        producerPeerId,
        label
      });
      if (!this.__device.loaded) {
        throw new Error("Device Not Loaded");
      }
      if (!this.__device.rtpCapabilities.codecs) {
        throw new Error("No Codecs Found");
      }
      const mediaSoupConsumer = await this.__mediasoupTransport.consume({
        id: data.consumerId,
        rtpParameters: data.rtpParameters,
        kind: data.kind,
        producerId: data.producerId,
        appData: data.appData
      });
      mediaSoupConsumer.on("transportclose", () => {
        this.closeConsumer({ label, peerId: producerPeerId });
      });
      mediaSoupConsumer.on("trackended", () => {
        this.closeConsumer({ label, peerId: producerPeerId });
      });
      this.__consumers.set(consumer.label, consumer.producerPeerId, consumer);
      consumer.setMediaSoupConsumer(mediaSoupConsumer);
      return { consumer, mediaSoupConsumer };
    } catch (error) {
      logger.error(error);
      throw new Error("\u274C Error calling consume()");
    }
  };
  consumeData = async (data) => {
    const {
      label,
      appData,
      dataProducerId,
      protocol,
      id,
      peerId,
      sctpStreamParameters
    } = data;
    logger.info(
      `\u{1F514} ConsumeData from producer ${peerId} consumerIdFromServer:${id}`
    );
    try {
      if (this.transportType !== "recv") {
        throw new Error(`Cannot consume on ${this.transportType} transport`);
      }
      if (!this.__device.loaded) {
        throw new Error("Device Not Loaded");
      }
      if (!this.__device.rtpCapabilities.codecs) {
        throw new Error("No Codecs Found");
      }
      const dataConsumer = await this.transport.consumeData({
        id,
        dataProducerId,
        sctpStreamParameters,
        label,
        protocol,
        appData
      });
      dataConsumer.on("open", () => {
        logger.info(`\u2705 DataConsumer with ${label} opened`);
      });
      dataConsumer.on("close", () => {
        logger.warn(`\u2705 DataConsumer with ${label} closed`);
        this.__dataConsumers.delete(label);
      });
      dataConsumer.on("error", (error) => {
        logger.error(`\u2705 DataConsumer "error": ${error} closed`);
      });
      this.__dataConsumers.set(label, dataConsumer);
      return dataConsumer;
    } catch (error) {
      logger.error(error);
      throw new Error("\u274C Error calling consumeData()");
    }
  };
  closeConsumer = (data) => {
    try {
      const consumer = this.getConsumer(data);
      if (!consumer) {
        throw new Error(
          `\u274C Consumer not found label: ${data.label}, peerId: ${data.peerId}`
        );
      }
      consumer.close();
      this.__consumers.delete(data.label, data.peerId);
    } catch (error) {
      logger.error("\u274C Error closing consumer");
      logger.error(error);
    }
  };
  close = async (data) => {
    try {
      if (data.retries <= 0) {
        logger.error("\u274C Error closing transport, max retries exceeded");
        return;
      }
      logger.info(`\u{1F514} Closing ${this.transportType} transport`);
      this.__mediasoupTransport.close();
      logger.info(`\u2705 ${this.transportType} transport closed`);
    } catch (error) {
      logger.error("\u274C Error closing transport");
      logger.error(error);
      logger.error("Retrying...");
      this.close({ retries: data.retries - 1 });
    }
  };
  __connectionStateChangeHandler = (state) => {
    try {
      logger.debug(
        `\u{1F514} ${this.transportType} Transport Connection State Changed, state: ${state}`
      );
      const transportType = this.transportType;
      const handler = {
        connected: () => {
          logger.debug(`\u{1F514} ${this.transportType} Transport Connected`);
        },
        disconnected: () => {
          if (this.__iceRestartDebounce)
            return;
          this.__iceRestartDebounce = true;
          this.__socket.publish("restartTransportIce", {
            transportId: this.__mediasoupTransport.id,
            transportType
          });
          setTimeout(() => {
            this.__iceRestartDebounce = false;
          }, 3e3);
          logger.debug(`\u{1F514} ${transportType} Transport Disconnected`);
        },
        failed: () => {
          logger.debug(`\u{1F514} ${transportType} Transport Failed`);
        },
        connecting: () => {
          logger.debug(`\u{1F514} ${transportType} Transport Connecting`);
        },
        closed: () => {
          logger.debug(`\u{1F514} ${transportType} Transport closed`);
        },
        new: () => {
          logger.debug(`\u{1F514} ${transportType} Transport new`);
        }
      };
      handler[state]();
    } catch (err) {
      logger.error("\u274C Error in connectionStateChangeHandler");
      logger.error(err);
    }
  };
};
var Transport_default = Transport;

export {
  Transport_default
};
//# sourceMappingURL=chunk-OKUP6CWC.js.map